#!/usr/bin/env bash
# build-file: Build the .cmi (from .mli) or .cmx (from .ml) for a given file
#             and all its dependencies.
# Usage: scripts/build-file <file.ml|file.mli>  (run from repo root)
#
# Prerequisite: run "make boot-compiler" at least once (even if it fails) to
# generate the workspace file duneconf/boot.ws and other build configuration.

set -eou pipefail

if [ -z "$1" ]; then
  echo "Usage: $0 <file.ml|file.mli>" >&2
  exit 1
fi

if [ ! -f duneconf/boot.ws ]; then
  echo "Error: duneconf/boot.ws not found." >&2
  echo "Run 'make boot-compiler' first (it may fail, but it generates the workspace file)." >&2
  exit 1
fi

file="$1"
base=$(basename "$file" | sed 's/\.ml[i]\?$//')

case "$file" in
  *.mli) ext=cmi ;;
  *.ml)  ext=cmx ;;
  *)     echo "Expected .ml or .mli file" >&2; exit 1 ;;
esac

# Try building a dune target. Exits on success or build error.
# Returns 0 if the target doesn't exist (caller should try next).
try_target() {
  local target="$1"
  local label="$2"
  local rc=0
  local result
  result=$(RUNTIME_DIR=runtime dune build --root=. --workspace=duneconf/boot.ws "$target" 2>&1) || rc=$?
  if echo "$result" | grep -q "Don't know how to build"; then
    return 0
  fi
  if [ $rc -eq 0 ]; then
    echo "OK: ${base}.${ext} (${label})"
  else
    echo "$result" >&2
  fi
  exit $rc
}

# 1) Try top-level unwrapped libraries (ocamlcommon, ocamloptcomp, etc.)
for lib in ocamlcommon ocamloptcomp ocamlbytecomp ocamljcomp oxcaml_common; do
  if [ "$ext" = "cmx" ]; then
    target=".${lib}.objs/native/${base}.cmx"
  else
    target=".${lib}.objs/byte/${base}.cmi"
  fi
  try_target "$target" "$lib"
done

# 2) Try wrapped sub-libraries by walking up from the file's directory.
#    Wrapped library targets look like: dir/.libname.objs/byte/libname__Module.cmi
cap_base="${base^}"

dir=$(dirname "$file")
while [ "$dir" != "." ] && [ "$dir" != "/" ]; do
  if [ -f "$dir/dune" ]; then
    # Extract all library names from this dune file
    libs=$(grep -A1 '(library' "$dir/dune" 2>/dev/null | grep '(name' | sed 's/.*name \([^ )]*\).*/\1/' || true)
    for lib in $libs; do
      # Try wrapped naming: libname__Module.cmi
      if [ "$ext" = "cmx" ]; then
        target="${dir}/.${lib}.objs/native/${lib}__${cap_base}.cmx"
      else
        target="${dir}/.${lib}.objs/byte/${lib}__${cap_base}.cmi"
      fi
      try_target "$target" "$lib"

      # Try unwrapped naming: module.cmi (for (wrapped false) sub-libraries)
      if [ "$ext" = "cmx" ]; then
        target="${dir}/.${lib}.objs/native/${base}.cmx"
      else
        target="${dir}/.${lib}.objs/byte/${base}.cmi"
      fi
      try_target "$target" "$lib"
    done
  fi
  dir=$(dirname "$dir")
done

# 3) Try as a single-module executable (e.g. driver/main.ml, boot_ocamlopt.ml)
if [ "$ext" = "cmx" ]; then
  target=".${base}.eobjs/native/${base}.cmx"
else
  target=".${base}.eobjs/byte/${base}.cmi"
fi
try_target "$target" "exe:${base}"

echo "Module ${base} not found in any library or executable" >&2
exit 2
