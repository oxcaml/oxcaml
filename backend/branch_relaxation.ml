(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                    Mark Shinwell, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

[@@@ocaml.warning "+a-40-41-42"]

(* CR gyorsh/mshinwell: This pass needs fixing for register availability set
   propagation *)

open! Int_replace_polymorphic_compare
open Linear
module DLL = Oxcaml_utils.Doubly_linked_list

module Make (T : Branch_relaxation_intf.S) = struct
  let label_map code =
    let map = Hashtbl.create 37 in
    let rec fill_map pc cell_opt =
      match cell_opt with
      | None -> pc, map
      | Some cell -> (
        let data = DLL.value cell in
        match data.desc with
        | Llabel { label = lbl; _ } ->
          Hashtbl.add map lbl (pc, cell);
          fill_map pc (DLL.next cell)
        | Lend -> fill_map pc (DLL.next cell)
        | Lprologue | Lepilogue_open | Lepilogue_close | Lreloadretaddr
        | Lreturn | Lentertrap | Lpoptrap _ | Lop _ | Lcall_op _ | Lbranch _
        | Lcondbranch (_, _)
        | Lcondbranch3 (_, _, _)
        | Lswitch _ | Ladjust_stack_offset _ | Lpushtrap _ | Lraise _
        | Lstackcheck _ ->
          fill_map (pc + T.instr_size data) (DLL.next cell))
    in
    fill_map 0 (DLL.hd_cell code)

  let branch_overflows map pc_branch lbl_dest max_branch_offset =
    let pc_dest, _cell = Hashtbl.find map lbl_dest in
    let delta = pc_dest - (pc_branch + T.offset_pc_at_branch) in
    delta <= -max_branch_offset || delta >= max_branch_offset

  let opt_branch_overflows map pc_branch opt_lbl_dest max_branch_offset =
    match opt_lbl_dest with
    | None -> false
    | Some lbl_dest -> branch_overflows map pc_branch lbl_dest max_branch_offset

  let instr_overflows ~code_size ~max_out_of_line_code_offset data map pc =
    match T.Cond_branch.classify_instr data.desc with
    | None -> false
    | Some branch -> (
      let max_branch_offset =
        (* Remember to cut some slack for multi-word instructions (in the
           [Linear] sense of the word) where the branch can be anywhere in the
           middle. 12 words of slack is plenty. *)
        T.Cond_branch.max_displacement branch - 12
      in
      match data.desc with
      | Lop (Alloc _) | Lop Poll | Lop (Specific _) ->
        (* We assume that any branches eligible for relaxation generated by
           these instructions only branch forward. We further assume that any of
           these may branch to an out-of-line code block. *)
        code_size + max_out_of_line_code_offset - pc >= max_branch_offset
      | Lcondbranch (_, lbl) -> branch_overflows map pc lbl max_branch_offset
      | Lcondbranch3 (lbl0, lbl1, lbl2) ->
        opt_branch_overflows map pc lbl0 max_branch_offset
        || opt_branch_overflows map pc lbl1 max_branch_offset
        || opt_branch_overflows map pc lbl2 max_branch_offset
      | Lend
      | Lop
          ( Move | Spill | Reload | Opaque | Pause | Begin_region | End_region
          | Dls_get | Tls_get | Domain_index | Const_int _ | Const_float32 _
          | Const_float _ | Const_symbol _ | Const_vec128 _ | Const_vec256 _
          | Const_vec512 _ | Stackoffset _ | Load _
          | Store (_, _, _)
          | Intop _ | Int128op _
          | Intop_imm (_, _)
          | Intop_atomic _
          | Floatop (_, _)
          | Csel _ | Reinterpret_cast _ | Static_cast _ | Probe_is_enabled _
          | Name_for_debugger _ )
      | Lprologue | Lepilogue_open | Lepilogue_close | Lreloadretaddr | Lreturn
      | Lentertrap | Lpoptrap _ | Lcall_op _ | Llabel _ | Lbranch _ | Lswitch _
      | Ladjust_stack_offset _ | Lpushtrap _ | Lraise _ | Lstackcheck _ ->
        Misc.fatal_error "Unsupported instruction for branch relaxation")

  let fixup_branches ~code_size ~max_out_of_line_code_offset map code =
    let rec fixup did_fix pc cell_opt =
      match cell_opt with
      | None -> did_fix
      | Some cell -> (
        let data = DLL.value cell in
        match data.desc with
        | Lend -> fixup did_fix pc (DLL.next cell)
        | Lprologue | Lepilogue_open | Lepilogue_close | Lreloadretaddr
        | Lreturn | Lentertrap | Lpoptrap _ | Lop _ | Lcall_op _ | Llabel _
        | Lbranch _
        | Lcondbranch (_, _)
        | Lcondbranch3 (_, _, _)
        | Lswitch _ | Ladjust_stack_offset _ | Lpushtrap _ | Lraise _
        | Lstackcheck _ -> (
          let overflows =
            instr_overflows ~code_size ~max_out_of_line_code_offset data map pc
          in
          if not overflows
          then fixup did_fix (pc + T.instr_size data) (DLL.next cell)
          else
            match data.desc with
            | Lop Poll ->
              let new_data = { data with desc = T.relax_poll () } in
              DLL.set_value cell new_data;
              fixup true (pc + T.instr_size new_data) (DLL.next cell)
            | Lop (Alloc { bytes = num_bytes; dbginfo; _ }) ->
              let new_data =
                { data with desc = T.relax_allocation ~num_bytes ~dbginfo }
              in
              DLL.set_value cell new_data;
              fixup true (pc + T.instr_size new_data) (DLL.next cell)
            | Lcondbranch (test, lbl) ->
              let lbl2 = Cmm.new_label () in
              let new_data =
                { data with
                  desc = Lcondbranch (Operation.invert_test test, lbl2)
                }
              in
              DLL.set_value cell new_data;
              let branch_data =
                make_instr_data (Lbranch lbl) [||] [||]
                  ~available_before:Reg_availability_set.Unreachable
                  ~available_across:Reg_availability_set.Unreachable
              in
              let branch_cell = DLL.insert_and_return_after cell branch_data in
              let label_data =
                make_instr_data
                  (Llabel { label = lbl2; section_name = None })
                  [||] [||] ~available_before:Reg_availability_set.Unreachable
                  ~available_across:Reg_availability_set.Unreachable
              in
              DLL.insert_after branch_cell label_data;
              fixup true (pc + T.instr_size new_data) (DLL.next cell)
            | Lcondbranch3 (lbl0, lbl1, lbl2) ->
              (* Expand Lcondbranch3 into a sequence of conditional branches.
                 The original instruction is replaced by the first expanded
                 instruction, and subsequent instructions are inserted after. *)
              let insert_condbranch cell_to_insert_after lbl n arg =
                match lbl with
                | None -> cell_to_insert_after
                | Some l ->
                  let branch_data =
                    make_instr_data
                      (Lcondbranch (Iinttest_imm (Ceq, n), l))
                      arg [||]
                      ~available_before:Reg_availability_set.Unreachable
                      ~available_across:Reg_availability_set.Unreachable
                  in
                  DLL.insert_and_return_after cell_to_insert_after branch_data
              in
              (* We need to handle the first branch specially by replacing the
                 current cell, then insert subsequent branches after. *)
              let first_branch_inserted = ref false in
              let last_cell = ref cell in
              Option.iter
                (fun l ->
                  if not !first_branch_inserted
                  then (
                    DLL.set_value cell
                      { data with
                        desc = Lcondbranch (Iinttest_imm (Ceq, 0), l)
                      };
                    first_branch_inserted := true)
                  else
                    last_cell
                      := insert_condbranch !last_cell (Some l) 0 data.arg)
                lbl0;
              Option.iter
                (fun l ->
                  if not !first_branch_inserted
                  then (
                    DLL.set_value cell
                      { data with
                        desc = Lcondbranch (Iinttest_imm (Ceq, 1), l)
                      };
                    first_branch_inserted := true)
                  else
                    last_cell
                      := insert_condbranch !last_cell (Some l) 1 data.arg)
                lbl1;
              Option.iter
                (fun l ->
                  if not !first_branch_inserted
                  then (
                    DLL.set_value cell
                      { data with
                        desc = Lcondbranch (Iinttest_imm (Ceq, 2), l)
                      };
                    first_branch_inserted := true)
                  else
                    last_cell
                      := insert_condbranch !last_cell (Some l) 2 data.arg)
                lbl2;
              (* Continue from the current cell since we've modified it *)
              fixup true pc (Some cell)
            | Lend | Lprologue | Lepilogue_open | Lepilogue_close
            | Lreloadretaddr | Lreturn | Lentertrap | Lpoptrap _ | Lcall_op _
            | Llabel _ | Lbranch _ | Lswitch _ | Ladjust_stack_offset _
            | Lpushtrap _ | Lraise _ | Lstackcheck _
            | Lop
                ( Move | Spill | Reload | Opaque | Pause | Begin_region
                | End_region | Dls_get | Tls_get | Domain_index | Const_int _
                | Const_float32 _ | Const_float _ | Const_symbol _
                | Const_vec128 _ | Const_vec256 _ | Const_vec512 _
                | Stackoffset _ | Load _
                | Store (_, _, _)
                | Intop _ | Int128op _
                | Intop_imm (_, _)
                | Intop_atomic _
                | Floatop (_, _)
                | Csel _ | Reinterpret_cast _ | Static_cast _
                | Probe_is_enabled _ | Name_for_debugger _ | Specific _ ) ->
              (* Any other instruction has already been rejected in
                 [instr_overflows] above. We can *never* get here. *)
              assert false))
    in
    fixup false 0 (DLL.hd_cell code)

  (* Iterate branch expansion till all conditional branches are OK *)

  let rec relax code ~max_out_of_line_code_offset =
    let min_of_max_branch_offsets =
      List.fold_left
        (fun min_of_max_branch_offsets branch ->
          min min_of_max_branch_offsets (T.Cond_branch.max_displacement branch))
        max_int T.Cond_branch.all
    in
    let code_size, map = label_map code in
    if
      code_size >= min_of_max_branch_offsets
      && fixup_branches ~code_size ~max_out_of_line_code_offset map code
    then relax code ~max_out_of_line_code_offset
    else ()
end
