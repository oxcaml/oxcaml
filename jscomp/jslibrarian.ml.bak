open Misc
open Config
open Cmx_format

type error =
  | File_not_found of string
  | Not_an_object_file of string
  | Archiver_error of string

exception Error of error

let read_info name =
  let filename =
    try
      Load_path.find name
    with Not_found ->
      raise(Error(File_not_found name)) in
  let (info, crc) = Compilenv.read_unit_info filename in
  info.ui_force_link <- info.ui_force_link || !Clflags.link_everything;
  (* There is no need to keep the approximation in the .cmjxa file,
     since the compiler will go looking directly for .cmjx files.
     The linker, which is the only one that reads .cmjxa files, does not
     need the approximation. *)
  info.ui_export_info <- None;
  (filename, (info, crc))

let create_archive file_list lib_name =
  (* Determine base output name, stripping any extension and warning if wrong *)
  let base_name =
    if not (Filename.check_suffix lib_name ".cmjxa")
    then Printf.eprintf "Warning: output file has no extension, expected .cmjxa\n%!";
    Filename.remove_extension lib_name
    end
  in
  let cmjxa_name = base_name ^ ".cmjxa" in
  let cmja_name = base_name ^ ".cmja" in
  (* Process input files and collect both .cmjx and .cmjo files *)
  let process_file name =
    let file_name =
      try Load_path.find name
      with Not_found -> raise (Error (File_not_found name))
    in
    if Filename.check_suffix file_name ".cmjx" then
      (* When given .cmjx, REQUIRE corresponding .cmjo *)
      let cmjo = Filename.chop_suffix file_name ".cmjx" ^ ".cmjo" in
      if not (Sys.file_exists cmjo) then
        raise (Error (File_not_found cmjo));
      (Some file_name, Some cmjo)
    else if Filename.check_suffix file_name ".cmjo" then
      (* When given .cmjo, EXPECT corresponding .cmjx (warn if missing) *)
      let cmjx = Filename.chop_suffix file_name ".cmjo" ^ ".cmjx" in
      if Sys.file_exists cmjx then
        (Some cmjx, Some file_name)
      else (
        Printf.eprintf "Warning: no .cmjx file found for %s\n" file_name;
        (None, Some file_name))
    else if Filename.check_suffix file_name ".cmja" then
      (* When given .cmja, EXPECT corresponding .cmjxa *)
      let cmjxa = Filename.chop_suffix file_name ".cmja" ^ ".cmjxa" in
      if not (Sys.file_exists cmjxa) then
        Printf.eprintf "Warning: no .cmjxa file found for %s\n" file_name;
      (* For archives, we just pass them through to js_of_ocaml *)
      ("", file_name)
    else if Filename.check_suffix file_name ".cmjxa" then
      (* When given .cmjxa, REQUIRE corresponding .cmja *)
      let cmja = Filename.chop_suffix file_name ".cmjxa" ^ ".cmja" in
      if not (Sys.file_exists cmja) then
        raise (Error (File_not_found cmja));
      (* For archives, we just pass the .cmja through *)
      ("", cmja)
    else
      raise (Error (Not_an_object_file file_name))
  in

  let files = List.map process_file file_list in
  let cmjx_files = List.filter_map (fun (cmjx, _) ->
    if cmjx <> "" then Some cmjx else None) files in
  let cmjo_files = List.filter_map (fun (_, cmjo) ->
    (* Filter out empty strings (from archives that were already processed) *)
    if cmjo <> "" then Some cmjo else None) files in

  (* Create the .cmja JavaScript archive only if we have .cmjo files *)
  if cmjo_files <> [] then begin
    let linkall_flag = if !Clflags.link_everything then ["--linkall"] else [] in
    let debug_flag = if !Clflags.debug then ["--debug-info"] else [] in
    Jscompile.run_jsoo_exn
      ~args:([ "link"; "-a" ] @ linkall_flag @ debug_flag @ [ "-o"; cmja_name ] @ cmjo_files)
  end;

  (* Always create .cmjxa metadata archive (may be empty if no .cmjx files) *)
  let outchan = open_out_bin cmjxa_name in
  Misc.try_finally
    ~always:(fun () -> close_out outchan)
    ~exceptionally:(fun () -> remove_file cmjxa_name)
    (fun () ->
       output_string outchan cmxa_magic_number;
       if cmjx_files <> [] then begin
         let (_, descr_list) =
           List.split (List.map read_info cmjx_files) in
         List.iter2
           (fun file_name (unit, crc) ->
              Asmlink.check_consistency file_name unit crc)
           cmjx_files descr_list;
         let cmis = Asmlink.extract_crc_interfaces () in
         let cmxs = Asmlink.extract_crc_implementations () in
         let cmis = Array.of_list cmis in
         let cmxs = Array.of_list cmxs in
         let cmi_index = Compilation_unit.Name.Tbl.create 42 in
         Array.iteri (fun i import ->
             Compilation_unit.Name.Tbl.add cmi_index (Import_info.name import) i)
           cmis;
         let cmx_index = Compilation_unit.Tbl.create 42 in
         Array.iteri (fun i import ->
             Compilation_unit.Tbl.add cmx_index (Import_info.cu import) i)
           cmxs;
         let genfns = Generic_fns.Tbl.make () in
         let mk_bitmap arr ix entries ~find ~get_name =
           let module B = Misc.Bitmap in
           let b = B.make (Array.length arr) in
           List.iter (fun import -> B.set b (find ix (get_name import))) entries;
           b
         in
         let units =
           List.map (fun (unit, crc) ->
             ignore (Generic_fns.Tbl.add
                                    ~imports:Generic_fns.Partition.Set.empty
                                    genfns
                                    unit.ui_generic_fns);
             { li_name = unit.ui_unit;
               li_crc = crc;
               li_defines = unit.ui_defines;
               li_force_link = unit.ui_force_link;
               li_imports_cmi =
                 mk_bitmap cmis cmi_index unit.ui_imports_cmi
                   ~find:Compilation_unit.Name.Tbl.find
                   ~get_name:Import_info.name;
               li_imports_cmx =
                 mk_bitmap cmxs cmx_index unit.ui_imports_cmx
                   ~find:Compilation_unit.Tbl.find
                   ~get_name:Import_info.cu;
               li_external_symbols = Array.of_list unit.ui_external_symbols })
           descr_list
         in
         let infos =
           { lib_units = units;
             lib_imports_cmi = cmis;
             lib_imports_cmx = cmxs;
             lib_generic_fns = Generic_fns.Tbl.entries genfns;
             lib_ccobjs = !Clflags.ccobjs;
             lib_ccopts = !Clflags.all_ccopts } in
         output_value outchan infos
       end else begin
         (* Create minimal .cmjxa with empty metadata *)
         let infos =
           { lib_units = [];
             lib_imports_cmi = [||];
             lib_imports_cmx = [||];
             lib_generic_fns = Generic_fns.Tbl.entries (Generic_fns.Tbl.make ());
             lib_ccobjs = [];
             lib_ccopts = [] } in
         output_value outchan infos
       end
    )

open Format
module Style = Misc.Style

let report_error ppf = function
  | File_not_found name ->
      fprintf ppf "Cannot find file %a" Style.inline_code name
  | Not_an_object_file name ->
      fprintf ppf "The file %a is not a JavaScript object file (.cmjo/.cmjx) or archive (.cmja)"
        (Style.as_inline_code Location.print_filename)
        name
  | Archiver_error name ->
      fprintf ppf "Error while creating the library %s" name

let () =
  Location.register_error_of_exn
    (function
      | Error err -> Some (Location.error_of_printer_file report_error err)
      | _ -> None
    )

let reset () = ()
