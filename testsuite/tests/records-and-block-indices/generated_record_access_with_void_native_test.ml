(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "idx_repr.ml stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void mod everything
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

let int64x2_u_equal i1 i2 =
    let a1 = int64_of_int64x2 i1 in
    let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
    let a2 = int64_of_int64x2 i2 in
    let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
    Int64.equal a1 a2 && Int64.equal b1 b2

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any mod separable) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any mod separable) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = { mutable a0 : unit_u; mutable b0 : int64# } (* { unit_u; int64# } *)
type t1 = { mutable a1 : unit_u; mutable b1 : nativeint# } (* { unit_u; nativeint# } *)
type t2 = { mutable a2 : unit_u; mutable b2 : unit_u; mutable c2 : string } (* { unit_u; unit_u; string } *)
type v3 = C3_0 of unit_u (* (| unit_u) *)
type t4 = { mutable a4 : float; mutable b4 : v3 } (* { float; (| unit_u) } *)
type t5 = #{ a5 : unit_u; b5 : string } (* #{ unit_u; string } *)
type t6 = { mutable a6 : string; mutable b6 : t5 } (* { string; #{ unit_u; string } } *)
type t7 = { mutable a7 : v3; mutable b7 : unit_u } (* { (| unit_u); unit_u } *)
type t8 = #{ a8 : unit_u } (* #{ unit_u } *)
type t9 = { mutable a9 : t8; mutable b9 : string } (* { #{ unit_u }; string } *)
type t10 = { mutable a10 : t5; mutable b10 : string } (* { #{ unit_u; string }; string } *)
type t11 = #{ a11 : string; b11 : unit_u } (* #{ string; unit_u } *)
type t12 = { mutable a12 : t11; mutable b12 : unit_u } (* { #{ string; unit_u }; unit_u } *)

let to_run () =
  (*******************************)
  (*   t0 = { unit_u; int64# }   *)
  (*******************************)
  let r = { a0 = (unbox_unit ()); b0 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = (unbox_unit ()) in
  mark_test_run 1;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1 failed";
  (* Paths of depth 1 *)
  (* .b0 *)
  let actual = r.b0 in
  let expected = #0L in
  mark_test_run 2;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 2 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01; b0 = b01 } { a0 = a02; b0 = b02 } -> (fun _ _ -> true) a01 a02 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b01 b02) in
  let next_r = { a0 = (unbox_unit ()); b0 = #100L } in
  let r_expected = { a0 = (unbox_unit ()); b0 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 3;
  let test = eq r r_expected in
  if not test then failwithf "test 3 failed";
  Gc.compact ();
  (* .b0 *)
  r.b0 <- next_r.b0;
  let r_expected = { r_expected with b0 = next_r.b0 } in
  mark_test_run 4;
  let test = eq r r_expected in
  if not test then failwithf "test 4 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0; b0 } = r in
  let expected_a0 = (unbox_unit ()) in
  mark_test_run 5;
  let test = (fun _ _ -> true) expected_a0 a0 in
  if not test then failwithf "test 5 failed";
  let expected_b0 = #100L in
  mark_test_run 6;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b0 b0 in
  if not test then failwithf "test 6 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0; b0 } = r in
  let expected_a0 = (unbox_unit ()) in
  mark_test_run 7;
  let test = (fun _ _ -> true) expected_a0 a0 in
  if not test then failwithf "test 7 failed";
  let expected_b0 = #100L in
  mark_test_run 8;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b0 b0 in
  if not test then failwithf "test 8 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t1 = { unit_u; nativeint# }   *)
  (***********************************)
  let r = { a1 = (unbox_unit ()); b1 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = (unbox_unit ()) in
  mark_test_run 9;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 9 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = #0n in
  mark_test_run 10;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 10 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun _ _ -> true) a11 a12 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b11 b12) in
  let next_r = { a1 = (unbox_unit ()); b1 = #100n } in
  let r_expected = { a1 = (unbox_unit ()); b1 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 11;
  let test = eq r r_expected in
  if not test then failwithf "test 11 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 12;
  let test = eq r r_expected in
  if not test then failwithf "test 12 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = (unbox_unit ()) in
  mark_test_run 13;
  let test = (fun _ _ -> true) expected_a1 a1 in
  if not test then failwithf "test 13 failed";
  let expected_b1 = #100n in
  mark_test_run 14;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b1 b1 in
  if not test then failwithf "test 14 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = (unbox_unit ()) in
  mark_test_run 15;
  let test = (fun _ _ -> true) expected_a1 a1 in
  if not test then failwithf "test 15 failed";
  let expected_b1 = #100n in
  mark_test_run 16;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b1 b1 in
  if not test then failwithf "test 16 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t2 = { unit_u; unit_u; string }   *)
  (***************************************)
  let r = { a2 = (unbox_unit ()); b2 = (unbox_unit ()); c2 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a2 *)
  let actual = r.a2 in
  let expected = (unbox_unit ()) in
  mark_test_run 17;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 17 failed";
  (* Paths of depth 1 *)
  (* .b2 *)
  let actual = r.b2 in
  let expected = (unbox_unit ()) in
  mark_test_run 18;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 18 failed";
  (* Paths of depth 1 *)
  (* .c2 *)
  let actual = r.c2 in
  let expected = "0" in
  mark_test_run 19;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 19 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a2 = a21; b2 = b21; c2 = c21 } { a2 = a22; b2 = b22; c2 = c22 } -> (fun _ _ -> true) a21 a22 && (fun _ _ -> true) b21 b22 && (fun a b -> String.equal (globalize a) (globalize b)) c21 c22) in
  let next_r = { a2 = (unbox_unit ()); b2 = (unbox_unit ()); c2 = "100" } in
  let r_expected = { a2 = (unbox_unit ()); b2 = (unbox_unit ()); c2 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a2 *)
  r.a2 <- next_r.a2;
  let r_expected = { r_expected with a2 = next_r.a2 } in
  mark_test_run 20;
  let test = eq r r_expected in
  if not test then failwithf "test 20 failed";
  Gc.compact ();
  (* .b2 *)
  r.b2 <- next_r.b2;
  let r_expected = { r_expected with b2 = next_r.b2 } in
  mark_test_run 21;
  let test = eq r r_expected in
  if not test then failwithf "test 21 failed";
  Gc.compact ();
  (* .c2 *)
  r.c2 <- next_r.c2;
  let r_expected = { r_expected with c2 = next_r.c2 } in
  mark_test_run 22;
  let test = eq r r_expected in
  if not test then failwithf "test 22 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a2; b2; c2 } = r in
  let expected_a2 = (unbox_unit ()) in
  mark_test_run 23;
  let test = (fun _ _ -> true) expected_a2 a2 in
  if not test then failwithf "test 23 failed";
  let expected_b2 = (unbox_unit ()) in
  mark_test_run 24;
  let test = (fun _ _ -> true) expected_b2 b2 in
  if not test then failwithf "test 24 failed";
  let expected_c2 = "100" in
  mark_test_run 25;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c2 c2 in
  if not test then failwithf "test 25 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a2; b2; c2 } = r in
  let expected_a2 = (unbox_unit ()) in
  mark_test_run 26;
  let test = (fun _ _ -> true) expected_a2 a2 in
  if not test then failwithf "test 26 failed";
  let expected_b2 = (unbox_unit ()) in
  mark_test_run 27;
  let test = (fun _ _ -> true) expected_b2 b2 in
  if not test then failwithf "test 27 failed";
  let expected_c2 = "100" in
  mark_test_run 28;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c2 c2 in
  if not test then failwithf "test 28 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t4 = { float; (| unit_u) }   *)
  (**********************************)
  let r = { a4 = 0.; b4 = (C3_0 (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a4 *)
  let actual = r.a4 in
  let expected = 0. in
  mark_test_run 29;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 29 failed";
  (* Paths of depth 1 *)
  (* .b4 *)
  let actual = r.b4 in
  let expected = (C3_0 (unbox_unit ())) in
  mark_test_run 30;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 30 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a4 = a41; b4 = b41 } { a4 = a42; b4 = b42 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a41 a42 && (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) b41 b42) in
  let next_r = { a4 = 100.; b4 = (C3_0 (unbox_unit ())) } in
  let r_expected = { a4 = 0.; b4 = (C3_0 (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a4 *)
  r.a4 <- next_r.a4;
  let r_expected = { r_expected with a4 = next_r.a4 } in
  mark_test_run 31;
  let test = eq r r_expected in
  if not test then failwithf "test 31 failed";
  Gc.compact ();
  (* .b4 *)
  r.b4 <- next_r.b4;
  let r_expected = { r_expected with b4 = next_r.b4 } in
  mark_test_run 32;
  let test = eq r r_expected in
  if not test then failwithf "test 32 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a4; b4 } = r in
  let expected_a4 = 100. in
  mark_test_run 33;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a4 a4 in
  if not test then failwithf "test 33 failed";
  let expected_b4 = (C3_0 (unbox_unit ())) in
  mark_test_run 34;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) expected_b4 b4 in
  if not test then failwithf "test 34 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a4; b4 } = r in
  let expected_a4 = 100. in
  mark_test_run 35;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a4 a4 in
  if not test then failwithf "test 35 failed";
  let expected_b4 = (C3_0 (unbox_unit ())) in
  mark_test_run 36;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) expected_b4 b4 in
  if not test then failwithf "test 36 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t6 = { string; #{ unit_u; string } }   *)
  (********************************************)
  let r = { a6 = "0"; b6 = #{ a5 = (unbox_unit ()); b5 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = "0" in
  mark_test_run 37;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 37 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = #{ a5 = (unbox_unit ()); b5 = "1" } in
  mark_test_run 38;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) actual expected in
  if not test then failwithf "test 38 failed";
  (* Paths of depth 2 *)
  (* .b6.#a5 *)
  let actual = r.b6.#a5 in
  let expected = (unbox_unit ()) in
  mark_test_run 39;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 39 failed";
  (* .b6.#b5 *)
  let actual = r.b6.#b5 in
  let expected = "1" in
  mark_test_run 40;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 40 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61 } { a6 = a62; b6 = b62 } -> (fun a b -> String.equal (globalize a) (globalize b)) a61 a62 && (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) b61 b62) in
  let next_r = { a6 = "100"; b6 = #{ a5 = (unbox_unit ()); b5 = "101" } } in
  let r_expected = { a6 = "0"; b6 = #{ a5 = (unbox_unit ()); b5 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 41;
  let test = eq r r_expected in
  if not test then failwithf "test 41 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 42;
  let test = eq r r_expected in
  if not test then failwithf "test 42 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6 = #{ a5; b5 } } = r in
  let expected_a6 = "100" in
  mark_test_run 43;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a6 a6 in
  if not test then failwithf "test 43 failed";
  let expected_a5 = (unbox_unit ()) in
  mark_test_run 44;
  let test = (fun _ _ -> true) expected_a5 a5 in
  if not test then failwithf "test 44 failed";
  let expected_b5 = "101" in
  mark_test_run 45;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b5 b5 in
  if not test then failwithf "test 45 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6 } = r in
  let expected_a6 = "100" in
  mark_test_run 46;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a6 a6 in
  if not test then failwithf "test 46 failed";
  let expected_b6 = #{ a5 = (unbox_unit ()); b5 = "101" } in
  mark_test_run 47;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) expected_b6 b6 in
  if not test then failwithf "test 47 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t7 = { (| unit_u); unit_u }   *)
  (***********************************)
  let r = { a7 = (C3_0 (unbox_unit ())); b7 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = (C3_0 (unbox_unit ())) in
  mark_test_run 48;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 48 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = (unbox_unit ()) in
  mark_test_run 49;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 49 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) a71 a72 && (fun _ _ -> true) b71 b72) in
  let next_r = { a7 = (C3_0 (unbox_unit ())); b7 = (unbox_unit ()) } in
  let r_expected = { a7 = (C3_0 (unbox_unit ())); b7 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 50;
  let test = eq r r_expected in
  if not test then failwithf "test 50 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 51;
  let test = eq r r_expected in
  if not test then failwithf "test 51 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 } = r in
  let expected_a7 = (C3_0 (unbox_unit ())) in
  mark_test_run 52;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) expected_a7 a7 in
  if not test then failwithf "test 52 failed";
  let expected_b7 = (unbox_unit ()) in
  mark_test_run 53;
  let test = (fun _ _ -> true) expected_b7 b7 in
  if not test then failwithf "test 53 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = (C3_0 (unbox_unit ())) in
  mark_test_run 54;
  let test = (fun a b -> match a, b with C3_0(a0), C3_0(b0) -> (fun _ _ -> true) a0 b0) expected_a7 a7 in
  if not test then failwithf "test 54 failed";
  let expected_b7 = (unbox_unit ()) in
  mark_test_run 55;
  let test = (fun _ _ -> true) expected_b7 b7 in
  if not test then failwithf "test 55 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t9 = { #{ unit_u }; string }   *)
  (************************************)
  let r = { a9 = #{ a8 = (unbox_unit ()) }; b9 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a8 = (unbox_unit ()) } in
  mark_test_run 56;
  let test = (fun #{ a8 = a81 } #{ a8 = a82 } -> (fun _ _ -> true) a81 a82) actual expected in
  if not test then failwithf "test 56 failed";
  (* Paths of depth 2 *)
  (* .a9.#a8 *)
  let actual = r.a9.#a8 in
  let expected = (unbox_unit ()) in
  mark_test_run 57;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 57 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = "0" in
  mark_test_run 58;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 58 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a8 = a81 } #{ a8 = a82 } -> (fun _ _ -> true) a81 a82) a91 a92 && (fun a b -> String.equal (globalize a) (globalize b)) b91 b92) in
  let next_r = { a9 = #{ a8 = (unbox_unit ()) }; b9 = "100" } in
  let r_expected = { a9 = #{ a8 = (unbox_unit ()) }; b9 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 59;
  let test = eq r r_expected in
  if not test then failwithf "test 59 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 60;
  let test = eq r r_expected in
  if not test then failwithf "test 60 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a8 }; b9 } = r in
  let expected_a8 = (unbox_unit ()) in
  mark_test_run 61;
  let test = (fun _ _ -> true) expected_a8 a8 in
  if not test then failwithf "test 61 failed";
  let expected_b9 = "100" in
  mark_test_run 62;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b9 b9 in
  if not test then failwithf "test 62 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a8 = (unbox_unit ()) } in
  mark_test_run 63;
  let test = (fun #{ a8 = a81 } #{ a8 = a82 } -> (fun _ _ -> true) a81 a82) expected_a9 a9 in
  if not test then failwithf "test 63 failed";
  let expected_b9 = "100" in
  mark_test_run 64;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b9 b9 in
  if not test then failwithf "test 64 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t10 = { #{ unit_u; string }; string }   *)
  (*********************************************)
  let r = { a10 = #{ a5 = (unbox_unit ()); b5 = "0" }; b10 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a5 = (unbox_unit ()); b5 = "0" } in
  mark_test_run 65;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) actual expected in
  if not test then failwithf "test 65 failed";
  (* Paths of depth 2 *)
  (* .a10.#a5 *)
  let actual = r.a10.#a5 in
  let expected = (unbox_unit ()) in
  mark_test_run 66;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 66 failed";
  (* .a10.#b5 *)
  let actual = r.a10.#b5 in
  let expected = "0" in
  mark_test_run 67;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 67 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = "1" in
  mark_test_run 68;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 68 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) a101 a102 && (fun a b -> String.equal (globalize a) (globalize b)) b101 b102) in
  let next_r = { a10 = #{ a5 = (unbox_unit ()); b5 = "100" }; b10 = "101" } in
  let r_expected = { a10 = #{ a5 = (unbox_unit ()); b5 = "0" }; b10 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 69;
  let test = eq r r_expected in
  if not test then failwithf "test 69 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 70;
  let test = eq r r_expected in
  if not test then failwithf "test 70 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a5; b5 }; b10 } = r in
  let expected_a5 = (unbox_unit ()) in
  mark_test_run 71;
  let test = (fun _ _ -> true) expected_a5 a5 in
  if not test then failwithf "test 71 failed";
  let expected_b5 = "100" in
  mark_test_run 72;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b5 b5 in
  if not test then failwithf "test 72 failed";
  let expected_b10 = "101" in
  mark_test_run 73;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b10 b10 in
  if not test then failwithf "test 73 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a5 = (unbox_unit ()); b5 = "100" } in
  mark_test_run 74;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52) expected_a10 a10 in
  if not test then failwithf "test 74 failed";
  let expected_b10 = "101" in
  mark_test_run 75;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b10 b10 in
  if not test then failwithf "test 75 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t12 = { #{ string; unit_u }; unit_u }   *)
  (*********************************************)
  let r = { a12 = #{ a11 = "0"; b11 = (unbox_unit ()) }; b12 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a12 *)
  let actual = r.a12 in
  let expected = #{ a11 = "0"; b11 = (unbox_unit ()) } in
  mark_test_run 76;
  let test = (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> (fun a b -> String.equal (globalize a) (globalize b)) a111 a112 && (fun _ _ -> true) b111 b112) actual expected in
  if not test then failwithf "test 76 failed";
  (* Paths of depth 2 *)
  (* .a12.#a11 *)
  let actual = r.a12.#a11 in
  let expected = "0" in
  mark_test_run 77;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 77 failed";
  (* .a12.#b11 *)
  let actual = r.a12.#b11 in
  let expected = (unbox_unit ()) in
  mark_test_run 78;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 78 failed";
  (* Paths of depth 1 *)
  (* .b12 *)
  let actual = r.b12 in
  let expected = (unbox_unit ()) in
  mark_test_run 79;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 79 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a12 = a121; b12 = b121 } { a12 = a122; b12 = b122 } -> (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> (fun a b -> String.equal (globalize a) (globalize b)) a111 a112 && (fun _ _ -> true) b111 b112) a121 a122 && (fun _ _ -> true) b121 b122) in
  let next_r = { a12 = #{ a11 = "100"; b11 = (unbox_unit ()) }; b12 = (unbox_unit ()) } in
  let r_expected = { a12 = #{ a11 = "0"; b11 = (unbox_unit ()) }; b12 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a12 *)
  r.a12 <- next_r.a12;
  let r_expected = { r_expected with a12 = next_r.a12 } in
  mark_test_run 80;
  let test = eq r r_expected in
  if not test then failwithf "test 80 failed";
  Gc.compact ();
  (* .b12 *)
  r.b12 <- next_r.b12;
  let r_expected = { r_expected with b12 = next_r.b12 } in
  mark_test_run 81;
  let test = eq r r_expected in
  if not test then failwithf "test 81 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a12 = #{ a11; b11 }; b12 } = r in
  let expected_a11 = "100" in
  mark_test_run 82;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a11 a11 in
  if not test then failwithf "test 82 failed";
  let expected_b11 = (unbox_unit ()) in
  mark_test_run 83;
  let test = (fun _ _ -> true) expected_b11 b11 in
  if not test then failwithf "test 83 failed";
  let expected_b12 = (unbox_unit ()) in
  mark_test_run 84;
  let test = (fun _ _ -> true) expected_b12 b12 in
  if not test then failwithf "test 84 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a12; b12 } = r in
  let expected_a12 = #{ a11 = "100"; b11 = (unbox_unit ()) } in
  mark_test_run 85;
  let test = (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> (fun a b -> String.equal (globalize a) (globalize b)) a111 a112 && (fun _ _ -> true) b111 b112) expected_a12 a12 in
  if not test then failwithf "test 85 failed";
  let expected_b12 = (unbox_unit ()) in
  mark_test_run 86;
  let test = (fun _ _ -> true) expected_b12 b12 in
  if not test then failwithf "test 86 failed";

  ()
;;
let () = to_run ();;

for i = 1 to 86 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
