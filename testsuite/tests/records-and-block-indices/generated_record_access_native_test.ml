(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

let int64x2_u_equal i1 i2 =
    let a1 = int64_of_int64x2 i1 in
    let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
    let a2 = int64_of_int64x2 i2 in
    let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
    Int64.equal a1 a2 && Int64.equal b1 b2

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = { mutable a0 : int } (* { int } *)
type t1 = { mutable a1 : int; mutable b1 : int } (* { int; int } *)
type t2 = #{ a2 : int } (* #{ int } *)
type t3 = { mutable a3 : t2 } (* { #{ int } } *)
type t4 = #{ a4 : int; b4 : int } (* #{ int; int } *)
type t5 = { mutable a5 : t4 } (* { #{ int; int } } *)
type t6 = { mutable a6 : int; mutable b6 : int; mutable c6 : int } (* { int; int; int } *)
type t7 = { mutable a7 : int; mutable b7 : t2 } (* { int; #{ int } } *)
type t8 = { mutable a8 : int; mutable b8 : t4 } (* { int; #{ int; int } } *)
type t9 = { mutable a9 : t2; mutable b9 : int } (* { #{ int }; int } *)
type t10 = { mutable a10 : t4; mutable b10 : int } (* { #{ int; int }; int } *)

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 1;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 2;
  let test = eq r r_expected in
  if not test then failwithf "test 2 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 3;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 3 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 4;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 4 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 5;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 6;
  let test = eq r r_expected in
  if not test then failwithf "test 6 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 7;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 7 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 8;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 8 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 9;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 9 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 10;
  let test = eq r r_expected in
  if not test then failwithf "test 10 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 11;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 11 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 12;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 12 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 13;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 13 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 14;
  let test = eq r r_expected in
  if not test then failwithf "test 14 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 15;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 15 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 16;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 16 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 17;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 17 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 18;
  let test = eq r r_expected in
  if not test then failwithf "test 18 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 19;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 19 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 20;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 20 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 21;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 21 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 22;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 22 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 23;
  let test = eq r r_expected in
  if not test then failwithf "test 23 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 24;
  let test = eq r r_expected in
  if not test then failwithf "test 24 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 25;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 25 failed";
  let expected_b1 = 101 in
  mark_test_run 26;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 26 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 27;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 27 failed";
  let expected_b1 = 101 in
  mark_test_run 28;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 28 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 29;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 29 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 30;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 30 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 31;
  let test = eq r r_expected in
  if not test then failwithf "test 31 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 32;
  let test = eq r r_expected in
  if not test then failwithf "test 32 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 33;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 33 failed";
  let expected_b1 = 101 in
  mark_test_run 34;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 34 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 35;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 35 failed";
  let expected_b1 = 101 in
  mark_test_run 36;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 36 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 37;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 37 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 38;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 38 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 39;
  let test = eq r r_expected in
  if not test then failwithf "test 39 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 40;
  let test = eq r r_expected in
  if not test then failwithf "test 40 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 41;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 41 failed";
  let expected_b1 = 101 in
  mark_test_run 42;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 42 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 43;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 43 failed";
  let expected_b1 = 101 in
  mark_test_run 44;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 44 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 45;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 45 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 46;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 46 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 47;
  let test = eq r r_expected in
  if not test then failwithf "test 47 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 48;
  let test = eq r r_expected in
  if not test then failwithf "test 48 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 49;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 49 failed";
  let expected_b1 = 101 in
  mark_test_run 50;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 50 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 51;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 51 failed";
  let expected_b1 = 101 in
  mark_test_run 52;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 52 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 53;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 53 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 54;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 54 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 55;
  let test = eq r r_expected in
  if not test then failwithf "test 55 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 56;
  let test = eq r r_expected in
  if not test then failwithf "test 56 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 57;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 57 failed";
  let expected_b1 = 101 in
  mark_test_run 58;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 58 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 59;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 59 failed";
  let expected_b1 = 101 in
  mark_test_run 60;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 60 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 61;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 61 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 62;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 62 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 63;
  let test = eq r r_expected in
  if not test then failwithf "test 63 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 64;
  let test = eq r r_expected in
  if not test then failwithf "test 64 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 65;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 65 failed";
  let expected_b1 = 101 in
  mark_test_run 66;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 66 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 67;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 67 failed";
  let expected_b1 = 101 in
  mark_test_run 68;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 68 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 69;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 69 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 70;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 70 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 71;
  let test = eq r r_expected in
  if not test then failwithf "test 71 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 72;
  let test = eq r r_expected in
  if not test then failwithf "test 72 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 73;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 73 failed";
  let expected_b1 = 101 in
  mark_test_run 74;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 74 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 75;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 75 failed";
  let expected_b1 = 101 in
  mark_test_run 76;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 76 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 77;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 77 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 78;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 78 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 79;
  let test = eq r r_expected in
  if not test then failwithf "test 79 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 80;
  let test = eq r r_expected in
  if not test then failwithf "test 80 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 81;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 81 failed";
  let expected_b1 = 101 in
  mark_test_run 82;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 82 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 83;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 83 failed";
  let expected_b1 = 101 in
  mark_test_run 84;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 84 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 85;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 85 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 86;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 86 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 87;
  let test = eq r r_expected in
  if not test then failwithf "test 87 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 88;
  let test = eq r r_expected in
  if not test then failwithf "test 88 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 89;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 89 failed";
  let expected_b1 = 101 in
  mark_test_run 90;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 90 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 91;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 91 failed";
  let expected_b1 = 101 in
  mark_test_run 92;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 92 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 93;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 93 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 94;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 94 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 95;
  let test = eq r r_expected in
  if not test then failwithf "test 95 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 96;
  let test = eq r r_expected in
  if not test then failwithf "test 96 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 97;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 97 failed";
  let expected_b1 = 101 in
  mark_test_run 98;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 98 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 99;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 99 failed";
  let expected_b1 = 101 in
  mark_test_run 100;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 100 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 101;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 101 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 102;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 102 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 103;
  let test = eq r r_expected in
  if not test then failwithf "test 103 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 104;
  let test = eq r r_expected in
  if not test then failwithf "test 104 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 105;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 105 failed";
  let expected_b1 = 101 in
  mark_test_run 106;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 106 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 107;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 107 failed";
  let expected_b1 = 101 in
  mark_test_run 108;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 108 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 109;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 109 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 110;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 110 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 111;
  let test = eq r r_expected in
  if not test then failwithf "test 111 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 112;
  let test = eq r r_expected in
  if not test then failwithf "test 112 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 113;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 113 failed";
  let expected_b1 = 101 in
  mark_test_run 114;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 114 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 115;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 115 failed";
  let expected_b1 = 101 in
  mark_test_run 116;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 116 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 117;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 117 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 118;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 118 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 119;
  let test = eq r r_expected in
  if not test then failwithf "test 119 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 120;
  let test = eq r r_expected in
  if not test then failwithf "test 120 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 121;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 121 failed";
  let expected_b1 = 101 in
  mark_test_run 122;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 122 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 123;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 123 failed";
  let expected_b1 = 101 in
  mark_test_run 124;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 124 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 125;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 125 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 126;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 126 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 127;
  let test = eq r r_expected in
  if not test then failwithf "test 127 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 128;
  let test = eq r r_expected in
  if not test then failwithf "test 128 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 129;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 129 failed";
  let expected_b1 = 101 in
  mark_test_run 130;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 130 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 131;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 131 failed";
  let expected_b1 = 101 in
  mark_test_run 132;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 132 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 133;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 133 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 134;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 134 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 135;
  let test = eq r r_expected in
  if not test then failwithf "test 135 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 136;
  let test = eq r r_expected in
  if not test then failwithf "test 136 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 137;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 137 failed";
  let expected_b1 = 101 in
  mark_test_run 138;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 138 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 139;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 139 failed";
  let expected_b1 = 101 in
  mark_test_run 140;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 140 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 141;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 141 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 142;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 142 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 143;
  let test = eq r r_expected in
  if not test then failwithf "test 143 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 144;
  let test = eq r r_expected in
  if not test then failwithf "test 144 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 145;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 145 failed";
  let expected_b1 = 101 in
  mark_test_run 146;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 146 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 147;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 147 failed";
  let expected_b1 = 101 in
  mark_test_run 148;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 148 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 149;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 149 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 150;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 150 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 151;
  let test = eq r r_expected in
  if not test then failwithf "test 151 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 152;
  let test = eq r r_expected in
  if not test then failwithf "test 152 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 153;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 153 failed";
  let expected_b1 = 101 in
  mark_test_run 154;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 154 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 155;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 155 failed";
  let expected_b1 = 101 in
  mark_test_run 156;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 156 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 157;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 157 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 158;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 158 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 159;
  let test = eq r r_expected in
  if not test then failwithf "test 159 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 160;
  let test = eq r r_expected in
  if not test then failwithf "test 160 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 161;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 161 failed";
  let expected_b1 = 101 in
  mark_test_run 162;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 162 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 163;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 163 failed";
  let expected_b1 = 101 in
  mark_test_run 164;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 164 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 165;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 165 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 166;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 166 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 167;
  let test = eq r r_expected in
  if not test then failwithf "test 167 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 168;
  let test = eq r r_expected in
  if not test then failwithf "test 168 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 169;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 169 failed";
  let expected_b1 = 101 in
  mark_test_run 170;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 170 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 171;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 171 failed";
  let expected_b1 = 101 in
  mark_test_run 172;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 172 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 173;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 173 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 174;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 174 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 175;
  let test = eq r r_expected in
  if not test then failwithf "test 175 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 176;
  let test = eq r r_expected in
  if not test then failwithf "test 176 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 177;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 177 failed";
  let expected_b1 = 101 in
  mark_test_run 178;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 178 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 179;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 179 failed";
  let expected_b1 = 101 in
  mark_test_run 180;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 180 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 181;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 181 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 182;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 182 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 183;
  let test = eq r r_expected in
  if not test then failwithf "test 183 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 184;
  let test = eq r r_expected in
  if not test then failwithf "test 184 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 185;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 185 failed";
  let expected_b1 = 101 in
  mark_test_run 186;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 186 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 187;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 187 failed";
  let expected_b1 = 101 in
  mark_test_run 188;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 188 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 189;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 189 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 190;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 190 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 191;
  let test = eq r r_expected in
  if not test then failwithf "test 191 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 192;
  let test = eq r r_expected in
  if not test then failwithf "test 192 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 193;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 193 failed";
  let expected_b1 = 101 in
  mark_test_run 194;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 194 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 195;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 195 failed";
  let expected_b1 = 101 in
  mark_test_run 196;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 196 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 197;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 197 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 198;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 198 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 199;
  let test = eq r r_expected in
  if not test then failwithf "test 199 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 200;
  let test = eq r r_expected in
  if not test then failwithf "test 200 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 201;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 201 failed";
  let expected_b1 = 101 in
  mark_test_run 202;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 202 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 203;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 203 failed";
  let expected_b1 = 101 in
  mark_test_run 204;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 204 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 205;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 205 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 206;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 206 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 207;
  let test = eq r r_expected in
  if not test then failwithf "test 207 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 208;
  let test = eq r r_expected in
  if not test then failwithf "test 208 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 209;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 209 failed";
  let expected_b1 = 101 in
  mark_test_run 210;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 210 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 211;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 211 failed";
  let expected_b1 = 101 in
  mark_test_run 212;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 212 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 213;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 213 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 214;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 214 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 215;
  let test = eq r r_expected in
  if not test then failwithf "test 215 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 216;
  let test = eq r r_expected in
  if not test then failwithf "test 216 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 217;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 217 failed";
  let expected_b1 = 101 in
  mark_test_run 218;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 218 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 219;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 219 failed";
  let expected_b1 = 101 in
  mark_test_run 220;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 220 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t3 = { #{ int } }   *)
  (*************************)
  let r = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = #{ a2 = 0 } in
  mark_test_run 221;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 221 failed";
  (* Paths of depth 2 *)
  (* .a3.#a2 *)
  let actual = r.a3.#a2 in
  let expected = 0 in
  mark_test_run 222;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 222 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31 } { a3 = a32 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a31 a32) in
  let next_r = { a3 = #{ a2 = 100 } } in
  let r_expected = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 223;
  let test = eq r r_expected in
  if not test then failwithf "test 223 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3 = #{ a2 } } = r in
  let expected_a2 = 100 in
  mark_test_run 224;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 224 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3 } = r in
  let expected_a3 = #{ a2 = 100 } in
  mark_test_run 225;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a3 a3 in
  if not test then failwithf "test 225 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t3 = { #{ int } }   *)
  (*************************)
  let r = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = #{ a2 = 0 } in
  mark_test_run 226;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 226 failed";
  (* Paths of depth 2 *)
  (* .a3.#a2 *)
  let actual = r.a3.#a2 in
  let expected = 0 in
  mark_test_run 227;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 227 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31 } { a3 = a32 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a31 a32) in
  let next_r = { a3 = #{ a2 = 100 } } in
  let r_expected = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 228;
  let test = eq r r_expected in
  if not test then failwithf "test 228 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3 = #{ a2 } } = r in
  let expected_a2 = 100 in
  mark_test_run 229;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 229 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3 } = r in
  let expected_a3 = #{ a2 = 100 } in
  mark_test_run 230;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a3 a3 in
  if not test then failwithf "test 230 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t3 = { #{ int } }   *)
  (*************************)
  let r = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = #{ a2 = 0 } in
  mark_test_run 231;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 231 failed";
  (* Paths of depth 2 *)
  (* .a3.#a2 *)
  let actual = r.a3.#a2 in
  let expected = 0 in
  mark_test_run 232;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 232 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31 } { a3 = a32 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a31 a32) in
  let next_r = { a3 = #{ a2 = 100 } } in
  let r_expected = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 233;
  let test = eq r r_expected in
  if not test then failwithf "test 233 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3 = #{ a2 } } = r in
  let expected_a2 = 100 in
  mark_test_run 234;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 234 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3 } = r in
  let expected_a3 = #{ a2 = 100 } in
  mark_test_run 235;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a3 a3 in
  if not test then failwithf "test 235 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t3 = { #{ int } }   *)
  (*************************)
  let r = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = #{ a2 = 0 } in
  mark_test_run 236;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 236 failed";
  (* Paths of depth 2 *)
  (* .a3.#a2 *)
  let actual = r.a3.#a2 in
  let expected = 0 in
  mark_test_run 237;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 237 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31 } { a3 = a32 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a31 a32) in
  let next_r = { a3 = #{ a2 = 100 } } in
  let r_expected = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 238;
  let test = eq r r_expected in
  if not test then failwithf "test 238 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3 = #{ a2 } } = r in
  let expected_a2 = 100 in
  mark_test_run 239;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 239 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3 } = r in
  let expected_a3 = #{ a2 = 100 } in
  mark_test_run 240;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a3 a3 in
  if not test then failwithf "test 240 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t3 = { #{ int } }   *)
  (*************************)
  let r = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = #{ a2 = 0 } in
  mark_test_run 241;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 241 failed";
  (* Paths of depth 2 *)
  (* .a3.#a2 *)
  let actual = r.a3.#a2 in
  let expected = 0 in
  mark_test_run 242;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 242 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31 } { a3 = a32 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a31 a32) in
  let next_r = { a3 = #{ a2 = 100 } } in
  let r_expected = { a3 = #{ a2 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 243;
  let test = eq r r_expected in
  if not test then failwithf "test 243 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3 = #{ a2 } } = r in
  let expected_a2 = 100 in
  mark_test_run 244;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 244 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3 } = r in
  let expected_a3 = #{ a2 = 100 } in
  mark_test_run 245;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a3 a3 in
  if not test then failwithf "test 245 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 246;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 246 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 247;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 247 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 248;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 248 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 249;
  let test = eq r r_expected in
  if not test then failwithf "test 249 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 250;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 250 failed";
  let expected_b4 = 101 in
  mark_test_run 251;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 251 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 252;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 252 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 253;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 253 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 254;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 254 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 255;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 255 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 256;
  let test = eq r r_expected in
  if not test then failwithf "test 256 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 257;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 257 failed";
  let expected_b4 = 101 in
  mark_test_run 258;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 258 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 259;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 259 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 260;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 260 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 261;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 261 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 262;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 262 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 263;
  let test = eq r r_expected in
  if not test then failwithf "test 263 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 264;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 264 failed";
  let expected_b4 = 101 in
  mark_test_run 265;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 265 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 266;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 266 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 267;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 267 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 268;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 268 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 269;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 269 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 270;
  let test = eq r r_expected in
  if not test then failwithf "test 270 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 271;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 271 failed";
  let expected_b4 = 101 in
  mark_test_run 272;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 272 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 273;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 273 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 274;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 274 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 275;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 275 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 276;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 276 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 277;
  let test = eq r r_expected in
  if not test then failwithf "test 277 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 278;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 278 failed";
  let expected_b4 = 101 in
  mark_test_run 279;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 279 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 280;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 280 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 281;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 281 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 282;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 282 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 283;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 283 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 284;
  let test = eq r r_expected in
  if not test then failwithf "test 284 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 285;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 285 failed";
  let expected_b4 = 101 in
  mark_test_run 286;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 286 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 287;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 287 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 288;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 288 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 289;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 289 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 290;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 290 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 291;
  let test = eq r r_expected in
  if not test then failwithf "test 291 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 292;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 292 failed";
  let expected_b4 = 101 in
  mark_test_run 293;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 293 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 294;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 294 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 295;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 295 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 296;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 296 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 297;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 297 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 298;
  let test = eq r r_expected in
  if not test then failwithf "test 298 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 299;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 299 failed";
  let expected_b4 = 101 in
  mark_test_run 300;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 300 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 301;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 301 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 302;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 302 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 303;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 303 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 304;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 304 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 305;
  let test = eq r r_expected in
  if not test then failwithf "test 305 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 306;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 306 failed";
  let expected_b4 = 101 in
  mark_test_run 307;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 307 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 308;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 308 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 309;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 309 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 310;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 310 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 311;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 311 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 312;
  let test = eq r r_expected in
  if not test then failwithf "test 312 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 313;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 313 failed";
  let expected_b4 = 101 in
  mark_test_run 314;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 314 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 315;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 315 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 316;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 316 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 317;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 317 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 318;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 318 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 319;
  let test = eq r r_expected in
  if not test then failwithf "test 319 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 320;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 320 failed";
  let expected_b4 = 101 in
  mark_test_run 321;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 321 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 322;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 322 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 323;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 323 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 324;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 324 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 325;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 325 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 326;
  let test = eq r r_expected in
  if not test then failwithf "test 326 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 327;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 327 failed";
  let expected_b4 = 101 in
  mark_test_run 328;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 328 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 329;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 329 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 330;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 330 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 331;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 331 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 332;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 332 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 333;
  let test = eq r r_expected in
  if not test then failwithf "test 333 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 334;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 334 failed";
  let expected_b4 = 101 in
  mark_test_run 335;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 335 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 336;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 336 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 337;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 337 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 338;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 338 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 339;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 339 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 340;
  let test = eq r r_expected in
  if not test then failwithf "test 340 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 341;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 341 failed";
  let expected_b4 = 101 in
  mark_test_run 342;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 342 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 343;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 343 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 344;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 344 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 345;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 345 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 346;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 346 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 347;
  let test = eq r r_expected in
  if not test then failwithf "test 347 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 348;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 348 failed";
  let expected_b4 = 101 in
  mark_test_run 349;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 349 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 350;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 350 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 351;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 351 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 352;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 352 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 353;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 353 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 354;
  let test = eq r r_expected in
  if not test then failwithf "test 354 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 355;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 355 failed";
  let expected_b4 = 101 in
  mark_test_run 356;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 356 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 357;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 357 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 358;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 358 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 359;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 359 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 360;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 360 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 361;
  let test = eq r r_expected in
  if not test then failwithf "test 361 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 362;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 362 failed";
  let expected_b4 = 101 in
  mark_test_run 363;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 363 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 364;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 364 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 365;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 365 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 366;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 366 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 367;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 367 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 368;
  let test = eq r r_expected in
  if not test then failwithf "test 368 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 369;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 369 failed";
  let expected_b4 = 101 in
  mark_test_run 370;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 370 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 371;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 371 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 372;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 372 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 373;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 373 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 374;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 374 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 375;
  let test = eq r r_expected in
  if not test then failwithf "test 375 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 376;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 376 failed";
  let expected_b4 = 101 in
  mark_test_run 377;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 377 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 378;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 378 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 379;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 379 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 380;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 380 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 381;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 381 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 382;
  let test = eq r r_expected in
  if not test then failwithf "test 382 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 383;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 383 failed";
  let expected_b4 = 101 in
  mark_test_run 384;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 384 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 385;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 385 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 386;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 386 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 387;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 387 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 388;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 388 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 389;
  let test = eq r r_expected in
  if not test then failwithf "test 389 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 390;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 390 failed";
  let expected_b4 = 101 in
  mark_test_run 391;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 391 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 392;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 392 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 393;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 393 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 394;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 394 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 395;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 395 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 396;
  let test = eq r r_expected in
  if not test then failwithf "test 396 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 397;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 397 failed";
  let expected_b4 = 101 in
  mark_test_run 398;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 398 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 399;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 399 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 400;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 400 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 401;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 401 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 402;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 402 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 403;
  let test = eq r r_expected in
  if not test then failwithf "test 403 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 404;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 404 failed";
  let expected_b4 = 101 in
  mark_test_run 405;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 405 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 406;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 406 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 407;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 407 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 408;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 408 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 409;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 409 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 410;
  let test = eq r r_expected in
  if not test then failwithf "test 410 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 411;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 411 failed";
  let expected_b4 = 101 in
  mark_test_run 412;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 412 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 413;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 413 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t5 = { #{ int; int } }   *)
  (******************************)
  let r = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 414;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 414 failed";
  (* Paths of depth 2 *)
  (* .a5.#a4 *)
  let actual = r.a5.#a4 in
  let expected = 0 in
  mark_test_run 415;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 415 failed";
  (* .a5.#b4 *)
  let actual = r.a5.#b4 in
  let expected = 1 in
  mark_test_run 416;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 416 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51 } { a5 = a52 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a51 a52) in
  let next_r = { a5 = #{ a4 = 100; b4 = 101 } } in
  let r_expected = { a5 = #{ a4 = 0; b4 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 417;
  let test = eq r r_expected in
  if not test then failwithf "test 417 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5 = #{ a4; b4 } } = r in
  let expected_a4 = 100 in
  mark_test_run 418;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 418 failed";
  let expected_b4 = 101 in
  mark_test_run 419;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 419 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5 } = r in
  let expected_a5 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 420;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a5 a5 in
  if not test then failwithf "test 420 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 421;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 421 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 422;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 422 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 423;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 423 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 424;
  let test = eq r r_expected in
  if not test then failwithf "test 424 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 425;
  let test = eq r r_expected in
  if not test then failwithf "test 425 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 426;
  let test = eq r r_expected in
  if not test then failwithf "test 426 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 427;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 427 failed";
  let expected_b6 = 101 in
  mark_test_run 428;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 428 failed";
  let expected_c6 = 102 in
  mark_test_run 429;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 429 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 430;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 430 failed";
  let expected_b6 = 101 in
  mark_test_run 431;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 431 failed";
  let expected_c6 = 102 in
  mark_test_run 432;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 432 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 433;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 433 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 434;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 434 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 435;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 435 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 436;
  let test = eq r r_expected in
  if not test then failwithf "test 436 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 437;
  let test = eq r r_expected in
  if not test then failwithf "test 437 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 438;
  let test = eq r r_expected in
  if not test then failwithf "test 438 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 439;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 439 failed";
  let expected_b6 = 101 in
  mark_test_run 440;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 440 failed";
  let expected_c6 = 102 in
  mark_test_run 441;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 441 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 442;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 442 failed";
  let expected_b6 = 101 in
  mark_test_run 443;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 443 failed";
  let expected_c6 = 102 in
  mark_test_run 444;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 444 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 445;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 445 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 446;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 446 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 447;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 447 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 448;
  let test = eq r r_expected in
  if not test then failwithf "test 448 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 449;
  let test = eq r r_expected in
  if not test then failwithf "test 449 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 450;
  let test = eq r r_expected in
  if not test then failwithf "test 450 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 451;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 451 failed";
  let expected_b6 = 101 in
  mark_test_run 452;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 452 failed";
  let expected_c6 = 102 in
  mark_test_run 453;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 453 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 454;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 454 failed";
  let expected_b6 = 101 in
  mark_test_run 455;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 455 failed";
  let expected_c6 = 102 in
  mark_test_run 456;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 456 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 457;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 457 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 458;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 458 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 459;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 459 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 460;
  let test = eq r r_expected in
  if not test then failwithf "test 460 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 461;
  let test = eq r r_expected in
  if not test then failwithf "test 461 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 462;
  let test = eq r r_expected in
  if not test then failwithf "test 462 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 463;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 463 failed";
  let expected_b6 = 101 in
  mark_test_run 464;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 464 failed";
  let expected_c6 = 102 in
  mark_test_run 465;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 465 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 466;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 466 failed";
  let expected_b6 = 101 in
  mark_test_run 467;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 467 failed";
  let expected_c6 = 102 in
  mark_test_run 468;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 468 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 469;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 469 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 470;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 470 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 471;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 471 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 472;
  let test = eq r r_expected in
  if not test then failwithf "test 472 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 473;
  let test = eq r r_expected in
  if not test then failwithf "test 473 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 474;
  let test = eq r r_expected in
  if not test then failwithf "test 474 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 475;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 475 failed";
  let expected_b6 = 101 in
  mark_test_run 476;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 476 failed";
  let expected_c6 = 102 in
  mark_test_run 477;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 477 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 478;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 478 failed";
  let expected_b6 = 101 in
  mark_test_run 479;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 479 failed";
  let expected_c6 = 102 in
  mark_test_run 480;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 480 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 481;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 481 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 482;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 482 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 483;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 483 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 484;
  let test = eq r r_expected in
  if not test then failwithf "test 484 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 485;
  let test = eq r r_expected in
  if not test then failwithf "test 485 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 486;
  let test = eq r r_expected in
  if not test then failwithf "test 486 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 487;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 487 failed";
  let expected_b6 = 101 in
  mark_test_run 488;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 488 failed";
  let expected_c6 = 102 in
  mark_test_run 489;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 489 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 490;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 490 failed";
  let expected_b6 = 101 in
  mark_test_run 491;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 491 failed";
  let expected_c6 = 102 in
  mark_test_run 492;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 492 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 493;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 493 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 494;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 494 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 495;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 495 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 496;
  let test = eq r r_expected in
  if not test then failwithf "test 496 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 497;
  let test = eq r r_expected in
  if not test then failwithf "test 497 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 498;
  let test = eq r r_expected in
  if not test then failwithf "test 498 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 499;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 499 failed";
  let expected_b6 = 101 in
  mark_test_run 500;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 500 failed";
  let expected_c6 = 102 in
  mark_test_run 501;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 501 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 502;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 502 failed";
  let expected_b6 = 101 in
  mark_test_run 503;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 503 failed";
  let expected_c6 = 102 in
  mark_test_run 504;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 504 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 505;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 505 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 506;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 506 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 507;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 507 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 508;
  let test = eq r r_expected in
  if not test then failwithf "test 508 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 509;
  let test = eq r r_expected in
  if not test then failwithf "test 509 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 510;
  let test = eq r r_expected in
  if not test then failwithf "test 510 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 511;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 511 failed";
  let expected_b6 = 101 in
  mark_test_run 512;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 512 failed";
  let expected_c6 = 102 in
  mark_test_run 513;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 513 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 514;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 514 failed";
  let expected_b6 = 101 in
  mark_test_run 515;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 515 failed";
  let expected_c6 = 102 in
  mark_test_run 516;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 516 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 517;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 517 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 518;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 518 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 519;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 519 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 520;
  let test = eq r r_expected in
  if not test then failwithf "test 520 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 521;
  let test = eq r r_expected in
  if not test then failwithf "test 521 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 522;
  let test = eq r r_expected in
  if not test then failwithf "test 522 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 523;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 523 failed";
  let expected_b6 = 101 in
  mark_test_run 524;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 524 failed";
  let expected_c6 = 102 in
  mark_test_run 525;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 525 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 526;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 526 failed";
  let expected_b6 = 101 in
  mark_test_run 527;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 527 failed";
  let expected_c6 = 102 in
  mark_test_run 528;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 528 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 529;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 529 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 530;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 530 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 531;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 531 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 532;
  let test = eq r r_expected in
  if not test then failwithf "test 532 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 533;
  let test = eq r r_expected in
  if not test then failwithf "test 533 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 534;
  let test = eq r r_expected in
  if not test then failwithf "test 534 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 535;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 535 failed";
  let expected_b6 = 101 in
  mark_test_run 536;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 536 failed";
  let expected_c6 = 102 in
  mark_test_run 537;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 537 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 538;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 538 failed";
  let expected_b6 = 101 in
  mark_test_run 539;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 539 failed";
  let expected_c6 = 102 in
  mark_test_run 540;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 540 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 541;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 541 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 542;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 542 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 543;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 543 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 544;
  let test = eq r r_expected in
  if not test then failwithf "test 544 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 545;
  let test = eq r r_expected in
  if not test then failwithf "test 545 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 546;
  let test = eq r r_expected in
  if not test then failwithf "test 546 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 547;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 547 failed";
  let expected_b6 = 101 in
  mark_test_run 548;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 548 failed";
  let expected_c6 = 102 in
  mark_test_run 549;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 549 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 550;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 550 failed";
  let expected_b6 = 101 in
  mark_test_run 551;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 551 failed";
  let expected_c6 = 102 in
  mark_test_run 552;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 552 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 553;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 553 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 554;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 554 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 555;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 555 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 556;
  let test = eq r r_expected in
  if not test then failwithf "test 556 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 557;
  let test = eq r r_expected in
  if not test then failwithf "test 557 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 558;
  let test = eq r r_expected in
  if not test then failwithf "test 558 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 559;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 559 failed";
  let expected_b6 = 101 in
  mark_test_run 560;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 560 failed";
  let expected_c6 = 102 in
  mark_test_run 561;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 561 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 562;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 562 failed";
  let expected_b6 = 101 in
  mark_test_run 563;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 563 failed";
  let expected_c6 = 102 in
  mark_test_run 564;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 564 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 565;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 565 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 566;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 566 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 567;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 567 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 568;
  let test = eq r r_expected in
  if not test then failwithf "test 568 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 569;
  let test = eq r r_expected in
  if not test then failwithf "test 569 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 570;
  let test = eq r r_expected in
  if not test then failwithf "test 570 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 571;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 571 failed";
  let expected_b6 = 101 in
  mark_test_run 572;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 572 failed";
  let expected_c6 = 102 in
  mark_test_run 573;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 573 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 574;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 574 failed";
  let expected_b6 = 101 in
  mark_test_run 575;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 575 failed";
  let expected_c6 = 102 in
  mark_test_run 576;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 576 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 577;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 577 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 578;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 578 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 579;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 579 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 580;
  let test = eq r r_expected in
  if not test then failwithf "test 580 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 581;
  let test = eq r r_expected in
  if not test then failwithf "test 581 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 582;
  let test = eq r r_expected in
  if not test then failwithf "test 582 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 583;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 583 failed";
  let expected_b6 = 101 in
  mark_test_run 584;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 584 failed";
  let expected_c6 = 102 in
  mark_test_run 585;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 585 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 586;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 586 failed";
  let expected_b6 = 101 in
  mark_test_run 587;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 587 failed";
  let expected_c6 = 102 in
  mark_test_run 588;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 588 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 589;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 589 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 590;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 590 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 591;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 591 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 592;
  let test = eq r r_expected in
  if not test then failwithf "test 592 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 593;
  let test = eq r r_expected in
  if not test then failwithf "test 593 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 594;
  let test = eq r r_expected in
  if not test then failwithf "test 594 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 595;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 595 failed";
  let expected_b6 = 101 in
  mark_test_run 596;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 596 failed";
  let expected_c6 = 102 in
  mark_test_run 597;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 597 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 598;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 598 failed";
  let expected_b6 = 101 in
  mark_test_run 599;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 599 failed";
  let expected_c6 = 102 in
  mark_test_run 600;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 600 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 601;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 601 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 602;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 602 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 603;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 603 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 604;
  let test = eq r r_expected in
  if not test then failwithf "test 604 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 605;
  let test = eq r r_expected in
  if not test then failwithf "test 605 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 606;
  let test = eq r r_expected in
  if not test then failwithf "test 606 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 607;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 607 failed";
  let expected_b6 = 101 in
  mark_test_run 608;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 608 failed";
  let expected_c6 = 102 in
  mark_test_run 609;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 609 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 610;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 610 failed";
  let expected_b6 = 101 in
  mark_test_run 611;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 611 failed";
  let expected_c6 = 102 in
  mark_test_run 612;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 612 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 613;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 613 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 614;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 614 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 615;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 615 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 616;
  let test = eq r r_expected in
  if not test then failwithf "test 616 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 617;
  let test = eq r r_expected in
  if not test then failwithf "test 617 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 618;
  let test = eq r r_expected in
  if not test then failwithf "test 618 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 619;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 619 failed";
  let expected_b6 = 101 in
  mark_test_run 620;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 620 failed";
  let expected_c6 = 102 in
  mark_test_run 621;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 621 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 622;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 622 failed";
  let expected_b6 = 101 in
  mark_test_run 623;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 623 failed";
  let expected_c6 = 102 in
  mark_test_run 624;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 624 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 625;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 625 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 626;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 626 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 627;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 627 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 628;
  let test = eq r r_expected in
  if not test then failwithf "test 628 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 629;
  let test = eq r r_expected in
  if not test then failwithf "test 629 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 630;
  let test = eq r r_expected in
  if not test then failwithf "test 630 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 631;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 631 failed";
  let expected_b6 = 101 in
  mark_test_run 632;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 632 failed";
  let expected_c6 = 102 in
  mark_test_run 633;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 633 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 634;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 634 failed";
  let expected_b6 = 101 in
  mark_test_run 635;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 635 failed";
  let expected_c6 = 102 in
  mark_test_run 636;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 636 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 637;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 637 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 638;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 638 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 639;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 639 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 640;
  let test = eq r r_expected in
  if not test then failwithf "test 640 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 641;
  let test = eq r r_expected in
  if not test then failwithf "test 641 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 642;
  let test = eq r r_expected in
  if not test then failwithf "test 642 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 643;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 643 failed";
  let expected_b6 = 101 in
  mark_test_run 644;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 644 failed";
  let expected_c6 = 102 in
  mark_test_run 645;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 645 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 646;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 646 failed";
  let expected_b6 = 101 in
  mark_test_run 647;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 647 failed";
  let expected_c6 = 102 in
  mark_test_run 648;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 648 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 649;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 649 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 650;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 650 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 651;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 651 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 652;
  let test = eq r r_expected in
  if not test then failwithf "test 652 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 653;
  let test = eq r r_expected in
  if not test then failwithf "test 653 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 654;
  let test = eq r r_expected in
  if not test then failwithf "test 654 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 655;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 655 failed";
  let expected_b6 = 101 in
  mark_test_run 656;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 656 failed";
  let expected_c6 = 102 in
  mark_test_run 657;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 657 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 658;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 658 failed";
  let expected_b6 = 101 in
  mark_test_run 659;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 659 failed";
  let expected_c6 = 102 in
  mark_test_run 660;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 660 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 661;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 661 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 662;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 662 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 663;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 663 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 664;
  let test = eq r r_expected in
  if not test then failwithf "test 664 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 665;
  let test = eq r r_expected in
  if not test then failwithf "test 665 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 666;
  let test = eq r r_expected in
  if not test then failwithf "test 666 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 667;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 667 failed";
  let expected_b6 = 101 in
  mark_test_run 668;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 668 failed";
  let expected_c6 = 102 in
  mark_test_run 669;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 669 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 670;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 670 failed";
  let expected_b6 = 101 in
  mark_test_run 671;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 671 failed";
  let expected_c6 = 102 in
  mark_test_run 672;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 672 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 673;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 673 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 674;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 674 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 675;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 675 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 676;
  let test = eq r r_expected in
  if not test then failwithf "test 676 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 677;
  let test = eq r r_expected in
  if not test then failwithf "test 677 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 678;
  let test = eq r r_expected in
  if not test then failwithf "test 678 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 679;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 679 failed";
  let expected_b6 = 101 in
  mark_test_run 680;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 680 failed";
  let expected_c6 = 102 in
  mark_test_run 681;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 681 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 682;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 682 failed";
  let expected_b6 = 101 in
  mark_test_run 683;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 683 failed";
  let expected_c6 = 102 in
  mark_test_run 684;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 684 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 685;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 685 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 686;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 686 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 687;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 687 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 688;
  let test = eq r r_expected in
  if not test then failwithf "test 688 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 689;
  let test = eq r r_expected in
  if not test then failwithf "test 689 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 690;
  let test = eq r r_expected in
  if not test then failwithf "test 690 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 691;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 691 failed";
  let expected_b6 = 101 in
  mark_test_run 692;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 692 failed";
  let expected_c6 = 102 in
  mark_test_run 693;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 693 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 694;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 694 failed";
  let expected_b6 = 101 in
  mark_test_run 695;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 695 failed";
  let expected_c6 = 102 in
  mark_test_run 696;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 696 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 697;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 697 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 698;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 698 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 699;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 699 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 700;
  let test = eq r r_expected in
  if not test then failwithf "test 700 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 701;
  let test = eq r r_expected in
  if not test then failwithf "test 701 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 702;
  let test = eq r r_expected in
  if not test then failwithf "test 702 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 703;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 703 failed";
  let expected_b6 = 101 in
  mark_test_run 704;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 704 failed";
  let expected_c6 = 102 in
  mark_test_run 705;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 705 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 706;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 706 failed";
  let expected_b6 = 101 in
  mark_test_run 707;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 707 failed";
  let expected_c6 = 102 in
  mark_test_run 708;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 708 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 709;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 709 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 710;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 710 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 711;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 711 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 712;
  let test = eq r r_expected in
  if not test then failwithf "test 712 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 713;
  let test = eq r r_expected in
  if not test then failwithf "test 713 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 714;
  let test = eq r r_expected in
  if not test then failwithf "test 714 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 715;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 715 failed";
  let expected_b6 = 101 in
  mark_test_run 716;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 716 failed";
  let expected_c6 = 102 in
  mark_test_run 717;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 717 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 718;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 718 failed";
  let expected_b6 = 101 in
  mark_test_run 719;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 719 failed";
  let expected_c6 = 102 in
  mark_test_run 720;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 720 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 721;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 721 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 722;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 722 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 723;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 723 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 724;
  let test = eq r r_expected in
  if not test then failwithf "test 724 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 725;
  let test = eq r r_expected in
  if not test then failwithf "test 725 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 726;
  let test = eq r r_expected in
  if not test then failwithf "test 726 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 727;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 727 failed";
  let expected_b6 = 101 in
  mark_test_run 728;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 728 failed";
  let expected_c6 = 102 in
  mark_test_run 729;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 729 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 730;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 730 failed";
  let expected_b6 = 101 in
  mark_test_run 731;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 731 failed";
  let expected_c6 = 102 in
  mark_test_run 732;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 732 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 733;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 733 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 734;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 734 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 735;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 735 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 736;
  let test = eq r r_expected in
  if not test then failwithf "test 736 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 737;
  let test = eq r r_expected in
  if not test then failwithf "test 737 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 738;
  let test = eq r r_expected in
  if not test then failwithf "test 738 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 739;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 739 failed";
  let expected_b6 = 101 in
  mark_test_run 740;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 740 failed";
  let expected_c6 = 102 in
  mark_test_run 741;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 741 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 742;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 742 failed";
  let expected_b6 = 101 in
  mark_test_run 743;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 743 failed";
  let expected_c6 = 102 in
  mark_test_run 744;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 744 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 745;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 745 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 746;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 746 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 747;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 747 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 748;
  let test = eq r r_expected in
  if not test then failwithf "test 748 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 749;
  let test = eq r r_expected in
  if not test then failwithf "test 749 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 750;
  let test = eq r r_expected in
  if not test then failwithf "test 750 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 751;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 751 failed";
  let expected_b6 = 101 in
  mark_test_run 752;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 752 failed";
  let expected_c6 = 102 in
  mark_test_run 753;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 753 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 754;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 754 failed";
  let expected_b6 = 101 in
  mark_test_run 755;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 755 failed";
  let expected_c6 = 102 in
  mark_test_run 756;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 756 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 757;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 757 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 758;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 758 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 759;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 759 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 760;
  let test = eq r r_expected in
  if not test then failwithf "test 760 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 761;
  let test = eq r r_expected in
  if not test then failwithf "test 761 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 762;
  let test = eq r r_expected in
  if not test then failwithf "test 762 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 763;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 763 failed";
  let expected_b6 = 101 in
  mark_test_run 764;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 764 failed";
  let expected_c6 = 102 in
  mark_test_run 765;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 765 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 766;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 766 failed";
  let expected_b6 = 101 in
  mark_test_run 767;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 767 failed";
  let expected_c6 = 102 in
  mark_test_run 768;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 768 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 769;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 769 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 770;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 770 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 771;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 771 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 772;
  let test = eq r r_expected in
  if not test then failwithf "test 772 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 773;
  let test = eq r r_expected in
  if not test then failwithf "test 773 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 774;
  let test = eq r r_expected in
  if not test then failwithf "test 774 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 775;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 775 failed";
  let expected_b6 = 101 in
  mark_test_run 776;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 776 failed";
  let expected_c6 = 102 in
  mark_test_run 777;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 777 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 778;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 778 failed";
  let expected_b6 = 101 in
  mark_test_run 779;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 779 failed";
  let expected_c6 = 102 in
  mark_test_run 780;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 780 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 781;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 781 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 782;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 782 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 783;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 783 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 784;
  let test = eq r r_expected in
  if not test then failwithf "test 784 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 785;
  let test = eq r r_expected in
  if not test then failwithf "test 785 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 786;
  let test = eq r r_expected in
  if not test then failwithf "test 786 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 787;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 787 failed";
  let expected_b6 = 101 in
  mark_test_run 788;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 788 failed";
  let expected_c6 = 102 in
  mark_test_run 789;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 789 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 790;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 790 failed";
  let expected_b6 = 101 in
  mark_test_run 791;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 791 failed";
  let expected_c6 = 102 in
  mark_test_run 792;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 792 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 793;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 793 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 794;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 794 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 795;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 795 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 796;
  let test = eq r r_expected in
  if not test then failwithf "test 796 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 797;
  let test = eq r r_expected in
  if not test then failwithf "test 797 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 798;
  let test = eq r r_expected in
  if not test then failwithf "test 798 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 799;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 799 failed";
  let expected_b6 = 101 in
  mark_test_run 800;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 800 failed";
  let expected_c6 = 102 in
  mark_test_run 801;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 801 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 802;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 802 failed";
  let expected_b6 = 101 in
  mark_test_run 803;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 803 failed";
  let expected_c6 = 102 in
  mark_test_run 804;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 804 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 805;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 805 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 806;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 806 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 807;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 807 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 808;
  let test = eq r r_expected in
  if not test then failwithf "test 808 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 809;
  let test = eq r r_expected in
  if not test then failwithf "test 809 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 810;
  let test = eq r r_expected in
  if not test then failwithf "test 810 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 811;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 811 failed";
  let expected_b6 = 101 in
  mark_test_run 812;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 812 failed";
  let expected_c6 = 102 in
  mark_test_run 813;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 813 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 814;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 814 failed";
  let expected_b6 = 101 in
  mark_test_run 815;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 815 failed";
  let expected_c6 = 102 in
  mark_test_run 816;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 816 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 817;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 817 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 818;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 818 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 819;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 819 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 820;
  let test = eq r r_expected in
  if not test then failwithf "test 820 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 821;
  let test = eq r r_expected in
  if not test then failwithf "test 821 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 822;
  let test = eq r r_expected in
  if not test then failwithf "test 822 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 823;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 823 failed";
  let expected_b6 = 101 in
  mark_test_run 824;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 824 failed";
  let expected_c6 = 102 in
  mark_test_run 825;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 825 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 826;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 826 failed";
  let expected_b6 = 101 in
  mark_test_run 827;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 827 failed";
  let expected_c6 = 102 in
  mark_test_run 828;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 828 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 829;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 829 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 830;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 830 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 831;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 831 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 832;
  let test = eq r r_expected in
  if not test then failwithf "test 832 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 833;
  let test = eq r r_expected in
  if not test then failwithf "test 833 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 834;
  let test = eq r r_expected in
  if not test then failwithf "test 834 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 835;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 835 failed";
  let expected_b6 = 101 in
  mark_test_run 836;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 836 failed";
  let expected_c6 = 102 in
  mark_test_run 837;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 837 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 838;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 838 failed";
  let expected_b6 = 101 in
  mark_test_run 839;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 839 failed";
  let expected_c6 = 102 in
  mark_test_run 840;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 840 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 841;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 841 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 842;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 842 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 843;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 843 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 844;
  let test = eq r r_expected in
  if not test then failwithf "test 844 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 845;
  let test = eq r r_expected in
  if not test then failwithf "test 845 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 846;
  let test = eq r r_expected in
  if not test then failwithf "test 846 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 847;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 847 failed";
  let expected_b6 = 101 in
  mark_test_run 848;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 848 failed";
  let expected_c6 = 102 in
  mark_test_run 849;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 849 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 850;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 850 failed";
  let expected_b6 = 101 in
  mark_test_run 851;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 851 failed";
  let expected_c6 = 102 in
  mark_test_run 852;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 852 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 853;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 853 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 854;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 854 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 855;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 855 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 856;
  let test = eq r r_expected in
  if not test then failwithf "test 856 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 857;
  let test = eq r r_expected in
  if not test then failwithf "test 857 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 858;
  let test = eq r r_expected in
  if not test then failwithf "test 858 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 859;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 859 failed";
  let expected_b6 = 101 in
  mark_test_run 860;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 860 failed";
  let expected_c6 = 102 in
  mark_test_run 861;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 861 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 862;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 862 failed";
  let expected_b6 = 101 in
  mark_test_run 863;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 863 failed";
  let expected_c6 = 102 in
  mark_test_run 864;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 864 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 865;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 865 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 866;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 866 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 867;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 867 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 868;
  let test = eq r r_expected in
  if not test then failwithf "test 868 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 869;
  let test = eq r r_expected in
  if not test then failwithf "test 869 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 870;
  let test = eq r r_expected in
  if not test then failwithf "test 870 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 871;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 871 failed";
  let expected_b6 = 101 in
  mark_test_run 872;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 872 failed";
  let expected_c6 = 102 in
  mark_test_run 873;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 873 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 874;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 874 failed";
  let expected_b6 = 101 in
  mark_test_run 875;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 875 failed";
  let expected_c6 = 102 in
  mark_test_run 876;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 876 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 877;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 877 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 878;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 878 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 879;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 879 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 880;
  let test = eq r r_expected in
  if not test then failwithf "test 880 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 881;
  let test = eq r r_expected in
  if not test then failwithf "test 881 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 882;
  let test = eq r r_expected in
  if not test then failwithf "test 882 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 883;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 883 failed";
  let expected_b6 = 101 in
  mark_test_run 884;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 884 failed";
  let expected_c6 = 102 in
  mark_test_run 885;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 885 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 886;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 886 failed";
  let expected_b6 = 101 in
  mark_test_run 887;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 887 failed";
  let expected_c6 = 102 in
  mark_test_run 888;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 888 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 889;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 889 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 890;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 890 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 891;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 891 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 892;
  let test = eq r r_expected in
  if not test then failwithf "test 892 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 893;
  let test = eq r r_expected in
  if not test then failwithf "test 893 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 894;
  let test = eq r r_expected in
  if not test then failwithf "test 894 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 895;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 895 failed";
  let expected_b6 = 101 in
  mark_test_run 896;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 896 failed";
  let expected_c6 = 102 in
  mark_test_run 897;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 897 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 898;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 898 failed";
  let expected_b6 = 101 in
  mark_test_run 899;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 899 failed";
  let expected_c6 = 102 in
  mark_test_run 900;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 900 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 901;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 901 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 902;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 902 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 903;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 903 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 904;
  let test = eq r r_expected in
  if not test then failwithf "test 904 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 905;
  let test = eq r r_expected in
  if not test then failwithf "test 905 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 906;
  let test = eq r r_expected in
  if not test then failwithf "test 906 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 907;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 907 failed";
  let expected_b6 = 101 in
  mark_test_run 908;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 908 failed";
  let expected_c6 = 102 in
  mark_test_run 909;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 909 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 910;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 910 failed";
  let expected_b6 = 101 in
  mark_test_run 911;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 911 failed";
  let expected_c6 = 102 in
  mark_test_run 912;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 912 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 913;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 913 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 914;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 914 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 915;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 915 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 916;
  let test = eq r r_expected in
  if not test then failwithf "test 916 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 917;
  let test = eq r r_expected in
  if not test then failwithf "test 917 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 918;
  let test = eq r r_expected in
  if not test then failwithf "test 918 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 919;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 919 failed";
  let expected_b6 = 101 in
  mark_test_run 920;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 920 failed";
  let expected_c6 = 102 in
  mark_test_run 921;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 921 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 922;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 922 failed";
  let expected_b6 = 101 in
  mark_test_run 923;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 923 failed";
  let expected_c6 = 102 in
  mark_test_run 924;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 924 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 925;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 925 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 926;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 926 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 927;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 927 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 928;
  let test = eq r r_expected in
  if not test then failwithf "test 928 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 929;
  let test = eq r r_expected in
  if not test then failwithf "test 929 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 930;
  let test = eq r r_expected in
  if not test then failwithf "test 930 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 931;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 931 failed";
  let expected_b6 = 101 in
  mark_test_run 932;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 932 failed";
  let expected_c6 = 102 in
  mark_test_run 933;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 933 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 934;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 934 failed";
  let expected_b6 = 101 in
  mark_test_run 935;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 935 failed";
  let expected_c6 = 102 in
  mark_test_run 936;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 936 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 937;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 937 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 938;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 938 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 939;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 939 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 940;
  let test = eq r r_expected in
  if not test then failwithf "test 940 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 941;
  let test = eq r r_expected in
  if not test then failwithf "test 941 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 942;
  let test = eq r r_expected in
  if not test then failwithf "test 942 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 943;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 943 failed";
  let expected_b6 = 101 in
  mark_test_run 944;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 944 failed";
  let expected_c6 = 102 in
  mark_test_run 945;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 945 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 946;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 946 failed";
  let expected_b6 = 101 in
  mark_test_run 947;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 947 failed";
  let expected_c6 = 102 in
  mark_test_run 948;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 948 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 949;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 949 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 950;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 950 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 951;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 951 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 952;
  let test = eq r r_expected in
  if not test then failwithf "test 952 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 953;
  let test = eq r r_expected in
  if not test then failwithf "test 953 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 954;
  let test = eq r r_expected in
  if not test then failwithf "test 954 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 955;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 955 failed";
  let expected_b6 = 101 in
  mark_test_run 956;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 956 failed";
  let expected_c6 = 102 in
  mark_test_run 957;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 957 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 958;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 958 failed";
  let expected_b6 = 101 in
  mark_test_run 959;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 959 failed";
  let expected_c6 = 102 in
  mark_test_run 960;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 960 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 961;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 961 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 962;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 962 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 963;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 963 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 964;
  let test = eq r r_expected in
  if not test then failwithf "test 964 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 965;
  let test = eq r r_expected in
  if not test then failwithf "test 965 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 966;
  let test = eq r r_expected in
  if not test then failwithf "test 966 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 967;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 967 failed";
  let expected_b6 = 101 in
  mark_test_run 968;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 968 failed";
  let expected_c6 = 102 in
  mark_test_run 969;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 969 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 970;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 970 failed";
  let expected_b6 = 101 in
  mark_test_run 971;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 971 failed";
  let expected_c6 = 102 in
  mark_test_run 972;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 972 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 973;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 973 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 974;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 974 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 975;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 975 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 976;
  let test = eq r r_expected in
  if not test then failwithf "test 976 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 977;
  let test = eq r r_expected in
  if not test then failwithf "test 977 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 978;
  let test = eq r r_expected in
  if not test then failwithf "test 978 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 979;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 979 failed";
  let expected_b6 = 101 in
  mark_test_run 980;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 980 failed";
  let expected_c6 = 102 in
  mark_test_run 981;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 981 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 982;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 982 failed";
  let expected_b6 = 101 in
  mark_test_run 983;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 983 failed";
  let expected_c6 = 102 in
  mark_test_run 984;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 984 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 985;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 985 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 986;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 986 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 987;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 987 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 988;
  let test = eq r r_expected in
  if not test then failwithf "test 988 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 989;
  let test = eq r r_expected in
  if not test then failwithf "test 989 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 990;
  let test = eq r r_expected in
  if not test then failwithf "test 990 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 991;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 991 failed";
  let expected_b6 = 101 in
  mark_test_run 992;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 992 failed";
  let expected_c6 = 102 in
  mark_test_run 993;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 993 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 994;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 994 failed";
  let expected_b6 = 101 in
  mark_test_run 995;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 995 failed";
  let expected_c6 = 102 in
  mark_test_run 996;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 996 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 997;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 997 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 998;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 998 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 999;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 999 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1000;
  let test = eq r r_expected in
  if not test then failwithf "test 1000 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1001;
  let test = eq r r_expected in
  if not test then failwithf "test 1001 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1002;
  let test = eq r r_expected in
  if not test then failwithf "test 1002 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1003;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1003 failed";
  let expected_b6 = 101 in
  mark_test_run 1004;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1004 failed";
  let expected_c6 = 102 in
  mark_test_run 1005;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1005 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1006;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1006 failed";
  let expected_b6 = 101 in
  mark_test_run 1007;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1007 failed";
  let expected_c6 = 102 in
  mark_test_run 1008;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1008 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1009;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1009 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1010;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1010 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1011;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1011 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1012;
  let test = eq r r_expected in
  if not test then failwithf "test 1012 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1013;
  let test = eq r r_expected in
  if not test then failwithf "test 1013 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1014;
  let test = eq r r_expected in
  if not test then failwithf "test 1014 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1015;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1015 failed";
  let expected_b6 = 101 in
  mark_test_run 1016;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1016 failed";
  let expected_c6 = 102 in
  mark_test_run 1017;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1017 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1018;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1018 failed";
  let expected_b6 = 101 in
  mark_test_run 1019;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1019 failed";
  let expected_c6 = 102 in
  mark_test_run 1020;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1020 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1021;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1021 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1022;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1022 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1023;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1023 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1024;
  let test = eq r r_expected in
  if not test then failwithf "test 1024 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1025;
  let test = eq r r_expected in
  if not test then failwithf "test 1025 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1026;
  let test = eq r r_expected in
  if not test then failwithf "test 1026 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1027;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1027 failed";
  let expected_b6 = 101 in
  mark_test_run 1028;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1028 failed";
  let expected_c6 = 102 in
  mark_test_run 1029;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1029 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1030;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1030 failed";
  let expected_b6 = 101 in
  mark_test_run 1031;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1031 failed";
  let expected_c6 = 102 in
  mark_test_run 1032;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1032 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1033;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1033 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1034;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1034 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1035;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1035 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1036;
  let test = eq r r_expected in
  if not test then failwithf "test 1036 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1037;
  let test = eq r r_expected in
  if not test then failwithf "test 1037 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1038;
  let test = eq r r_expected in
  if not test then failwithf "test 1038 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1039;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1039 failed";
  let expected_b6 = 101 in
  mark_test_run 1040;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1040 failed";
  let expected_c6 = 102 in
  mark_test_run 1041;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1041 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1042;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1042 failed";
  let expected_b6 = 101 in
  mark_test_run 1043;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1043 failed";
  let expected_c6 = 102 in
  mark_test_run 1044;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1044 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1045;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1045 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1046;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1046 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1047;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1047 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1048;
  let test = eq r r_expected in
  if not test then failwithf "test 1048 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1049;
  let test = eq r r_expected in
  if not test then failwithf "test 1049 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1050;
  let test = eq r r_expected in
  if not test then failwithf "test 1050 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1051;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1051 failed";
  let expected_b6 = 101 in
  mark_test_run 1052;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1052 failed";
  let expected_c6 = 102 in
  mark_test_run 1053;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1053 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1054;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1054 failed";
  let expected_b6 = 101 in
  mark_test_run 1055;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1055 failed";
  let expected_c6 = 102 in
  mark_test_run 1056;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1056 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1057;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1057 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1058;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1058 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1059;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1059 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1060;
  let test = eq r r_expected in
  if not test then failwithf "test 1060 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1061;
  let test = eq r r_expected in
  if not test then failwithf "test 1061 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1062;
  let test = eq r r_expected in
  if not test then failwithf "test 1062 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1063;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1063 failed";
  let expected_b6 = 101 in
  mark_test_run 1064;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1064 failed";
  let expected_c6 = 102 in
  mark_test_run 1065;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1065 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1066;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1066 failed";
  let expected_b6 = 101 in
  mark_test_run 1067;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1067 failed";
  let expected_c6 = 102 in
  mark_test_run 1068;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1068 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1069;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1069 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1070;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1070 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1071;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1071 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1072;
  let test = eq r r_expected in
  if not test then failwithf "test 1072 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1073;
  let test = eq r r_expected in
  if not test then failwithf "test 1073 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1074;
  let test = eq r r_expected in
  if not test then failwithf "test 1074 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1075;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1075 failed";
  let expected_b6 = 101 in
  mark_test_run 1076;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1076 failed";
  let expected_c6 = 102 in
  mark_test_run 1077;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1077 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1078;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1078 failed";
  let expected_b6 = 101 in
  mark_test_run 1079;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1079 failed";
  let expected_c6 = 102 in
  mark_test_run 1080;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1080 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1081;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1081 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1082;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1082 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1083;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1083 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1084;
  let test = eq r r_expected in
  if not test then failwithf "test 1084 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1085;
  let test = eq r r_expected in
  if not test then failwithf "test 1085 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1086;
  let test = eq r r_expected in
  if not test then failwithf "test 1086 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1087;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1087 failed";
  let expected_b6 = 101 in
  mark_test_run 1088;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1088 failed";
  let expected_c6 = 102 in
  mark_test_run 1089;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1089 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1090;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1090 failed";
  let expected_b6 = 101 in
  mark_test_run 1091;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1091 failed";
  let expected_c6 = 102 in
  mark_test_run 1092;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1092 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1093;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1093 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1094;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1094 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1095;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1095 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1096;
  let test = eq r r_expected in
  if not test then failwithf "test 1096 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1097;
  let test = eq r r_expected in
  if not test then failwithf "test 1097 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1098;
  let test = eq r r_expected in
  if not test then failwithf "test 1098 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1099;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1099 failed";
  let expected_b6 = 101 in
  mark_test_run 1100;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1100 failed";
  let expected_c6 = 102 in
  mark_test_run 1101;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1101 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1102;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1102 failed";
  let expected_b6 = 101 in
  mark_test_run 1103;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1103 failed";
  let expected_c6 = 102 in
  mark_test_run 1104;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1104 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1105;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1105 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1106;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1106 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1107;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1107 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1108;
  let test = eq r r_expected in
  if not test then failwithf "test 1108 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1109;
  let test = eq r r_expected in
  if not test then failwithf "test 1109 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1110;
  let test = eq r r_expected in
  if not test then failwithf "test 1110 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1111;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1111 failed";
  let expected_b6 = 101 in
  mark_test_run 1112;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1112 failed";
  let expected_c6 = 102 in
  mark_test_run 1113;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1113 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1114;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1114 failed";
  let expected_b6 = 101 in
  mark_test_run 1115;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1115 failed";
  let expected_c6 = 102 in
  mark_test_run 1116;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1116 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1117;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1117 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1118;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1118 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1119;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1119 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1120;
  let test = eq r r_expected in
  if not test then failwithf "test 1120 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1121;
  let test = eq r r_expected in
  if not test then failwithf "test 1121 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1122;
  let test = eq r r_expected in
  if not test then failwithf "test 1122 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1123;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1123 failed";
  let expected_b6 = 101 in
  mark_test_run 1124;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1124 failed";
  let expected_c6 = 102 in
  mark_test_run 1125;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1125 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1126;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1126 failed";
  let expected_b6 = 101 in
  mark_test_run 1127;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1127 failed";
  let expected_c6 = 102 in
  mark_test_run 1128;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1128 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1129;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1129 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1130;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1130 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1131;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1131 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1132;
  let test = eq r r_expected in
  if not test then failwithf "test 1132 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1133;
  let test = eq r r_expected in
  if not test then failwithf "test 1133 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1134;
  let test = eq r r_expected in
  if not test then failwithf "test 1134 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1135;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1135 failed";
  let expected_b6 = 101 in
  mark_test_run 1136;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1136 failed";
  let expected_c6 = 102 in
  mark_test_run 1137;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1137 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1138;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1138 failed";
  let expected_b6 = 101 in
  mark_test_run 1139;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1139 failed";
  let expected_c6 = 102 in
  mark_test_run 1140;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1140 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1141;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1141 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1142;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1142 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1143;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1143 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1144;
  let test = eq r r_expected in
  if not test then failwithf "test 1144 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1145;
  let test = eq r r_expected in
  if not test then failwithf "test 1145 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1146;
  let test = eq r r_expected in
  if not test then failwithf "test 1146 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1147;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1147 failed";
  let expected_b6 = 101 in
  mark_test_run 1148;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1148 failed";
  let expected_c6 = 102 in
  mark_test_run 1149;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1149 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1150;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1150 failed";
  let expected_b6 = 101 in
  mark_test_run 1151;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1151 failed";
  let expected_c6 = 102 in
  mark_test_run 1152;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1152 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1153;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1153 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1154;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1154 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1155;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1155 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1156;
  let test = eq r r_expected in
  if not test then failwithf "test 1156 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1157;
  let test = eq r r_expected in
  if not test then failwithf "test 1157 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1158;
  let test = eq r r_expected in
  if not test then failwithf "test 1158 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1159;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1159 failed";
  let expected_b6 = 101 in
  mark_test_run 1160;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1160 failed";
  let expected_c6 = 102 in
  mark_test_run 1161;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1161 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1162;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1162 failed";
  let expected_b6 = 101 in
  mark_test_run 1163;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1163 failed";
  let expected_c6 = 102 in
  mark_test_run 1164;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1164 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1165;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1165 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1166;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1166 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1167;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1167 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1168;
  let test = eq r r_expected in
  if not test then failwithf "test 1168 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1169;
  let test = eq r r_expected in
  if not test then failwithf "test 1169 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1170;
  let test = eq r r_expected in
  if not test then failwithf "test 1170 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1171;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1171 failed";
  let expected_b6 = 101 in
  mark_test_run 1172;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1172 failed";
  let expected_c6 = 102 in
  mark_test_run 1173;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1173 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1174;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1174 failed";
  let expected_b6 = 101 in
  mark_test_run 1175;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1175 failed";
  let expected_c6 = 102 in
  mark_test_run 1176;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1176 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1177;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1177 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1178;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1178 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1179;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1179 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1180;
  let test = eq r r_expected in
  if not test then failwithf "test 1180 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1181;
  let test = eq r r_expected in
  if not test then failwithf "test 1181 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1182;
  let test = eq r r_expected in
  if not test then failwithf "test 1182 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1183;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1183 failed";
  let expected_b6 = 101 in
  mark_test_run 1184;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1184 failed";
  let expected_c6 = 102 in
  mark_test_run 1185;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1185 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1186;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1186 failed";
  let expected_b6 = 101 in
  mark_test_run 1187;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1187 failed";
  let expected_c6 = 102 in
  mark_test_run 1188;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1188 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1189;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1189 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1190;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1190 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1191;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1191 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1192;
  let test = eq r r_expected in
  if not test then failwithf "test 1192 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1193;
  let test = eq r r_expected in
  if not test then failwithf "test 1193 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1194;
  let test = eq r r_expected in
  if not test then failwithf "test 1194 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1195;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1195 failed";
  let expected_b6 = 101 in
  mark_test_run 1196;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1196 failed";
  let expected_c6 = 102 in
  mark_test_run 1197;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1197 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1198;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1198 failed";
  let expected_b6 = 101 in
  mark_test_run 1199;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1199 failed";
  let expected_c6 = 102 in
  mark_test_run 1200;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1200 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1201;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1201 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1202;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1202 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1203;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1203 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1204;
  let test = eq r r_expected in
  if not test then failwithf "test 1204 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1205;
  let test = eq r r_expected in
  if not test then failwithf "test 1205 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1206;
  let test = eq r r_expected in
  if not test then failwithf "test 1206 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1207;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1207 failed";
  let expected_b6 = 101 in
  mark_test_run 1208;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1208 failed";
  let expected_c6 = 102 in
  mark_test_run 1209;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1209 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1210;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1210 failed";
  let expected_b6 = 101 in
  mark_test_run 1211;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1211 failed";
  let expected_c6 = 102 in
  mark_test_run 1212;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1212 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1213;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1213 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1214;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1214 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1215;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1215 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1216;
  let test = eq r r_expected in
  if not test then failwithf "test 1216 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1217;
  let test = eq r r_expected in
  if not test then failwithf "test 1217 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1218;
  let test = eq r r_expected in
  if not test then failwithf "test 1218 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1219;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1219 failed";
  let expected_b6 = 101 in
  mark_test_run 1220;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1220 failed";
  let expected_c6 = 102 in
  mark_test_run 1221;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1221 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1222;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1222 failed";
  let expected_b6 = 101 in
  mark_test_run 1223;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1223 failed";
  let expected_c6 = 102 in
  mark_test_run 1224;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1224 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1225;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1225 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1226;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1226 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1227;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1227 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1228;
  let test = eq r r_expected in
  if not test then failwithf "test 1228 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1229;
  let test = eq r r_expected in
  if not test then failwithf "test 1229 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1230;
  let test = eq r r_expected in
  if not test then failwithf "test 1230 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1231;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1231 failed";
  let expected_b6 = 101 in
  mark_test_run 1232;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1232 failed";
  let expected_c6 = 102 in
  mark_test_run 1233;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1233 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1234;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1234 failed";
  let expected_b6 = 101 in
  mark_test_run 1235;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1235 failed";
  let expected_c6 = 102 in
  mark_test_run 1236;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1236 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1237;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1237 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1238;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1238 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1239;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1239 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1240;
  let test = eq r r_expected in
  if not test then failwithf "test 1240 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1241;
  let test = eq r r_expected in
  if not test then failwithf "test 1241 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1242;
  let test = eq r r_expected in
  if not test then failwithf "test 1242 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1243;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1243 failed";
  let expected_b6 = 101 in
  mark_test_run 1244;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1244 failed";
  let expected_c6 = 102 in
  mark_test_run 1245;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1245 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1246;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1246 failed";
  let expected_b6 = 101 in
  mark_test_run 1247;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1247 failed";
  let expected_c6 = 102 in
  mark_test_run 1248;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1248 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1249;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1249 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1250;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1250 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1251;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1251 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1252;
  let test = eq r r_expected in
  if not test then failwithf "test 1252 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1253;
  let test = eq r r_expected in
  if not test then failwithf "test 1253 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1254;
  let test = eq r r_expected in
  if not test then failwithf "test 1254 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1255;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1255 failed";
  let expected_b6 = 101 in
  mark_test_run 1256;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1256 failed";
  let expected_c6 = 102 in
  mark_test_run 1257;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1257 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1258;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1258 failed";
  let expected_b6 = 101 in
  mark_test_run 1259;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1259 failed";
  let expected_c6 = 102 in
  mark_test_run 1260;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1260 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1261;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1261 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1262;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1262 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1263;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1263 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1264;
  let test = eq r r_expected in
  if not test then failwithf "test 1264 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1265;
  let test = eq r r_expected in
  if not test then failwithf "test 1265 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1266;
  let test = eq r r_expected in
  if not test then failwithf "test 1266 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1267;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1267 failed";
  let expected_b6 = 101 in
  mark_test_run 1268;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1268 failed";
  let expected_c6 = 102 in
  mark_test_run 1269;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1269 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1270;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1270 failed";
  let expected_b6 = 101 in
  mark_test_run 1271;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1271 failed";
  let expected_c6 = 102 in
  mark_test_run 1272;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1272 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1273;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1273 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1274;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1274 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1275;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1275 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1276;
  let test = eq r r_expected in
  if not test then failwithf "test 1276 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1277;
  let test = eq r r_expected in
  if not test then failwithf "test 1277 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1278;
  let test = eq r r_expected in
  if not test then failwithf "test 1278 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1279;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1279 failed";
  let expected_b6 = 101 in
  mark_test_run 1280;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1280 failed";
  let expected_c6 = 102 in
  mark_test_run 1281;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1281 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1282;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1282 failed";
  let expected_b6 = 101 in
  mark_test_run 1283;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1283 failed";
  let expected_c6 = 102 in
  mark_test_run 1284;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1284 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1285;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1285 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1286;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1286 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1287;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1287 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1288;
  let test = eq r r_expected in
  if not test then failwithf "test 1288 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1289;
  let test = eq r r_expected in
  if not test then failwithf "test 1289 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1290;
  let test = eq r r_expected in
  if not test then failwithf "test 1290 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1291;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1291 failed";
  let expected_b6 = 101 in
  mark_test_run 1292;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1292 failed";
  let expected_c6 = 102 in
  mark_test_run 1293;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1293 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1294;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1294 failed";
  let expected_b6 = 101 in
  mark_test_run 1295;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1295 failed";
  let expected_c6 = 102 in
  mark_test_run 1296;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1296 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1297;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1297 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1298;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1298 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1299;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1299 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1300;
  let test = eq r r_expected in
  if not test then failwithf "test 1300 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1301;
  let test = eq r r_expected in
  if not test then failwithf "test 1301 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1302;
  let test = eq r r_expected in
  if not test then failwithf "test 1302 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1303;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1303 failed";
  let expected_b6 = 101 in
  mark_test_run 1304;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1304 failed";
  let expected_c6 = 102 in
  mark_test_run 1305;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1305 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1306;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1306 failed";
  let expected_b6 = 101 in
  mark_test_run 1307;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1307 failed";
  let expected_c6 = 102 in
  mark_test_run 1308;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1308 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1309;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1309 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1310;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1310 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1311;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1311 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1312;
  let test = eq r r_expected in
  if not test then failwithf "test 1312 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1313;
  let test = eq r r_expected in
  if not test then failwithf "test 1313 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1314;
  let test = eq r r_expected in
  if not test then failwithf "test 1314 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1315;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1315 failed";
  let expected_b6 = 101 in
  mark_test_run 1316;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1316 failed";
  let expected_c6 = 102 in
  mark_test_run 1317;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1317 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1318;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1318 failed";
  let expected_b6 = 101 in
  mark_test_run 1319;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1319 failed";
  let expected_c6 = 102 in
  mark_test_run 1320;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1320 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1321;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1321 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1322;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1322 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1323;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1323 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1324;
  let test = eq r r_expected in
  if not test then failwithf "test 1324 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1325;
  let test = eq r r_expected in
  if not test then failwithf "test 1325 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1326;
  let test = eq r r_expected in
  if not test then failwithf "test 1326 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1327;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1327 failed";
  let expected_b6 = 101 in
  mark_test_run 1328;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1328 failed";
  let expected_c6 = 102 in
  mark_test_run 1329;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1329 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1330;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1330 failed";
  let expected_b6 = 101 in
  mark_test_run 1331;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1331 failed";
  let expected_c6 = 102 in
  mark_test_run 1332;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1332 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1333;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1333 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1334;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1334 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1335;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1335 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1336;
  let test = eq r r_expected in
  if not test then failwithf "test 1336 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1337;
  let test = eq r r_expected in
  if not test then failwithf "test 1337 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1338;
  let test = eq r r_expected in
  if not test then failwithf "test 1338 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1339;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1339 failed";
  let expected_b6 = 101 in
  mark_test_run 1340;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1340 failed";
  let expected_c6 = 102 in
  mark_test_run 1341;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1341 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1342;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1342 failed";
  let expected_b6 = 101 in
  mark_test_run 1343;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1343 failed";
  let expected_c6 = 102 in
  mark_test_run 1344;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1344 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1345;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1345 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1346;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1346 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1347;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1347 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1348;
  let test = eq r r_expected in
  if not test then failwithf "test 1348 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1349;
  let test = eq r r_expected in
  if not test then failwithf "test 1349 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1350;
  let test = eq r r_expected in
  if not test then failwithf "test 1350 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1351;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1351 failed";
  let expected_b6 = 101 in
  mark_test_run 1352;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1352 failed";
  let expected_c6 = 102 in
  mark_test_run 1353;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1353 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1354;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1354 failed";
  let expected_b6 = 101 in
  mark_test_run 1355;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1355 failed";
  let expected_c6 = 102 in
  mark_test_run 1356;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1356 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1357;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1357 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1358;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1358 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1359;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1359 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1360;
  let test = eq r r_expected in
  if not test then failwithf "test 1360 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1361;
  let test = eq r r_expected in
  if not test then failwithf "test 1361 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1362;
  let test = eq r r_expected in
  if not test then failwithf "test 1362 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1363;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1363 failed";
  let expected_b6 = 101 in
  mark_test_run 1364;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1364 failed";
  let expected_c6 = 102 in
  mark_test_run 1365;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1365 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1366;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1366 failed";
  let expected_b6 = 101 in
  mark_test_run 1367;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1367 failed";
  let expected_c6 = 102 in
  mark_test_run 1368;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1368 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1369;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1369 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1370;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1370 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1371;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1371 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1372;
  let test = eq r r_expected in
  if not test then failwithf "test 1372 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1373;
  let test = eq r r_expected in
  if not test then failwithf "test 1373 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1374;
  let test = eq r r_expected in
  if not test then failwithf "test 1374 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1375;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1375 failed";
  let expected_b6 = 101 in
  mark_test_run 1376;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1376 failed";
  let expected_c6 = 102 in
  mark_test_run 1377;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1377 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1378;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1378 failed";
  let expected_b6 = 101 in
  mark_test_run 1379;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1379 failed";
  let expected_c6 = 102 in
  mark_test_run 1380;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1380 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1381;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1381 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1382;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1382 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1383;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1383 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1384;
  let test = eq r r_expected in
  if not test then failwithf "test 1384 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1385;
  let test = eq r r_expected in
  if not test then failwithf "test 1385 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1386;
  let test = eq r r_expected in
  if not test then failwithf "test 1386 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1387;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1387 failed";
  let expected_b6 = 101 in
  mark_test_run 1388;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1388 failed";
  let expected_c6 = 102 in
  mark_test_run 1389;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1389 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1390;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1390 failed";
  let expected_b6 = 101 in
  mark_test_run 1391;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1391 failed";
  let expected_c6 = 102 in
  mark_test_run 1392;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1392 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1393;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1393 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1394;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1394 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1395;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1395 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1396;
  let test = eq r r_expected in
  if not test then failwithf "test 1396 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1397;
  let test = eq r r_expected in
  if not test then failwithf "test 1397 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1398;
  let test = eq r r_expected in
  if not test then failwithf "test 1398 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1399;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1399 failed";
  let expected_b6 = 101 in
  mark_test_run 1400;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1400 failed";
  let expected_c6 = 102 in
  mark_test_run 1401;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1401 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1402;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1402 failed";
  let expected_b6 = 101 in
  mark_test_run 1403;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1403 failed";
  let expected_c6 = 102 in
  mark_test_run 1404;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1404 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1405;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1405 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1406;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1406 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1407;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1407 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1408;
  let test = eq r r_expected in
  if not test then failwithf "test 1408 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1409;
  let test = eq r r_expected in
  if not test then failwithf "test 1409 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1410;
  let test = eq r r_expected in
  if not test then failwithf "test 1410 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1411;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1411 failed";
  let expected_b6 = 101 in
  mark_test_run 1412;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1412 failed";
  let expected_c6 = 102 in
  mark_test_run 1413;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1413 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1414;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1414 failed";
  let expected_b6 = 101 in
  mark_test_run 1415;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1415 failed";
  let expected_c6 = 102 in
  mark_test_run 1416;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1416 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1417;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1417 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1418;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1418 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1419;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1419 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1420;
  let test = eq r r_expected in
  if not test then failwithf "test 1420 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1421;
  let test = eq r r_expected in
  if not test then failwithf "test 1421 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1422;
  let test = eq r r_expected in
  if not test then failwithf "test 1422 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1423;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1423 failed";
  let expected_b6 = 101 in
  mark_test_run 1424;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1424 failed";
  let expected_c6 = 102 in
  mark_test_run 1425;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1425 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1426;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1426 failed";
  let expected_b6 = 101 in
  mark_test_run 1427;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1427 failed";
  let expected_c6 = 102 in
  mark_test_run 1428;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1428 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1429;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1429 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1430;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1430 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1431;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1431 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1432;
  let test = eq r r_expected in
  if not test then failwithf "test 1432 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1433;
  let test = eq r r_expected in
  if not test then failwithf "test 1433 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1434;
  let test = eq r r_expected in
  if not test then failwithf "test 1434 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1435;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1435 failed";
  let expected_b6 = 101 in
  mark_test_run 1436;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1436 failed";
  let expected_c6 = 102 in
  mark_test_run 1437;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1437 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1438;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1438 failed";
  let expected_b6 = 101 in
  mark_test_run 1439;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1439 failed";
  let expected_c6 = 102 in
  mark_test_run 1440;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1440 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1441;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1441 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1442;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1442 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1443;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1443 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1444;
  let test = eq r r_expected in
  if not test then failwithf "test 1444 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1445;
  let test = eq r r_expected in
  if not test then failwithf "test 1445 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1446;
  let test = eq r r_expected in
  if not test then failwithf "test 1446 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1447;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1447 failed";
  let expected_b6 = 101 in
  mark_test_run 1448;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1448 failed";
  let expected_c6 = 102 in
  mark_test_run 1449;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1449 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1450;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1450 failed";
  let expected_b6 = 101 in
  mark_test_run 1451;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1451 failed";
  let expected_c6 = 102 in
  mark_test_run 1452;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1452 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1453;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1453 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1454;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1454 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1455;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1455 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1456;
  let test = eq r r_expected in
  if not test then failwithf "test 1456 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1457;
  let test = eq r r_expected in
  if not test then failwithf "test 1457 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1458;
  let test = eq r r_expected in
  if not test then failwithf "test 1458 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1459;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1459 failed";
  let expected_b6 = 101 in
  mark_test_run 1460;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1460 failed";
  let expected_c6 = 102 in
  mark_test_run 1461;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1461 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1462;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1462 failed";
  let expected_b6 = 101 in
  mark_test_run 1463;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1463 failed";
  let expected_c6 = 102 in
  mark_test_run 1464;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1464 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1465;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1465 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1466;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1466 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1467;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1467 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1468;
  let test = eq r r_expected in
  if not test then failwithf "test 1468 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1469;
  let test = eq r r_expected in
  if not test then failwithf "test 1469 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1470;
  let test = eq r r_expected in
  if not test then failwithf "test 1470 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1471;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1471 failed";
  let expected_b6 = 101 in
  mark_test_run 1472;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1472 failed";
  let expected_c6 = 102 in
  mark_test_run 1473;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1473 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1474;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1474 failed";
  let expected_b6 = 101 in
  mark_test_run 1475;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1475 failed";
  let expected_c6 = 102 in
  mark_test_run 1476;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1476 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1477;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1477 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1478;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1478 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1479;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1479 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1480;
  let test = eq r r_expected in
  if not test then failwithf "test 1480 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1481;
  let test = eq r r_expected in
  if not test then failwithf "test 1481 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1482;
  let test = eq r r_expected in
  if not test then failwithf "test 1482 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1483;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1483 failed";
  let expected_b6 = 101 in
  mark_test_run 1484;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1484 failed";
  let expected_c6 = 102 in
  mark_test_run 1485;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1485 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1486;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1486 failed";
  let expected_b6 = 101 in
  mark_test_run 1487;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1487 failed";
  let expected_c6 = 102 in
  mark_test_run 1488;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1488 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1489;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1489 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1490;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1490 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1491;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1491 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1492;
  let test = eq r r_expected in
  if not test then failwithf "test 1492 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1493;
  let test = eq r r_expected in
  if not test then failwithf "test 1493 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1494;
  let test = eq r r_expected in
  if not test then failwithf "test 1494 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1495;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1495 failed";
  let expected_b6 = 101 in
  mark_test_run 1496;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1496 failed";
  let expected_c6 = 102 in
  mark_test_run 1497;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1497 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1498;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1498 failed";
  let expected_b6 = 101 in
  mark_test_run 1499;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1499 failed";
  let expected_c6 = 102 in
  mark_test_run 1500;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1500 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1501;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1501 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1502;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1502 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1503;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1503 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1504;
  let test = eq r r_expected in
  if not test then failwithf "test 1504 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1505;
  let test = eq r r_expected in
  if not test then failwithf "test 1505 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1506;
  let test = eq r r_expected in
  if not test then failwithf "test 1506 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1507;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1507 failed";
  let expected_b6 = 101 in
  mark_test_run 1508;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1508 failed";
  let expected_c6 = 102 in
  mark_test_run 1509;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1509 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1510;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1510 failed";
  let expected_b6 = 101 in
  mark_test_run 1511;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1511 failed";
  let expected_c6 = 102 in
  mark_test_run 1512;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1512 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1513;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1513 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1514;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1514 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1515;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1515 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1516;
  let test = eq r r_expected in
  if not test then failwithf "test 1516 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1517;
  let test = eq r r_expected in
  if not test then failwithf "test 1517 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1518;
  let test = eq r r_expected in
  if not test then failwithf "test 1518 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1519;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1519 failed";
  let expected_b6 = 101 in
  mark_test_run 1520;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1520 failed";
  let expected_c6 = 102 in
  mark_test_run 1521;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1521 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1522;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1522 failed";
  let expected_b6 = 101 in
  mark_test_run 1523;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1523 failed";
  let expected_c6 = 102 in
  mark_test_run 1524;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1524 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1525;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1525 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1526;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1526 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1527;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1527 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1528;
  let test = eq r r_expected in
  if not test then failwithf "test 1528 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1529;
  let test = eq r r_expected in
  if not test then failwithf "test 1529 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1530;
  let test = eq r r_expected in
  if not test then failwithf "test 1530 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1531;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1531 failed";
  let expected_b6 = 101 in
  mark_test_run 1532;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1532 failed";
  let expected_c6 = 102 in
  mark_test_run 1533;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1533 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1534;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1534 failed";
  let expected_b6 = 101 in
  mark_test_run 1535;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1535 failed";
  let expected_c6 = 102 in
  mark_test_run 1536;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1536 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1537;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1537 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1538;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1538 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1539;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1539 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1540;
  let test = eq r r_expected in
  if not test then failwithf "test 1540 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1541;
  let test = eq r r_expected in
  if not test then failwithf "test 1541 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1542;
  let test = eq r r_expected in
  if not test then failwithf "test 1542 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1543;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1543 failed";
  let expected_b6 = 101 in
  mark_test_run 1544;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1544 failed";
  let expected_c6 = 102 in
  mark_test_run 1545;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1545 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1546;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1546 failed";
  let expected_b6 = 101 in
  mark_test_run 1547;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1547 failed";
  let expected_c6 = 102 in
  mark_test_run 1548;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1548 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1549;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1549 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1550;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1550 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1551;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1551 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1552;
  let test = eq r r_expected in
  if not test then failwithf "test 1552 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1553;
  let test = eq r r_expected in
  if not test then failwithf "test 1553 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1554;
  let test = eq r r_expected in
  if not test then failwithf "test 1554 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1555;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1555 failed";
  let expected_b6 = 101 in
  mark_test_run 1556;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1556 failed";
  let expected_c6 = 102 in
  mark_test_run 1557;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1557 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1558;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1558 failed";
  let expected_b6 = 101 in
  mark_test_run 1559;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1559 failed";
  let expected_c6 = 102 in
  mark_test_run 1560;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1560 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1561;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1561 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1562;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1562 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1563;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1563 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1564;
  let test = eq r r_expected in
  if not test then failwithf "test 1564 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1565;
  let test = eq r r_expected in
  if not test then failwithf "test 1565 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1566;
  let test = eq r r_expected in
  if not test then failwithf "test 1566 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1567;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1567 failed";
  let expected_b6 = 101 in
  mark_test_run 1568;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1568 failed";
  let expected_c6 = 102 in
  mark_test_run 1569;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1569 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1570;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1570 failed";
  let expected_b6 = 101 in
  mark_test_run 1571;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1571 failed";
  let expected_c6 = 102 in
  mark_test_run 1572;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1572 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1573;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1573 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1574;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1574 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1575;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1575 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1576;
  let test = eq r r_expected in
  if not test then failwithf "test 1576 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1577;
  let test = eq r r_expected in
  if not test then failwithf "test 1577 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1578;
  let test = eq r r_expected in
  if not test then failwithf "test 1578 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1579;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1579 failed";
  let expected_b6 = 101 in
  mark_test_run 1580;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1580 failed";
  let expected_c6 = 102 in
  mark_test_run 1581;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1581 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1582;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1582 failed";
  let expected_b6 = 101 in
  mark_test_run 1583;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1583 failed";
  let expected_c6 = 102 in
  mark_test_run 1584;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1584 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1585;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1585 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1586;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1586 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1587;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1587 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1588;
  let test = eq r r_expected in
  if not test then failwithf "test 1588 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1589;
  let test = eq r r_expected in
  if not test then failwithf "test 1589 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1590;
  let test = eq r r_expected in
  if not test then failwithf "test 1590 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1591;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1591 failed";
  let expected_b6 = 101 in
  mark_test_run 1592;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1592 failed";
  let expected_c6 = 102 in
  mark_test_run 1593;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1593 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1594;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1594 failed";
  let expected_b6 = 101 in
  mark_test_run 1595;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1595 failed";
  let expected_c6 = 102 in
  mark_test_run 1596;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1596 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1597;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1597 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1598;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1598 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1599;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1599 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1600;
  let test = eq r r_expected in
  if not test then failwithf "test 1600 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1601;
  let test = eq r r_expected in
  if not test then failwithf "test 1601 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1602;
  let test = eq r r_expected in
  if not test then failwithf "test 1602 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1603;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1603 failed";
  let expected_b6 = 101 in
  mark_test_run 1604;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1604 failed";
  let expected_c6 = 102 in
  mark_test_run 1605;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1605 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1606;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1606 failed";
  let expected_b6 = 101 in
  mark_test_run 1607;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1607 failed";
  let expected_c6 = 102 in
  mark_test_run 1608;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1608 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1609;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1609 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1610;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1610 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1611;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1611 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1612;
  let test = eq r r_expected in
  if not test then failwithf "test 1612 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1613;
  let test = eq r r_expected in
  if not test then failwithf "test 1613 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1614;
  let test = eq r r_expected in
  if not test then failwithf "test 1614 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1615;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1615 failed";
  let expected_b6 = 101 in
  mark_test_run 1616;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1616 failed";
  let expected_c6 = 102 in
  mark_test_run 1617;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1617 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1618;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1618 failed";
  let expected_b6 = 101 in
  mark_test_run 1619;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1619 failed";
  let expected_c6 = 102 in
  mark_test_run 1620;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1620 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1621;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1621 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1622;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1622 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1623;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1623 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1624;
  let test = eq r r_expected in
  if not test then failwithf "test 1624 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1625;
  let test = eq r r_expected in
  if not test then failwithf "test 1625 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1626;
  let test = eq r r_expected in
  if not test then failwithf "test 1626 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1627;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1627 failed";
  let expected_b6 = 101 in
  mark_test_run 1628;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1628 failed";
  let expected_c6 = 102 in
  mark_test_run 1629;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1629 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1630;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1630 failed";
  let expected_b6 = 101 in
  mark_test_run 1631;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1631 failed";
  let expected_c6 = 102 in
  mark_test_run 1632;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1632 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1633;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1633 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1634;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1634 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1635;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1635 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1636;
  let test = eq r r_expected in
  if not test then failwithf "test 1636 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1637;
  let test = eq r r_expected in
  if not test then failwithf "test 1637 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1638;
  let test = eq r r_expected in
  if not test then failwithf "test 1638 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1639;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1639 failed";
  let expected_b6 = 101 in
  mark_test_run 1640;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1640 failed";
  let expected_c6 = 102 in
  mark_test_run 1641;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1641 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1642;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1642 failed";
  let expected_b6 = 101 in
  mark_test_run 1643;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1643 failed";
  let expected_c6 = 102 in
  mark_test_run 1644;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1644 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1645;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1645 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1646;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1646 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1647;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1647 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1648;
  let test = eq r r_expected in
  if not test then failwithf "test 1648 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1649;
  let test = eq r r_expected in
  if not test then failwithf "test 1649 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1650;
  let test = eq r r_expected in
  if not test then failwithf "test 1650 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1651;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1651 failed";
  let expected_b6 = 101 in
  mark_test_run 1652;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1652 failed";
  let expected_c6 = 102 in
  mark_test_run 1653;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1653 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1654;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1654 failed";
  let expected_b6 = 101 in
  mark_test_run 1655;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1655 failed";
  let expected_c6 = 102 in
  mark_test_run 1656;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1656 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1657;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1657 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1658;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1658 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1659;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1659 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1660;
  let test = eq r r_expected in
  if not test then failwithf "test 1660 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1661;
  let test = eq r r_expected in
  if not test then failwithf "test 1661 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1662;
  let test = eq r r_expected in
  if not test then failwithf "test 1662 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1663;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1663 failed";
  let expected_b6 = 101 in
  mark_test_run 1664;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1664 failed";
  let expected_c6 = 102 in
  mark_test_run 1665;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1665 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1666;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1666 failed";
  let expected_b6 = 101 in
  mark_test_run 1667;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1667 failed";
  let expected_c6 = 102 in
  mark_test_run 1668;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1668 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1669;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1669 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1670;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1670 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1671;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1671 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1672;
  let test = eq r r_expected in
  if not test then failwithf "test 1672 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1673;
  let test = eq r r_expected in
  if not test then failwithf "test 1673 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1674;
  let test = eq r r_expected in
  if not test then failwithf "test 1674 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1675;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1675 failed";
  let expected_b6 = 101 in
  mark_test_run 1676;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1676 failed";
  let expected_c6 = 102 in
  mark_test_run 1677;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1677 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1678;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1678 failed";
  let expected_b6 = 101 in
  mark_test_run 1679;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1679 failed";
  let expected_c6 = 102 in
  mark_test_run 1680;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1680 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1681;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1681 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1682;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1682 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1683;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1683 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1684;
  let test = eq r r_expected in
  if not test then failwithf "test 1684 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1685;
  let test = eq r r_expected in
  if not test then failwithf "test 1685 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1686;
  let test = eq r r_expected in
  if not test then failwithf "test 1686 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1687;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1687 failed";
  let expected_b6 = 101 in
  mark_test_run 1688;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1688 failed";
  let expected_c6 = 102 in
  mark_test_run 1689;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1689 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1690;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1690 failed";
  let expected_b6 = 101 in
  mark_test_run 1691;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1691 failed";
  let expected_c6 = 102 in
  mark_test_run 1692;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1692 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1693;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1693 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1694;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1694 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1695;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1695 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1696;
  let test = eq r r_expected in
  if not test then failwithf "test 1696 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1697;
  let test = eq r r_expected in
  if not test then failwithf "test 1697 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1698;
  let test = eq r r_expected in
  if not test then failwithf "test 1698 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1699;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1699 failed";
  let expected_b6 = 101 in
  mark_test_run 1700;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1700 failed";
  let expected_c6 = 102 in
  mark_test_run 1701;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1701 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1702;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1702 failed";
  let expected_b6 = 101 in
  mark_test_run 1703;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1703 failed";
  let expected_c6 = 102 in
  mark_test_run 1704;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1704 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1705;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1705 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1706;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1706 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1707;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1707 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1708;
  let test = eq r r_expected in
  if not test then failwithf "test 1708 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1709;
  let test = eq r r_expected in
  if not test then failwithf "test 1709 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1710;
  let test = eq r r_expected in
  if not test then failwithf "test 1710 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1711;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1711 failed";
  let expected_b6 = 101 in
  mark_test_run 1712;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1712 failed";
  let expected_c6 = 102 in
  mark_test_run 1713;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1713 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1714;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1714 failed";
  let expected_b6 = 101 in
  mark_test_run 1715;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1715 failed";
  let expected_c6 = 102 in
  mark_test_run 1716;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1716 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1717;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1717 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1718;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1718 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1719;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1719 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1720;
  let test = eq r r_expected in
  if not test then failwithf "test 1720 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1721;
  let test = eq r r_expected in
  if not test then failwithf "test 1721 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1722;
  let test = eq r r_expected in
  if not test then failwithf "test 1722 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1723;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1723 failed";
  let expected_b6 = 101 in
  mark_test_run 1724;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1724 failed";
  let expected_c6 = 102 in
  mark_test_run 1725;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1725 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1726;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1726 failed";
  let expected_b6 = 101 in
  mark_test_run 1727;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1727 failed";
  let expected_c6 = 102 in
  mark_test_run 1728;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1728 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1729;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1729 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1730;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1730 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1731;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1731 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1732;
  let test = eq r r_expected in
  if not test then failwithf "test 1732 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1733;
  let test = eq r r_expected in
  if not test then failwithf "test 1733 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1734;
  let test = eq r r_expected in
  if not test then failwithf "test 1734 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1735;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1735 failed";
  let expected_b6 = 101 in
  mark_test_run 1736;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1736 failed";
  let expected_c6 = 102 in
  mark_test_run 1737;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1737 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1738;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1738 failed";
  let expected_b6 = 101 in
  mark_test_run 1739;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1739 failed";
  let expected_c6 = 102 in
  mark_test_run 1740;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1740 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1741;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1741 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1742;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1742 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1743;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1743 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1744;
  let test = eq r r_expected in
  if not test then failwithf "test 1744 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1745;
  let test = eq r r_expected in
  if not test then failwithf "test 1745 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1746;
  let test = eq r r_expected in
  if not test then failwithf "test 1746 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1747;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1747 failed";
  let expected_b6 = 101 in
  mark_test_run 1748;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1748 failed";
  let expected_c6 = 102 in
  mark_test_run 1749;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1749 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1750;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1750 failed";
  let expected_b6 = 101 in
  mark_test_run 1751;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1751 failed";
  let expected_c6 = 102 in
  mark_test_run 1752;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1752 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1753;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1753 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1754;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1754 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1755;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1755 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1756;
  let test = eq r r_expected in
  if not test then failwithf "test 1756 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1757;
  let test = eq r r_expected in
  if not test then failwithf "test 1757 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1758;
  let test = eq r r_expected in
  if not test then failwithf "test 1758 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1759;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1759 failed";
  let expected_b6 = 101 in
  mark_test_run 1760;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1760 failed";
  let expected_c6 = 102 in
  mark_test_run 1761;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1761 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1762;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1762 failed";
  let expected_b6 = 101 in
  mark_test_run 1763;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1763 failed";
  let expected_c6 = 102 in
  mark_test_run 1764;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1764 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1765;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1765 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1766;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1766 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1767;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1767 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1768;
  let test = eq r r_expected in
  if not test then failwithf "test 1768 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1769;
  let test = eq r r_expected in
  if not test then failwithf "test 1769 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1770;
  let test = eq r r_expected in
  if not test then failwithf "test 1770 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1771;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1771 failed";
  let expected_b6 = 101 in
  mark_test_run 1772;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1772 failed";
  let expected_c6 = 102 in
  mark_test_run 1773;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1773 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1774;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1774 failed";
  let expected_b6 = 101 in
  mark_test_run 1775;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1775 failed";
  let expected_c6 = 102 in
  mark_test_run 1776;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1776 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1777;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1777 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1778;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1778 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1779;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1779 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1780;
  let test = eq r r_expected in
  if not test then failwithf "test 1780 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1781;
  let test = eq r r_expected in
  if not test then failwithf "test 1781 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1782;
  let test = eq r r_expected in
  if not test then failwithf "test 1782 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1783;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1783 failed";
  let expected_b6 = 101 in
  mark_test_run 1784;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1784 failed";
  let expected_c6 = 102 in
  mark_test_run 1785;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1785 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1786;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1786 failed";
  let expected_b6 = 101 in
  mark_test_run 1787;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1787 failed";
  let expected_c6 = 102 in
  mark_test_run 1788;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1788 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1789;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1789 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1790;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1790 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1791;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1791 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1792;
  let test = eq r r_expected in
  if not test then failwithf "test 1792 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1793;
  let test = eq r r_expected in
  if not test then failwithf "test 1793 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1794;
  let test = eq r r_expected in
  if not test then failwithf "test 1794 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1795;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1795 failed";
  let expected_b6 = 101 in
  mark_test_run 1796;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1796 failed";
  let expected_c6 = 102 in
  mark_test_run 1797;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1797 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1798;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1798 failed";
  let expected_b6 = 101 in
  mark_test_run 1799;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1799 failed";
  let expected_c6 = 102 in
  mark_test_run 1800;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1800 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1801;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1801 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1802;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1802 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1803;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1803 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1804;
  let test = eq r r_expected in
  if not test then failwithf "test 1804 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1805;
  let test = eq r r_expected in
  if not test then failwithf "test 1805 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1806;
  let test = eq r r_expected in
  if not test then failwithf "test 1806 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1807;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1807 failed";
  let expected_b6 = 101 in
  mark_test_run 1808;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1808 failed";
  let expected_c6 = 102 in
  mark_test_run 1809;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1809 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1810;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1810 failed";
  let expected_b6 = 101 in
  mark_test_run 1811;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1811 failed";
  let expected_c6 = 102 in
  mark_test_run 1812;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1812 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1813;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1813 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1814;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1814 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1815;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1815 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1816;
  let test = eq r r_expected in
  if not test then failwithf "test 1816 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1817;
  let test = eq r r_expected in
  if not test then failwithf "test 1817 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1818;
  let test = eq r r_expected in
  if not test then failwithf "test 1818 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1819;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1819 failed";
  let expected_b6 = 101 in
  mark_test_run 1820;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1820 failed";
  let expected_c6 = 102 in
  mark_test_run 1821;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1821 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1822;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1822 failed";
  let expected_b6 = 101 in
  mark_test_run 1823;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1823 failed";
  let expected_c6 = 102 in
  mark_test_run 1824;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1824 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1825;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1825 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1826;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1826 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1827;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1827 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1828;
  let test = eq r r_expected in
  if not test then failwithf "test 1828 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1829;
  let test = eq r r_expected in
  if not test then failwithf "test 1829 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1830;
  let test = eq r r_expected in
  if not test then failwithf "test 1830 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1831;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1831 failed";
  let expected_b6 = 101 in
  mark_test_run 1832;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1832 failed";
  let expected_c6 = 102 in
  mark_test_run 1833;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1833 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1834;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1834 failed";
  let expected_b6 = 101 in
  mark_test_run 1835;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1835 failed";
  let expected_c6 = 102 in
  mark_test_run 1836;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1836 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1837;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1837 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1838;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1838 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1839;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1839 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1840;
  let test = eq r r_expected in
  if not test then failwithf "test 1840 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1841;
  let test = eq r r_expected in
  if not test then failwithf "test 1841 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1842;
  let test = eq r r_expected in
  if not test then failwithf "test 1842 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1843;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1843 failed";
  let expected_b6 = 101 in
  mark_test_run 1844;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1844 failed";
  let expected_c6 = 102 in
  mark_test_run 1845;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1845 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1846;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1846 failed";
  let expected_b6 = 101 in
  mark_test_run 1847;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1847 failed";
  let expected_c6 = 102 in
  mark_test_run 1848;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1848 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1849;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1849 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1850;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1850 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1851;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1851 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1852;
  let test = eq r r_expected in
  if not test then failwithf "test 1852 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1853;
  let test = eq r r_expected in
  if not test then failwithf "test 1853 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1854;
  let test = eq r r_expected in
  if not test then failwithf "test 1854 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1855;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1855 failed";
  let expected_b6 = 101 in
  mark_test_run 1856;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1856 failed";
  let expected_c6 = 102 in
  mark_test_run 1857;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1857 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1858;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1858 failed";
  let expected_b6 = 101 in
  mark_test_run 1859;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1859 failed";
  let expected_c6 = 102 in
  mark_test_run 1860;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1860 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1861;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1861 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1862;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1862 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1863;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1863 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1864;
  let test = eq r r_expected in
  if not test then failwithf "test 1864 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1865;
  let test = eq r r_expected in
  if not test then failwithf "test 1865 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1866;
  let test = eq r r_expected in
  if not test then failwithf "test 1866 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1867;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1867 failed";
  let expected_b6 = 101 in
  mark_test_run 1868;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1868 failed";
  let expected_c6 = 102 in
  mark_test_run 1869;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1869 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1870;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1870 failed";
  let expected_b6 = 101 in
  mark_test_run 1871;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1871 failed";
  let expected_c6 = 102 in
  mark_test_run 1872;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1872 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1873;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1873 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1874;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1874 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1875;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1875 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1876;
  let test = eq r r_expected in
  if not test then failwithf "test 1876 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1877;
  let test = eq r r_expected in
  if not test then failwithf "test 1877 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1878;
  let test = eq r r_expected in
  if not test then failwithf "test 1878 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1879;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1879 failed";
  let expected_b6 = 101 in
  mark_test_run 1880;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1880 failed";
  let expected_c6 = 102 in
  mark_test_run 1881;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1881 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1882;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1882 failed";
  let expected_b6 = 101 in
  mark_test_run 1883;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1883 failed";
  let expected_c6 = 102 in
  mark_test_run 1884;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1884 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1885;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1885 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1886;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1886 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1887;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1887 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1888;
  let test = eq r r_expected in
  if not test then failwithf "test 1888 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1889;
  let test = eq r r_expected in
  if not test then failwithf "test 1889 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1890;
  let test = eq r r_expected in
  if not test then failwithf "test 1890 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1891;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1891 failed";
  let expected_b6 = 101 in
  mark_test_run 1892;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1892 failed";
  let expected_c6 = 102 in
  mark_test_run 1893;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1893 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1894;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1894 failed";
  let expected_b6 = 101 in
  mark_test_run 1895;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1895 failed";
  let expected_c6 = 102 in
  mark_test_run 1896;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1896 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1897;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1897 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1898;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1898 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1899;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1899 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1900;
  let test = eq r r_expected in
  if not test then failwithf "test 1900 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1901;
  let test = eq r r_expected in
  if not test then failwithf "test 1901 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1902;
  let test = eq r r_expected in
  if not test then failwithf "test 1902 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1903;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1903 failed";
  let expected_b6 = 101 in
  mark_test_run 1904;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1904 failed";
  let expected_c6 = 102 in
  mark_test_run 1905;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1905 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1906;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1906 failed";
  let expected_b6 = 101 in
  mark_test_run 1907;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1907 failed";
  let expected_c6 = 102 in
  mark_test_run 1908;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1908 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t6 = { int; int; int }   *)
  (******************************)
  let r = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 1909;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1909 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1 in
  mark_test_run 1910;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1910 failed";
  (* Paths of depth 1 *)
  (* .c6 *)
  let actual = r.c6 in
  let expected = 2 in
  mark_test_run 1911;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1911 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61; c6 = c61 } { a6 = a62; b6 = b62; c6 = c62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int.equal a b) b61 b62 && (fun a b -> Int.equal a b) c61 c62) in
  let next_r = { a6 = 100; b6 = 101; c6 = 102 } in
  let r_expected = { a6 = 0; b6 = 1; c6 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 1912;
  let test = eq r r_expected in
  if not test then failwithf "test 1912 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 1913;
  let test = eq r r_expected in
  if not test then failwithf "test 1913 failed";
  Gc.compact ();
  (* .c6 *)
  r.c6 <- next_r.c6;
  let r_expected = { r_expected with c6 = next_r.c6 } in
  mark_test_run 1914;
  let test = eq r r_expected in
  if not test then failwithf "test 1914 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1915;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1915 failed";
  let expected_b6 = 101 in
  mark_test_run 1916;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1916 failed";
  let expected_c6 = 102 in
  mark_test_run 1917;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1917 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6; c6 } = r in
  let expected_a6 = 100 in
  mark_test_run 1918;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 1918 failed";
  let expected_b6 = 101 in
  mark_test_run 1919;
  let test = (fun a b -> Int.equal a b) expected_b6 b6 in
  if not test then failwithf "test 1919 failed";
  let expected_c6 = 102 in
  mark_test_run 1920;
  let test = (fun a b -> Int.equal a b) expected_c6 c6 in
  if not test then failwithf "test 1920 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1921;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1921 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1922;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1922 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1923;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1923 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1924;
  let test = eq r r_expected in
  if not test then failwithf "test 1924 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1925;
  let test = eq r r_expected in
  if not test then failwithf "test 1925 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1926;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1926 failed";
  let expected_a2 = 101 in
  mark_test_run 1927;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1927 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1928;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1928 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1929;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1929 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1930;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1930 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1931;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1931 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1932;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1932 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1933;
  let test = eq r r_expected in
  if not test then failwithf "test 1933 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1934;
  let test = eq r r_expected in
  if not test then failwithf "test 1934 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1935;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1935 failed";
  let expected_a2 = 101 in
  mark_test_run 1936;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1936 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1937;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1937 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1938;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1938 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1939;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1939 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1940;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1940 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1941;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1941 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1942;
  let test = eq r r_expected in
  if not test then failwithf "test 1942 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1943;
  let test = eq r r_expected in
  if not test then failwithf "test 1943 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1944;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1944 failed";
  let expected_a2 = 101 in
  mark_test_run 1945;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1945 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1946;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1946 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1947;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1947 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1948;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1948 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1949;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1949 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1950;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1950 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1951;
  let test = eq r r_expected in
  if not test then failwithf "test 1951 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1952;
  let test = eq r r_expected in
  if not test then failwithf "test 1952 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1953;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1953 failed";
  let expected_a2 = 101 in
  mark_test_run 1954;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1954 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1955;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1955 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1956;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1956 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1957;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1957 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1958;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1958 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1959;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1959 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1960;
  let test = eq r r_expected in
  if not test then failwithf "test 1960 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1961;
  let test = eq r r_expected in
  if not test then failwithf "test 1961 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1962;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1962 failed";
  let expected_a2 = 101 in
  mark_test_run 1963;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1963 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1964;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1964 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1965;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1965 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1966;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1966 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1967;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1967 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1968;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1968 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1969;
  let test = eq r r_expected in
  if not test then failwithf "test 1969 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1970;
  let test = eq r r_expected in
  if not test then failwithf "test 1970 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1971;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1971 failed";
  let expected_a2 = 101 in
  mark_test_run 1972;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1972 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1973;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1973 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1974;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1974 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1975;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1975 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1976;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1976 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1977;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1977 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1978;
  let test = eq r r_expected in
  if not test then failwithf "test 1978 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1979;
  let test = eq r r_expected in
  if not test then failwithf "test 1979 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1980;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1980 failed";
  let expected_a2 = 101 in
  mark_test_run 1981;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1981 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1982;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1982 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1983;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1983 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1984;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1984 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1985;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1985 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1986;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1986 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1987;
  let test = eq r r_expected in
  if not test then failwithf "test 1987 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1988;
  let test = eq r r_expected in
  if not test then failwithf "test 1988 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1989;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1989 failed";
  let expected_a2 = 101 in
  mark_test_run 1990;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1990 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 1991;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1991 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 1992;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 1992 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 1993;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1993 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 1994;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 1994 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 1995;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1995 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 1996;
  let test = eq r r_expected in
  if not test then failwithf "test 1996 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 1997;
  let test = eq r r_expected in
  if not test then failwithf "test 1997 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 1998;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 1998 failed";
  let expected_a2 = 101 in
  mark_test_run 1999;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 1999 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2000;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2000 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2001;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2001 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2002;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2002 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2003;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2003 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2004;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2004 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2005;
  let test = eq r r_expected in
  if not test then failwithf "test 2005 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2006;
  let test = eq r r_expected in
  if not test then failwithf "test 2006 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2007;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2007 failed";
  let expected_a2 = 101 in
  mark_test_run 2008;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2008 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2009;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2009 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2010;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2010 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2011;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2011 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2012;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2012 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2013;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2013 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2014;
  let test = eq r r_expected in
  if not test then failwithf "test 2014 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2015;
  let test = eq r r_expected in
  if not test then failwithf "test 2015 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2016;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2016 failed";
  let expected_a2 = 101 in
  mark_test_run 2017;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2017 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2018;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2018 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2019;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2019 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2020;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2020 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2021;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2021 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2022;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2022 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2023;
  let test = eq r r_expected in
  if not test then failwithf "test 2023 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2024;
  let test = eq r r_expected in
  if not test then failwithf "test 2024 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2025;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2025 failed";
  let expected_a2 = 101 in
  mark_test_run 2026;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2026 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2027;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2027 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2028;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2028 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2029;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2029 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2030;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2030 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2031;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2031 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2032;
  let test = eq r r_expected in
  if not test then failwithf "test 2032 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2033;
  let test = eq r r_expected in
  if not test then failwithf "test 2033 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2034;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2034 failed";
  let expected_a2 = 101 in
  mark_test_run 2035;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2035 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2036;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2036 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2037;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2037 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2038;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2038 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2039;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2039 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2040;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2040 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2041;
  let test = eq r r_expected in
  if not test then failwithf "test 2041 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2042;
  let test = eq r r_expected in
  if not test then failwithf "test 2042 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2043;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2043 failed";
  let expected_a2 = 101 in
  mark_test_run 2044;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2044 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2045;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2045 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2046;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2046 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2047;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2047 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2048;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2048 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2049;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2049 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2050;
  let test = eq r r_expected in
  if not test then failwithf "test 2050 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2051;
  let test = eq r r_expected in
  if not test then failwithf "test 2051 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2052;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2052 failed";
  let expected_a2 = 101 in
  mark_test_run 2053;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2053 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2054;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2054 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2055;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2055 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2056;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2056 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2057;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2057 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2058;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2058 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2059;
  let test = eq r r_expected in
  if not test then failwithf "test 2059 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2060;
  let test = eq r r_expected in
  if not test then failwithf "test 2060 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2061;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2061 failed";
  let expected_a2 = 101 in
  mark_test_run 2062;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2062 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2063;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2063 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2064;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2064 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2065;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2065 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2066;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2066 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2067;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2067 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2068;
  let test = eq r r_expected in
  if not test then failwithf "test 2068 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2069;
  let test = eq r r_expected in
  if not test then failwithf "test 2069 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2070;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2070 failed";
  let expected_a2 = 101 in
  mark_test_run 2071;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2071 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2072;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2072 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2073;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2073 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2074;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2074 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2075;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2075 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2076;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2076 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2077;
  let test = eq r r_expected in
  if not test then failwithf "test 2077 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2078;
  let test = eq r r_expected in
  if not test then failwithf "test 2078 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2079;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2079 failed";
  let expected_a2 = 101 in
  mark_test_run 2080;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2080 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2081;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2081 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2082;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2082 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2083;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2083 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2084;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2084 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2085;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2085 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2086;
  let test = eq r r_expected in
  if not test then failwithf "test 2086 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2087;
  let test = eq r r_expected in
  if not test then failwithf "test 2087 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2088;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2088 failed";
  let expected_a2 = 101 in
  mark_test_run 2089;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2089 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2090;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2090 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2091;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2091 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2092;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2092 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2093;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2093 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2094;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2094 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2095;
  let test = eq r r_expected in
  if not test then failwithf "test 2095 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2096;
  let test = eq r r_expected in
  if not test then failwithf "test 2096 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2097;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2097 failed";
  let expected_a2 = 101 in
  mark_test_run 2098;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2098 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2099;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2099 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2100;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2100 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2101;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2101 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2102;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2102 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2103;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2103 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2104;
  let test = eq r r_expected in
  if not test then failwithf "test 2104 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2105;
  let test = eq r r_expected in
  if not test then failwithf "test 2105 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2106;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2106 failed";
  let expected_a2 = 101 in
  mark_test_run 2107;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2107 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2108;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2108 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2109;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2109 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2110;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2110 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2111;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2111 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2112;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2112 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2113;
  let test = eq r r_expected in
  if not test then failwithf "test 2113 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2114;
  let test = eq r r_expected in
  if not test then failwithf "test 2114 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2115;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2115 failed";
  let expected_a2 = 101 in
  mark_test_run 2116;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2116 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2117;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2117 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2118;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2118 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2119;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2119 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2120;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2120 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2121;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2121 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2122;
  let test = eq r r_expected in
  if not test then failwithf "test 2122 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2123;
  let test = eq r r_expected in
  if not test then failwithf "test 2123 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2124;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2124 failed";
  let expected_a2 = 101 in
  mark_test_run 2125;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2125 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2126;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2126 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2127;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2127 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2128;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2128 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2129;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2129 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2130;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2130 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2131;
  let test = eq r r_expected in
  if not test then failwithf "test 2131 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2132;
  let test = eq r r_expected in
  if not test then failwithf "test 2132 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2133;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2133 failed";
  let expected_a2 = 101 in
  mark_test_run 2134;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2134 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2135;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2135 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2136;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2136 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t7 = { int; #{ int } }   *)
  (******************************)
  let r = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 2137;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2137 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a2 = 1 } in
  mark_test_run 2138;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 2138 failed";
  (* Paths of depth 2 *)
  (* .b7.#a2 *)
  let actual = r.b7.#a2 in
  let expected = 1 in
  mark_test_run 2139;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2139 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) b71 b72) in
  let next_r = { a7 = 100; b7 = #{ a2 = 101 } } in
  let r_expected = { a7 = 0; b7 = #{ a2 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 2140;
  let test = eq r r_expected in
  if not test then failwithf "test 2140 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 2141;
  let test = eq r r_expected in
  if not test then failwithf "test 2141 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a2 } } = r in
  let expected_a7 = 100 in
  mark_test_run 2142;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2142 failed";
  let expected_a2 = 101 in
  mark_test_run 2143;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 2143 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 2144;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 2144 failed";
  let expected_b7 = #{ a2 = 101 } in
  mark_test_run 2145;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_b7 b7 in
  if not test then failwithf "test 2145 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2146;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2146 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2147;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2147 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2148;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2148 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2149;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2149 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2150;
  let test = eq r r_expected in
  if not test then failwithf "test 2150 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2151;
  let test = eq r r_expected in
  if not test then failwithf "test 2151 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2152;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2152 failed";
  let expected_a4 = 101 in
  mark_test_run 2153;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2153 failed";
  let expected_b4 = 102 in
  mark_test_run 2154;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2154 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2155;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2155 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2156;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2156 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2157;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2157 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2158;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2158 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2159;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2159 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2160;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2160 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2161;
  let test = eq r r_expected in
  if not test then failwithf "test 2161 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2162;
  let test = eq r r_expected in
  if not test then failwithf "test 2162 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2163;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2163 failed";
  let expected_a4 = 101 in
  mark_test_run 2164;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2164 failed";
  let expected_b4 = 102 in
  mark_test_run 2165;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2165 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2166;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2166 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2167;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2167 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2168;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2168 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2169;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2169 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2170;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2170 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2171;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2171 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2172;
  let test = eq r r_expected in
  if not test then failwithf "test 2172 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2173;
  let test = eq r r_expected in
  if not test then failwithf "test 2173 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2174;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2174 failed";
  let expected_a4 = 101 in
  mark_test_run 2175;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2175 failed";
  let expected_b4 = 102 in
  mark_test_run 2176;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2176 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2177;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2177 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2178;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2178 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2179;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2179 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2180;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2180 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2181;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2181 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2182;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2182 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2183;
  let test = eq r r_expected in
  if not test then failwithf "test 2183 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2184;
  let test = eq r r_expected in
  if not test then failwithf "test 2184 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2185;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2185 failed";
  let expected_a4 = 101 in
  mark_test_run 2186;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2186 failed";
  let expected_b4 = 102 in
  mark_test_run 2187;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2187 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2188;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2188 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2189;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2189 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2190;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2190 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2191;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2191 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2192;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2192 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2193;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2193 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2194;
  let test = eq r r_expected in
  if not test then failwithf "test 2194 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2195;
  let test = eq r r_expected in
  if not test then failwithf "test 2195 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2196;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2196 failed";
  let expected_a4 = 101 in
  mark_test_run 2197;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2197 failed";
  let expected_b4 = 102 in
  mark_test_run 2198;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2198 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2199;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2199 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2200;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2200 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2201;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2201 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2202;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2202 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2203;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2203 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2204;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2204 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2205;
  let test = eq r r_expected in
  if not test then failwithf "test 2205 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2206;
  let test = eq r r_expected in
  if not test then failwithf "test 2206 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2207;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2207 failed";
  let expected_a4 = 101 in
  mark_test_run 2208;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2208 failed";
  let expected_b4 = 102 in
  mark_test_run 2209;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2209 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2210;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2210 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2211;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2211 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2212;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2212 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2213;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2213 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2214;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2214 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2215;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2215 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2216;
  let test = eq r r_expected in
  if not test then failwithf "test 2216 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2217;
  let test = eq r r_expected in
  if not test then failwithf "test 2217 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2218;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2218 failed";
  let expected_a4 = 101 in
  mark_test_run 2219;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2219 failed";
  let expected_b4 = 102 in
  mark_test_run 2220;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2220 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2221;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2221 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2222;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2222 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2223;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2223 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2224;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2224 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2225;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2225 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2226;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2226 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2227;
  let test = eq r r_expected in
  if not test then failwithf "test 2227 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2228;
  let test = eq r r_expected in
  if not test then failwithf "test 2228 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2229;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2229 failed";
  let expected_a4 = 101 in
  mark_test_run 2230;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2230 failed";
  let expected_b4 = 102 in
  mark_test_run 2231;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2231 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2232;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2232 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2233;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2233 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2234;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2234 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2235;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2235 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2236;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2236 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2237;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2237 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2238;
  let test = eq r r_expected in
  if not test then failwithf "test 2238 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2239;
  let test = eq r r_expected in
  if not test then failwithf "test 2239 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2240;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2240 failed";
  let expected_a4 = 101 in
  mark_test_run 2241;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2241 failed";
  let expected_b4 = 102 in
  mark_test_run 2242;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2242 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2243;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2243 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2244;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2244 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2245;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2245 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2246;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2246 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2247;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2247 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2248;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2248 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2249;
  let test = eq r r_expected in
  if not test then failwithf "test 2249 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2250;
  let test = eq r r_expected in
  if not test then failwithf "test 2250 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2251;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2251 failed";
  let expected_a4 = 101 in
  mark_test_run 2252;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2252 failed";
  let expected_b4 = 102 in
  mark_test_run 2253;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2253 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2254;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2254 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2255;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2255 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2256;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2256 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2257;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2257 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2258;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2258 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2259;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2259 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2260;
  let test = eq r r_expected in
  if not test then failwithf "test 2260 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2261;
  let test = eq r r_expected in
  if not test then failwithf "test 2261 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2262;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2262 failed";
  let expected_a4 = 101 in
  mark_test_run 2263;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2263 failed";
  let expected_b4 = 102 in
  mark_test_run 2264;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2264 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2265;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2265 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2266;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2266 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2267;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2267 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2268;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2268 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2269;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2269 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2270;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2270 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2271;
  let test = eq r r_expected in
  if not test then failwithf "test 2271 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2272;
  let test = eq r r_expected in
  if not test then failwithf "test 2272 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2273;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2273 failed";
  let expected_a4 = 101 in
  mark_test_run 2274;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2274 failed";
  let expected_b4 = 102 in
  mark_test_run 2275;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2275 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2276;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2276 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2277;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2277 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2278;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2278 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2279;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2279 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2280;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2280 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2281;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2281 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2282;
  let test = eq r r_expected in
  if not test then failwithf "test 2282 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2283;
  let test = eq r r_expected in
  if not test then failwithf "test 2283 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2284;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2284 failed";
  let expected_a4 = 101 in
  mark_test_run 2285;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2285 failed";
  let expected_b4 = 102 in
  mark_test_run 2286;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2286 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2287;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2287 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2288;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2288 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2289;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2289 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2290;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2290 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2291;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2291 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2292;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2292 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2293;
  let test = eq r r_expected in
  if not test then failwithf "test 2293 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2294;
  let test = eq r r_expected in
  if not test then failwithf "test 2294 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2295;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2295 failed";
  let expected_a4 = 101 in
  mark_test_run 2296;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2296 failed";
  let expected_b4 = 102 in
  mark_test_run 2297;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2297 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2298;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2298 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2299;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2299 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2300;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2300 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2301;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2301 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2302;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2302 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2303;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2303 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2304;
  let test = eq r r_expected in
  if not test then failwithf "test 2304 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2305;
  let test = eq r r_expected in
  if not test then failwithf "test 2305 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2306;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2306 failed";
  let expected_a4 = 101 in
  mark_test_run 2307;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2307 failed";
  let expected_b4 = 102 in
  mark_test_run 2308;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2308 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2309;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2309 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2310;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2310 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2311;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2311 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2312;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2312 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2313;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2313 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2314;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2314 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2315;
  let test = eq r r_expected in
  if not test then failwithf "test 2315 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2316;
  let test = eq r r_expected in
  if not test then failwithf "test 2316 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2317;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2317 failed";
  let expected_a4 = 101 in
  mark_test_run 2318;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2318 failed";
  let expected_b4 = 102 in
  mark_test_run 2319;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2319 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2320;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2320 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2321;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2321 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2322;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2322 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2323;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2323 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2324;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2324 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2325;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2325 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2326;
  let test = eq r r_expected in
  if not test then failwithf "test 2326 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2327;
  let test = eq r r_expected in
  if not test then failwithf "test 2327 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2328;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2328 failed";
  let expected_a4 = 101 in
  mark_test_run 2329;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2329 failed";
  let expected_b4 = 102 in
  mark_test_run 2330;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2330 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2331;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2331 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2332;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2332 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2333;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2333 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2334;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2334 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2335;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2335 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2336;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2336 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2337;
  let test = eq r r_expected in
  if not test then failwithf "test 2337 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2338;
  let test = eq r r_expected in
  if not test then failwithf "test 2338 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2339;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2339 failed";
  let expected_a4 = 101 in
  mark_test_run 2340;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2340 failed";
  let expected_b4 = 102 in
  mark_test_run 2341;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2341 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2342;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2342 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2343;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2343 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2344;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2344 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2345;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2345 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2346;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2346 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2347;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2347 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2348;
  let test = eq r r_expected in
  if not test then failwithf "test 2348 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2349;
  let test = eq r r_expected in
  if not test then failwithf "test 2349 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2350;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2350 failed";
  let expected_a4 = 101 in
  mark_test_run 2351;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2351 failed";
  let expected_b4 = 102 in
  mark_test_run 2352;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2352 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2353;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2353 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2354;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2354 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2355;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2355 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2356;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2356 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2357;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2357 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2358;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2358 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2359;
  let test = eq r r_expected in
  if not test then failwithf "test 2359 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2360;
  let test = eq r r_expected in
  if not test then failwithf "test 2360 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2361;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2361 failed";
  let expected_a4 = 101 in
  mark_test_run 2362;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2362 failed";
  let expected_b4 = 102 in
  mark_test_run 2363;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2363 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2364;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2364 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2365;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2365 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2366;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2366 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2367;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2367 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2368;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2368 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2369;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2369 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2370;
  let test = eq r r_expected in
  if not test then failwithf "test 2370 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2371;
  let test = eq r r_expected in
  if not test then failwithf "test 2371 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2372;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2372 failed";
  let expected_a4 = 101 in
  mark_test_run 2373;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2373 failed";
  let expected_b4 = 102 in
  mark_test_run 2374;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2374 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2375;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2375 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2376;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2376 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2377;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2377 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2378;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2378 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2379;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2379 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2380;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2380 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2381;
  let test = eq r r_expected in
  if not test then failwithf "test 2381 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2382;
  let test = eq r r_expected in
  if not test then failwithf "test 2382 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2383;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2383 failed";
  let expected_a4 = 101 in
  mark_test_run 2384;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2384 failed";
  let expected_b4 = 102 in
  mark_test_run 2385;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2385 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2386;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2386 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2387;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2387 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2388;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2388 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2389;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2389 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2390;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2390 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2391;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2391 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2392;
  let test = eq r r_expected in
  if not test then failwithf "test 2392 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2393;
  let test = eq r r_expected in
  if not test then failwithf "test 2393 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2394;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2394 failed";
  let expected_a4 = 101 in
  mark_test_run 2395;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2395 failed";
  let expected_b4 = 102 in
  mark_test_run 2396;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2396 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2397;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2397 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2398;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2398 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2399;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2399 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2400;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2400 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2401;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2401 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2402;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2402 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2403;
  let test = eq r r_expected in
  if not test then failwithf "test 2403 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2404;
  let test = eq r r_expected in
  if not test then failwithf "test 2404 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2405;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2405 failed";
  let expected_a4 = 101 in
  mark_test_run 2406;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2406 failed";
  let expected_b4 = 102 in
  mark_test_run 2407;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2407 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2408;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2408 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2409;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2409 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2410;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2410 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2411;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2411 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2412;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2412 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2413;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2413 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2414;
  let test = eq r r_expected in
  if not test then failwithf "test 2414 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2415;
  let test = eq r r_expected in
  if not test then failwithf "test 2415 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2416;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2416 failed";
  let expected_a4 = 101 in
  mark_test_run 2417;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2417 failed";
  let expected_b4 = 102 in
  mark_test_run 2418;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2418 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2419;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2419 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2420;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2420 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2421;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2421 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2422;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2422 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2423;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2423 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2424;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2424 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2425;
  let test = eq r r_expected in
  if not test then failwithf "test 2425 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2426;
  let test = eq r r_expected in
  if not test then failwithf "test 2426 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2427;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2427 failed";
  let expected_a4 = 101 in
  mark_test_run 2428;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2428 failed";
  let expected_b4 = 102 in
  mark_test_run 2429;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2429 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2430;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2430 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2431;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2431 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2432;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2432 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2433;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2433 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2434;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2434 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2435;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2435 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2436;
  let test = eq r r_expected in
  if not test then failwithf "test 2436 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2437;
  let test = eq r r_expected in
  if not test then failwithf "test 2437 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2438;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2438 failed";
  let expected_a4 = 101 in
  mark_test_run 2439;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2439 failed";
  let expected_b4 = 102 in
  mark_test_run 2440;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2440 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2441;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2441 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2442;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2442 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2443;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2443 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2444;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2444 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2445;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2445 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2446;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2446 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2447;
  let test = eq r r_expected in
  if not test then failwithf "test 2447 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2448;
  let test = eq r r_expected in
  if not test then failwithf "test 2448 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2449;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2449 failed";
  let expected_a4 = 101 in
  mark_test_run 2450;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2450 failed";
  let expected_b4 = 102 in
  mark_test_run 2451;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2451 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2452;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2452 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2453;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2453 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2454;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2454 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2455;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2455 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2456;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2456 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2457;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2457 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2458;
  let test = eq r r_expected in
  if not test then failwithf "test 2458 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2459;
  let test = eq r r_expected in
  if not test then failwithf "test 2459 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2460;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2460 failed";
  let expected_a4 = 101 in
  mark_test_run 2461;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2461 failed";
  let expected_b4 = 102 in
  mark_test_run 2462;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2462 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2463;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2463 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2464;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2464 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2465;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2465 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2466;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2466 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2467;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2467 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2468;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2468 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2469;
  let test = eq r r_expected in
  if not test then failwithf "test 2469 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2470;
  let test = eq r r_expected in
  if not test then failwithf "test 2470 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2471;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2471 failed";
  let expected_a4 = 101 in
  mark_test_run 2472;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2472 failed";
  let expected_b4 = 102 in
  mark_test_run 2473;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2473 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2474;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2474 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2475;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2475 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2476;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2476 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2477;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2477 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2478;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2478 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2479;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2479 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2480;
  let test = eq r r_expected in
  if not test then failwithf "test 2480 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2481;
  let test = eq r r_expected in
  if not test then failwithf "test 2481 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2482;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2482 failed";
  let expected_a4 = 101 in
  mark_test_run 2483;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2483 failed";
  let expected_b4 = 102 in
  mark_test_run 2484;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2484 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2485;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2485 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2486;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2486 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2487;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2487 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2488;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2488 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2489;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2489 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2490;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2490 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2491;
  let test = eq r r_expected in
  if not test then failwithf "test 2491 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2492;
  let test = eq r r_expected in
  if not test then failwithf "test 2492 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2493;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2493 failed";
  let expected_a4 = 101 in
  mark_test_run 2494;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2494 failed";
  let expected_b4 = 102 in
  mark_test_run 2495;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2495 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2496;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2496 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2497;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2497 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2498;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2498 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2499;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2499 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2500;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2500 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2501;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2501 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2502;
  let test = eq r r_expected in
  if not test then failwithf "test 2502 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2503;
  let test = eq r r_expected in
  if not test then failwithf "test 2503 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2504;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2504 failed";
  let expected_a4 = 101 in
  mark_test_run 2505;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2505 failed";
  let expected_b4 = 102 in
  mark_test_run 2506;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2506 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2507;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2507 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2508;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2508 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2509;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2509 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2510;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2510 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2511;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2511 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2512;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2512 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2513;
  let test = eq r r_expected in
  if not test then failwithf "test 2513 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2514;
  let test = eq r r_expected in
  if not test then failwithf "test 2514 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2515;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2515 failed";
  let expected_a4 = 101 in
  mark_test_run 2516;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2516 failed";
  let expected_b4 = 102 in
  mark_test_run 2517;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2517 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2518;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2518 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2519;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2519 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2520;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2520 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2521;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2521 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2522;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2522 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2523;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2523 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2524;
  let test = eq r r_expected in
  if not test then failwithf "test 2524 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2525;
  let test = eq r r_expected in
  if not test then failwithf "test 2525 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2526;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2526 failed";
  let expected_a4 = 101 in
  mark_test_run 2527;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2527 failed";
  let expected_b4 = 102 in
  mark_test_run 2528;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2528 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2529;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2529 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2530;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2530 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2531;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2531 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2532;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2532 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2533;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2533 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2534;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2534 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2535;
  let test = eq r r_expected in
  if not test then failwithf "test 2535 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2536;
  let test = eq r r_expected in
  if not test then failwithf "test 2536 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2537;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2537 failed";
  let expected_a4 = 101 in
  mark_test_run 2538;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2538 failed";
  let expected_b4 = 102 in
  mark_test_run 2539;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2539 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2540;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2540 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2541;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2541 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2542;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2542 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2543;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2543 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2544;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2544 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2545;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2545 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2546;
  let test = eq r r_expected in
  if not test then failwithf "test 2546 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2547;
  let test = eq r r_expected in
  if not test then failwithf "test 2547 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2548;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2548 failed";
  let expected_a4 = 101 in
  mark_test_run 2549;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2549 failed";
  let expected_b4 = 102 in
  mark_test_run 2550;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2550 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2551;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2551 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2552;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2552 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2553;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2553 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2554;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2554 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2555;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2555 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2556;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2556 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2557;
  let test = eq r r_expected in
  if not test then failwithf "test 2557 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2558;
  let test = eq r r_expected in
  if not test then failwithf "test 2558 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2559;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2559 failed";
  let expected_a4 = 101 in
  mark_test_run 2560;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2560 failed";
  let expected_b4 = 102 in
  mark_test_run 2561;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2561 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2562;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2562 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2563;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2563 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2564;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2564 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2565;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2565 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2566;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2566 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2567;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2567 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2568;
  let test = eq r r_expected in
  if not test then failwithf "test 2568 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2569;
  let test = eq r r_expected in
  if not test then failwithf "test 2569 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2570;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2570 failed";
  let expected_a4 = 101 in
  mark_test_run 2571;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2571 failed";
  let expected_b4 = 102 in
  mark_test_run 2572;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2572 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2573;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2573 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2574;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2574 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2575;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2575 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2576;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2576 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2577;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2577 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2578;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2578 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2579;
  let test = eq r r_expected in
  if not test then failwithf "test 2579 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2580;
  let test = eq r r_expected in
  if not test then failwithf "test 2580 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2581;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2581 failed";
  let expected_a4 = 101 in
  mark_test_run 2582;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2582 failed";
  let expected_b4 = 102 in
  mark_test_run 2583;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2583 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2584;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2584 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2585;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2585 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2586;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2586 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2587;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2587 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2588;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2588 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2589;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2589 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2590;
  let test = eq r r_expected in
  if not test then failwithf "test 2590 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2591;
  let test = eq r r_expected in
  if not test then failwithf "test 2591 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2592;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2592 failed";
  let expected_a4 = 101 in
  mark_test_run 2593;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2593 failed";
  let expected_b4 = 102 in
  mark_test_run 2594;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2594 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2595;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2595 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2596;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2596 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2597;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2597 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2598;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2598 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2599;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2599 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2600;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2600 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2601;
  let test = eq r r_expected in
  if not test then failwithf "test 2601 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2602;
  let test = eq r r_expected in
  if not test then failwithf "test 2602 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2603;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2603 failed";
  let expected_a4 = 101 in
  mark_test_run 2604;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2604 failed";
  let expected_b4 = 102 in
  mark_test_run 2605;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2605 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2606;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2606 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2607;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2607 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2608;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2608 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2609;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2609 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2610;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2610 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2611;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2611 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2612;
  let test = eq r r_expected in
  if not test then failwithf "test 2612 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2613;
  let test = eq r r_expected in
  if not test then failwithf "test 2613 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2614;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2614 failed";
  let expected_a4 = 101 in
  mark_test_run 2615;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2615 failed";
  let expected_b4 = 102 in
  mark_test_run 2616;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2616 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2617;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2617 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2618;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2618 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2619;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2619 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2620;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2620 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2621;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2621 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2622;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2622 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2623;
  let test = eq r r_expected in
  if not test then failwithf "test 2623 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2624;
  let test = eq r r_expected in
  if not test then failwithf "test 2624 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2625;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2625 failed";
  let expected_a4 = 101 in
  mark_test_run 2626;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2626 failed";
  let expected_b4 = 102 in
  mark_test_run 2627;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2627 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2628;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2628 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2629;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2629 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2630;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2630 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2631;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2631 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2632;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2632 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2633;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2633 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2634;
  let test = eq r r_expected in
  if not test then failwithf "test 2634 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2635;
  let test = eq r r_expected in
  if not test then failwithf "test 2635 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2636;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2636 failed";
  let expected_a4 = 101 in
  mark_test_run 2637;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2637 failed";
  let expected_b4 = 102 in
  mark_test_run 2638;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2638 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2639;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2639 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2640;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2640 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2641;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2641 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2642;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2642 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2643;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2643 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2644;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2644 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2645;
  let test = eq r r_expected in
  if not test then failwithf "test 2645 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2646;
  let test = eq r r_expected in
  if not test then failwithf "test 2646 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2647;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2647 failed";
  let expected_a4 = 101 in
  mark_test_run 2648;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2648 failed";
  let expected_b4 = 102 in
  mark_test_run 2649;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2649 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2650;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2650 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2651;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2651 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2652;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2652 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2653;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2653 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2654;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2654 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2655;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2655 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2656;
  let test = eq r r_expected in
  if not test then failwithf "test 2656 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2657;
  let test = eq r r_expected in
  if not test then failwithf "test 2657 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2658;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2658 failed";
  let expected_a4 = 101 in
  mark_test_run 2659;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2659 failed";
  let expected_b4 = 102 in
  mark_test_run 2660;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2660 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2661;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2661 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2662;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2662 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2663;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2663 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2664;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2664 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2665;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2665 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2666;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2666 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2667;
  let test = eq r r_expected in
  if not test then failwithf "test 2667 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2668;
  let test = eq r r_expected in
  if not test then failwithf "test 2668 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2669;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2669 failed";
  let expected_a4 = 101 in
  mark_test_run 2670;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2670 failed";
  let expected_b4 = 102 in
  mark_test_run 2671;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2671 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2672;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2672 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2673;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2673 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2674;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2674 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2675;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2675 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2676;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2676 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2677;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2677 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2678;
  let test = eq r r_expected in
  if not test then failwithf "test 2678 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2679;
  let test = eq r r_expected in
  if not test then failwithf "test 2679 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2680;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2680 failed";
  let expected_a4 = 101 in
  mark_test_run 2681;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2681 failed";
  let expected_b4 = 102 in
  mark_test_run 2682;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2682 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2683;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2683 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2684;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2684 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2685;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2685 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2686;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2686 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2687;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2687 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2688;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2688 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2689;
  let test = eq r r_expected in
  if not test then failwithf "test 2689 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2690;
  let test = eq r r_expected in
  if not test then failwithf "test 2690 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2691;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2691 failed";
  let expected_a4 = 101 in
  mark_test_run 2692;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2692 failed";
  let expected_b4 = 102 in
  mark_test_run 2693;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2693 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2694;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2694 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2695;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2695 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2696;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2696 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2697;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2697 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2698;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2698 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2699;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2699 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2700;
  let test = eq r r_expected in
  if not test then failwithf "test 2700 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2701;
  let test = eq r r_expected in
  if not test then failwithf "test 2701 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2702;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2702 failed";
  let expected_a4 = 101 in
  mark_test_run 2703;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2703 failed";
  let expected_b4 = 102 in
  mark_test_run 2704;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2704 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2705;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2705 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2706;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2706 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2707;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2707 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2708;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2708 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2709;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2709 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2710;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2710 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2711;
  let test = eq r r_expected in
  if not test then failwithf "test 2711 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2712;
  let test = eq r r_expected in
  if not test then failwithf "test 2712 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2713;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2713 failed";
  let expected_a4 = 101 in
  mark_test_run 2714;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2714 failed";
  let expected_b4 = 102 in
  mark_test_run 2715;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2715 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2716;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2716 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2717;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2717 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2718;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2718 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2719;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2719 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2720;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2720 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2721;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2721 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2722;
  let test = eq r r_expected in
  if not test then failwithf "test 2722 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2723;
  let test = eq r r_expected in
  if not test then failwithf "test 2723 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2724;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2724 failed";
  let expected_a4 = 101 in
  mark_test_run 2725;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2725 failed";
  let expected_b4 = 102 in
  mark_test_run 2726;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2726 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2727;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2727 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2728;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2728 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2729;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2729 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2730;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2730 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2731;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2731 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2732;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2732 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2733;
  let test = eq r r_expected in
  if not test then failwithf "test 2733 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2734;
  let test = eq r r_expected in
  if not test then failwithf "test 2734 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2735;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2735 failed";
  let expected_a4 = 101 in
  mark_test_run 2736;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2736 failed";
  let expected_b4 = 102 in
  mark_test_run 2737;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2737 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2738;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2738 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2739;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2739 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2740;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2740 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2741;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2741 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2742;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2742 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2743;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2743 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2744;
  let test = eq r r_expected in
  if not test then failwithf "test 2744 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2745;
  let test = eq r r_expected in
  if not test then failwithf "test 2745 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2746;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2746 failed";
  let expected_a4 = 101 in
  mark_test_run 2747;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2747 failed";
  let expected_b4 = 102 in
  mark_test_run 2748;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2748 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2749;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2749 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2750;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2750 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2751;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2751 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2752;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2752 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2753;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2753 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2754;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2754 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2755;
  let test = eq r r_expected in
  if not test then failwithf "test 2755 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2756;
  let test = eq r r_expected in
  if not test then failwithf "test 2756 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2757;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2757 failed";
  let expected_a4 = 101 in
  mark_test_run 2758;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2758 failed";
  let expected_b4 = 102 in
  mark_test_run 2759;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2759 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2760;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2760 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2761;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2761 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2762;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2762 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2763;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2763 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2764;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2764 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2765;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2765 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2766;
  let test = eq r r_expected in
  if not test then failwithf "test 2766 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2767;
  let test = eq r r_expected in
  if not test then failwithf "test 2767 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2768;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2768 failed";
  let expected_a4 = 101 in
  mark_test_run 2769;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2769 failed";
  let expected_b4 = 102 in
  mark_test_run 2770;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2770 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2771;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2771 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2772;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2772 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2773;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2773 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2774;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2774 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2775;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2775 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2776;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2776 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2777;
  let test = eq r r_expected in
  if not test then failwithf "test 2777 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2778;
  let test = eq r r_expected in
  if not test then failwithf "test 2778 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2779;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2779 failed";
  let expected_a4 = 101 in
  mark_test_run 2780;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2780 failed";
  let expected_b4 = 102 in
  mark_test_run 2781;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2781 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2782;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2782 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2783;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2783 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2784;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2784 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2785;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2785 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2786;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2786 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2787;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2787 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2788;
  let test = eq r r_expected in
  if not test then failwithf "test 2788 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2789;
  let test = eq r r_expected in
  if not test then failwithf "test 2789 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2790;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2790 failed";
  let expected_a4 = 101 in
  mark_test_run 2791;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2791 failed";
  let expected_b4 = 102 in
  mark_test_run 2792;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2792 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2793;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2793 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2794;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2794 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2795;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2795 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2796;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2796 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2797;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2797 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2798;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2798 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2799;
  let test = eq r r_expected in
  if not test then failwithf "test 2799 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2800;
  let test = eq r r_expected in
  if not test then failwithf "test 2800 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2801;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2801 failed";
  let expected_a4 = 101 in
  mark_test_run 2802;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2802 failed";
  let expected_b4 = 102 in
  mark_test_run 2803;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2803 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2804;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2804 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2805;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2805 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2806;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2806 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2807;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2807 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2808;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2808 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2809;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2809 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2810;
  let test = eq r r_expected in
  if not test then failwithf "test 2810 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2811;
  let test = eq r r_expected in
  if not test then failwithf "test 2811 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2812;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2812 failed";
  let expected_a4 = 101 in
  mark_test_run 2813;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2813 failed";
  let expected_b4 = 102 in
  mark_test_run 2814;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2814 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2815;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2815 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2816;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2816 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2817;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2817 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2818;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2818 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2819;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2819 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2820;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2820 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2821;
  let test = eq r r_expected in
  if not test then failwithf "test 2821 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2822;
  let test = eq r r_expected in
  if not test then failwithf "test 2822 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2823;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2823 failed";
  let expected_a4 = 101 in
  mark_test_run 2824;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2824 failed";
  let expected_b4 = 102 in
  mark_test_run 2825;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2825 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2826;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2826 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2827;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2827 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2828;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2828 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2829;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2829 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2830;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2830 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2831;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2831 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2832;
  let test = eq r r_expected in
  if not test then failwithf "test 2832 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2833;
  let test = eq r r_expected in
  if not test then failwithf "test 2833 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2834;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2834 failed";
  let expected_a4 = 101 in
  mark_test_run 2835;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2835 failed";
  let expected_b4 = 102 in
  mark_test_run 2836;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2836 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2837;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2837 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2838;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2838 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2839;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2839 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2840;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2840 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2841;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2841 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2842;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2842 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2843;
  let test = eq r r_expected in
  if not test then failwithf "test 2843 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2844;
  let test = eq r r_expected in
  if not test then failwithf "test 2844 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2845;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2845 failed";
  let expected_a4 = 101 in
  mark_test_run 2846;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2846 failed";
  let expected_b4 = 102 in
  mark_test_run 2847;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2847 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2848;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2848 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2849;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2849 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2850;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2850 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2851;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2851 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2852;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2852 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2853;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2853 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2854;
  let test = eq r r_expected in
  if not test then failwithf "test 2854 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2855;
  let test = eq r r_expected in
  if not test then failwithf "test 2855 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2856;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2856 failed";
  let expected_a4 = 101 in
  mark_test_run 2857;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2857 failed";
  let expected_b4 = 102 in
  mark_test_run 2858;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2858 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2859;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2859 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2860;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2860 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2861;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2861 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2862;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2862 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2863;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2863 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2864;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2864 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2865;
  let test = eq r r_expected in
  if not test then failwithf "test 2865 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2866;
  let test = eq r r_expected in
  if not test then failwithf "test 2866 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2867;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2867 failed";
  let expected_a4 = 101 in
  mark_test_run 2868;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2868 failed";
  let expected_b4 = 102 in
  mark_test_run 2869;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2869 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2870;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2870 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2871;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2871 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2872;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2872 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2873;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2873 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2874;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2874 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2875;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2875 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2876;
  let test = eq r r_expected in
  if not test then failwithf "test 2876 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2877;
  let test = eq r r_expected in
  if not test then failwithf "test 2877 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2878;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2878 failed";
  let expected_a4 = 101 in
  mark_test_run 2879;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2879 failed";
  let expected_b4 = 102 in
  mark_test_run 2880;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2880 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2881;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2881 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2882;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2882 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2883;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2883 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2884;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2884 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2885;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2885 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2886;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2886 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2887;
  let test = eq r r_expected in
  if not test then failwithf "test 2887 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2888;
  let test = eq r r_expected in
  if not test then failwithf "test 2888 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2889;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2889 failed";
  let expected_a4 = 101 in
  mark_test_run 2890;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2890 failed";
  let expected_b4 = 102 in
  mark_test_run 2891;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2891 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2892;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2892 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2893;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2893 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2894;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2894 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2895;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2895 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2896;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2896 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2897;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2897 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2898;
  let test = eq r r_expected in
  if not test then failwithf "test 2898 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2899;
  let test = eq r r_expected in
  if not test then failwithf "test 2899 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2900;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2900 failed";
  let expected_a4 = 101 in
  mark_test_run 2901;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2901 failed";
  let expected_b4 = 102 in
  mark_test_run 2902;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2902 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2903;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2903 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2904;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2904 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2905;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2905 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2906;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2906 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2907;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2907 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2908;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2908 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2909;
  let test = eq r r_expected in
  if not test then failwithf "test 2909 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2910;
  let test = eq r r_expected in
  if not test then failwithf "test 2910 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2911;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2911 failed";
  let expected_a4 = 101 in
  mark_test_run 2912;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2912 failed";
  let expected_b4 = 102 in
  mark_test_run 2913;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2913 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2914;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2914 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2915;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2915 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2916;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2916 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2917;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2917 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2918;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2918 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2919;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2919 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2920;
  let test = eq r r_expected in
  if not test then failwithf "test 2920 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2921;
  let test = eq r r_expected in
  if not test then failwithf "test 2921 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2922;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2922 failed";
  let expected_a4 = 101 in
  mark_test_run 2923;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2923 failed";
  let expected_b4 = 102 in
  mark_test_run 2924;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2924 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2925;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2925 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2926;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2926 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2927;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2927 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2928;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2928 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2929;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2929 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2930;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2930 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2931;
  let test = eq r r_expected in
  if not test then failwithf "test 2931 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2932;
  let test = eq r r_expected in
  if not test then failwithf "test 2932 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2933;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2933 failed";
  let expected_a4 = 101 in
  mark_test_run 2934;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2934 failed";
  let expected_b4 = 102 in
  mark_test_run 2935;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2935 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2936;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2936 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2937;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2937 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2938;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2938 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2939;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2939 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2940;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2940 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2941;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2941 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2942;
  let test = eq r r_expected in
  if not test then failwithf "test 2942 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2943;
  let test = eq r r_expected in
  if not test then failwithf "test 2943 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2944;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2944 failed";
  let expected_a4 = 101 in
  mark_test_run 2945;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2945 failed";
  let expected_b4 = 102 in
  mark_test_run 2946;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2946 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2947;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2947 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2948;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2948 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2949;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2949 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2950;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2950 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2951;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2951 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2952;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2952 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2953;
  let test = eq r r_expected in
  if not test then failwithf "test 2953 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2954;
  let test = eq r r_expected in
  if not test then failwithf "test 2954 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2955;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2955 failed";
  let expected_a4 = 101 in
  mark_test_run 2956;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2956 failed";
  let expected_b4 = 102 in
  mark_test_run 2957;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2957 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2958;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2958 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2959;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2959 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2960;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2960 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2961;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2961 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2962;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2962 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2963;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2963 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2964;
  let test = eq r r_expected in
  if not test then failwithf "test 2964 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2965;
  let test = eq r r_expected in
  if not test then failwithf "test 2965 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2966;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2966 failed";
  let expected_a4 = 101 in
  mark_test_run 2967;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2967 failed";
  let expected_b4 = 102 in
  mark_test_run 2968;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2968 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2969;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2969 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2970;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2970 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2971;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2971 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2972;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2972 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2973;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2973 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2974;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2974 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2975;
  let test = eq r r_expected in
  if not test then failwithf "test 2975 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2976;
  let test = eq r r_expected in
  if not test then failwithf "test 2976 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2977;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2977 failed";
  let expected_a4 = 101 in
  mark_test_run 2978;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2978 failed";
  let expected_b4 = 102 in
  mark_test_run 2979;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2979 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2980;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2980 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2981;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2981 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2982;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2982 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2983;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2983 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2984;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2984 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2985;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2985 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2986;
  let test = eq r r_expected in
  if not test then failwithf "test 2986 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2987;
  let test = eq r r_expected in
  if not test then failwithf "test 2987 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2988;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2988 failed";
  let expected_a4 = 101 in
  mark_test_run 2989;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 2989 failed";
  let expected_b4 = 102 in
  mark_test_run 2990;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 2990 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 2991;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2991 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 2992;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 2992 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 2993;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2993 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 2994;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 2994 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 2995;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2995 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 2996;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2996 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 2997;
  let test = eq r r_expected in
  if not test then failwithf "test 2997 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 2998;
  let test = eq r r_expected in
  if not test then failwithf "test 2998 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 2999;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 2999 failed";
  let expected_a4 = 101 in
  mark_test_run 3000;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3000 failed";
  let expected_b4 = 102 in
  mark_test_run 3001;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3001 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3002;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3002 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3003;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3003 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3004;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3004 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3005;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3005 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3006;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3006 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3007;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3007 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3008;
  let test = eq r r_expected in
  if not test then failwithf "test 3008 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3009;
  let test = eq r r_expected in
  if not test then failwithf "test 3009 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3010;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3010 failed";
  let expected_a4 = 101 in
  mark_test_run 3011;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3011 failed";
  let expected_b4 = 102 in
  mark_test_run 3012;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3012 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3013;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3013 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3014;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3014 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3015;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3015 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3016;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3016 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3017;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3017 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3018;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3018 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3019;
  let test = eq r r_expected in
  if not test then failwithf "test 3019 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3020;
  let test = eq r r_expected in
  if not test then failwithf "test 3020 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3021;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3021 failed";
  let expected_a4 = 101 in
  mark_test_run 3022;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3022 failed";
  let expected_b4 = 102 in
  mark_test_run 3023;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3023 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3024;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3024 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3025;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3025 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3026;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3026 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3027;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3027 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3028;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3028 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3029;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3029 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3030;
  let test = eq r r_expected in
  if not test then failwithf "test 3030 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3031;
  let test = eq r r_expected in
  if not test then failwithf "test 3031 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3032;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3032 failed";
  let expected_a4 = 101 in
  mark_test_run 3033;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3033 failed";
  let expected_b4 = 102 in
  mark_test_run 3034;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3034 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3035;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3035 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3036;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3036 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3037;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3037 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3038;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3038 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3039;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3039 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3040;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3040 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3041;
  let test = eq r r_expected in
  if not test then failwithf "test 3041 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3042;
  let test = eq r r_expected in
  if not test then failwithf "test 3042 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3043;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3043 failed";
  let expected_a4 = 101 in
  mark_test_run 3044;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3044 failed";
  let expected_b4 = 102 in
  mark_test_run 3045;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3045 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3046;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3046 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3047;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3047 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3048;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3048 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3049;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3049 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3050;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3050 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3051;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3051 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3052;
  let test = eq r r_expected in
  if not test then failwithf "test 3052 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3053;
  let test = eq r r_expected in
  if not test then failwithf "test 3053 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3054;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3054 failed";
  let expected_a4 = 101 in
  mark_test_run 3055;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3055 failed";
  let expected_b4 = 102 in
  mark_test_run 3056;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3056 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3057;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3057 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3058;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3058 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3059;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3059 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3060;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3060 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3061;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3061 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3062;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3062 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3063;
  let test = eq r r_expected in
  if not test then failwithf "test 3063 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3064;
  let test = eq r r_expected in
  if not test then failwithf "test 3064 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3065;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3065 failed";
  let expected_a4 = 101 in
  mark_test_run 3066;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3066 failed";
  let expected_b4 = 102 in
  mark_test_run 3067;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3067 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3068;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3068 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3069;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3069 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3070;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3070 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3071;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3071 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3072;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3072 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3073;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3073 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3074;
  let test = eq r r_expected in
  if not test then failwithf "test 3074 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3075;
  let test = eq r r_expected in
  if not test then failwithf "test 3075 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3076;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3076 failed";
  let expected_a4 = 101 in
  mark_test_run 3077;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3077 failed";
  let expected_b4 = 102 in
  mark_test_run 3078;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3078 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3079;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3079 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3080;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3080 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3081;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3081 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3082;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3082 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3083;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3083 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3084;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3084 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3085;
  let test = eq r r_expected in
  if not test then failwithf "test 3085 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3086;
  let test = eq r r_expected in
  if not test then failwithf "test 3086 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3087;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3087 failed";
  let expected_a4 = 101 in
  mark_test_run 3088;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3088 failed";
  let expected_b4 = 102 in
  mark_test_run 3089;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3089 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3090;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3090 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3091;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3091 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3092;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3092 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3093;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3093 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3094;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3094 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3095;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3095 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3096;
  let test = eq r r_expected in
  if not test then failwithf "test 3096 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3097;
  let test = eq r r_expected in
  if not test then failwithf "test 3097 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3098;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3098 failed";
  let expected_a4 = 101 in
  mark_test_run 3099;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3099 failed";
  let expected_b4 = 102 in
  mark_test_run 3100;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3100 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3101;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3101 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3102;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3102 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3103;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3103 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3104;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3104 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3105;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3105 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3106;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3106 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3107;
  let test = eq r r_expected in
  if not test then failwithf "test 3107 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3108;
  let test = eq r r_expected in
  if not test then failwithf "test 3108 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3109;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3109 failed";
  let expected_a4 = 101 in
  mark_test_run 3110;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3110 failed";
  let expected_b4 = 102 in
  mark_test_run 3111;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3111 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3112;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3112 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3113;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3113 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3114;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3114 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3115;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3115 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3116;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3116 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3117;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3117 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3118;
  let test = eq r r_expected in
  if not test then failwithf "test 3118 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3119;
  let test = eq r r_expected in
  if not test then failwithf "test 3119 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3120;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3120 failed";
  let expected_a4 = 101 in
  mark_test_run 3121;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3121 failed";
  let expected_b4 = 102 in
  mark_test_run 3122;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3122 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3123;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3123 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3124;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3124 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3125;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3125 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3126;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3126 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3127;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3127 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3128;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3128 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3129;
  let test = eq r r_expected in
  if not test then failwithf "test 3129 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3130;
  let test = eq r r_expected in
  if not test then failwithf "test 3130 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3131;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3131 failed";
  let expected_a4 = 101 in
  mark_test_run 3132;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3132 failed";
  let expected_b4 = 102 in
  mark_test_run 3133;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3133 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3134;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3134 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3135;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3135 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3136;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3136 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3137;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3137 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3138;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3138 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3139;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3139 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3140;
  let test = eq r r_expected in
  if not test then failwithf "test 3140 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3141;
  let test = eq r r_expected in
  if not test then failwithf "test 3141 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3142;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3142 failed";
  let expected_a4 = 101 in
  mark_test_run 3143;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3143 failed";
  let expected_b4 = 102 in
  mark_test_run 3144;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3144 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3145;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3145 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3146;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3146 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3147;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3147 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3148;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3148 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3149;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3149 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3150;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3150 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3151;
  let test = eq r r_expected in
  if not test then failwithf "test 3151 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3152;
  let test = eq r r_expected in
  if not test then failwithf "test 3152 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3153;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3153 failed";
  let expected_a4 = 101 in
  mark_test_run 3154;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3154 failed";
  let expected_b4 = 102 in
  mark_test_run 3155;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3155 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3156;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3156 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3157;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3157 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3158;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3158 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3159;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3159 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3160;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3160 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3161;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3161 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3162;
  let test = eq r r_expected in
  if not test then failwithf "test 3162 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3163;
  let test = eq r r_expected in
  if not test then failwithf "test 3163 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3164;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3164 failed";
  let expected_a4 = 101 in
  mark_test_run 3165;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3165 failed";
  let expected_b4 = 102 in
  mark_test_run 3166;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3166 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3167;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3167 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3168;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3168 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3169;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3169 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3170;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3170 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3171;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3171 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3172;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3172 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3173;
  let test = eq r r_expected in
  if not test then failwithf "test 3173 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3174;
  let test = eq r r_expected in
  if not test then failwithf "test 3174 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3175;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3175 failed";
  let expected_a4 = 101 in
  mark_test_run 3176;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3176 failed";
  let expected_b4 = 102 in
  mark_test_run 3177;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3177 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3178;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3178 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3179;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3179 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3180;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3180 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3181;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3181 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3182;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3182 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3183;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3183 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3184;
  let test = eq r r_expected in
  if not test then failwithf "test 3184 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3185;
  let test = eq r r_expected in
  if not test then failwithf "test 3185 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3186;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3186 failed";
  let expected_a4 = 101 in
  mark_test_run 3187;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3187 failed";
  let expected_b4 = 102 in
  mark_test_run 3188;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3188 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3189;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3189 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3190;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3190 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3191;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3191 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3192;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3192 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3193;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3193 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3194;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3194 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3195;
  let test = eq r r_expected in
  if not test then failwithf "test 3195 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3196;
  let test = eq r r_expected in
  if not test then failwithf "test 3196 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3197;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3197 failed";
  let expected_a4 = 101 in
  mark_test_run 3198;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3198 failed";
  let expected_b4 = 102 in
  mark_test_run 3199;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3199 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3200;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3200 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3201;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3201 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3202;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3202 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3203;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3203 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3204;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3204 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3205;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3205 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3206;
  let test = eq r r_expected in
  if not test then failwithf "test 3206 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3207;
  let test = eq r r_expected in
  if not test then failwithf "test 3207 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3208;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3208 failed";
  let expected_a4 = 101 in
  mark_test_run 3209;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3209 failed";
  let expected_b4 = 102 in
  mark_test_run 3210;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3210 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3211;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3211 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3212;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3212 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3213;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3213 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3214;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3214 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3215;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3215 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3216;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3216 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3217;
  let test = eq r r_expected in
  if not test then failwithf "test 3217 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3218;
  let test = eq r r_expected in
  if not test then failwithf "test 3218 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3219;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3219 failed";
  let expected_a4 = 101 in
  mark_test_run 3220;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3220 failed";
  let expected_b4 = 102 in
  mark_test_run 3221;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3221 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3222;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3222 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3223;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3223 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3224;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3224 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3225;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3225 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3226;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3226 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3227;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3227 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3228;
  let test = eq r r_expected in
  if not test then failwithf "test 3228 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3229;
  let test = eq r r_expected in
  if not test then failwithf "test 3229 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3230;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3230 failed";
  let expected_a4 = 101 in
  mark_test_run 3231;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3231 failed";
  let expected_b4 = 102 in
  mark_test_run 3232;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3232 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3233;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3233 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3234;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3234 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3235;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3235 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3236;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3236 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3237;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3237 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3238;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3238 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3239;
  let test = eq r r_expected in
  if not test then failwithf "test 3239 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3240;
  let test = eq r r_expected in
  if not test then failwithf "test 3240 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3241;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3241 failed";
  let expected_a4 = 101 in
  mark_test_run 3242;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3242 failed";
  let expected_b4 = 102 in
  mark_test_run 3243;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3243 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3244;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3244 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3245;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3245 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3246;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3246 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3247;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3247 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3248;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3248 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3249;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3249 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3250;
  let test = eq r r_expected in
  if not test then failwithf "test 3250 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3251;
  let test = eq r r_expected in
  if not test then failwithf "test 3251 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3252;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3252 failed";
  let expected_a4 = 101 in
  mark_test_run 3253;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3253 failed";
  let expected_b4 = 102 in
  mark_test_run 3254;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3254 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3255;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3255 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3256;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3256 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3257;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3257 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3258;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3258 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3259;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3259 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3260;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3260 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3261;
  let test = eq r r_expected in
  if not test then failwithf "test 3261 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3262;
  let test = eq r r_expected in
  if not test then failwithf "test 3262 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3263;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3263 failed";
  let expected_a4 = 101 in
  mark_test_run 3264;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3264 failed";
  let expected_b4 = 102 in
  mark_test_run 3265;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3265 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3266;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3266 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3267;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3267 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3268;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3268 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3269;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3269 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3270;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3270 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3271;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3271 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3272;
  let test = eq r r_expected in
  if not test then failwithf "test 3272 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3273;
  let test = eq r r_expected in
  if not test then failwithf "test 3273 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3274;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3274 failed";
  let expected_a4 = 101 in
  mark_test_run 3275;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3275 failed";
  let expected_b4 = 102 in
  mark_test_run 3276;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3276 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3277;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3277 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3278;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3278 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3279;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3279 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3280;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3280 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3281;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3281 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3282;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3282 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3283;
  let test = eq r r_expected in
  if not test then failwithf "test 3283 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3284;
  let test = eq r r_expected in
  if not test then failwithf "test 3284 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3285;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3285 failed";
  let expected_a4 = 101 in
  mark_test_run 3286;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3286 failed";
  let expected_b4 = 102 in
  mark_test_run 3287;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3287 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3288;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3288 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3289;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3289 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3290;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3290 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3291;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3291 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3292;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3292 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3293;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3293 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3294;
  let test = eq r r_expected in
  if not test then failwithf "test 3294 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3295;
  let test = eq r r_expected in
  if not test then failwithf "test 3295 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3296;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3296 failed";
  let expected_a4 = 101 in
  mark_test_run 3297;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3297 failed";
  let expected_b4 = 102 in
  mark_test_run 3298;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3298 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3299;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3299 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3300;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3300 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3301;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3301 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3302;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3302 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3303;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3303 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3304;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3304 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3305;
  let test = eq r r_expected in
  if not test then failwithf "test 3305 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3306;
  let test = eq r r_expected in
  if not test then failwithf "test 3306 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3307;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3307 failed";
  let expected_a4 = 101 in
  mark_test_run 3308;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3308 failed";
  let expected_b4 = 102 in
  mark_test_run 3309;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3309 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3310;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3310 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3311;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3311 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3312;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3312 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3313;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3313 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3314;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3314 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3315;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3315 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3316;
  let test = eq r r_expected in
  if not test then failwithf "test 3316 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3317;
  let test = eq r r_expected in
  if not test then failwithf "test 3317 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3318;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3318 failed";
  let expected_a4 = 101 in
  mark_test_run 3319;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3319 failed";
  let expected_b4 = 102 in
  mark_test_run 3320;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3320 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3321;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3321 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3322;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3322 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3323;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3323 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3324;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3324 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3325;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3325 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3326;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3326 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3327;
  let test = eq r r_expected in
  if not test then failwithf "test 3327 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3328;
  let test = eq r r_expected in
  if not test then failwithf "test 3328 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3329;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3329 failed";
  let expected_a4 = 101 in
  mark_test_run 3330;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3330 failed";
  let expected_b4 = 102 in
  mark_test_run 3331;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3331 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3332;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3332 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3333;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3333 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3334;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3334 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3335;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3335 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3336;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3336 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3337;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3337 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3338;
  let test = eq r r_expected in
  if not test then failwithf "test 3338 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3339;
  let test = eq r r_expected in
  if not test then failwithf "test 3339 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3340;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3340 failed";
  let expected_a4 = 101 in
  mark_test_run 3341;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3341 failed";
  let expected_b4 = 102 in
  mark_test_run 3342;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3342 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3343;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3343 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3344;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3344 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3345;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3345 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3346;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3346 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3347;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3347 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3348;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3348 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3349;
  let test = eq r r_expected in
  if not test then failwithf "test 3349 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3350;
  let test = eq r r_expected in
  if not test then failwithf "test 3350 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3351;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3351 failed";
  let expected_a4 = 101 in
  mark_test_run 3352;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3352 failed";
  let expected_b4 = 102 in
  mark_test_run 3353;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3353 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3354;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3354 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3355;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3355 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3356;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3356 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3357;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3357 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3358;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3358 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3359;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3359 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3360;
  let test = eq r r_expected in
  if not test then failwithf "test 3360 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3361;
  let test = eq r r_expected in
  if not test then failwithf "test 3361 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3362;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3362 failed";
  let expected_a4 = 101 in
  mark_test_run 3363;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3363 failed";
  let expected_b4 = 102 in
  mark_test_run 3364;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3364 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3365;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3365 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3366;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3366 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3367;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3367 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3368;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3368 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3369;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3369 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3370;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3370 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3371;
  let test = eq r r_expected in
  if not test then failwithf "test 3371 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3372;
  let test = eq r r_expected in
  if not test then failwithf "test 3372 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3373;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3373 failed";
  let expected_a4 = 101 in
  mark_test_run 3374;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3374 failed";
  let expected_b4 = 102 in
  mark_test_run 3375;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3375 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3376;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3376 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3377;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3377 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3378;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3378 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3379;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3379 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3380;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3380 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3381;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3381 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3382;
  let test = eq r r_expected in
  if not test then failwithf "test 3382 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3383;
  let test = eq r r_expected in
  if not test then failwithf "test 3383 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3384;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3384 failed";
  let expected_a4 = 101 in
  mark_test_run 3385;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3385 failed";
  let expected_b4 = 102 in
  mark_test_run 3386;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3386 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3387;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3387 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3388;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3388 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3389;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3389 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3390;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3390 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3391;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3391 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3392;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3392 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3393;
  let test = eq r r_expected in
  if not test then failwithf "test 3393 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3394;
  let test = eq r r_expected in
  if not test then failwithf "test 3394 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3395;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3395 failed";
  let expected_a4 = 101 in
  mark_test_run 3396;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3396 failed";
  let expected_b4 = 102 in
  mark_test_run 3397;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3397 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3398;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3398 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3399;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3399 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3400;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3400 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3401;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3401 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3402;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3402 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3403;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3403 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3404;
  let test = eq r r_expected in
  if not test then failwithf "test 3404 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3405;
  let test = eq r r_expected in
  if not test then failwithf "test 3405 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3406;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3406 failed";
  let expected_a4 = 101 in
  mark_test_run 3407;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3407 failed";
  let expected_b4 = 102 in
  mark_test_run 3408;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3408 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3409;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3409 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3410;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3410 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3411;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3411 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3412;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3412 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3413;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3413 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3414;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3414 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3415;
  let test = eq r r_expected in
  if not test then failwithf "test 3415 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3416;
  let test = eq r r_expected in
  if not test then failwithf "test 3416 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3417;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3417 failed";
  let expected_a4 = 101 in
  mark_test_run 3418;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3418 failed";
  let expected_b4 = 102 in
  mark_test_run 3419;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3419 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3420;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3420 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3421;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3421 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3422;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3422 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3423;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3423 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3424;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3424 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3425;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3425 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3426;
  let test = eq r r_expected in
  if not test then failwithf "test 3426 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3427;
  let test = eq r r_expected in
  if not test then failwithf "test 3427 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3428;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3428 failed";
  let expected_a4 = 101 in
  mark_test_run 3429;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3429 failed";
  let expected_b4 = 102 in
  mark_test_run 3430;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3430 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3431;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3431 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3432;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3432 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3433;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3433 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3434;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3434 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3435;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3435 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3436;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3436 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3437;
  let test = eq r r_expected in
  if not test then failwithf "test 3437 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3438;
  let test = eq r r_expected in
  if not test then failwithf "test 3438 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3439;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3439 failed";
  let expected_a4 = 101 in
  mark_test_run 3440;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3440 failed";
  let expected_b4 = 102 in
  mark_test_run 3441;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3441 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3442;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3442 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3443;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3443 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3444;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3444 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3445;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3445 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3446;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3446 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3447;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3447 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3448;
  let test = eq r r_expected in
  if not test then failwithf "test 3448 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3449;
  let test = eq r r_expected in
  if not test then failwithf "test 3449 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3450;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3450 failed";
  let expected_a4 = 101 in
  mark_test_run 3451;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3451 failed";
  let expected_b4 = 102 in
  mark_test_run 3452;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3452 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3453;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3453 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3454;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3454 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3455;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3455 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3456;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3456 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3457;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3457 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3458;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3458 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3459;
  let test = eq r r_expected in
  if not test then failwithf "test 3459 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3460;
  let test = eq r r_expected in
  if not test then failwithf "test 3460 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3461;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3461 failed";
  let expected_a4 = 101 in
  mark_test_run 3462;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3462 failed";
  let expected_b4 = 102 in
  mark_test_run 3463;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3463 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3464;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3464 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3465;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3465 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3466;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3466 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3467;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3467 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3468;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3468 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3469;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3469 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3470;
  let test = eq r r_expected in
  if not test then failwithf "test 3470 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3471;
  let test = eq r r_expected in
  if not test then failwithf "test 3471 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3472;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3472 failed";
  let expected_a4 = 101 in
  mark_test_run 3473;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3473 failed";
  let expected_b4 = 102 in
  mark_test_run 3474;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3474 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3475;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3475 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3476;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3476 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3477;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3477 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3478;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3478 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3479;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3479 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3480;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3480 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3481;
  let test = eq r r_expected in
  if not test then failwithf "test 3481 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3482;
  let test = eq r r_expected in
  if not test then failwithf "test 3482 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3483;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3483 failed";
  let expected_a4 = 101 in
  mark_test_run 3484;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3484 failed";
  let expected_b4 = 102 in
  mark_test_run 3485;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3485 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3486;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3486 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3487;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3487 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3488;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3488 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3489;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3489 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3490;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3490 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3491;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3491 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3492;
  let test = eq r r_expected in
  if not test then failwithf "test 3492 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3493;
  let test = eq r r_expected in
  if not test then failwithf "test 3493 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3494;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3494 failed";
  let expected_a4 = 101 in
  mark_test_run 3495;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3495 failed";
  let expected_b4 = 102 in
  mark_test_run 3496;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3496 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3497;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3497 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3498;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3498 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3499;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3499 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3500;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3500 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3501;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3501 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3502;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3502 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3503;
  let test = eq r r_expected in
  if not test then failwithf "test 3503 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3504;
  let test = eq r r_expected in
  if not test then failwithf "test 3504 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3505;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3505 failed";
  let expected_a4 = 101 in
  mark_test_run 3506;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3506 failed";
  let expected_b4 = 102 in
  mark_test_run 3507;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3507 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3508;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3508 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3509;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3509 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t8 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 3510;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3510 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a4 = 1; b4 = 2 } in
  mark_test_run 3511;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3511 failed";
  (* Paths of depth 2 *)
  (* .b8.#a4 *)
  let actual = r.b8.#a4 in
  let expected = 1 in
  mark_test_run 3512;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3512 failed";
  (* .b8.#b4 *)
  let actual = r.b8.#b4 in
  let expected = 2 in
  mark_test_run 3513;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3513 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a4 = 101; b4 = 102 } } in
  let r_expected = { a8 = 0; b8 = #{ a4 = 1; b4 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 3514;
  let test = eq r r_expected in
  if not test then failwithf "test 3514 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 3515;
  let test = eq r r_expected in
  if not test then failwithf "test 3515 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a4; b4 } } = r in
  let expected_a8 = 100 in
  mark_test_run 3516;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3516 failed";
  let expected_a4 = 101 in
  mark_test_run 3517;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3517 failed";
  let expected_b4 = 102 in
  mark_test_run 3518;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3518 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 3519;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 3519 failed";
  let expected_b8 = #{ a4 = 101; b4 = 102 } in
  mark_test_run 3520;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_b8 b8 in
  if not test then failwithf "test 3520 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3521;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3521 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3522;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3522 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3523;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3523 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3524;
  let test = eq r r_expected in
  if not test then failwithf "test 3524 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3525;
  let test = eq r r_expected in
  if not test then failwithf "test 3525 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3526;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3526 failed";
  let expected_b9 = 101 in
  mark_test_run 3527;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3527 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3528;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3528 failed";
  let expected_b9 = 101 in
  mark_test_run 3529;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3529 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3530;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3530 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3531;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3531 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3532;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3532 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3533;
  let test = eq r r_expected in
  if not test then failwithf "test 3533 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3534;
  let test = eq r r_expected in
  if not test then failwithf "test 3534 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3535;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3535 failed";
  let expected_b9 = 101 in
  mark_test_run 3536;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3536 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3537;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3537 failed";
  let expected_b9 = 101 in
  mark_test_run 3538;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3538 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3539;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3539 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3540;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3540 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3541;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3541 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3542;
  let test = eq r r_expected in
  if not test then failwithf "test 3542 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3543;
  let test = eq r r_expected in
  if not test then failwithf "test 3543 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3544;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3544 failed";
  let expected_b9 = 101 in
  mark_test_run 3545;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3545 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3546;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3546 failed";
  let expected_b9 = 101 in
  mark_test_run 3547;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3547 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3548;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3548 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3549;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3549 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3550;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3550 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3551;
  let test = eq r r_expected in
  if not test then failwithf "test 3551 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3552;
  let test = eq r r_expected in
  if not test then failwithf "test 3552 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3553;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3553 failed";
  let expected_b9 = 101 in
  mark_test_run 3554;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3554 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3555;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3555 failed";
  let expected_b9 = 101 in
  mark_test_run 3556;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3556 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3557;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3557 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3558;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3558 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3559;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3559 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3560;
  let test = eq r r_expected in
  if not test then failwithf "test 3560 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3561;
  let test = eq r r_expected in
  if not test then failwithf "test 3561 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3562;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3562 failed";
  let expected_b9 = 101 in
  mark_test_run 3563;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3563 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3564;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3564 failed";
  let expected_b9 = 101 in
  mark_test_run 3565;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3565 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3566;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3566 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3567;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3567 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3568;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3568 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3569;
  let test = eq r r_expected in
  if not test then failwithf "test 3569 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3570;
  let test = eq r r_expected in
  if not test then failwithf "test 3570 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3571;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3571 failed";
  let expected_b9 = 101 in
  mark_test_run 3572;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3572 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3573;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3573 failed";
  let expected_b9 = 101 in
  mark_test_run 3574;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3574 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3575;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3575 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3576;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3576 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3577;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3577 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3578;
  let test = eq r r_expected in
  if not test then failwithf "test 3578 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3579;
  let test = eq r r_expected in
  if not test then failwithf "test 3579 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3580;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3580 failed";
  let expected_b9 = 101 in
  mark_test_run 3581;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3581 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3582;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3582 failed";
  let expected_b9 = 101 in
  mark_test_run 3583;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3583 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3584;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3584 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3585;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3585 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3586;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3586 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3587;
  let test = eq r r_expected in
  if not test then failwithf "test 3587 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3588;
  let test = eq r r_expected in
  if not test then failwithf "test 3588 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3589;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3589 failed";
  let expected_b9 = 101 in
  mark_test_run 3590;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3590 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3591;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3591 failed";
  let expected_b9 = 101 in
  mark_test_run 3592;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3592 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3593;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3593 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3594;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3594 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3595;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3595 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3596;
  let test = eq r r_expected in
  if not test then failwithf "test 3596 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3597;
  let test = eq r r_expected in
  if not test then failwithf "test 3597 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3598;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3598 failed";
  let expected_b9 = 101 in
  mark_test_run 3599;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3599 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3600;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3600 failed";
  let expected_b9 = 101 in
  mark_test_run 3601;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3601 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3602;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3602 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3603;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3603 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3604;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3604 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3605;
  let test = eq r r_expected in
  if not test then failwithf "test 3605 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3606;
  let test = eq r r_expected in
  if not test then failwithf "test 3606 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3607;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3607 failed";
  let expected_b9 = 101 in
  mark_test_run 3608;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3608 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3609;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3609 failed";
  let expected_b9 = 101 in
  mark_test_run 3610;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3610 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3611;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3611 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3612;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3612 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3613;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3613 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3614;
  let test = eq r r_expected in
  if not test then failwithf "test 3614 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3615;
  let test = eq r r_expected in
  if not test then failwithf "test 3615 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3616;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3616 failed";
  let expected_b9 = 101 in
  mark_test_run 3617;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3617 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3618;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3618 failed";
  let expected_b9 = 101 in
  mark_test_run 3619;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3619 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3620;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3620 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3621;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3621 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3622;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3622 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3623;
  let test = eq r r_expected in
  if not test then failwithf "test 3623 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3624;
  let test = eq r r_expected in
  if not test then failwithf "test 3624 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3625;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3625 failed";
  let expected_b9 = 101 in
  mark_test_run 3626;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3626 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3627;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3627 failed";
  let expected_b9 = 101 in
  mark_test_run 3628;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3628 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3629;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3629 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3630;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3630 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3631;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3631 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3632;
  let test = eq r r_expected in
  if not test then failwithf "test 3632 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3633;
  let test = eq r r_expected in
  if not test then failwithf "test 3633 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3634;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3634 failed";
  let expected_b9 = 101 in
  mark_test_run 3635;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3635 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3636;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3636 failed";
  let expected_b9 = 101 in
  mark_test_run 3637;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3637 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3638;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3638 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3639;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3639 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3640;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3640 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3641;
  let test = eq r r_expected in
  if not test then failwithf "test 3641 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3642;
  let test = eq r r_expected in
  if not test then failwithf "test 3642 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3643;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3643 failed";
  let expected_b9 = 101 in
  mark_test_run 3644;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3644 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3645;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3645 failed";
  let expected_b9 = 101 in
  mark_test_run 3646;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3646 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3647;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3647 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3648;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3648 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3649;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3649 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3650;
  let test = eq r r_expected in
  if not test then failwithf "test 3650 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3651;
  let test = eq r r_expected in
  if not test then failwithf "test 3651 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3652;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3652 failed";
  let expected_b9 = 101 in
  mark_test_run 3653;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3653 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3654;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3654 failed";
  let expected_b9 = 101 in
  mark_test_run 3655;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3655 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3656;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3656 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3657;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3657 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3658;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3658 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3659;
  let test = eq r r_expected in
  if not test then failwithf "test 3659 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3660;
  let test = eq r r_expected in
  if not test then failwithf "test 3660 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3661;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3661 failed";
  let expected_b9 = 101 in
  mark_test_run 3662;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3662 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3663;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3663 failed";
  let expected_b9 = 101 in
  mark_test_run 3664;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3664 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3665;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3665 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3666;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3666 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3667;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3667 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3668;
  let test = eq r r_expected in
  if not test then failwithf "test 3668 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3669;
  let test = eq r r_expected in
  if not test then failwithf "test 3669 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3670;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3670 failed";
  let expected_b9 = 101 in
  mark_test_run 3671;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3671 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3672;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3672 failed";
  let expected_b9 = 101 in
  mark_test_run 3673;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3673 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3674;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3674 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3675;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3675 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3676;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3676 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3677;
  let test = eq r r_expected in
  if not test then failwithf "test 3677 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3678;
  let test = eq r r_expected in
  if not test then failwithf "test 3678 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3679;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3679 failed";
  let expected_b9 = 101 in
  mark_test_run 3680;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3680 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3681;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3681 failed";
  let expected_b9 = 101 in
  mark_test_run 3682;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3682 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3683;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3683 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3684;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3684 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3685;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3685 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3686;
  let test = eq r r_expected in
  if not test then failwithf "test 3686 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3687;
  let test = eq r r_expected in
  if not test then failwithf "test 3687 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3688;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3688 failed";
  let expected_b9 = 101 in
  mark_test_run 3689;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3689 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3690;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3690 failed";
  let expected_b9 = 101 in
  mark_test_run 3691;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3691 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3692;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3692 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3693;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3693 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3694;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3694 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3695;
  let test = eq r r_expected in
  if not test then failwithf "test 3695 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3696;
  let test = eq r r_expected in
  if not test then failwithf "test 3696 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3697;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3697 failed";
  let expected_b9 = 101 in
  mark_test_run 3698;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3698 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3699;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3699 failed";
  let expected_b9 = 101 in
  mark_test_run 3700;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3700 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3701;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3701 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3702;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3702 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3703;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3703 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3704;
  let test = eq r r_expected in
  if not test then failwithf "test 3704 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3705;
  let test = eq r r_expected in
  if not test then failwithf "test 3705 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3706;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3706 failed";
  let expected_b9 = 101 in
  mark_test_run 3707;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3707 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3708;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3708 failed";
  let expected_b9 = 101 in
  mark_test_run 3709;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3709 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3710;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3710 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3711;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3711 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3712;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3712 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3713;
  let test = eq r r_expected in
  if not test then failwithf "test 3713 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3714;
  let test = eq r r_expected in
  if not test then failwithf "test 3714 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3715;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3715 failed";
  let expected_b9 = 101 in
  mark_test_run 3716;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3716 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3717;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3717 failed";
  let expected_b9 = 101 in
  mark_test_run 3718;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3718 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3719;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3719 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3720;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3720 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3721;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3721 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3722;
  let test = eq r r_expected in
  if not test then failwithf "test 3722 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3723;
  let test = eq r r_expected in
  if not test then failwithf "test 3723 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3724;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3724 failed";
  let expected_b9 = 101 in
  mark_test_run 3725;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3725 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3726;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3726 failed";
  let expected_b9 = 101 in
  mark_test_run 3727;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3727 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3728;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3728 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3729;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3729 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3730;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3730 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3731;
  let test = eq r r_expected in
  if not test then failwithf "test 3731 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3732;
  let test = eq r r_expected in
  if not test then failwithf "test 3732 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3733;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3733 failed";
  let expected_b9 = 101 in
  mark_test_run 3734;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3734 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3735;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3735 failed";
  let expected_b9 = 101 in
  mark_test_run 3736;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3736 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t9 = { #{ int }; int }   *)
  (******************************)
  let r = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = #{ a2 = 0 } in
  mark_test_run 3737;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) actual expected in
  if not test then failwithf "test 3737 failed";
  (* Paths of depth 2 *)
  (* .a9.#a2 *)
  let actual = r.a9.#a2 in
  let expected = 0 in
  mark_test_run 3738;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3738 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = 1 in
  mark_test_run 3739;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3739 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91 } { a9 = a92; b9 = b92 } -> (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) a91 a92 && (fun a b -> Int.equal a b) b91 b92) in
  let next_r = { a9 = #{ a2 = 100 }; b9 = 101 } in
  let r_expected = { a9 = #{ a2 = 0 }; b9 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 3740;
  let test = eq r r_expected in
  if not test then failwithf "test 3740 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 3741;
  let test = eq r r_expected in
  if not test then failwithf "test 3741 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9 = #{ a2 }; b9 } = r in
  let expected_a2 = 100 in
  mark_test_run 3742;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 3742 failed";
  let expected_b9 = 101 in
  mark_test_run 3743;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3743 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9 } = r in
  let expected_a9 = #{ a2 = 100 } in
  mark_test_run 3744;
  let test = (fun #{ a2 = a21 } #{ a2 = a22 } -> (fun a b -> Int.equal a b) a21 a22) expected_a9 a9 in
  if not test then failwithf "test 3744 failed";
  let expected_b9 = 101 in
  mark_test_run 3745;
  let test = (fun a b -> Int.equal a b) expected_b9 b9 in
  if not test then failwithf "test 3745 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3746;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3746 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3747;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3747 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3748;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3748 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3749;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3749 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3750;
  let test = eq r r_expected in
  if not test then failwithf "test 3750 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3751;
  let test = eq r r_expected in
  if not test then failwithf "test 3751 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3752;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3752 failed";
  let expected_b4 = 101 in
  mark_test_run 3753;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3753 failed";
  let expected_b10 = 102 in
  mark_test_run 3754;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3754 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3755;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3755 failed";
  let expected_b10 = 102 in
  mark_test_run 3756;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3756 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3757;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3757 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3758;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3758 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3759;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3759 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3760;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3760 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3761;
  let test = eq r r_expected in
  if not test then failwithf "test 3761 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3762;
  let test = eq r r_expected in
  if not test then failwithf "test 3762 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3763;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3763 failed";
  let expected_b4 = 101 in
  mark_test_run 3764;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3764 failed";
  let expected_b10 = 102 in
  mark_test_run 3765;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3765 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3766;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3766 failed";
  let expected_b10 = 102 in
  mark_test_run 3767;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3767 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3768;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3768 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3769;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3769 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3770;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3770 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3771;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3771 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3772;
  let test = eq r r_expected in
  if not test then failwithf "test 3772 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3773;
  let test = eq r r_expected in
  if not test then failwithf "test 3773 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3774;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3774 failed";
  let expected_b4 = 101 in
  mark_test_run 3775;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3775 failed";
  let expected_b10 = 102 in
  mark_test_run 3776;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3776 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3777;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3777 failed";
  let expected_b10 = 102 in
  mark_test_run 3778;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3778 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3779;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3779 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3780;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3780 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3781;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3781 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3782;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3782 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3783;
  let test = eq r r_expected in
  if not test then failwithf "test 3783 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3784;
  let test = eq r r_expected in
  if not test then failwithf "test 3784 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3785;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3785 failed";
  let expected_b4 = 101 in
  mark_test_run 3786;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3786 failed";
  let expected_b10 = 102 in
  mark_test_run 3787;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3787 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3788;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3788 failed";
  let expected_b10 = 102 in
  mark_test_run 3789;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3789 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3790;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3790 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3791;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3791 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3792;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3792 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3793;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3793 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3794;
  let test = eq r r_expected in
  if not test then failwithf "test 3794 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3795;
  let test = eq r r_expected in
  if not test then failwithf "test 3795 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3796;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3796 failed";
  let expected_b4 = 101 in
  mark_test_run 3797;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3797 failed";
  let expected_b10 = 102 in
  mark_test_run 3798;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3798 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3799;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3799 failed";
  let expected_b10 = 102 in
  mark_test_run 3800;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3800 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3801;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3801 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3802;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3802 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3803;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3803 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3804;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3804 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3805;
  let test = eq r r_expected in
  if not test then failwithf "test 3805 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3806;
  let test = eq r r_expected in
  if not test then failwithf "test 3806 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3807;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3807 failed";
  let expected_b4 = 101 in
  mark_test_run 3808;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3808 failed";
  let expected_b10 = 102 in
  mark_test_run 3809;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3809 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3810;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3810 failed";
  let expected_b10 = 102 in
  mark_test_run 3811;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3811 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3812;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3812 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3813;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3813 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3814;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3814 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3815;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3815 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3816;
  let test = eq r r_expected in
  if not test then failwithf "test 3816 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3817;
  let test = eq r r_expected in
  if not test then failwithf "test 3817 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3818;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3818 failed";
  let expected_b4 = 101 in
  mark_test_run 3819;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3819 failed";
  let expected_b10 = 102 in
  mark_test_run 3820;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3820 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3821;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3821 failed";
  let expected_b10 = 102 in
  mark_test_run 3822;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3822 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3823;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3823 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3824;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3824 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3825;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3825 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3826;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3826 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3827;
  let test = eq r r_expected in
  if not test then failwithf "test 3827 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3828;
  let test = eq r r_expected in
  if not test then failwithf "test 3828 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3829;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3829 failed";
  let expected_b4 = 101 in
  mark_test_run 3830;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3830 failed";
  let expected_b10 = 102 in
  mark_test_run 3831;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3831 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3832;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3832 failed";
  let expected_b10 = 102 in
  mark_test_run 3833;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3833 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3834;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3834 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3835;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3835 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3836;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3836 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3837;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3837 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3838;
  let test = eq r r_expected in
  if not test then failwithf "test 3838 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3839;
  let test = eq r r_expected in
  if not test then failwithf "test 3839 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3840;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3840 failed";
  let expected_b4 = 101 in
  mark_test_run 3841;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3841 failed";
  let expected_b10 = 102 in
  mark_test_run 3842;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3842 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3843;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3843 failed";
  let expected_b10 = 102 in
  mark_test_run 3844;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3844 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3845;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3845 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3846;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3846 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3847;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3847 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3848;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3848 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3849;
  let test = eq r r_expected in
  if not test then failwithf "test 3849 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3850;
  let test = eq r r_expected in
  if not test then failwithf "test 3850 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3851;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3851 failed";
  let expected_b4 = 101 in
  mark_test_run 3852;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3852 failed";
  let expected_b10 = 102 in
  mark_test_run 3853;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3853 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3854;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3854 failed";
  let expected_b10 = 102 in
  mark_test_run 3855;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3855 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3856;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3856 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3857;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3857 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3858;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3858 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3859;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3859 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3860;
  let test = eq r r_expected in
  if not test then failwithf "test 3860 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3861;
  let test = eq r r_expected in
  if not test then failwithf "test 3861 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3862;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3862 failed";
  let expected_b4 = 101 in
  mark_test_run 3863;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3863 failed";
  let expected_b10 = 102 in
  mark_test_run 3864;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3864 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3865;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3865 failed";
  let expected_b10 = 102 in
  mark_test_run 3866;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3866 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3867;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3867 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3868;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3868 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3869;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3869 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3870;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3870 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3871;
  let test = eq r r_expected in
  if not test then failwithf "test 3871 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3872;
  let test = eq r r_expected in
  if not test then failwithf "test 3872 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3873;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3873 failed";
  let expected_b4 = 101 in
  mark_test_run 3874;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3874 failed";
  let expected_b10 = 102 in
  mark_test_run 3875;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3875 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3876;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3876 failed";
  let expected_b10 = 102 in
  mark_test_run 3877;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3877 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3878;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3878 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3879;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3879 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3880;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3880 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3881;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3881 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3882;
  let test = eq r r_expected in
  if not test then failwithf "test 3882 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3883;
  let test = eq r r_expected in
  if not test then failwithf "test 3883 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3884;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3884 failed";
  let expected_b4 = 101 in
  mark_test_run 3885;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3885 failed";
  let expected_b10 = 102 in
  mark_test_run 3886;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3886 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3887;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3887 failed";
  let expected_b10 = 102 in
  mark_test_run 3888;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3888 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3889;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3889 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3890;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3890 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3891;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3891 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3892;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3892 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3893;
  let test = eq r r_expected in
  if not test then failwithf "test 3893 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3894;
  let test = eq r r_expected in
  if not test then failwithf "test 3894 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3895;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3895 failed";
  let expected_b4 = 101 in
  mark_test_run 3896;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3896 failed";
  let expected_b10 = 102 in
  mark_test_run 3897;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3897 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3898;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3898 failed";
  let expected_b10 = 102 in
  mark_test_run 3899;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3899 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3900;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3900 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3901;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3901 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3902;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3902 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3903;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3903 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3904;
  let test = eq r r_expected in
  if not test then failwithf "test 3904 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3905;
  let test = eq r r_expected in
  if not test then failwithf "test 3905 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3906;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3906 failed";
  let expected_b4 = 101 in
  mark_test_run 3907;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3907 failed";
  let expected_b10 = 102 in
  mark_test_run 3908;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3908 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3909;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3909 failed";
  let expected_b10 = 102 in
  mark_test_run 3910;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3910 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3911;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3911 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3912;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3912 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3913;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3913 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3914;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3914 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3915;
  let test = eq r r_expected in
  if not test then failwithf "test 3915 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3916;
  let test = eq r r_expected in
  if not test then failwithf "test 3916 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3917;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3917 failed";
  let expected_b4 = 101 in
  mark_test_run 3918;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3918 failed";
  let expected_b10 = 102 in
  mark_test_run 3919;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3919 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3920;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3920 failed";
  let expected_b10 = 102 in
  mark_test_run 3921;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3921 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3922;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3922 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3923;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3923 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3924;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3924 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3925;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3925 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3926;
  let test = eq r r_expected in
  if not test then failwithf "test 3926 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3927;
  let test = eq r r_expected in
  if not test then failwithf "test 3927 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3928;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3928 failed";
  let expected_b4 = 101 in
  mark_test_run 3929;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3929 failed";
  let expected_b10 = 102 in
  mark_test_run 3930;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3930 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3931;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3931 failed";
  let expected_b10 = 102 in
  mark_test_run 3932;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3932 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3933;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3933 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3934;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3934 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3935;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3935 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3936;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3936 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3937;
  let test = eq r r_expected in
  if not test then failwithf "test 3937 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3938;
  let test = eq r r_expected in
  if not test then failwithf "test 3938 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3939;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3939 failed";
  let expected_b4 = 101 in
  mark_test_run 3940;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3940 failed";
  let expected_b10 = 102 in
  mark_test_run 3941;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3941 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3942;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3942 failed";
  let expected_b10 = 102 in
  mark_test_run 3943;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3943 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3944;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3944 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3945;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3945 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3946;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3946 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3947;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3947 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3948;
  let test = eq r r_expected in
  if not test then failwithf "test 3948 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3949;
  let test = eq r r_expected in
  if not test then failwithf "test 3949 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3950;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3950 failed";
  let expected_b4 = 101 in
  mark_test_run 3951;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3951 failed";
  let expected_b10 = 102 in
  mark_test_run 3952;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3952 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3953;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3953 failed";
  let expected_b10 = 102 in
  mark_test_run 3954;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3954 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3955;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3955 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3956;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3956 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3957;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3957 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3958;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3958 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3959;
  let test = eq r r_expected in
  if not test then failwithf "test 3959 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3960;
  let test = eq r r_expected in
  if not test then failwithf "test 3960 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3961;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3961 failed";
  let expected_b4 = 101 in
  mark_test_run 3962;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3962 failed";
  let expected_b10 = 102 in
  mark_test_run 3963;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3963 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3964;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3964 failed";
  let expected_b10 = 102 in
  mark_test_run 3965;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3965 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3966;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3966 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3967;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3967 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3968;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3968 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3969;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3969 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3970;
  let test = eq r r_expected in
  if not test then failwithf "test 3970 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3971;
  let test = eq r r_expected in
  if not test then failwithf "test 3971 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3972;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3972 failed";
  let expected_b4 = 101 in
  mark_test_run 3973;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3973 failed";
  let expected_b10 = 102 in
  mark_test_run 3974;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3974 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3975;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3975 failed";
  let expected_b10 = 102 in
  mark_test_run 3976;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3976 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3977;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3977 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3978;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3978 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3979;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3979 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3980;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3980 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3981;
  let test = eq r r_expected in
  if not test then failwithf "test 3981 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3982;
  let test = eq r r_expected in
  if not test then failwithf "test 3982 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3983;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3983 failed";
  let expected_b4 = 101 in
  mark_test_run 3984;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3984 failed";
  let expected_b10 = 102 in
  mark_test_run 3985;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3985 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3986;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3986 failed";
  let expected_b10 = 102 in
  mark_test_run 3987;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3987 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3988;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3988 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 3989;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3989 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 3990;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3990 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 3991;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3991 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 3992;
  let test = eq r r_expected in
  if not test then failwithf "test 3992 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 3993;
  let test = eq r r_expected in
  if not test then failwithf "test 3993 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 3994;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 3994 failed";
  let expected_b4 = 101 in
  mark_test_run 3995;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 3995 failed";
  let expected_b10 = 102 in
  mark_test_run 3996;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3996 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 3997;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 3997 failed";
  let expected_b10 = 102 in
  mark_test_run 3998;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 3998 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 3999;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 3999 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4000;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4000 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4001;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4001 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4002;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4002 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4003;
  let test = eq r r_expected in
  if not test then failwithf "test 4003 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4004;
  let test = eq r r_expected in
  if not test then failwithf "test 4004 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4005;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4005 failed";
  let expected_b4 = 101 in
  mark_test_run 4006;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4006 failed";
  let expected_b10 = 102 in
  mark_test_run 4007;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4007 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4008;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4008 failed";
  let expected_b10 = 102 in
  mark_test_run 4009;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4009 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4010;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4010 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4011;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4011 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4012;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4012 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4013;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4013 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4014;
  let test = eq r r_expected in
  if not test then failwithf "test 4014 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4015;
  let test = eq r r_expected in
  if not test then failwithf "test 4015 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4016;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4016 failed";
  let expected_b4 = 101 in
  mark_test_run 4017;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4017 failed";
  let expected_b10 = 102 in
  mark_test_run 4018;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4018 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4019;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4019 failed";
  let expected_b10 = 102 in
  mark_test_run 4020;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4020 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4021;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4021 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4022;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4022 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4023;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4023 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4024;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4024 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4025;
  let test = eq r r_expected in
  if not test then failwithf "test 4025 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4026;
  let test = eq r r_expected in
  if not test then failwithf "test 4026 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4027;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4027 failed";
  let expected_b4 = 101 in
  mark_test_run 4028;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4028 failed";
  let expected_b10 = 102 in
  mark_test_run 4029;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4029 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4030;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4030 failed";
  let expected_b10 = 102 in
  mark_test_run 4031;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4031 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4032;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4032 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4033;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4033 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4034;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4034 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4035;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4035 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4036;
  let test = eq r r_expected in
  if not test then failwithf "test 4036 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4037;
  let test = eq r r_expected in
  if not test then failwithf "test 4037 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4038;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4038 failed";
  let expected_b4 = 101 in
  mark_test_run 4039;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4039 failed";
  let expected_b10 = 102 in
  mark_test_run 4040;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4040 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4041;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4041 failed";
  let expected_b10 = 102 in
  mark_test_run 4042;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4042 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4043;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4043 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4044;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4044 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4045;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4045 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4046;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4046 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4047;
  let test = eq r r_expected in
  if not test then failwithf "test 4047 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4048;
  let test = eq r r_expected in
  if not test then failwithf "test 4048 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4049;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4049 failed";
  let expected_b4 = 101 in
  mark_test_run 4050;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4050 failed";
  let expected_b10 = 102 in
  mark_test_run 4051;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4051 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4052;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4052 failed";
  let expected_b10 = 102 in
  mark_test_run 4053;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4053 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4054;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4054 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4055;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4055 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4056;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4056 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4057;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4057 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4058;
  let test = eq r r_expected in
  if not test then failwithf "test 4058 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4059;
  let test = eq r r_expected in
  if not test then failwithf "test 4059 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4060;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4060 failed";
  let expected_b4 = 101 in
  mark_test_run 4061;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4061 failed";
  let expected_b10 = 102 in
  mark_test_run 4062;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4062 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4063;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4063 failed";
  let expected_b10 = 102 in
  mark_test_run 4064;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4064 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4065;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4065 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4066;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4066 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4067;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4067 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4068;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4068 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4069;
  let test = eq r r_expected in
  if not test then failwithf "test 4069 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4070;
  let test = eq r r_expected in
  if not test then failwithf "test 4070 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4071;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4071 failed";
  let expected_b4 = 101 in
  mark_test_run 4072;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4072 failed";
  let expected_b10 = 102 in
  mark_test_run 4073;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4073 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4074;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4074 failed";
  let expected_b10 = 102 in
  mark_test_run 4075;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4075 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4076;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4076 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4077;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4077 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4078;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4078 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4079;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4079 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4080;
  let test = eq r r_expected in
  if not test then failwithf "test 4080 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4081;
  let test = eq r r_expected in
  if not test then failwithf "test 4081 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4082;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4082 failed";
  let expected_b4 = 101 in
  mark_test_run 4083;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4083 failed";
  let expected_b10 = 102 in
  mark_test_run 4084;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4084 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4085;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4085 failed";
  let expected_b10 = 102 in
  mark_test_run 4086;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4086 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4087;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4087 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4088;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4088 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4089;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4089 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4090;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4090 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4091;
  let test = eq r r_expected in
  if not test then failwithf "test 4091 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4092;
  let test = eq r r_expected in
  if not test then failwithf "test 4092 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4093;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4093 failed";
  let expected_b4 = 101 in
  mark_test_run 4094;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4094 failed";
  let expected_b10 = 102 in
  mark_test_run 4095;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4095 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4096;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4096 failed";
  let expected_b10 = 102 in
  mark_test_run 4097;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4097 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4098;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4098 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4099;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4099 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4100;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4100 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4101;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4101 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4102;
  let test = eq r r_expected in
  if not test then failwithf "test 4102 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4103;
  let test = eq r r_expected in
  if not test then failwithf "test 4103 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4104;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4104 failed";
  let expected_b4 = 101 in
  mark_test_run 4105;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4105 failed";
  let expected_b10 = 102 in
  mark_test_run 4106;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4106 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4107;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4107 failed";
  let expected_b10 = 102 in
  mark_test_run 4108;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4108 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4109;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4109 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4110;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4110 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4111;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4111 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4112;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4112 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4113;
  let test = eq r r_expected in
  if not test then failwithf "test 4113 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4114;
  let test = eq r r_expected in
  if not test then failwithf "test 4114 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4115;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4115 failed";
  let expected_b4 = 101 in
  mark_test_run 4116;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4116 failed";
  let expected_b10 = 102 in
  mark_test_run 4117;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4117 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4118;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4118 failed";
  let expected_b10 = 102 in
  mark_test_run 4119;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4119 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4120;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4120 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4121;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4121 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4122;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4122 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4123;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4123 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4124;
  let test = eq r r_expected in
  if not test then failwithf "test 4124 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4125;
  let test = eq r r_expected in
  if not test then failwithf "test 4125 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4126;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4126 failed";
  let expected_b4 = 101 in
  mark_test_run 4127;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4127 failed";
  let expected_b10 = 102 in
  mark_test_run 4128;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4128 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4129;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4129 failed";
  let expected_b10 = 102 in
  mark_test_run 4130;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4130 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4131;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4131 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4132;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4132 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4133;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4133 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4134;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4134 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4135;
  let test = eq r r_expected in
  if not test then failwithf "test 4135 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4136;
  let test = eq r r_expected in
  if not test then failwithf "test 4136 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4137;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4137 failed";
  let expected_b4 = 101 in
  mark_test_run 4138;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4138 failed";
  let expected_b10 = 102 in
  mark_test_run 4139;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4139 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4140;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4140 failed";
  let expected_b10 = 102 in
  mark_test_run 4141;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4141 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4142;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4142 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4143;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4143 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4144;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4144 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4145;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4145 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4146;
  let test = eq r r_expected in
  if not test then failwithf "test 4146 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4147;
  let test = eq r r_expected in
  if not test then failwithf "test 4147 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4148;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4148 failed";
  let expected_b4 = 101 in
  mark_test_run 4149;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4149 failed";
  let expected_b10 = 102 in
  mark_test_run 4150;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4150 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4151;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4151 failed";
  let expected_b10 = 102 in
  mark_test_run 4152;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4152 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4153;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4153 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4154;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4154 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4155;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4155 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4156;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4156 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4157;
  let test = eq r r_expected in
  if not test then failwithf "test 4157 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4158;
  let test = eq r r_expected in
  if not test then failwithf "test 4158 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4159;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4159 failed";
  let expected_b4 = 101 in
  mark_test_run 4160;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4160 failed";
  let expected_b10 = 102 in
  mark_test_run 4161;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4161 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4162;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4162 failed";
  let expected_b10 = 102 in
  mark_test_run 4163;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4163 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4164;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4164 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4165;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4165 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4166;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4166 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4167;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4167 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4168;
  let test = eq r r_expected in
  if not test then failwithf "test 4168 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4169;
  let test = eq r r_expected in
  if not test then failwithf "test 4169 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4170;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4170 failed";
  let expected_b4 = 101 in
  mark_test_run 4171;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4171 failed";
  let expected_b10 = 102 in
  mark_test_run 4172;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4172 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4173;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4173 failed";
  let expected_b10 = 102 in
  mark_test_run 4174;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4174 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4175;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4175 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4176;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4176 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4177;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4177 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4178;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4178 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4179;
  let test = eq r r_expected in
  if not test then failwithf "test 4179 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4180;
  let test = eq r r_expected in
  if not test then failwithf "test 4180 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4181;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4181 failed";
  let expected_b4 = 101 in
  mark_test_run 4182;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4182 failed";
  let expected_b10 = 102 in
  mark_test_run 4183;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4183 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4184;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4184 failed";
  let expected_b10 = 102 in
  mark_test_run 4185;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4185 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4186;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4186 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4187;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4187 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4188;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4188 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4189;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4189 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4190;
  let test = eq r r_expected in
  if not test then failwithf "test 4190 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4191;
  let test = eq r r_expected in
  if not test then failwithf "test 4191 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4192;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4192 failed";
  let expected_b4 = 101 in
  mark_test_run 4193;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4193 failed";
  let expected_b10 = 102 in
  mark_test_run 4194;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4194 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4195;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4195 failed";
  let expected_b10 = 102 in
  mark_test_run 4196;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4196 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4197;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4197 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4198;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4198 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4199;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4199 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4200;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4200 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4201;
  let test = eq r r_expected in
  if not test then failwithf "test 4201 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4202;
  let test = eq r r_expected in
  if not test then failwithf "test 4202 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4203;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4203 failed";
  let expected_b4 = 101 in
  mark_test_run 4204;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4204 failed";
  let expected_b10 = 102 in
  mark_test_run 4205;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4205 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4206;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4206 failed";
  let expected_b10 = 102 in
  mark_test_run 4207;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4207 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4208;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4208 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4209;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4209 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4210;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4210 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4211;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4211 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4212;
  let test = eq r r_expected in
  if not test then failwithf "test 4212 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4213;
  let test = eq r r_expected in
  if not test then failwithf "test 4213 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4214;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4214 failed";
  let expected_b4 = 101 in
  mark_test_run 4215;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4215 failed";
  let expected_b10 = 102 in
  mark_test_run 4216;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4216 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4217;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4217 failed";
  let expected_b10 = 102 in
  mark_test_run 4218;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4218 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4219;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4219 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4220;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4220 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4221;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4221 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4222;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4222 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4223;
  let test = eq r r_expected in
  if not test then failwithf "test 4223 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4224;
  let test = eq r r_expected in
  if not test then failwithf "test 4224 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4225;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4225 failed";
  let expected_b4 = 101 in
  mark_test_run 4226;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4226 failed";
  let expected_b10 = 102 in
  mark_test_run 4227;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4227 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4228;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4228 failed";
  let expected_b10 = 102 in
  mark_test_run 4229;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4229 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4230;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4230 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4231;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4231 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4232;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4232 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4233;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4233 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4234;
  let test = eq r r_expected in
  if not test then failwithf "test 4234 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4235;
  let test = eq r r_expected in
  if not test then failwithf "test 4235 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4236;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4236 failed";
  let expected_b4 = 101 in
  mark_test_run 4237;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4237 failed";
  let expected_b10 = 102 in
  mark_test_run 4238;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4238 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4239;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4239 failed";
  let expected_b10 = 102 in
  mark_test_run 4240;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4240 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4241;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4241 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4242;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4242 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4243;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4243 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4244;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4244 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4245;
  let test = eq r r_expected in
  if not test then failwithf "test 4245 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4246;
  let test = eq r r_expected in
  if not test then failwithf "test 4246 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4247;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4247 failed";
  let expected_b4 = 101 in
  mark_test_run 4248;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4248 failed";
  let expected_b10 = 102 in
  mark_test_run 4249;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4249 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4250;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4250 failed";
  let expected_b10 = 102 in
  mark_test_run 4251;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4251 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4252;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4252 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4253;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4253 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4254;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4254 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4255;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4255 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4256;
  let test = eq r r_expected in
  if not test then failwithf "test 4256 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4257;
  let test = eq r r_expected in
  if not test then failwithf "test 4257 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4258;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4258 failed";
  let expected_b4 = 101 in
  mark_test_run 4259;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4259 failed";
  let expected_b10 = 102 in
  mark_test_run 4260;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4260 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4261;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4261 failed";
  let expected_b10 = 102 in
  mark_test_run 4262;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4262 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4263;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4263 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4264;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4264 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4265;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4265 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4266;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4266 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4267;
  let test = eq r r_expected in
  if not test then failwithf "test 4267 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4268;
  let test = eq r r_expected in
  if not test then failwithf "test 4268 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4269;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4269 failed";
  let expected_b4 = 101 in
  mark_test_run 4270;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4270 failed";
  let expected_b10 = 102 in
  mark_test_run 4271;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4271 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4272;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4272 failed";
  let expected_b10 = 102 in
  mark_test_run 4273;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4273 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4274;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4274 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4275;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4275 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4276;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4276 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4277;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4277 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4278;
  let test = eq r r_expected in
  if not test then failwithf "test 4278 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4279;
  let test = eq r r_expected in
  if not test then failwithf "test 4279 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4280;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4280 failed";
  let expected_b4 = 101 in
  mark_test_run 4281;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4281 failed";
  let expected_b10 = 102 in
  mark_test_run 4282;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4282 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4283;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4283 failed";
  let expected_b10 = 102 in
  mark_test_run 4284;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4284 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4285;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4285 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4286;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4286 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4287;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4287 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4288;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4288 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4289;
  let test = eq r r_expected in
  if not test then failwithf "test 4289 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4290;
  let test = eq r r_expected in
  if not test then failwithf "test 4290 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4291;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4291 failed";
  let expected_b4 = 101 in
  mark_test_run 4292;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4292 failed";
  let expected_b10 = 102 in
  mark_test_run 4293;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4293 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4294;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4294 failed";
  let expected_b10 = 102 in
  mark_test_run 4295;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4295 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4296;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4296 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4297;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4297 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4298;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4298 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4299;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4299 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4300;
  let test = eq r r_expected in
  if not test then failwithf "test 4300 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4301;
  let test = eq r r_expected in
  if not test then failwithf "test 4301 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4302;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4302 failed";
  let expected_b4 = 101 in
  mark_test_run 4303;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4303 failed";
  let expected_b10 = 102 in
  mark_test_run 4304;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4304 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4305;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4305 failed";
  let expected_b10 = 102 in
  mark_test_run 4306;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4306 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4307;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4307 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4308;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4308 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4309;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4309 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4310;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4310 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4311;
  let test = eq r r_expected in
  if not test then failwithf "test 4311 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4312;
  let test = eq r r_expected in
  if not test then failwithf "test 4312 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4313;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4313 failed";
  let expected_b4 = 101 in
  mark_test_run 4314;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4314 failed";
  let expected_b10 = 102 in
  mark_test_run 4315;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4315 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4316;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4316 failed";
  let expected_b10 = 102 in
  mark_test_run 4317;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4317 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4318;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4318 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4319;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4319 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4320;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4320 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4321;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4321 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4322;
  let test = eq r r_expected in
  if not test then failwithf "test 4322 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4323;
  let test = eq r r_expected in
  if not test then failwithf "test 4323 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4324;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4324 failed";
  let expected_b4 = 101 in
  mark_test_run 4325;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4325 failed";
  let expected_b10 = 102 in
  mark_test_run 4326;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4326 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4327;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4327 failed";
  let expected_b10 = 102 in
  mark_test_run 4328;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4328 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4329;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4329 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4330;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4330 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4331;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4331 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4332;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4332 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4333;
  let test = eq r r_expected in
  if not test then failwithf "test 4333 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4334;
  let test = eq r r_expected in
  if not test then failwithf "test 4334 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4335;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4335 failed";
  let expected_b4 = 101 in
  mark_test_run 4336;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4336 failed";
  let expected_b10 = 102 in
  mark_test_run 4337;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4337 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4338;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4338 failed";
  let expected_b10 = 102 in
  mark_test_run 4339;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4339 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4340;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4340 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4341;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4341 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4342;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4342 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4343;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4343 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4344;
  let test = eq r r_expected in
  if not test then failwithf "test 4344 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4345;
  let test = eq r r_expected in
  if not test then failwithf "test 4345 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4346;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4346 failed";
  let expected_b4 = 101 in
  mark_test_run 4347;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4347 failed";
  let expected_b10 = 102 in
  mark_test_run 4348;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4348 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4349;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4349 failed";
  let expected_b10 = 102 in
  mark_test_run 4350;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4350 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4351;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4351 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4352;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4352 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4353;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4353 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4354;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4354 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4355;
  let test = eq r r_expected in
  if not test then failwithf "test 4355 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4356;
  let test = eq r r_expected in
  if not test then failwithf "test 4356 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4357;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4357 failed";
  let expected_b4 = 101 in
  mark_test_run 4358;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4358 failed";
  let expected_b10 = 102 in
  mark_test_run 4359;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4359 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4360;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4360 failed";
  let expected_b10 = 102 in
  mark_test_run 4361;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4361 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4362;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4362 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4363;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4363 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4364;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4364 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4365;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4365 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4366;
  let test = eq r r_expected in
  if not test then failwithf "test 4366 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4367;
  let test = eq r r_expected in
  if not test then failwithf "test 4367 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4368;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4368 failed";
  let expected_b4 = 101 in
  mark_test_run 4369;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4369 failed";
  let expected_b10 = 102 in
  mark_test_run 4370;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4370 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4371;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4371 failed";
  let expected_b10 = 102 in
  mark_test_run 4372;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4372 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4373;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4373 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4374;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4374 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4375;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4375 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4376;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4376 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4377;
  let test = eq r r_expected in
  if not test then failwithf "test 4377 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4378;
  let test = eq r r_expected in
  if not test then failwithf "test 4378 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4379;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4379 failed";
  let expected_b4 = 101 in
  mark_test_run 4380;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4380 failed";
  let expected_b10 = 102 in
  mark_test_run 4381;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4381 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4382;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4382 failed";
  let expected_b10 = 102 in
  mark_test_run 4383;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4383 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4384;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4384 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4385;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4385 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4386;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4386 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4387;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4387 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4388;
  let test = eq r r_expected in
  if not test then failwithf "test 4388 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4389;
  let test = eq r r_expected in
  if not test then failwithf "test 4389 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4390;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4390 failed";
  let expected_b4 = 101 in
  mark_test_run 4391;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4391 failed";
  let expected_b10 = 102 in
  mark_test_run 4392;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4392 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4393;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4393 failed";
  let expected_b10 = 102 in
  mark_test_run 4394;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4394 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4395;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4395 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4396;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4396 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4397;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4397 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4398;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4398 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4399;
  let test = eq r r_expected in
  if not test then failwithf "test 4399 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4400;
  let test = eq r r_expected in
  if not test then failwithf "test 4400 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4401;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4401 failed";
  let expected_b4 = 101 in
  mark_test_run 4402;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4402 failed";
  let expected_b10 = 102 in
  mark_test_run 4403;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4403 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4404;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4404 failed";
  let expected_b10 = 102 in
  mark_test_run 4405;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4405 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4406;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4406 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4407;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4407 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4408;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4408 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4409;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4409 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4410;
  let test = eq r r_expected in
  if not test then failwithf "test 4410 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4411;
  let test = eq r r_expected in
  if not test then failwithf "test 4411 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4412;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4412 failed";
  let expected_b4 = 101 in
  mark_test_run 4413;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4413 failed";
  let expected_b10 = 102 in
  mark_test_run 4414;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4414 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4415;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4415 failed";
  let expected_b10 = 102 in
  mark_test_run 4416;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4416 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4417;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4417 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4418;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4418 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4419;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4419 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4420;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4420 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4421;
  let test = eq r r_expected in
  if not test then failwithf "test 4421 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4422;
  let test = eq r r_expected in
  if not test then failwithf "test 4422 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4423;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4423 failed";
  let expected_b4 = 101 in
  mark_test_run 4424;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4424 failed";
  let expected_b10 = 102 in
  mark_test_run 4425;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4425 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4426;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4426 failed";
  let expected_b10 = 102 in
  mark_test_run 4427;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4427 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4428;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4428 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4429;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4429 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4430;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4430 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4431;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4431 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4432;
  let test = eq r r_expected in
  if not test then failwithf "test 4432 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4433;
  let test = eq r r_expected in
  if not test then failwithf "test 4433 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4434;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4434 failed";
  let expected_b4 = 101 in
  mark_test_run 4435;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4435 failed";
  let expected_b10 = 102 in
  mark_test_run 4436;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4436 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4437;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4437 failed";
  let expected_b10 = 102 in
  mark_test_run 4438;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4438 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4439;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4439 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4440;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4440 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4441;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4441 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4442;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4442 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4443;
  let test = eq r r_expected in
  if not test then failwithf "test 4443 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4444;
  let test = eq r r_expected in
  if not test then failwithf "test 4444 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4445;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4445 failed";
  let expected_b4 = 101 in
  mark_test_run 4446;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4446 failed";
  let expected_b10 = 102 in
  mark_test_run 4447;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4447 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4448;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4448 failed";
  let expected_b10 = 102 in
  mark_test_run 4449;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4449 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4450;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4450 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4451;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4451 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4452;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4452 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4453;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4453 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4454;
  let test = eq r r_expected in
  if not test then failwithf "test 4454 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4455;
  let test = eq r r_expected in
  if not test then failwithf "test 4455 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4456;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4456 failed";
  let expected_b4 = 101 in
  mark_test_run 4457;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4457 failed";
  let expected_b10 = 102 in
  mark_test_run 4458;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4458 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4459;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4459 failed";
  let expected_b10 = 102 in
  mark_test_run 4460;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4460 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4461;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4461 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4462;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4462 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4463;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4463 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4464;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4464 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4465;
  let test = eq r r_expected in
  if not test then failwithf "test 4465 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4466;
  let test = eq r r_expected in
  if not test then failwithf "test 4466 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4467;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4467 failed";
  let expected_b4 = 101 in
  mark_test_run 4468;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4468 failed";
  let expected_b10 = 102 in
  mark_test_run 4469;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4469 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4470;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4470 failed";
  let expected_b10 = 102 in
  mark_test_run 4471;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4471 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4472;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4472 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4473;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4473 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4474;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4474 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4475;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4475 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4476;
  let test = eq r r_expected in
  if not test then failwithf "test 4476 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4477;
  let test = eq r r_expected in
  if not test then failwithf "test 4477 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4478;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4478 failed";
  let expected_b4 = 101 in
  mark_test_run 4479;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4479 failed";
  let expected_b10 = 102 in
  mark_test_run 4480;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4480 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4481;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4481 failed";
  let expected_b10 = 102 in
  mark_test_run 4482;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4482 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4483;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4483 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4484;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4484 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4485;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4485 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4486;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4486 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4487;
  let test = eq r r_expected in
  if not test then failwithf "test 4487 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4488;
  let test = eq r r_expected in
  if not test then failwithf "test 4488 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4489;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4489 failed";
  let expected_b4 = 101 in
  mark_test_run 4490;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4490 failed";
  let expected_b10 = 102 in
  mark_test_run 4491;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4491 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4492;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4492 failed";
  let expected_b10 = 102 in
  mark_test_run 4493;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4493 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4494;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4494 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4495;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4495 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4496;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4496 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4497;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4497 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4498;
  let test = eq r r_expected in
  if not test then failwithf "test 4498 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4499;
  let test = eq r r_expected in
  if not test then failwithf "test 4499 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4500;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4500 failed";
  let expected_b4 = 101 in
  mark_test_run 4501;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4501 failed";
  let expected_b10 = 102 in
  mark_test_run 4502;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4502 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4503;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4503 failed";
  let expected_b10 = 102 in
  mark_test_run 4504;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4504 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4505;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4505 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4506;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4506 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4507;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4507 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4508;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4508 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4509;
  let test = eq r r_expected in
  if not test then failwithf "test 4509 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4510;
  let test = eq r r_expected in
  if not test then failwithf "test 4510 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4511;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4511 failed";
  let expected_b4 = 101 in
  mark_test_run 4512;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4512 failed";
  let expected_b10 = 102 in
  mark_test_run 4513;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4513 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4514;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4514 failed";
  let expected_b10 = 102 in
  mark_test_run 4515;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4515 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4516;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4516 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4517;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4517 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4518;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4518 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4519;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4519 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4520;
  let test = eq r r_expected in
  if not test then failwithf "test 4520 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4521;
  let test = eq r r_expected in
  if not test then failwithf "test 4521 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4522;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4522 failed";
  let expected_b4 = 101 in
  mark_test_run 4523;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4523 failed";
  let expected_b10 = 102 in
  mark_test_run 4524;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4524 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4525;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4525 failed";
  let expected_b10 = 102 in
  mark_test_run 4526;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4526 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4527;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4527 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4528;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4528 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4529;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4529 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4530;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4530 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4531;
  let test = eq r r_expected in
  if not test then failwithf "test 4531 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4532;
  let test = eq r r_expected in
  if not test then failwithf "test 4532 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4533;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4533 failed";
  let expected_b4 = 101 in
  mark_test_run 4534;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4534 failed";
  let expected_b10 = 102 in
  mark_test_run 4535;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4535 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4536;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4536 failed";
  let expected_b10 = 102 in
  mark_test_run 4537;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4537 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4538;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4538 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4539;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4539 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4540;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4540 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4541;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4541 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4542;
  let test = eq r r_expected in
  if not test then failwithf "test 4542 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4543;
  let test = eq r r_expected in
  if not test then failwithf "test 4543 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4544;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4544 failed";
  let expected_b4 = 101 in
  mark_test_run 4545;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4545 failed";
  let expected_b10 = 102 in
  mark_test_run 4546;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4546 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4547;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4547 failed";
  let expected_b10 = 102 in
  mark_test_run 4548;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4548 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4549;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4549 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4550;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4550 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4551;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4551 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4552;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4552 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4553;
  let test = eq r r_expected in
  if not test then failwithf "test 4553 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4554;
  let test = eq r r_expected in
  if not test then failwithf "test 4554 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4555;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4555 failed";
  let expected_b4 = 101 in
  mark_test_run 4556;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4556 failed";
  let expected_b10 = 102 in
  mark_test_run 4557;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4557 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4558;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4558 failed";
  let expected_b10 = 102 in
  mark_test_run 4559;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4559 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4560;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4560 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4561;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4561 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4562;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4562 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4563;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4563 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4564;
  let test = eq r r_expected in
  if not test then failwithf "test 4564 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4565;
  let test = eq r r_expected in
  if not test then failwithf "test 4565 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4566;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4566 failed";
  let expected_b4 = 101 in
  mark_test_run 4567;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4567 failed";
  let expected_b10 = 102 in
  mark_test_run 4568;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4568 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4569;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4569 failed";
  let expected_b10 = 102 in
  mark_test_run 4570;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4570 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4571;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4571 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4572;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4572 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4573;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4573 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4574;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4574 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4575;
  let test = eq r r_expected in
  if not test then failwithf "test 4575 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4576;
  let test = eq r r_expected in
  if not test then failwithf "test 4576 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4577;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4577 failed";
  let expected_b4 = 101 in
  mark_test_run 4578;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4578 failed";
  let expected_b10 = 102 in
  mark_test_run 4579;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4579 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4580;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4580 failed";
  let expected_b10 = 102 in
  mark_test_run 4581;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4581 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4582;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4582 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4583;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4583 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4584;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4584 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4585;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4585 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4586;
  let test = eq r r_expected in
  if not test then failwithf "test 4586 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4587;
  let test = eq r r_expected in
  if not test then failwithf "test 4587 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4588;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4588 failed";
  let expected_b4 = 101 in
  mark_test_run 4589;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4589 failed";
  let expected_b10 = 102 in
  mark_test_run 4590;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4590 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4591;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4591 failed";
  let expected_b10 = 102 in
  mark_test_run 4592;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4592 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4593;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4593 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4594;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4594 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4595;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4595 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4596;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4596 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4597;
  let test = eq r r_expected in
  if not test then failwithf "test 4597 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4598;
  let test = eq r r_expected in
  if not test then failwithf "test 4598 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4599;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4599 failed";
  let expected_b4 = 101 in
  mark_test_run 4600;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4600 failed";
  let expected_b10 = 102 in
  mark_test_run 4601;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4601 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4602;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4602 failed";
  let expected_b10 = 102 in
  mark_test_run 4603;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4603 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4604;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4604 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4605;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4605 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4606;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4606 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4607;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4607 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4608;
  let test = eq r r_expected in
  if not test then failwithf "test 4608 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4609;
  let test = eq r r_expected in
  if not test then failwithf "test 4609 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4610;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4610 failed";
  let expected_b4 = 101 in
  mark_test_run 4611;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4611 failed";
  let expected_b10 = 102 in
  mark_test_run 4612;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4612 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4613;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4613 failed";
  let expected_b10 = 102 in
  mark_test_run 4614;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4614 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4615;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4615 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4616;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4616 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4617;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4617 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4618;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4618 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4619;
  let test = eq r r_expected in
  if not test then failwithf "test 4619 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4620;
  let test = eq r r_expected in
  if not test then failwithf "test 4620 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4621;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4621 failed";
  let expected_b4 = 101 in
  mark_test_run 4622;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4622 failed";
  let expected_b10 = 102 in
  mark_test_run 4623;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4623 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4624;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4624 failed";
  let expected_b10 = 102 in
  mark_test_run 4625;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4625 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4626;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4626 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4627;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4627 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4628;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4628 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4629;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4629 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4630;
  let test = eq r r_expected in
  if not test then failwithf "test 4630 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4631;
  let test = eq r r_expected in
  if not test then failwithf "test 4631 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4632;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4632 failed";
  let expected_b4 = 101 in
  mark_test_run 4633;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4633 failed";
  let expected_b10 = 102 in
  mark_test_run 4634;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4634 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4635;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4635 failed";
  let expected_b10 = 102 in
  mark_test_run 4636;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4636 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4637;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4637 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4638;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4638 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4639;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4639 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4640;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4640 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4641;
  let test = eq r r_expected in
  if not test then failwithf "test 4641 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4642;
  let test = eq r r_expected in
  if not test then failwithf "test 4642 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4643;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4643 failed";
  let expected_b4 = 101 in
  mark_test_run 4644;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4644 failed";
  let expected_b10 = 102 in
  mark_test_run 4645;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4645 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4646;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4646 failed";
  let expected_b10 = 102 in
  mark_test_run 4647;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4647 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4648;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4648 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4649;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4649 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4650;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4650 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4651;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4651 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4652;
  let test = eq r r_expected in
  if not test then failwithf "test 4652 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4653;
  let test = eq r r_expected in
  if not test then failwithf "test 4653 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4654;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4654 failed";
  let expected_b4 = 101 in
  mark_test_run 4655;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4655 failed";
  let expected_b10 = 102 in
  mark_test_run 4656;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4656 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4657;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4657 failed";
  let expected_b10 = 102 in
  mark_test_run 4658;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4658 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4659;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4659 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4660;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4660 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4661;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4661 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4662;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4662 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4663;
  let test = eq r r_expected in
  if not test then failwithf "test 4663 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4664;
  let test = eq r r_expected in
  if not test then failwithf "test 4664 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4665;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4665 failed";
  let expected_b4 = 101 in
  mark_test_run 4666;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4666 failed";
  let expected_b10 = 102 in
  mark_test_run 4667;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4667 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4668;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4668 failed";
  let expected_b10 = 102 in
  mark_test_run 4669;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4669 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4670;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4670 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4671;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4671 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4672;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4672 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4673;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4673 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4674;
  let test = eq r r_expected in
  if not test then failwithf "test 4674 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4675;
  let test = eq r r_expected in
  if not test then failwithf "test 4675 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4676;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4676 failed";
  let expected_b4 = 101 in
  mark_test_run 4677;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4677 failed";
  let expected_b10 = 102 in
  mark_test_run 4678;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4678 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4679;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4679 failed";
  let expected_b10 = 102 in
  mark_test_run 4680;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4680 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4681;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4681 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4682;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4682 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4683;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4683 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4684;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4684 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4685;
  let test = eq r r_expected in
  if not test then failwithf "test 4685 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4686;
  let test = eq r r_expected in
  if not test then failwithf "test 4686 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4687;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4687 failed";
  let expected_b4 = 101 in
  mark_test_run 4688;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4688 failed";
  let expected_b10 = 102 in
  mark_test_run 4689;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4689 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4690;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4690 failed";
  let expected_b10 = 102 in
  mark_test_run 4691;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4691 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4692;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4692 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4693;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4693 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4694;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4694 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4695;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4695 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4696;
  let test = eq r r_expected in
  if not test then failwithf "test 4696 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4697;
  let test = eq r r_expected in
  if not test then failwithf "test 4697 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4698;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4698 failed";
  let expected_b4 = 101 in
  mark_test_run 4699;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4699 failed";
  let expected_b10 = 102 in
  mark_test_run 4700;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4700 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4701;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4701 failed";
  let expected_b10 = 102 in
  mark_test_run 4702;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4702 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4703;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4703 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4704;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4704 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4705;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4705 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4706;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4706 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4707;
  let test = eq r r_expected in
  if not test then failwithf "test 4707 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4708;
  let test = eq r r_expected in
  if not test then failwithf "test 4708 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4709;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4709 failed";
  let expected_b4 = 101 in
  mark_test_run 4710;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4710 failed";
  let expected_b10 = 102 in
  mark_test_run 4711;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4711 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4712;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4712 failed";
  let expected_b10 = 102 in
  mark_test_run 4713;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4713 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4714;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4714 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4715;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4715 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4716;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4716 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4717;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4717 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4718;
  let test = eq r r_expected in
  if not test then failwithf "test 4718 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4719;
  let test = eq r r_expected in
  if not test then failwithf "test 4719 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4720;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4720 failed";
  let expected_b4 = 101 in
  mark_test_run 4721;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4721 failed";
  let expected_b10 = 102 in
  mark_test_run 4722;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4722 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4723;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4723 failed";
  let expected_b10 = 102 in
  mark_test_run 4724;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4724 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4725;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4725 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4726;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4726 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4727;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4727 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4728;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4728 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4729;
  let test = eq r r_expected in
  if not test then failwithf "test 4729 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4730;
  let test = eq r r_expected in
  if not test then failwithf "test 4730 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4731;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4731 failed";
  let expected_b4 = 101 in
  mark_test_run 4732;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4732 failed";
  let expected_b10 = 102 in
  mark_test_run 4733;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4733 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4734;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4734 failed";
  let expected_b10 = 102 in
  mark_test_run 4735;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4735 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4736;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4736 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4737;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4737 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4738;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4738 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4739;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4739 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4740;
  let test = eq r r_expected in
  if not test then failwithf "test 4740 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4741;
  let test = eq r r_expected in
  if not test then failwithf "test 4741 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4742;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4742 failed";
  let expected_b4 = 101 in
  mark_test_run 4743;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4743 failed";
  let expected_b10 = 102 in
  mark_test_run 4744;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4744 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4745;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4745 failed";
  let expected_b10 = 102 in
  mark_test_run 4746;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4746 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4747;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4747 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4748;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4748 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4749;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4749 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4750;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4750 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4751;
  let test = eq r r_expected in
  if not test then failwithf "test 4751 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4752;
  let test = eq r r_expected in
  if not test then failwithf "test 4752 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4753;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4753 failed";
  let expected_b4 = 101 in
  mark_test_run 4754;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4754 failed";
  let expected_b10 = 102 in
  mark_test_run 4755;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4755 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4756;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4756 failed";
  let expected_b10 = 102 in
  mark_test_run 4757;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4757 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4758;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4758 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4759;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4759 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4760;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4760 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4761;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4761 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4762;
  let test = eq r r_expected in
  if not test then failwithf "test 4762 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4763;
  let test = eq r r_expected in
  if not test then failwithf "test 4763 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4764;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4764 failed";
  let expected_b4 = 101 in
  mark_test_run 4765;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4765 failed";
  let expected_b10 = 102 in
  mark_test_run 4766;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4766 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4767;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4767 failed";
  let expected_b10 = 102 in
  mark_test_run 4768;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4768 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4769;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4769 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4770;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4770 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4771;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4771 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4772;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4772 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4773;
  let test = eq r r_expected in
  if not test then failwithf "test 4773 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4774;
  let test = eq r r_expected in
  if not test then failwithf "test 4774 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4775;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4775 failed";
  let expected_b4 = 101 in
  mark_test_run 4776;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4776 failed";
  let expected_b10 = 102 in
  mark_test_run 4777;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4777 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4778;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4778 failed";
  let expected_b10 = 102 in
  mark_test_run 4779;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4779 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4780;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4780 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4781;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4781 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4782;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4782 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4783;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4783 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4784;
  let test = eq r r_expected in
  if not test then failwithf "test 4784 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4785;
  let test = eq r r_expected in
  if not test then failwithf "test 4785 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4786;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4786 failed";
  let expected_b4 = 101 in
  mark_test_run 4787;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4787 failed";
  let expected_b10 = 102 in
  mark_test_run 4788;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4788 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4789;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4789 failed";
  let expected_b10 = 102 in
  mark_test_run 4790;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4790 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4791;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4791 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4792;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4792 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4793;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4793 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4794;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4794 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4795;
  let test = eq r r_expected in
  if not test then failwithf "test 4795 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4796;
  let test = eq r r_expected in
  if not test then failwithf "test 4796 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4797;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4797 failed";
  let expected_b4 = 101 in
  mark_test_run 4798;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4798 failed";
  let expected_b10 = 102 in
  mark_test_run 4799;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4799 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4800;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4800 failed";
  let expected_b10 = 102 in
  mark_test_run 4801;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4801 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4802;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4802 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4803;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4803 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4804;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4804 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4805;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4805 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4806;
  let test = eq r r_expected in
  if not test then failwithf "test 4806 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4807;
  let test = eq r r_expected in
  if not test then failwithf "test 4807 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4808;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4808 failed";
  let expected_b4 = 101 in
  mark_test_run 4809;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4809 failed";
  let expected_b10 = 102 in
  mark_test_run 4810;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4810 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4811;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4811 failed";
  let expected_b10 = 102 in
  mark_test_run 4812;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4812 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4813;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4813 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4814;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4814 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4815;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4815 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4816;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4816 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4817;
  let test = eq r r_expected in
  if not test then failwithf "test 4817 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4818;
  let test = eq r r_expected in
  if not test then failwithf "test 4818 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4819;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4819 failed";
  let expected_b4 = 101 in
  mark_test_run 4820;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4820 failed";
  let expected_b10 = 102 in
  mark_test_run 4821;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4821 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4822;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4822 failed";
  let expected_b10 = 102 in
  mark_test_run 4823;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4823 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4824;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4824 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4825;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4825 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4826;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4826 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4827;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4827 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4828;
  let test = eq r r_expected in
  if not test then failwithf "test 4828 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4829;
  let test = eq r r_expected in
  if not test then failwithf "test 4829 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4830;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4830 failed";
  let expected_b4 = 101 in
  mark_test_run 4831;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4831 failed";
  let expected_b10 = 102 in
  mark_test_run 4832;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4832 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4833;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4833 failed";
  let expected_b10 = 102 in
  mark_test_run 4834;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4834 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4835;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4835 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4836;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4836 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4837;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4837 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4838;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4838 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4839;
  let test = eq r r_expected in
  if not test then failwithf "test 4839 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4840;
  let test = eq r r_expected in
  if not test then failwithf "test 4840 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4841;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4841 failed";
  let expected_b4 = 101 in
  mark_test_run 4842;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4842 failed";
  let expected_b10 = 102 in
  mark_test_run 4843;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4843 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4844;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4844 failed";
  let expected_b10 = 102 in
  mark_test_run 4845;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4845 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4846;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4846 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4847;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4847 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4848;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4848 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4849;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4849 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4850;
  let test = eq r r_expected in
  if not test then failwithf "test 4850 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4851;
  let test = eq r r_expected in
  if not test then failwithf "test 4851 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4852;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4852 failed";
  let expected_b4 = 101 in
  mark_test_run 4853;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4853 failed";
  let expected_b10 = 102 in
  mark_test_run 4854;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4854 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4855;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4855 failed";
  let expected_b10 = 102 in
  mark_test_run 4856;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4856 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4857;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4857 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4858;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4858 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4859;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4859 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4860;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4860 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4861;
  let test = eq r r_expected in
  if not test then failwithf "test 4861 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4862;
  let test = eq r r_expected in
  if not test then failwithf "test 4862 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4863;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4863 failed";
  let expected_b4 = 101 in
  mark_test_run 4864;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4864 failed";
  let expected_b10 = 102 in
  mark_test_run 4865;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4865 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4866;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4866 failed";
  let expected_b10 = 102 in
  mark_test_run 4867;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4867 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4868;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4868 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4869;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4869 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4870;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4870 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4871;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4871 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4872;
  let test = eq r r_expected in
  if not test then failwithf "test 4872 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4873;
  let test = eq r r_expected in
  if not test then failwithf "test 4873 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4874;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4874 failed";
  let expected_b4 = 101 in
  mark_test_run 4875;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4875 failed";
  let expected_b10 = 102 in
  mark_test_run 4876;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4876 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4877;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4877 failed";
  let expected_b10 = 102 in
  mark_test_run 4878;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4878 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4879;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4879 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4880;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4880 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4881;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4881 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4882;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4882 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4883;
  let test = eq r r_expected in
  if not test then failwithf "test 4883 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4884;
  let test = eq r r_expected in
  if not test then failwithf "test 4884 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4885;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4885 failed";
  let expected_b4 = 101 in
  mark_test_run 4886;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4886 failed";
  let expected_b10 = 102 in
  mark_test_run 4887;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4887 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4888;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4888 failed";
  let expected_b10 = 102 in
  mark_test_run 4889;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4889 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4890;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4890 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4891;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4891 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4892;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4892 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4893;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4893 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4894;
  let test = eq r r_expected in
  if not test then failwithf "test 4894 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4895;
  let test = eq r r_expected in
  if not test then failwithf "test 4895 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4896;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4896 failed";
  let expected_b4 = 101 in
  mark_test_run 4897;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4897 failed";
  let expected_b10 = 102 in
  mark_test_run 4898;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4898 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4899;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4899 failed";
  let expected_b10 = 102 in
  mark_test_run 4900;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4900 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4901;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4901 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4902;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4902 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4903;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4903 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4904;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4904 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4905;
  let test = eq r r_expected in
  if not test then failwithf "test 4905 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4906;
  let test = eq r r_expected in
  if not test then failwithf "test 4906 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4907;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4907 failed";
  let expected_b4 = 101 in
  mark_test_run 4908;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4908 failed";
  let expected_b10 = 102 in
  mark_test_run 4909;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4909 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4910;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4910 failed";
  let expected_b10 = 102 in
  mark_test_run 4911;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4911 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4912;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4912 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4913;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4913 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4914;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4914 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4915;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4915 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4916;
  let test = eq r r_expected in
  if not test then failwithf "test 4916 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4917;
  let test = eq r r_expected in
  if not test then failwithf "test 4917 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4918;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4918 failed";
  let expected_b4 = 101 in
  mark_test_run 4919;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4919 failed";
  let expected_b10 = 102 in
  mark_test_run 4920;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4920 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4921;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4921 failed";
  let expected_b10 = 102 in
  mark_test_run 4922;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4922 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4923;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4923 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4924;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4924 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4925;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4925 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4926;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4926 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4927;
  let test = eq r r_expected in
  if not test then failwithf "test 4927 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4928;
  let test = eq r r_expected in
  if not test then failwithf "test 4928 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4929;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4929 failed";
  let expected_b4 = 101 in
  mark_test_run 4930;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4930 failed";
  let expected_b10 = 102 in
  mark_test_run 4931;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4931 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4932;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4932 failed";
  let expected_b10 = 102 in
  mark_test_run 4933;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4933 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4934;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4934 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4935;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4935 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4936;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4936 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4937;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4937 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4938;
  let test = eq r r_expected in
  if not test then failwithf "test 4938 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4939;
  let test = eq r r_expected in
  if not test then failwithf "test 4939 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4940;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4940 failed";
  let expected_b4 = 101 in
  mark_test_run 4941;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4941 failed";
  let expected_b10 = 102 in
  mark_test_run 4942;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4942 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4943;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4943 failed";
  let expected_b10 = 102 in
  mark_test_run 4944;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4944 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4945;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4945 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4946;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4946 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4947;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4947 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4948;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4948 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4949;
  let test = eq r r_expected in
  if not test then failwithf "test 4949 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4950;
  let test = eq r r_expected in
  if not test then failwithf "test 4950 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4951;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4951 failed";
  let expected_b4 = 101 in
  mark_test_run 4952;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4952 failed";
  let expected_b10 = 102 in
  mark_test_run 4953;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4953 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4954;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4954 failed";
  let expected_b10 = 102 in
  mark_test_run 4955;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4955 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4956;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4956 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4957;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4957 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4958;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4958 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4959;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4959 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4960;
  let test = eq r r_expected in
  if not test then failwithf "test 4960 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4961;
  let test = eq r r_expected in
  if not test then failwithf "test 4961 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4962;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4962 failed";
  let expected_b4 = 101 in
  mark_test_run 4963;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4963 failed";
  let expected_b10 = 102 in
  mark_test_run 4964;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4964 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4965;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4965 failed";
  let expected_b10 = 102 in
  mark_test_run 4966;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4966 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4967;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4967 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4968;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4968 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4969;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4969 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4970;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4970 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4971;
  let test = eq r r_expected in
  if not test then failwithf "test 4971 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4972;
  let test = eq r r_expected in
  if not test then failwithf "test 4972 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4973;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4973 failed";
  let expected_b4 = 101 in
  mark_test_run 4974;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4974 failed";
  let expected_b10 = 102 in
  mark_test_run 4975;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4975 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4976;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4976 failed";
  let expected_b10 = 102 in
  mark_test_run 4977;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4977 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4978;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4978 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4979;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4979 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4980;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4980 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4981;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4981 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4982;
  let test = eq r r_expected in
  if not test then failwithf "test 4982 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4983;
  let test = eq r r_expected in
  if not test then failwithf "test 4983 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4984;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4984 failed";
  let expected_b4 = 101 in
  mark_test_run 4985;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4985 failed";
  let expected_b10 = 102 in
  mark_test_run 4986;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4986 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4987;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4987 failed";
  let expected_b10 = 102 in
  mark_test_run 4988;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4988 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 4989;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 4989 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 4990;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4990 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 4991;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4991 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 4992;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4992 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 4993;
  let test = eq r r_expected in
  if not test then failwithf "test 4993 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 4994;
  let test = eq r r_expected in
  if not test then failwithf "test 4994 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 4995;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 4995 failed";
  let expected_b4 = 101 in
  mark_test_run 4996;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 4996 failed";
  let expected_b10 = 102 in
  mark_test_run 4997;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4997 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 4998;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 4998 failed";
  let expected_b10 = 102 in
  mark_test_run 4999;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 4999 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5000;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5000 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5001;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5001 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5002;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5002 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5003;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5003 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5004;
  let test = eq r r_expected in
  if not test then failwithf "test 5004 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5005;
  let test = eq r r_expected in
  if not test then failwithf "test 5005 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5006;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5006 failed";
  let expected_b4 = 101 in
  mark_test_run 5007;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5007 failed";
  let expected_b10 = 102 in
  mark_test_run 5008;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5008 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5009;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5009 failed";
  let expected_b10 = 102 in
  mark_test_run 5010;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5010 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5011;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5011 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5012;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5012 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5013;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5013 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5014;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5014 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5015;
  let test = eq r r_expected in
  if not test then failwithf "test 5015 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5016;
  let test = eq r r_expected in
  if not test then failwithf "test 5016 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5017;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5017 failed";
  let expected_b4 = 101 in
  mark_test_run 5018;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5018 failed";
  let expected_b10 = 102 in
  mark_test_run 5019;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5019 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5020;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5020 failed";
  let expected_b10 = 102 in
  mark_test_run 5021;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5021 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5022;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5022 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5023;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5023 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5024;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5024 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5025;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5025 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5026;
  let test = eq r r_expected in
  if not test then failwithf "test 5026 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5027;
  let test = eq r r_expected in
  if not test then failwithf "test 5027 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5028;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5028 failed";
  let expected_b4 = 101 in
  mark_test_run 5029;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5029 failed";
  let expected_b10 = 102 in
  mark_test_run 5030;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5030 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5031;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5031 failed";
  let expected_b10 = 102 in
  mark_test_run 5032;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5032 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5033;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5033 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5034;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5034 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5035;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5035 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5036;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5036 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5037;
  let test = eq r r_expected in
  if not test then failwithf "test 5037 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5038;
  let test = eq r r_expected in
  if not test then failwithf "test 5038 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5039;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5039 failed";
  let expected_b4 = 101 in
  mark_test_run 5040;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5040 failed";
  let expected_b10 = 102 in
  mark_test_run 5041;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5041 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5042;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5042 failed";
  let expected_b10 = 102 in
  mark_test_run 5043;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5043 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5044;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5044 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5045;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5045 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5046;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5046 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5047;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5047 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5048;
  let test = eq r r_expected in
  if not test then failwithf "test 5048 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5049;
  let test = eq r r_expected in
  if not test then failwithf "test 5049 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5050;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5050 failed";
  let expected_b4 = 101 in
  mark_test_run 5051;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5051 failed";
  let expected_b10 = 102 in
  mark_test_run 5052;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5052 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5053;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5053 failed";
  let expected_b10 = 102 in
  mark_test_run 5054;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5054 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5055;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5055 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5056;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5056 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5057;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5057 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5058;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5058 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5059;
  let test = eq r r_expected in
  if not test then failwithf "test 5059 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5060;
  let test = eq r r_expected in
  if not test then failwithf "test 5060 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5061;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5061 failed";
  let expected_b4 = 101 in
  mark_test_run 5062;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5062 failed";
  let expected_b10 = 102 in
  mark_test_run 5063;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5063 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5064;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5064 failed";
  let expected_b10 = 102 in
  mark_test_run 5065;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5065 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5066;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5066 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5067;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5067 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5068;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5068 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5069;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5069 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5070;
  let test = eq r r_expected in
  if not test then failwithf "test 5070 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5071;
  let test = eq r r_expected in
  if not test then failwithf "test 5071 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5072;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5072 failed";
  let expected_b4 = 101 in
  mark_test_run 5073;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5073 failed";
  let expected_b10 = 102 in
  mark_test_run 5074;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5074 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5075;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5075 failed";
  let expected_b10 = 102 in
  mark_test_run 5076;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5076 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5077;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5077 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5078;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5078 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5079;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5079 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5080;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5080 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5081;
  let test = eq r r_expected in
  if not test then failwithf "test 5081 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5082;
  let test = eq r r_expected in
  if not test then failwithf "test 5082 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5083;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5083 failed";
  let expected_b4 = 101 in
  mark_test_run 5084;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5084 failed";
  let expected_b10 = 102 in
  mark_test_run 5085;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5085 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5086;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5086 failed";
  let expected_b10 = 102 in
  mark_test_run 5087;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5087 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5088;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5088 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5089;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5089 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5090;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5090 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5091;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5091 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5092;
  let test = eq r r_expected in
  if not test then failwithf "test 5092 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5093;
  let test = eq r r_expected in
  if not test then failwithf "test 5093 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5094;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5094 failed";
  let expected_b4 = 101 in
  mark_test_run 5095;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5095 failed";
  let expected_b10 = 102 in
  mark_test_run 5096;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5096 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5097;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5097 failed";
  let expected_b10 = 102 in
  mark_test_run 5098;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5098 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5099;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5099 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5100;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5100 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5101;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5101 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5102;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5102 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5103;
  let test = eq r r_expected in
  if not test then failwithf "test 5103 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5104;
  let test = eq r r_expected in
  if not test then failwithf "test 5104 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5105;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5105 failed";
  let expected_b4 = 101 in
  mark_test_run 5106;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5106 failed";
  let expected_b10 = 102 in
  mark_test_run 5107;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5107 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5108;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5108 failed";
  let expected_b10 = 102 in
  mark_test_run 5109;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5109 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t10 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = #{ a4 = 0; b4 = 1 } in
  mark_test_run 5110;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) actual expected in
  if not test then failwithf "test 5110 failed";
  (* Paths of depth 2 *)
  (* .a10.#a4 *)
  let actual = r.a10.#a4 in
  let expected = 0 in
  mark_test_run 5111;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5111 failed";
  (* .a10.#b4 *)
  let actual = r.a10.#b4 in
  let expected = 1 in
  mark_test_run 5112;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5112 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = 2 in
  mark_test_run 5113;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5113 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let next_r = { a10 = #{ a4 = 100; b4 = 101 }; b10 = 102 } in
  let r_expected = { a10 = #{ a4 = 0; b4 = 1 }; b10 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 5114;
  let test = eq r r_expected in
  if not test then failwithf "test 5114 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 5115;
  let test = eq r r_expected in
  if not test then failwithf "test 5115 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10 = #{ a4; b4 }; b10 } = r in
  let expected_a4 = 100 in
  mark_test_run 5116;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 5116 failed";
  let expected_b4 = 101 in
  mark_test_run 5117;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 5117 failed";
  let expected_b10 = 102 in
  mark_test_run 5118;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5118 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = #{ a4 = 100; b4 = 101 } in
  mark_test_run 5119;
  let test = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42) expected_a10 a10 in
  if not test then failwithf "test 5119 failed";
  let expected_b10 = 102 in
  mark_test_run 5120;
  let test = (fun a b -> Int.equal a b) expected_b10 b10 in
  if not test then failwithf "test 5120 failed";

  ()
;;
let () = to_run ();;

for i = 1 to 5120 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
  ()
done;;
let () = Printf.printf "All tests passed.%!\n";;
