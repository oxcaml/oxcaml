(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

let int64x2_u_equal i1 i2 =
    let a1 = int64_of_int64x2 i1 in
    let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
    let a2 = int64_of_int64x2 i2 in
    let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
    Int64.equal a1 a2 && Int64.equal b1 b2

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = { mutable a0 : int } (* { int } *)
type t1 = { mutable a1 : int; mutable b1 : int } (* { int; int } *)
type t2 = { mutable a2 : int; mutable b2 : int; mutable c2 : int } (* { int; int; int } *)
type t3 = { mutable a3 : int; mutable b3 : int; mutable c3 : int32# } (* { int; int; int32# } *)
type t4 = { mutable a4 : int; mutable b4 : int; mutable c4 : float } (* { int; int; float } *)
type t5 = { mutable a5 : int; mutable b5 : int; mutable c5 : int64x2# } (* { int; int; int64x2# } *)
type t6 = { mutable a6 : int; mutable b6 : int64 } (* { int; int64 } *)
type t7 = { mutable a7 : int; mutable b7 : int64# } (* { int; int64# } *)
type t8 = { mutable a8 : int; mutable b8 : int32# } (* { int; int32# } *)
type t9 = { mutable a9 : int; mutable b9 : int32#; mutable c9 : int } (* { int; int32#; int } *)
type t10 = { mutable a10 : int; mutable b10 : int32#; mutable c10 : int32# } (* { int; int32#; int32# } *)
type t11 = { mutable a11 : int; mutable b11 : nativeint# } (* { int; nativeint# } *)
type t12 = { mutable a12 : int; mutable b12 : unit_u } (* { int; unit_u } *)
type t13 = { mutable a13 : int; mutable b13 : float } (* { int; float } *)
type t14 = { mutable a14 : int; mutable b14 : float; mutable c14 : int } (* { int; float; int } *)
type t15 = { mutable a15 : int; mutable b15 : float; mutable c15 : float } (* { int; float; float } *)
type t16 = { mutable a16 : int; mutable b16 : int64x2# } (* { int; int64x2# } *)
type t17 = { mutable a17 : int; mutable b17 : int64x2#; mutable c17 : int } (* { int; int64x2#; int } *)
type t18 = { mutable a18 : int; mutable b18 : int64x2#; mutable c18 : int64x2# } (* { int; int64x2#; int64x2# } *)
type v19 = C19_0 of unit_u (* (| unit_u) *)
type t20 = { mutable a20 : int; mutable b20 : v19 } (* { int; (| unit_u) } *)
type v21 = C21_0 of unit_u | C21_1 of unit_u * unit_u | C21_2 of #(unit_u * unit_u) (* (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) *)
type t22 = { mutable a22 : int; mutable b22 : v21 } (* { int; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t23 = { mutable a23 : int; mutable b23 : #(unit_u * int) } (* { int; #(unit_u, int) } *)
type t24 = { mutable a24 : int; mutable b24 : #(unit_u * int64#) } (* { int; #(unit_u, int64#) } *)
type t25 = { mutable a25 : int; mutable b25 : #(unit_u * unit_u) } (* { int; #(unit_u, unit_u) } *)
type t26 = { mutable a26 : int; mutable b26 : #(unit_u * string) } (* { int; #(unit_u, string) } *)
type t27 = #{ a27 : int } (* #{ int } *)
type t28 = { mutable a28 : int; mutable b28 : t27 } (* { int; #{ int } } *)
type t29 = #{ a29 : int; b29 : int } (* #{ int; int } *)
type t30 = { mutable a30 : int; mutable b30 : t29 } (* { int; #{ int; int } } *)
type t31 = #{ a31 : int; b31 : int32# } (* #{ int; int32# } *)
type t32 = { mutable a32 : int; mutable b32 : t31 } (* { int; #{ int; int32# } } *)
type t33 = #{ a33 : int; b33 : float } (* #{ int; float } *)
type t34 = { mutable a34 : int; mutable b34 : t33 } (* { int; #{ int; float } } *)
type t35 = #{ a35 : int; b35 : int64x2# } (* #{ int; int64x2# } *)
type t36 = { mutable a36 : int; mutable b36 : t35 } (* { int; #{ int; int64x2# } } *)
type t37 = #{ a37 : int; b37 : t27 } (* #{ int; #{ int } } *)
type t38 = { mutable a38 : int; mutable b38 : t37 } (* { int; #{ int; #{ int } } } *)
type t39 = #{ a39 : int32# } (* #{ int32# } *)
type t40 = #{ a40 : int; b40 : t39 } (* #{ int; #{ int32# } } *)
type t41 = { mutable a41 : int; mutable b41 : t40 } (* { int; #{ int; #{ int32# } } } *)
type t42 = #{ a42 : float } (* #{ float } *)
type t43 = #{ a43 : int; b43 : t42 } (* #{ int; #{ float } } *)
type t44 = { mutable a44 : int; mutable b44 : t43 } (* { int; #{ int; #{ float } } } *)
type t45 = #{ a45 : int64x2# } (* #{ int64x2# } *)
type t46 = #{ a46 : int; b46 : t45 } (* #{ int; #{ int64x2# } } *)
type t47 = { mutable a47 : int; mutable b47 : t46 } (* { int; #{ int; #{ int64x2# } } } *)
type t48 = { mutable a48 : int; mutable b48 : t39 } (* { int; #{ int32# } } *)
type t49 = #{ a49 : int32#; b49 : int } (* #{ int32#; int } *)
type t50 = { mutable a50 : int; mutable b50 : t49 } (* { int; #{ int32#; int } } *)
type t51 = #{ a51 : int32#; b51 : int32# } (* #{ int32#; int32# } *)
type t52 = { mutable a52 : int; mutable b52 : t51 } (* { int; #{ int32#; int32# } } *)
type t53 = #{ a53 : int32#; b53 : t27 } (* #{ int32#; #{ int } } *)
type t54 = { mutable a54 : int; mutable b54 : t53 } (* { int; #{ int32#; #{ int } } } *)
type t55 = #{ a55 : int32#; b55 : t39 } (* #{ int32#; #{ int32# } } *)
type t56 = { mutable a56 : int; mutable b56 : t55 } (* { int; #{ int32#; #{ int32# } } } *)
type t57 = { mutable a57 : int; mutable b57 : t42 } (* { int; #{ float } } *)
type t58 = #{ a58 : float; b58 : int } (* #{ float; int } *)
type t59 = { mutable a59 : int; mutable b59 : t58 } (* { int; #{ float; int } } *)
type t60 = #{ a60 : float; b60 : float } (* #{ float; float } *)
type t61 = { mutable a61 : int; mutable b61 : t60 } (* { int; #{ float; float } } *)
type t62 = #{ a62 : float; b62 : t27 } (* #{ float; #{ int } } *)
type t63 = { mutable a63 : int; mutable b63 : t62 } (* { int; #{ float; #{ int } } } *)
type t64 = #{ a64 : float; b64 : t42 } (* #{ float; #{ float } } *)
type t65 = { mutable a65 : int; mutable b65 : t64 } (* { int; #{ float; #{ float } } } *)
type t66 = { mutable a66 : int; mutable b66 : t45 } (* { int; #{ int64x2# } } *)
type t67 = #{ a67 : int64x2#; b67 : int } (* #{ int64x2#; int } *)
type t68 = { mutable a68 : int; mutable b68 : t67 } (* { int; #{ int64x2#; int } } *)
type t69 = #{ a69 : int64x2#; b69 : int64x2# } (* #{ int64x2#; int64x2# } *)
type t70 = { mutable a70 : int; mutable b70 : t69 } (* { int; #{ int64x2#; int64x2# } } *)
type t71 = #{ a71 : int64x2#; b71 : t27 } (* #{ int64x2#; #{ int } } *)
type t72 = { mutable a72 : int; mutable b72 : t71 } (* { int; #{ int64x2#; #{ int } } } *)
type t73 = #{ a73 : int64x2#; b73 : t45 } (* #{ int64x2#; #{ int64x2# } } *)
type t74 = { mutable a74 : int; mutable b74 : t73 } (* { int; #{ int64x2#; #{ int64x2# } } } *)
type t75 = #{ a75 : t29 } (* #{ #{ int; int } } *)
type t76 = { mutable a76 : int; mutable b76 : t75 } (* { int; #{ #{ int; int } } } *)
type t77 = #{ a77 : t31 } (* #{ #{ int; int32# } } *)
type t78 = { mutable a78 : int; mutable b78 : t77 } (* { int; #{ #{ int; int32# } } } *)
type t79 = #{ a79 : t33 } (* #{ #{ int; float } } *)
type t80 = { mutable a80 : int; mutable b80 : t79 } (* { int; #{ #{ int; float } } } *)
type t81 = #{ a81 : t35 } (* #{ #{ int; int64x2# } } *)
type t82 = { mutable a82 : int; mutable b82 : t81 } (* { int; #{ #{ int; int64x2# } } } *)
type t83 = #{ a83 : t49 } (* #{ #{ int32#; int } } *)
type t84 = { mutable a84 : int; mutable b84 : t83 } (* { int; #{ #{ int32#; int } } } *)
type t85 = #{ a85 : t51 } (* #{ #{ int32#; int32# } } *)
type t86 = { mutable a86 : int; mutable b86 : t85 } (* { int; #{ #{ int32#; int32# } } } *)
type t87 = #{ a87 : t58 } (* #{ #{ float; int } } *)
type t88 = { mutable a88 : int; mutable b88 : t87 } (* { int; #{ #{ float; int } } } *)
type t89 = #{ a89 : t60 } (* #{ #{ float; float } } *)
type t90 = { mutable a90 : int; mutable b90 : t89 } (* { int; #{ #{ float; float } } } *)
type t91 = #{ a91 : t67 } (* #{ #{ int64x2#; int } } *)
type t92 = { mutable a92 : int; mutable b92 : t91 } (* { int; #{ #{ int64x2#; int } } } *)
type t93 = #{ a93 : t69 } (* #{ #{ int64x2#; int64x2# } } *)
type t94 = { mutable a94 : int; mutable b94 : t93 } (* { int; #{ #{ int64x2#; int64x2# } } } *)
type t95 = { mutable a95 : int64 } (* { int64 } *)
type t96 = { mutable a96 : int64; mutable b96 : int } (* { int64; int } *)
type t97 = { mutable a97 : int64; mutable b97 : int64 } (* { int64; int64 } *)
type t98 = { mutable a98 : int64; mutable b98 : int64# } (* { int64; int64# } *)
type t99 = { mutable a99 : int64; mutable b99 : int32# } (* { int64; int32# } *)
type t100 = { mutable a100 : int64; mutable b100 : nativeint# } (* { int64; nativeint# } *)
type t101 = { mutable a101 : int64; mutable b101 : unit_u } (* { int64; unit_u } *)
type t102 = { mutable a102 : int64; mutable b102 : float } (* { int64; float } *)
type t103 = { mutable a103 : int64; mutable b103 : v19 } (* { int64; (| unit_u) } *)
type t104 = { mutable a104 : int64; mutable b104 : v21 } (* { int64; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t105 = { mutable a105 : int64; mutable b105 : #(unit_u * int) } (* { int64; #(unit_u, int) } *)
type t106 = { mutable a106 : int64; mutable b106 : #(unit_u * int64#) } (* { int64; #(unit_u, int64#) } *)
type t107 = { mutable a107 : int64; mutable b107 : #(unit_u * unit_u) } (* { int64; #(unit_u, unit_u) } *)
type t108 = { mutable a108 : int64; mutable b108 : #(unit_u * string) } (* { int64; #(unit_u, string) } *)
type t109 = { mutable a109 : int64# } (* { int64# } *)
type t110 = { mutable a110 : int64#; mutable b110 : int } (* { int64#; int } *)
type t111 = { mutable a111 : int64#; mutable b111 : int64 } (* { int64#; int64 } *)
type t112 = { mutable a112 : int64#; mutable b112 : int64# } (* { int64#; int64# } *)
type t113 = { mutable a113 : int64#; mutable b113 : int32# } (* { int64#; int32# } *)
type t114 = { mutable a114 : int64#; mutable b114 : nativeint# } (* { int64#; nativeint# } *)
type t115 = { mutable a115 : int64#; mutable b115 : unit_u } (* { int64#; unit_u } *)
type t116 = { mutable a116 : int64#; mutable b116 : float } (* { int64#; float } *)
type t117 = { mutable a117 : int64#; mutable b117 : v19 } (* { int64#; (| unit_u) } *)
type t118 = { mutable a118 : int64#; mutable b118 : v21 } (* { int64#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t119 = { mutable a119 : int64#; mutable b119 : #(unit_u * int) } (* { int64#; #(unit_u, int) } *)
type t120 = { mutable a120 : int64#; mutable b120 : #(unit_u * int64#) } (* { int64#; #(unit_u, int64#) } *)
type t121 = { mutable a121 : int64#; mutable b121 : #(unit_u * unit_u) } (* { int64#; #(unit_u, unit_u) } *)
type t122 = { mutable a122 : int64#; mutable b122 : #(unit_u * string) } (* { int64#; #(unit_u, string) } *)
type t123 = { mutable a123 : int32# } (* { int32# } *)
type t124 = { mutable a124 : int32#; mutable b124 : int } (* { int32#; int } *)
type t125 = { mutable a125 : int32#; mutable b125 : int; mutable c125 : int } (* { int32#; int; int } *)
type t126 = { mutable a126 : int32#; mutable b126 : int; mutable c126 : int32# } (* { int32#; int; int32# } *)
type t127 = { mutable a127 : int32#; mutable b127 : int64 } (* { int32#; int64 } *)
type t128 = { mutable a128 : int32#; mutable b128 : int64# } (* { int32#; int64# } *)
type t129 = { mutable a129 : int32#; mutable b129 : int32# } (* { int32#; int32# } *)
type t130 = { mutable a130 : int32#; mutable b130 : int32#; mutable c130 : int } (* { int32#; int32#; int } *)
type t131 = { mutable a131 : int32#; mutable b131 : int32#; mutable c131 : int32# } (* { int32#; int32#; int32# } *)
type t132 = { mutable a132 : int32#; mutable b132 : nativeint# } (* { int32#; nativeint# } *)
type t133 = { mutable a133 : int32#; mutable b133 : unit_u } (* { int32#; unit_u } *)
type t134 = { mutable a134 : int32#; mutable b134 : float } (* { int32#; float } *)
type t135 = { mutable a135 : int32#; mutable b135 : v19 } (* { int32#; (| unit_u) } *)
type t136 = { mutable a136 : int32#; mutable b136 : v21 } (* { int32#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t137 = { mutable a137 : int32#; mutable b137 : #(unit_u * int) } (* { int32#; #(unit_u, int) } *)
type t138 = { mutable a138 : int32#; mutable b138 : #(unit_u * int64#) } (* { int32#; #(unit_u, int64#) } *)
type t139 = { mutable a139 : int32#; mutable b139 : #(unit_u * unit_u) } (* { int32#; #(unit_u, unit_u) } *)
type t140 = { mutable a140 : int32#; mutable b140 : #(unit_u * string) } (* { int32#; #(unit_u, string) } *)
type t141 = { mutable a141 : int32#; mutable b141 : t27 } (* { int32#; #{ int } } *)
type t142 = { mutable a142 : int32#; mutable b142 : t29 } (* { int32#; #{ int; int } } *)
type t143 = { mutable a143 : int32#; mutable b143 : t31 } (* { int32#; #{ int; int32# } } *)
type t144 = { mutable a144 : int32#; mutable b144 : t37 } (* { int32#; #{ int; #{ int } } } *)
type t145 = { mutable a145 : int32#; mutable b145 : t40 } (* { int32#; #{ int; #{ int32# } } } *)
type t146 = { mutable a146 : int32#; mutable b146 : t39 } (* { int32#; #{ int32# } } *)
type t147 = { mutable a147 : int32#; mutable b147 : t49 } (* { int32#; #{ int32#; int } } *)
type t148 = { mutable a148 : int32#; mutable b148 : t51 } (* { int32#; #{ int32#; int32# } } *)
type t149 = { mutable a149 : int32#; mutable b149 : t53 } (* { int32#; #{ int32#; #{ int } } } *)
type t150 = { mutable a150 : int32#; mutable b150 : t55 } (* { int32#; #{ int32#; #{ int32# } } } *)
type t151 = { mutable a151 : int32#; mutable b151 : t75 } (* { int32#; #{ #{ int; int } } } *)
type t152 = { mutable a152 : int32#; mutable b152 : t77 } (* { int32#; #{ #{ int; int32# } } } *)
type t153 = { mutable a153 : int32#; mutable b153 : t83 } (* { int32#; #{ #{ int32#; int } } } *)
type t154 = { mutable a154 : int32#; mutable b154 : t85 } (* { int32#; #{ #{ int32#; int32# } } } *)
type t155 = { mutable a155 : nativeint# } (* { nativeint# } *)
type t156 = { mutable a156 : nativeint#; mutable b156 : int } (* { nativeint#; int } *)
type t157 = { mutable a157 : nativeint#; mutable b157 : int64 } (* { nativeint#; int64 } *)
type t158 = { mutable a158 : nativeint#; mutable b158 : int64# } (* { nativeint#; int64# } *)
type t159 = { mutable a159 : nativeint#; mutable b159 : int32# } (* { nativeint#; int32# } *)
type t160 = { mutable a160 : nativeint#; mutable b160 : nativeint# } (* { nativeint#; nativeint# } *)
type t161 = { mutable a161 : nativeint#; mutable b161 : unit_u } (* { nativeint#; unit_u } *)
type t162 = { mutable a162 : nativeint#; mutable b162 : float } (* { nativeint#; float } *)
type t163 = { mutable a163 : nativeint#; mutable b163 : v19 } (* { nativeint#; (| unit_u) } *)
type t164 = { mutable a164 : nativeint#; mutable b164 : v21 } (* { nativeint#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t165 = { mutable a165 : nativeint#; mutable b165 : #(unit_u * int) } (* { nativeint#; #(unit_u, int) } *)
type t166 = { mutable a166 : nativeint#; mutable b166 : #(unit_u * int64#) } (* { nativeint#; #(unit_u, int64#) } *)
type t167 = { mutable a167 : nativeint#; mutable b167 : #(unit_u * unit_u) } (* { nativeint#; #(unit_u, unit_u) } *)
type t168 = { mutable a168 : nativeint#; mutable b168 : #(unit_u * string) } (* { nativeint#; #(unit_u, string) } *)
type t169 = { mutable a169 : unit_u; mutable b169 : int } (* { unit_u; int } *)
type t170 = { mutable a170 : unit_u; mutable b170 : int64 } (* { unit_u; int64 } *)
type t171 = { mutable a171 : unit_u; mutable b171 : int64# } (* { unit_u; int64# } *)
type t172 = { mutable a172 : unit_u; mutable b172 : int32# } (* { unit_u; int32# } *)
type t173 = { mutable a173 : unit_u; mutable b173 : nativeint# } (* { unit_u; nativeint# } *)
type t174 = { mutable a174 : unit_u; mutable b174 : unit_u; mutable c174 : string } (* { unit_u; unit_u; string } *)
type t175 = { mutable a175 : unit_u; mutable b175 : float } (* { unit_u; float } *)
type t176 = { mutable a176 : unit_u; mutable b176 : string } (* { unit_u; string } *)
type t177 = { mutable a177 : unit_u; mutable b177 : string; mutable c177 : unit_u } (* { unit_u; string; unit_u } *)
type t178 = { mutable a178 : unit_u; mutable b178 : string; mutable c178 : string } (* { unit_u; string; string } *)
type t179 = { mutable a179 : unit_u; mutable b179 : v19 } (* { unit_u; (| unit_u) } *)
type t180 = { mutable a180 : unit_u; mutable b180 : v21 } (* { unit_u; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t181 = { mutable a181 : unit_u; mutable b181 : #(unit_u * int) } (* { unit_u; #(unit_u, int) } *)
type t182 = { mutable a182 : unit_u; mutable b182 : #(unit_u * int64#) } (* { unit_u; #(unit_u, int64#) } *)
type t183 = { mutable a183 : unit_u; mutable b183 : #(unit_u * string) } (* { unit_u; #(unit_u, string) } *)
type t184 = #{ a184 : unit_u; b184 : string } (* #{ unit_u; string } *)
type t185 = { mutable a185 : unit_u; mutable b185 : t184 } (* { unit_u; #{ unit_u; string } } *)
type t186 = #{ a186 : string } (* #{ string } *)
type t187 = #{ a187 : unit_u; b187 : t186 } (* #{ unit_u; #{ string } } *)
type t188 = { mutable a188 : unit_u; mutable b188 : t187 } (* { unit_u; #{ unit_u; #{ string } } } *)
type t189 = { mutable a189 : unit_u; mutable b189 : t186 } (* { unit_u; #{ string } } *)
type t190 = #{ a190 : string; b190 : unit_u } (* #{ string; unit_u } *)
type t191 = { mutable a191 : unit_u; mutable b191 : t190 } (* { unit_u; #{ string; unit_u } } *)
type t192 = #{ a192 : string; b192 : string } (* #{ string; string } *)
type t193 = { mutable a193 : unit_u; mutable b193 : t192 } (* { unit_u; #{ string; string } } *)
type t194 = #{ a194 : unit_u } (* #{ unit_u } *)
type t195 = #{ a195 : string; b195 : t194 } (* #{ string; #{ unit_u } } *)
type t196 = { mutable a196 : unit_u; mutable b196 : t195 } (* { unit_u; #{ string; #{ unit_u } } } *)
type t197 = #{ a197 : string; b197 : t186 } (* #{ string; #{ string } } *)
type t198 = { mutable a198 : unit_u; mutable b198 : t197 } (* { unit_u; #{ string; #{ string } } } *)
type t199 = #{ a199 : t184 } (* #{ #{ unit_u; string } } *)
type t200 = { mutable a200 : unit_u; mutable b200 : t199 } (* { unit_u; #{ #{ unit_u; string } } } *)
type t201 = #{ a201 : t190 } (* #{ #{ string; unit_u } } *)
type t202 = { mutable a202 : unit_u; mutable b202 : t201 } (* { unit_u; #{ #{ string; unit_u } } } *)
type t203 = #{ a203 : t192 } (* #{ #{ string; string } } *)
type t204 = { mutable a204 : unit_u; mutable b204 : t203 } (* { unit_u; #{ #{ string; string } } } *)
type t205 = { mutable a205 : float } (* { float } *)
type t206 = { mutable a206 : float; mutable b206 : int } (* { float; int } *)
type t207 = { mutable a207 : float; mutable b207 : int; mutable c207 : int } (* { float; int; int } *)
type t208 = { mutable a208 : float; mutable b208 : int; mutable c208 : float } (* { float; int; float } *)
type t209 = { mutable a209 : float; mutable b209 : int64 } (* { float; int64 } *)
type t210 = { mutable a210 : float; mutable b210 : int64# } (* { float; int64# } *)
type t211 = { mutable a211 : float; mutable b211 : int32# } (* { float; int32# } *)
type t212 = { mutable a212 : float; mutable b212 : nativeint# } (* { float; nativeint# } *)
type t213 = { mutable a213 : float; mutable b213 : unit_u } (* { float; unit_u } *)
type t214 = { mutable a214 : float; mutable b214 : float } (* { float; float } *)
type t215 = { mutable a215 : float; mutable b215 : float; mutable c215 : int } (* { float; float; int } *)
type t216 = { mutable a216 : float; mutable b216 : float; mutable c216 : float } (* { float; float; float } *)
type t217 = { mutable a217 : float; mutable b217 : float; mutable c217 : float# } (* { float; float; float# } *)
type t218 = { mutable a218 : float; mutable b218 : float# } (* { float; float# } *)
type t219 = { mutable a219 : float; mutable b219 : float#; mutable c219 : float } (* { float; float#; float } *)
type t220 = { mutable a220 : float; mutable b220 : float#; mutable c220 : float# } (* { float; float#; float# } *)
type t221 = { mutable a221 : float; mutable b221 : v19 } (* { float; (| unit_u) } *)
type t222 = { mutable a222 : float; mutable b222 : v21 } (* { float; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t223 = { mutable a223 : float; mutable b223 : #(unit_u * int) } (* { float; #(unit_u, int) } *)
type t224 = { mutable a224 : float; mutable b224 : #(unit_u * int64#) } (* { float; #(unit_u, int64#) } *)
type t225 = { mutable a225 : float; mutable b225 : #(unit_u * unit_u) } (* { float; #(unit_u, unit_u) } *)
type t226 = { mutable a226 : float; mutable b226 : #(unit_u * string) } (* { float; #(unit_u, string) } *)
type t227 = { mutable a227 : float; mutable b227 : t27 } (* { float; #{ int } } *)
type t228 = { mutable a228 : float; mutable b228 : t29 } (* { float; #{ int; int } } *)
type t229 = { mutable a229 : float; mutable b229 : t33 } (* { float; #{ int; float } } *)
type t230 = { mutable a230 : float; mutable b230 : t37 } (* { float; #{ int; #{ int } } } *)
type t231 = { mutable a231 : float; mutable b231 : t43 } (* { float; #{ int; #{ float } } } *)
type t232 = { mutable a232 : float; mutable b232 : t42 } (* { float; #{ float } } *)
type t233 = { mutable a233 : float; mutable b233 : t58 } (* { float; #{ float; int } } *)
type t234 = { mutable a234 : float; mutable b234 : t60 } (* { float; #{ float; float } } *)
type t235 = #{ a235 : float; b235 : float# } (* #{ float; float# } *)
type t236 = { mutable a236 : float; mutable b236 : t235 } (* { float; #{ float; float# } } *)
type t237 = { mutable a237 : float; mutable b237 : t62 } (* { float; #{ float; #{ int } } } *)
type t238 = { mutable a238 : float; mutable b238 : t64 } (* { float; #{ float; #{ float } } } *)
type t239 = #{ a239 : float# } (* #{ float# } *)
type t240 = #{ a240 : float; b240 : t239 } (* #{ float; #{ float# } } *)
type t241 = { mutable a241 : float; mutable b241 : t240 } (* { float; #{ float; #{ float# } } } *)
type t242 = { mutable a242 : float; mutable b242 : t239 } (* { float; #{ float# } } *)
type t243 = #{ a243 : float#; b243 : float } (* #{ float#; float } *)
type t244 = { mutable a244 : float; mutable b244 : t243 } (* { float; #{ float#; float } } *)
type t245 = #{ a245 : float#; b245 : float# } (* #{ float#; float# } *)
type t246 = { mutable a246 : float; mutable b246 : t245 } (* { float; #{ float#; float# } } *)
type t247 = #{ a247 : float#; b247 : t42 } (* #{ float#; #{ float } } *)
type t248 = { mutable a248 : float; mutable b248 : t247 } (* { float; #{ float#; #{ float } } } *)
type t249 = #{ a249 : float#; b249 : t239 } (* #{ float#; #{ float# } } *)
type t250 = { mutable a250 : float; mutable b250 : t249 } (* { float; #{ float#; #{ float# } } } *)
type t251 = { mutable a251 : float; mutable b251 : t75 } (* { float; #{ #{ int; int } } } *)
type t252 = { mutable a252 : float; mutable b252 : t79 } (* { float; #{ #{ int; float } } } *)
type t253 = { mutable a253 : float; mutable b253 : t87 } (* { float; #{ #{ float; int } } } *)
type t254 = { mutable a254 : float; mutable b254 : t89 } (* { float; #{ #{ float; float } } } *)
type t255 = #{ a255 : t235 } (* #{ #{ float; float# } } *)
type t256 = { mutable a256 : float; mutable b256 : t255 } (* { float; #{ #{ float; float# } } } *)
type t257 = #{ a257 : t243 } (* #{ #{ float#; float } } *)
type t258 = { mutable a258 : float; mutable b258 : t257 } (* { float; #{ #{ float#; float } } } *)
type t259 = #{ a259 : t245 } (* #{ #{ float#; float# } } *)
type t260 = { mutable a260 : float; mutable b260 : t259 } (* { float; #{ #{ float#; float# } } } *)
type t261 = { mutable a261 : float# } (* { float# } *)
type t262 = { mutable a262 : float#; mutable b262 : float } (* { float#; float } *)
type t263 = { mutable a263 : float#; mutable b263 : float; mutable c263 : float } (* { float#; float; float } *)
type t264 = { mutable a264 : float#; mutable b264 : float; mutable c264 : float# } (* { float#; float; float# } *)
type t265 = { mutable a265 : float#; mutable b265 : float# } (* { float#; float# } *)
type t266 = { mutable a266 : float#; mutable b266 : float#; mutable c266 : float } (* { float#; float#; float } *)
type t267 = { mutable a267 : float#; mutable b267 : float#; mutable c267 : float# } (* { float#; float#; float# } *)
type t268 = { mutable a268 : float#; mutable b268 : t42 } (* { float#; #{ float } } *)
type t269 = { mutable a269 : float#; mutable b269 : t60 } (* { float#; #{ float; float } } *)
type t270 = { mutable a270 : float#; mutable b270 : t235 } (* { float#; #{ float; float# } } *)
type t271 = { mutable a271 : float#; mutable b271 : t64 } (* { float#; #{ float; #{ float } } } *)
type t272 = { mutable a272 : float#; mutable b272 : t240 } (* { float#; #{ float; #{ float# } } } *)
type t273 = { mutable a273 : float#; mutable b273 : t239 } (* { float#; #{ float# } } *)
type t274 = { mutable a274 : float#; mutable b274 : t243 } (* { float#; #{ float#; float } } *)
type t275 = { mutable a275 : float#; mutable b275 : t245 } (* { float#; #{ float#; float# } } *)
type t276 = { mutable a276 : float#; mutable b276 : t247 } (* { float#; #{ float#; #{ float } } } *)
type t277 = { mutable a277 : float#; mutable b277 : t249 } (* { float#; #{ float#; #{ float# } } } *)
type t278 = { mutable a278 : float#; mutable b278 : t89 } (* { float#; #{ #{ float; float } } } *)
type t279 = { mutable a279 : float#; mutable b279 : t255 } (* { float#; #{ #{ float; float# } } } *)
type t280 = { mutable a280 : float#; mutable b280 : t257 } (* { float#; #{ #{ float#; float } } } *)
type t281 = { mutable a281 : float#; mutable b281 : t259 } (* { float#; #{ #{ float#; float# } } } *)
type t282 = { mutable a282 : string } (* { string } *)
type t283 = { mutable a283 : string; mutable b283 : unit_u } (* { string; unit_u } *)
type t284 = { mutable a284 : string; mutable b284 : unit_u; mutable c284 : unit_u } (* { string; unit_u; unit_u } *)
type t285 = { mutable a285 : string; mutable b285 : unit_u; mutable c285 : string } (* { string; unit_u; string } *)
type t286 = { mutable a286 : string; mutable b286 : string } (* { string; string } *)
type t287 = { mutable a287 : string; mutable b287 : string; mutable c287 : unit_u } (* { string; string; unit_u } *)
type t288 = { mutable a288 : string; mutable b288 : string; mutable c288 : string } (* { string; string; string } *)
type t289 = { mutable a289 : string; mutable b289 : t194 } (* { string; #{ unit_u } } *)
type t290 = #{ a290 : unit_u; b290 : unit_u } (* #{ unit_u; unit_u } *)
type t291 = { mutable a291 : string; mutable b291 : t290 } (* { string; #{ unit_u; unit_u } } *)
type t292 = { mutable a292 : string; mutable b292 : t184 } (* { string; #{ unit_u; string } } *)
type t293 = #{ a293 : unit_u; b293 : t194 } (* #{ unit_u; #{ unit_u } } *)
type t294 = { mutable a294 : string; mutable b294 : t293 } (* { string; #{ unit_u; #{ unit_u } } } *)
type t295 = { mutable a295 : string; mutable b295 : t187 } (* { string; #{ unit_u; #{ string } } } *)
type t296 = { mutable a296 : string; mutable b296 : t186 } (* { string; #{ string } } *)
type t297 = { mutable a297 : string; mutable b297 : t190 } (* { string; #{ string; unit_u } } *)
type t298 = { mutable a298 : string; mutable b298 : t192 } (* { string; #{ string; string } } *)
type t299 = { mutable a299 : string; mutable b299 : t195 } (* { string; #{ string; #{ unit_u } } } *)
type t300 = { mutable a300 : string; mutable b300 : t197 } (* { string; #{ string; #{ string } } } *)
type t301 = #{ a301 : t290 } (* #{ #{ unit_u; unit_u } } *)
type t302 = { mutable a302 : string; mutable b302 : t301 } (* { string; #{ #{ unit_u; unit_u } } } *)
type t303 = { mutable a303 : string; mutable b303 : t199 } (* { string; #{ #{ unit_u; string } } } *)
type t304 = { mutable a304 : string; mutable b304 : t201 } (* { string; #{ #{ string; unit_u } } } *)
type t305 = { mutable a305 : string; mutable b305 : t203 } (* { string; #{ #{ string; string } } } *)
type t306 = { mutable a306 : int64x2# } (* { int64x2# } *)
type t307 = { mutable a307 : int64x2#; mutable b307 : int } (* { int64x2#; int } *)
type t308 = { mutable a308 : int64x2#; mutable b308 : int; mutable c308 : int } (* { int64x2#; int; int } *)
type t309 = { mutable a309 : int64x2#; mutable b309 : int; mutable c309 : int64x2# } (* { int64x2#; int; int64x2# } *)
type t310 = { mutable a310 : int64x2#; mutable b310 : int64x2# } (* { int64x2#; int64x2# } *)
type t311 = { mutable a311 : int64x2#; mutable b311 : int64x2#; mutable c311 : int } (* { int64x2#; int64x2#; int } *)
type t312 = { mutable a312 : int64x2#; mutable b312 : int64x2#; mutable c312 : int64x2# } (* { int64x2#; int64x2#; int64x2# } *)
type t313 = { mutable a313 : int64x2#; mutable b313 : t27 } (* { int64x2#; #{ int } } *)
type t314 = { mutable a314 : int64x2#; mutable b314 : t29 } (* { int64x2#; #{ int; int } } *)
type t315 = { mutable a315 : int64x2#; mutable b315 : t35 } (* { int64x2#; #{ int; int64x2# } } *)
type t316 = { mutable a316 : int64x2#; mutable b316 : t37 } (* { int64x2#; #{ int; #{ int } } } *)
type t317 = { mutable a317 : int64x2#; mutable b317 : t46 } (* { int64x2#; #{ int; #{ int64x2# } } } *)
type t318 = #{ a318 : string; b318 : float# } (* #{ string; float# } *)
type t319 = { mutable a319 : int64x2#; mutable b319 : t318 } (* { int64x2#; #{ string; float# } } *)
type t320 = { mutable a320 : int64x2#; mutable b320 : t45 } (* { int64x2#; #{ int64x2# } } *)
type t321 = { mutable a321 : int64x2#; mutable b321 : t67 } (* { int64x2#; #{ int64x2#; int } } *)
type t322 = { mutable a322 : int64x2#; mutable b322 : t69 } (* { int64x2#; #{ int64x2#; int64x2# } } *)
type t323 = { mutable a323 : int64x2#; mutable b323 : t71 } (* { int64x2#; #{ int64x2#; #{ int } } } *)
type t324 = { mutable a324 : int64x2#; mutable b324 : t73 } (* { int64x2#; #{ int64x2#; #{ int64x2# } } } *)
type t325 = { mutable a325 : int64x2#; mutable b325 : t75 } (* { int64x2#; #{ #{ int; int } } } *)
type t326 = { mutable a326 : int64x2#; mutable b326 : t81 } (* { int64x2#; #{ #{ int; int64x2# } } } *)
type t327 = { mutable a327 : int64x2#; mutable b327 : t91 } (* { int64x2#; #{ #{ int64x2#; int } } } *)
type t328 = { mutable a328 : int64x2#; mutable b328 : t93 } (* { int64x2#; #{ #{ int64x2#; int64x2# } } } *)
type t329 = { mutable a329 : v19 } (* { (| unit_u) } *)
type t330 = { mutable a330 : v19; mutable b330 : int } (* { (| unit_u); int } *)
type t331 = { mutable a331 : v19; mutable b331 : int64 } (* { (| unit_u); int64 } *)
type t332 = { mutable a332 : v19; mutable b332 : int64# } (* { (| unit_u); int64# } *)
type t333 = { mutable a333 : v19; mutable b333 : int32# } (* { (| unit_u); int32# } *)
type t334 = { mutable a334 : v19; mutable b334 : nativeint# } (* { (| unit_u); nativeint# } *)
type t335 = { mutable a335 : v19; mutable b335 : unit_u } (* { (| unit_u); unit_u } *)
type t336 = { mutable a336 : v19; mutable b336 : float } (* { (| unit_u); float } *)
type t337 = { mutable a337 : v19; mutable b337 : v19 } (* { (| unit_u); (| unit_u) } *)
type t338 = { mutable a338 : v19; mutable b338 : v21 } (* { (| unit_u); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t339 = { mutable a339 : v19; mutable b339 : #(unit_u * int) } (* { (| unit_u); #(unit_u, int) } *)
type t340 = { mutable a340 : v19; mutable b340 : #(unit_u * int64#) } (* { (| unit_u); #(unit_u, int64#) } *)
type t341 = { mutable a341 : v19; mutable b341 : #(unit_u * unit_u) } (* { (| unit_u); #(unit_u, unit_u) } *)
type t342 = { mutable a342 : v19; mutable b342 : #(unit_u * string) } (* { (| unit_u); #(unit_u, string) } *)
type t343 = { mutable a343 : v21 } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t344 = { mutable a344 : v21; mutable b344 : int } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int } *)
type t345 = { mutable a345 : v21; mutable b345 : int64 } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int64 } *)
type t346 = { mutable a346 : v21; mutable b346 : int64# } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int64# } *)
type t347 = { mutable a347 : v21; mutable b347 : int32# } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int32# } *)
type t348 = { mutable a348 : v21; mutable b348 : nativeint# } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); nativeint# } *)
type t349 = { mutable a349 : v21; mutable b349 : unit_u } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); unit_u } *)
type t350 = { mutable a350 : v21; mutable b350 : float } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); float } *)
type t351 = { mutable a351 : v21; mutable b351 : v19 } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); (| unit_u) } *)
type t352 = { mutable a352 : v21; mutable b352 : v21 } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t353 = { mutable a353 : v21; mutable b353 : #(unit_u * int) } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, int) } *)
type t354 = { mutable a354 : v21; mutable b354 : #(unit_u * int64#) } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, int64#) } *)
type t355 = { mutable a355 : v21; mutable b355 : #(unit_u * unit_u) } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, unit_u) } *)
type t356 = { mutable a356 : v21; mutable b356 : #(unit_u * string) } (* { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, string) } *)
type t357 = { mutable a357 : #(unit_u * int) } (* { #(unit_u, int) } *)
type t358 = { mutable a358 : #(unit_u * int); mutable b358 : int } (* { #(unit_u, int); int } *)
type t359 = { mutable a359 : #(unit_u * int); mutable b359 : int64 } (* { #(unit_u, int); int64 } *)
type t360 = { mutable a360 : #(unit_u * int); mutable b360 : int64# } (* { #(unit_u, int); int64# } *)
type t361 = { mutable a361 : #(unit_u * int); mutable b361 : int32# } (* { #(unit_u, int); int32# } *)
type t362 = { mutable a362 : #(unit_u * int); mutable b362 : nativeint# } (* { #(unit_u, int); nativeint# } *)
type t363 = { mutable a363 : #(unit_u * int); mutable b363 : unit_u } (* { #(unit_u, int); unit_u } *)
type t364 = { mutable a364 : #(unit_u * int); mutable b364 : float } (* { #(unit_u, int); float } *)
type t365 = { mutable a365 : #(unit_u * int); mutable b365 : v19 } (* { #(unit_u, int); (| unit_u) } *)
type t366 = { mutable a366 : #(unit_u * int); mutable b366 : v21 } (* { #(unit_u, int); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t367 = { mutable a367 : #(unit_u * int); mutable b367 : #(unit_u * int) } (* { #(unit_u, int); #(unit_u, int) } *)
type t368 = { mutable a368 : #(unit_u * int); mutable b368 : #(unit_u * int64#) } (* { #(unit_u, int); #(unit_u, int64#) } *)
type t369 = { mutable a369 : #(unit_u * int); mutable b369 : #(unit_u * unit_u) } (* { #(unit_u, int); #(unit_u, unit_u) } *)
type t370 = { mutable a370 : #(unit_u * int); mutable b370 : #(unit_u * string) } (* { #(unit_u, int); #(unit_u, string) } *)
type t371 = { mutable a371 : #(unit_u * int64#) } (* { #(unit_u, int64#) } *)
type t372 = { mutable a372 : #(unit_u * int64#); mutable b372 : int } (* { #(unit_u, int64#); int } *)
type t373 = { mutable a373 : #(unit_u * int64#); mutable b373 : int64 } (* { #(unit_u, int64#); int64 } *)
type t374 = { mutable a374 : #(unit_u * int64#); mutable b374 : int64# } (* { #(unit_u, int64#); int64# } *)
type t375 = { mutable a375 : #(unit_u * int64#); mutable b375 : int32# } (* { #(unit_u, int64#); int32# } *)
type t376 = { mutable a376 : #(unit_u * int64#); mutable b376 : nativeint# } (* { #(unit_u, int64#); nativeint# } *)
type t377 = { mutable a377 : #(unit_u * int64#); mutable b377 : unit_u } (* { #(unit_u, int64#); unit_u } *)
type t378 = { mutable a378 : #(unit_u * int64#); mutable b378 : float } (* { #(unit_u, int64#); float } *)
type t379 = { mutable a379 : #(unit_u * int64#); mutable b379 : v19 } (* { #(unit_u, int64#); (| unit_u) } *)
type t380 = { mutable a380 : #(unit_u * int64#); mutable b380 : v21 } (* { #(unit_u, int64#); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t381 = { mutable a381 : #(unit_u * int64#); mutable b381 : #(unit_u * int) } (* { #(unit_u, int64#); #(unit_u, int) } *)
type t382 = { mutable a382 : #(unit_u * int64#); mutable b382 : #(unit_u * int64#) } (* { #(unit_u, int64#); #(unit_u, int64#) } *)
type t383 = { mutable a383 : #(unit_u * int64#); mutable b383 : #(unit_u * unit_u) } (* { #(unit_u, int64#); #(unit_u, unit_u) } *)
type t384 = { mutable a384 : #(unit_u * int64#); mutable b384 : #(unit_u * string) } (* { #(unit_u, int64#); #(unit_u, string) } *)
type t385 = { mutable a385 : #(unit_u * unit_u); mutable b385 : int } (* { #(unit_u, unit_u); int } *)
type t386 = { mutable a386 : #(unit_u * unit_u); mutable b386 : int64 } (* { #(unit_u, unit_u); int64 } *)
type t387 = { mutable a387 : #(unit_u * unit_u); mutable b387 : int64# } (* { #(unit_u, unit_u); int64# } *)
type t388 = { mutable a388 : #(unit_u * unit_u); mutable b388 : int32# } (* { #(unit_u, unit_u); int32# } *)
type t389 = { mutable a389 : #(unit_u * unit_u); mutable b389 : nativeint# } (* { #(unit_u, unit_u); nativeint# } *)
type t390 = { mutable a390 : #(unit_u * unit_u); mutable b390 : float } (* { #(unit_u, unit_u); float } *)
type t391 = { mutable a391 : #(unit_u * unit_u); mutable b391 : v19 } (* { #(unit_u, unit_u); (| unit_u) } *)
type t392 = { mutable a392 : #(unit_u * unit_u); mutable b392 : v21 } (* { #(unit_u, unit_u); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t393 = { mutable a393 : #(unit_u * unit_u); mutable b393 : #(unit_u * int) } (* { #(unit_u, unit_u); #(unit_u, int) } *)
type t394 = { mutable a394 : #(unit_u * unit_u); mutable b394 : #(unit_u * int64#) } (* { #(unit_u, unit_u); #(unit_u, int64#) } *)
type t395 = { mutable a395 : #(unit_u * unit_u); mutable b395 : #(unit_u * string) } (* { #(unit_u, unit_u); #(unit_u, string) } *)
type t396 = { mutable a396 : #(unit_u * string) } (* { #(unit_u, string) } *)
type t397 = { mutable a397 : #(unit_u * string); mutable b397 : int } (* { #(unit_u, string); int } *)
type t398 = { mutable a398 : #(unit_u * string); mutable b398 : int64 } (* { #(unit_u, string); int64 } *)
type t399 = { mutable a399 : #(unit_u * string); mutable b399 : int64# } (* { #(unit_u, string); int64# } *)
type t400 = { mutable a400 : #(unit_u * string); mutable b400 : int32# } (* { #(unit_u, string); int32# } *)
type t401 = { mutable a401 : #(unit_u * string); mutable b401 : nativeint# } (* { #(unit_u, string); nativeint# } *)
type t402 = { mutable a402 : #(unit_u * string); mutable b402 : unit_u } (* { #(unit_u, string); unit_u } *)
type t403 = { mutable a403 : #(unit_u * string); mutable b403 : float } (* { #(unit_u, string); float } *)
type t404 = { mutable a404 : #(unit_u * string); mutable b404 : v19 } (* { #(unit_u, string); (| unit_u) } *)
type t405 = { mutable a405 : #(unit_u * string); mutable b405 : v21 } (* { #(unit_u, string); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) } *)
type t406 = { mutable a406 : #(unit_u * string); mutable b406 : #(unit_u * int) } (* { #(unit_u, string); #(unit_u, int) } *)
type t407 = { mutable a407 : #(unit_u * string); mutable b407 : #(unit_u * int64#) } (* { #(unit_u, string); #(unit_u, int64#) } *)
type t408 = { mutable a408 : #(unit_u * string); mutable b408 : #(unit_u * unit_u) } (* { #(unit_u, string); #(unit_u, unit_u) } *)
type t409 = { mutable a409 : #(unit_u * string); mutable b409 : #(unit_u * string) } (* { #(unit_u, string); #(unit_u, string) } *)
type t410 = { mutable a410 : t27 } (* { #{ int } } *)
type t411 = { mutable a411 : t27; mutable b411 : int } (* { #{ int }; int } *)
type t412 = { mutable a412 : t27; mutable b412 : int32# } (* { #{ int }; int32# } *)
type t413 = { mutable a413 : t27; mutable b413 : float } (* { #{ int }; float } *)
type t414 = { mutable a414 : t27; mutable b414 : int64x2# } (* { #{ int }; int64x2# } *)
type t415 = { mutable a415 : t29 } (* { #{ int; int } } *)
type t416 = { mutable a416 : t29; mutable b416 : int } (* { #{ int; int }; int } *)
type t417 = { mutable a417 : t29; mutable b417 : int32# } (* { #{ int; int }; int32# } *)
type t418 = { mutable a418 : t29; mutable b418 : float } (* { #{ int; int }; float } *)
type t419 = { mutable a419 : t29; mutable b419 : int64x2# } (* { #{ int; int }; int64x2# } *)
type t420 = { mutable a420 : t31 } (* { #{ int; int32# } } *)
type t421 = { mutable a421 : t31; mutable b421 : int } (* { #{ int; int32# }; int } *)
type t422 = { mutable a422 : t31; mutable b422 : int32# } (* { #{ int; int32# }; int32# } *)
type t423 = { mutable a423 : t33 } (* { #{ int; float } } *)
type t424 = { mutable a424 : t33; mutable b424 : int } (* { #{ int; float }; int } *)
type t425 = { mutable a425 : t33; mutable b425 : float } (* { #{ int; float }; float } *)
type t426 = { mutable a426 : t35 } (* { #{ int; int64x2# } } *)
type t427 = { mutable a427 : t35; mutable b427 : int } (* { #{ int; int64x2# }; int } *)
type t428 = { mutable a428 : t35; mutable b428 : int64x2# } (* { #{ int; int64x2# }; int64x2# } *)
type t429 = #{ a429 : int; b429 : t29 } (* #{ int; #{ int; int } } *)
type t430 = { mutable a430 : t429 } (* { #{ int; #{ int; int } } } *)
type t431 = #{ a431 : int; b431 : t31 } (* #{ int; #{ int; int32# } } *)
type t432 = { mutable a432 : t431 } (* { #{ int; #{ int; int32# } } } *)
type t433 = #{ a433 : int; b433 : t33 } (* #{ int; #{ int; float } } *)
type t434 = { mutable a434 : t433 } (* { #{ int; #{ int; float } } } *)
type t435 = #{ a435 : int; b435 : t35 } (* #{ int; #{ int; int64x2# } } *)
type t436 = { mutable a436 : t435 } (* { #{ int; #{ int; int64x2# } } } *)
type t437 = #{ a437 : int; b437 : t49 } (* #{ int; #{ int32#; int } } *)
type t438 = { mutable a438 : t437 } (* { #{ int; #{ int32#; int } } } *)
type t439 = #{ a439 : int; b439 : t51 } (* #{ int; #{ int32#; int32# } } *)
type t440 = { mutable a440 : t439 } (* { #{ int; #{ int32#; int32# } } } *)
type t441 = #{ a441 : int; b441 : t58 } (* #{ int; #{ float; int } } *)
type t442 = { mutable a442 : t441 } (* { #{ int; #{ float; int } } } *)
type t443 = #{ a443 : int; b443 : t60 } (* #{ int; #{ float; float } } *)
type t444 = { mutable a444 : t443 } (* { #{ int; #{ float; float } } } *)
type t445 = #{ a445 : int; b445 : t67 } (* #{ int; #{ int64x2#; int } } *)
type t446 = { mutable a446 : t445 } (* { #{ int; #{ int64x2#; int } } } *)
type t447 = #{ a447 : int; b447 : t69 } (* #{ int; #{ int64x2#; int64x2# } } *)
type t448 = { mutable a448 : t447 } (* { #{ int; #{ int64x2#; int64x2# } } } *)
type t449 = #{ a449 : int64; b449 : int64# } (* #{ int64; int64# } *)
type t450 = #{ a450 : int64#; b450 : float# } (* #{ int64#; float# } *)
type t451 = { mutable a451 : t449; mutable b451 : t450 } (* { #{ int64; int64# }; #{ int64#; float# } } *)
type t452 = #{ a452 : int64; b452 : string } (* #{ int64; string } *)
type t453 = #{ a453 : int64#; b453 : string } (* #{ int64#; string } *)
type t454 = { mutable a454 : t452; mutable b454 : t453 } (* { #{ int64; string }; #{ int64#; string } } *)
type t455 = #{ a455 : int64#; b455 : int64 } (* #{ int64#; int64 } *)
type t456 = #{ a456 : int64; b456 : int64 } (* #{ int64; int64 } *)
type t457 = { mutable a457 : t455; mutable b457 : t456 } (* { #{ int64#; int64 }; #{ int64; int64 } } *)
type t458 = #{ a458 : float32#; b458 : float } (* #{ float32#; float } *)
type t459 = { mutable a459 : t455; mutable b459 : t458 } (* { #{ int64#; int64 }; #{ float32#; float } } *)
type t460 = { mutable a460 : t39 } (* { #{ int32# } } *)
type t461 = { mutable a461 : t39; mutable b461 : int } (* { #{ int32# }; int } *)
type t462 = { mutable a462 : t39; mutable b462 : int32# } (* { #{ int32# }; int32# } *)
type t463 = { mutable a463 : t49 } (* { #{ int32#; int } } *)
type t464 = { mutable a464 : t49; mutable b464 : int } (* { #{ int32#; int }; int } *)
type t465 = { mutable a465 : t49; mutable b465 : int32# } (* { #{ int32#; int }; int32# } *)
type t466 = { mutable a466 : t51 } (* { #{ int32#; int32# } } *)
type t467 = { mutable a467 : t51; mutable b467 : int } (* { #{ int32#; int32# }; int } *)
type t468 = { mutable a468 : t51; mutable b468 : int32# } (* { #{ int32#; int32# }; int32# } *)
type t469 = #{ a469 : int32#; b469 : t29 } (* #{ int32#; #{ int; int } } *)
type t470 = { mutable a470 : t469 } (* { #{ int32#; #{ int; int } } } *)
type t471 = #{ a471 : int32#; b471 : t31 } (* #{ int32#; #{ int; int32# } } *)
type t472 = { mutable a472 : t471 } (* { #{ int32#; #{ int; int32# } } } *)
type t473 = #{ a473 : int32#; b473 : t49 } (* #{ int32#; #{ int32#; int } } *)
type t474 = { mutable a474 : t473 } (* { #{ int32#; #{ int32#; int } } } *)
type t475 = #{ a475 : int32#; b475 : t51 } (* #{ int32#; #{ int32#; int32# } } *)
type t476 = { mutable a476 : t475 } (* { #{ int32#; #{ int32#; int32# } } } *)
type t477 = { mutable a477 : t194; mutable b477 : string } (* { #{ unit_u }; string } *)
type t478 = { mutable a478 : t290; mutable b478 : string } (* { #{ unit_u; unit_u }; string } *)
type t479 = { mutable a479 : t184 } (* { #{ unit_u; string } } *)
type t480 = { mutable a480 : t184; mutable b480 : unit_u } (* { #{ unit_u; string }; unit_u } *)
type t481 = { mutable a481 : t184; mutable b481 : string } (* { #{ unit_u; string }; string } *)
type t482 = #{ a482 : unit_u; b482 : t184 } (* #{ unit_u; #{ unit_u; string } } *)
type t483 = { mutable a483 : t482 } (* { #{ unit_u; #{ unit_u; string } } } *)
type t484 = #{ a484 : unit_u; b484 : t190 } (* #{ unit_u; #{ string; unit_u } } *)
type t485 = { mutable a485 : t484 } (* { #{ unit_u; #{ string; unit_u } } } *)
type t486 = #{ a486 : unit_u; b486 : t192 } (* #{ unit_u; #{ string; string } } *)
type t487 = { mutable a487 : t486 } (* { #{ unit_u; #{ string; string } } } *)
type t488 = { mutable a488 : t42 } (* { #{ float } } *)
type t489 = { mutable a489 : t42; mutable b489 : int } (* { #{ float }; int } *)
type t490 = { mutable a490 : t42; mutable b490 : float } (* { #{ float }; float } *)
type t491 = { mutable a491 : t42; mutable b491 : float# } (* { #{ float }; float# } *)
type t492 = { mutable a492 : t58 } (* { #{ float; int } } *)
type t493 = { mutable a493 : t58; mutable b493 : int } (* { #{ float; int }; int } *)
type t494 = { mutable a494 : t58; mutable b494 : float } (* { #{ float; int }; float } *)
type t495 = { mutable a495 : t60 } (* { #{ float; float } } *)
type t496 = { mutable a496 : t60; mutable b496 : int } (* { #{ float; float }; int } *)
type t497 = { mutable a497 : t60; mutable b497 : float } (* { #{ float; float }; float } *)
type t498 = { mutable a498 : t60; mutable b498 : float# } (* { #{ float; float }; float# } *)
type t499 = { mutable a499 : t235 } (* { #{ float; float# } } *)
type t500 = { mutable a500 : t235; mutable b500 : float } (* { #{ float; float# }; float } *)
type t501 = { mutable a501 : t235; mutable b501 : float# } (* { #{ float; float# }; float# } *)
type t502 = #{ a502 : float; b502 : t29 } (* #{ float; #{ int; int } } *)
type t503 = { mutable a503 : t502 } (* { #{ float; #{ int; int } } } *)
type t504 = #{ a504 : float; b504 : t33 } (* #{ float; #{ int; float } } *)
type t505 = { mutable a505 : t504 } (* { #{ float; #{ int; float } } } *)
type t506 = #{ a506 : float; b506 : t58 } (* #{ float; #{ float; int } } *)
type t507 = { mutable a507 : t506 } (* { #{ float; #{ float; int } } } *)
type t508 = #{ a508 : float; b508 : t60 } (* #{ float; #{ float; float } } *)
type t509 = { mutable a509 : t508 } (* { #{ float; #{ float; float } } } *)
type t510 = #{ a510 : float; b510 : t235 } (* #{ float; #{ float; float# } } *)
type t511 = { mutable a511 : t510 } (* { #{ float; #{ float; float# } } } *)
type t512 = #{ a512 : float; b512 : t243 } (* #{ float; #{ float#; float } } *)
type t513 = { mutable a513 : t512 } (* { #{ float; #{ float#; float } } } *)
type t514 = #{ a514 : float; b514 : t245 } (* #{ float; #{ float#; float# } } *)
type t515 = { mutable a515 : t514 } (* { #{ float; #{ float#; float# } } } *)
type t516 = { mutable a516 : t239 } (* { #{ float# } } *)
type t517 = { mutable a517 : t239; mutable b517 : float } (* { #{ float# }; float } *)
type t518 = { mutable a518 : t239; mutable b518 : float# } (* { #{ float# }; float# } *)
type t519 = { mutable a519 : t243 } (* { #{ float#; float } } *)
type t520 = { mutable a520 : t243; mutable b520 : float } (* { #{ float#; float }; float } *)
type t521 = { mutable a521 : t243; mutable b521 : float# } (* { #{ float#; float }; float# } *)
type t522 = { mutable a522 : t245 } (* { #{ float#; float# } } *)
type t523 = { mutable a523 : t245; mutable b523 : float } (* { #{ float#; float# }; float } *)
type t524 = { mutable a524 : t245; mutable b524 : float# } (* { #{ float#; float# }; float# } *)
type t525 = #{ a525 : float#; b525 : t60 } (* #{ float#; #{ float; float } } *)
type t526 = { mutable a526 : t525 } (* { #{ float#; #{ float; float } } } *)
type t527 = #{ a527 : float#; b527 : t235 } (* #{ float#; #{ float; float# } } *)
type t528 = { mutable a528 : t527 } (* { #{ float#; #{ float; float# } } } *)
type t529 = #{ a529 : float#; b529 : t243 } (* #{ float#; #{ float#; float } } *)
type t530 = { mutable a530 : t529 } (* { #{ float#; #{ float#; float } } } *)
type t531 = #{ a531 : float#; b531 : t245 } (* #{ float#; #{ float#; float# } } *)
type t532 = { mutable a532 : t531 } (* { #{ float#; #{ float#; float# } } } *)
type t533 = #{ a533 : float32#; b533 : int64# } (* #{ float32#; int64# } *)
type t534 = #{ a534 : string; b534 : int64# } (* #{ string; int64# } *)
type t535 = { mutable a535 : t533; mutable b535 : t534 } (* { #{ float32#; int64# }; #{ string; int64# } } *)
type t536 = { mutable a536 : t186 } (* { #{ string } } *)
type t537 = { mutable a537 : t186; mutable b537 : unit_u } (* { #{ string }; unit_u } *)
type t538 = { mutable a538 : t186; mutable b538 : string } (* { #{ string }; string } *)
type t539 = { mutable a539 : t190 } (* { #{ string; unit_u } } *)
type t540 = { mutable a540 : t190; mutable b540 : unit_u } (* { #{ string; unit_u }; unit_u } *)
type t541 = { mutable a541 : t190; mutable b541 : string } (* { #{ string; unit_u }; string } *)
type t542 = { mutable a542 : t192 } (* { #{ string; string } } *)
type t543 = { mutable a543 : t192; mutable b543 : unit_u } (* { #{ string; string }; unit_u } *)
type t544 = { mutable a544 : t192; mutable b544 : string } (* { #{ string; string }; string } *)
type t545 = #{ a545 : string; b545 : t290 } (* #{ string; #{ unit_u; unit_u } } *)
type t546 = { mutable a546 : t545 } (* { #{ string; #{ unit_u; unit_u } } } *)
type t547 = #{ a547 : string; b547 : t184 } (* #{ string; #{ unit_u; string } } *)
type t548 = { mutable a548 : t547 } (* { #{ string; #{ unit_u; string } } } *)
type t549 = #{ a549 : string; b549 : t190 } (* #{ string; #{ string; unit_u } } *)
type t550 = { mutable a550 : t549 } (* { #{ string; #{ string; unit_u } } } *)
type t551 = #{ a551 : string; b551 : t192 } (* #{ string; #{ string; string } } *)
type t552 = { mutable a552 : t551 } (* { #{ string; #{ string; string } } } *)
type t553 = { mutable a553 : t45 } (* { #{ int64x2# } } *)
type t554 = { mutable a554 : t45; mutable b554 : int } (* { #{ int64x2# }; int } *)
type t555 = { mutable a555 : t45; mutable b555 : int64x2# } (* { #{ int64x2# }; int64x2# } *)
type t556 = { mutable a556 : t67 } (* { #{ int64x2#; int } } *)
type t557 = { mutable a557 : t67; mutable b557 : int } (* { #{ int64x2#; int }; int } *)
type t558 = { mutable a558 : t67; mutable b558 : int64x2# } (* { #{ int64x2#; int }; int64x2# } *)
type t559 = #{ a559 : int64x2#; b559 : string } (* #{ int64x2#; string } *)
type t560 = #{ a560 : int64; b560 : float# } (* #{ int64; float# } *)
type t561 = { mutable a561 : t559; mutable b561 : t560 } (* { #{ int64x2#; string }; #{ int64; float# } } *)
type t562 = { mutable a562 : t69 } (* { #{ int64x2#; int64x2# } } *)
type t563 = { mutable a563 : t69; mutable b563 : int } (* { #{ int64x2#; int64x2# }; int } *)
type t564 = { mutable a564 : t69; mutable b564 : int64x2# } (* { #{ int64x2#; int64x2# }; int64x2# } *)
type t565 = #{ a565 : int64x2#; b565 : t29 } (* #{ int64x2#; #{ int; int } } *)
type t566 = { mutable a566 : t565 } (* { #{ int64x2#; #{ int; int } } } *)
type t567 = #{ a567 : int64x2#; b567 : t35 } (* #{ int64x2#; #{ int; int64x2# } } *)
type t568 = { mutable a568 : t567 } (* { #{ int64x2#; #{ int; int64x2# } } } *)
type t569 = #{ a569 : int64x2#; b569 : t67 } (* #{ int64x2#; #{ int64x2#; int } } *)
type t570 = { mutable a570 : t569 } (* { #{ int64x2#; #{ int64x2#; int } } } *)
type t571 = #{ a571 : int64x2#; b571 : t69 } (* #{ int64x2#; #{ int64x2#; int64x2# } } *)
type t572 = { mutable a572 : t571 } (* { #{ int64x2#; #{ int64x2#; int64x2# } } } *)
type t573 = #{ a573 : t29; b573 : int } (* #{ #{ int; int }; int } *)
type t574 = { mutable a574 : t573 } (* { #{ #{ int; int }; int } } *)
type t575 = #{ a575 : t29; b575 : int32# } (* #{ #{ int; int }; int32# } *)
type t576 = { mutable a576 : t575 } (* { #{ #{ int; int }; int32# } } *)
type t577 = #{ a577 : t29; b577 : float } (* #{ #{ int; int }; float } *)
type t578 = { mutable a578 : t577 } (* { #{ #{ int; int }; float } } *)
type t579 = #{ a579 : t29; b579 : int64x2# } (* #{ #{ int; int }; int64x2# } *)
type t580 = { mutable a580 : t579 } (* { #{ #{ int; int }; int64x2# } } *)
type t581 = #{ a581 : t31; b581 : int } (* #{ #{ int; int32# }; int } *)
type t582 = { mutable a582 : t581 } (* { #{ #{ int; int32# }; int } } *)
type t583 = #{ a583 : t31; b583 : int32# } (* #{ #{ int; int32# }; int32# } *)
type t584 = { mutable a584 : t583 } (* { #{ #{ int; int32# }; int32# } } *)
type t585 = #{ a585 : t33; b585 : int } (* #{ #{ int; float }; int } *)
type t586 = { mutable a586 : t585 } (* { #{ #{ int; float }; int } } *)
type t587 = #{ a587 : t33; b587 : float } (* #{ #{ int; float }; float } *)
type t588 = { mutable a588 : t587 } (* { #{ #{ int; float }; float } } *)
type t589 = #{ a589 : t35; b589 : int } (* #{ #{ int; int64x2# }; int } *)
type t590 = { mutable a590 : t589 } (* { #{ #{ int; int64x2# }; int } } *)
type t591 = #{ a591 : t35; b591 : int64x2# } (* #{ #{ int; int64x2# }; int64x2# } *)
type t592 = { mutable a592 : t591 } (* { #{ #{ int; int64x2# }; int64x2# } } *)
type t593 = #{ a593 : t49; b593 : int } (* #{ #{ int32#; int }; int } *)
type t594 = { mutable a594 : t593 } (* { #{ #{ int32#; int }; int } } *)
type t595 = #{ a595 : t49; b595 : int32# } (* #{ #{ int32#; int }; int32# } *)
type t596 = { mutable a596 : t595 } (* { #{ #{ int32#; int }; int32# } } *)
type t597 = #{ a597 : t51; b597 : int } (* #{ #{ int32#; int32# }; int } *)
type t598 = { mutable a598 : t597 } (* { #{ #{ int32#; int32# }; int } } *)
type t599 = #{ a599 : t51; b599 : int32# } (* #{ #{ int32#; int32# }; int32# } *)
type t600 = { mutable a600 : t599 } (* { #{ #{ int32#; int32# }; int32# } } *)
type t601 = #{ a601 : t290; b601 : string } (* #{ #{ unit_u; unit_u }; string } *)
type t602 = { mutable a602 : t601 } (* { #{ #{ unit_u; unit_u }; string } } *)
type t603 = #{ a603 : t184; b603 : unit_u } (* #{ #{ unit_u; string }; unit_u } *)
type t604 = { mutable a604 : t603 } (* { #{ #{ unit_u; string }; unit_u } } *)
type t605 = #{ a605 : t184; b605 : string } (* #{ #{ unit_u; string }; string } *)
type t606 = { mutable a606 : t605 } (* { #{ #{ unit_u; string }; string } } *)
type t607 = #{ a607 : t58; b607 : int } (* #{ #{ float; int }; int } *)
type t608 = { mutable a608 : t607 } (* { #{ #{ float; int }; int } } *)
type t609 = #{ a609 : t58; b609 : float } (* #{ #{ float; int }; float } *)
type t610 = { mutable a610 : t609 } (* { #{ #{ float; int }; float } } *)
type t611 = #{ a611 : t60; b611 : int } (* #{ #{ float; float }; int } *)
type t612 = { mutable a612 : t611 } (* { #{ #{ float; float }; int } } *)
type t613 = #{ a613 : t60; b613 : float } (* #{ #{ float; float }; float } *)
type t614 = { mutable a614 : t613 } (* { #{ #{ float; float }; float } } *)
type t615 = #{ a615 : t60; b615 : float# } (* #{ #{ float; float }; float# } *)
type t616 = { mutable a616 : t615 } (* { #{ #{ float; float }; float# } } *)
type t617 = #{ a617 : t235; b617 : float } (* #{ #{ float; float# }; float } *)
type t618 = { mutable a618 : t617 } (* { #{ #{ float; float# }; float } } *)
type t619 = #{ a619 : t235; b619 : float# } (* #{ #{ float; float# }; float# } *)
type t620 = { mutable a620 : t619 } (* { #{ #{ float; float# }; float# } } *)
type t621 = #{ a621 : t243; b621 : float } (* #{ #{ float#; float }; float } *)
type t622 = { mutable a622 : t621 } (* { #{ #{ float#; float }; float } } *)
type t623 = #{ a623 : t243; b623 : float# } (* #{ #{ float#; float }; float# } *)
type t624 = { mutable a624 : t623 } (* { #{ #{ float#; float }; float# } } *)
type t625 = #{ a625 : t245; b625 : float } (* #{ #{ float#; float# }; float } *)
type t626 = { mutable a626 : t625 } (* { #{ #{ float#; float# }; float } } *)
type t627 = #{ a627 : t245; b627 : float# } (* #{ #{ float#; float# }; float# } *)
type t628 = { mutable a628 : t627 } (* { #{ #{ float#; float# }; float# } } *)
type t629 = #{ a629 : t190; b629 : unit_u } (* #{ #{ string; unit_u }; unit_u } *)
type t630 = { mutable a630 : t629 } (* { #{ #{ string; unit_u }; unit_u } } *)
type t631 = #{ a631 : t190; b631 : string } (* #{ #{ string; unit_u }; string } *)
type t632 = { mutable a632 : t631 } (* { #{ #{ string; unit_u }; string } } *)
type t633 = #{ a633 : t192; b633 : unit_u } (* #{ #{ string; string }; unit_u } *)
type t634 = { mutable a634 : t633 } (* { #{ #{ string; string }; unit_u } } *)
type t635 = #{ a635 : t192; b635 : string } (* #{ #{ string; string }; string } *)
type t636 = { mutable a636 : t635 } (* { #{ #{ string; string }; string } } *)
type t637 = #{ a637 : t67; b637 : int } (* #{ #{ int64x2#; int }; int } *)
type t638 = { mutable a638 : t637 } (* { #{ #{ int64x2#; int }; int } } *)
type t639 = #{ a639 : t67; b639 : int64x2# } (* #{ #{ int64x2#; int }; int64x2# } *)
type t640 = { mutable a640 : t639 } (* { #{ #{ int64x2#; int }; int64x2# } } *)
type t641 = #{ a641 : t69; b641 : int } (* #{ #{ int64x2#; int64x2# }; int } *)
type t642 = { mutable a642 : t641 } (* { #{ #{ int64x2#; int64x2# }; int } } *)
type t643 = #{ a643 : t69; b643 : int64x2# } (* #{ #{ int64x2#; int64x2# }; int64x2# } *)
type t644 = { mutable a644 : t643 } (* { #{ #{ int64x2#; int64x2# }; int64x2# } } *)

let to_run () =
  (********************)
  (*   t0 = { int }   *)
  (********************)
  let r = { a0 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 1;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01 } { a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let next_r = { a0 = 100 } in
  let r_expected = { a0 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 2;
  let test = eq r r_expected in
  if not test then failwithf "test 2 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 3;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 3 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0 } = r in
  let expected_a0 = 100 in
  mark_test_run 4;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 4 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t1 = { int; int }   *)
  (*************************)
  let r = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 5;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 5 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 6;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 6 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let next_r = { a1 = 100; b1 = 101 } in
  let r_expected = { a1 = 0; b1 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 7;
  let test = eq r r_expected in
  if not test then failwithf "test 7 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 8;
  let test = eq r r_expected in
  if not test then failwithf "test 8 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 9;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 9 failed";
  let expected_b1 = 101 in
  mark_test_run 10;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 10 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = 100 in
  mark_test_run 11;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 11 failed";
  let expected_b1 = 101 in
  mark_test_run 12;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 12 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t2 = { int; int; int }   *)
  (******************************)
  let r = { a2 = 0; b2 = 1; c2 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a2 *)
  let actual = r.a2 in
  let expected = 0 in
  mark_test_run 13;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 13 failed";
  (* Paths of depth 1 *)
  (* .b2 *)
  let actual = r.b2 in
  let expected = 1 in
  mark_test_run 14;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 14 failed";
  (* Paths of depth 1 *)
  (* .c2 *)
  let actual = r.c2 in
  let expected = 2 in
  mark_test_run 15;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 15 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a2 = a21; b2 = b21; c2 = c21 } { a2 = a22; b2 = b22; c2 = c22 } -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let next_r = { a2 = 100; b2 = 101; c2 = 102 } in
  let r_expected = { a2 = 0; b2 = 1; c2 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a2 *)
  r.a2 <- next_r.a2;
  let r_expected = { r_expected with a2 = next_r.a2 } in
  mark_test_run 16;
  let test = eq r r_expected in
  if not test then failwithf "test 16 failed";
  Gc.compact ();
  (* .b2 *)
  r.b2 <- next_r.b2;
  let r_expected = { r_expected with b2 = next_r.b2 } in
  mark_test_run 17;
  let test = eq r r_expected in
  if not test then failwithf "test 17 failed";
  Gc.compact ();
  (* .c2 *)
  r.c2 <- next_r.c2;
  let r_expected = { r_expected with c2 = next_r.c2 } in
  mark_test_run 18;
  let test = eq r r_expected in
  if not test then failwithf "test 18 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a2; b2; c2 } = r in
  let expected_a2 = 100 in
  mark_test_run 19;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 19 failed";
  let expected_b2 = 101 in
  mark_test_run 20;
  let test = (fun a b -> Int.equal a b) expected_b2 b2 in
  if not test then failwithf "test 20 failed";
  let expected_c2 = 102 in
  mark_test_run 21;
  let test = (fun a b -> Int.equal a b) expected_c2 c2 in
  if not test then failwithf "test 21 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a2; b2; c2 } = r in
  let expected_a2 = 100 in
  mark_test_run 22;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 22 failed";
  let expected_b2 = 101 in
  mark_test_run 23;
  let test = (fun a b -> Int.equal a b) expected_b2 b2 in
  if not test then failwithf "test 23 failed";
  let expected_c2 = 102 in
  mark_test_run 24;
  let test = (fun a b -> Int.equal a b) expected_c2 c2 in
  if not test then failwithf "test 24 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t3 = { int; int; int32# }   *)
  (*********************************)
  let r = { a3 = 0; b3 = 1; c3 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = 0 in
  mark_test_run 25;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 25 failed";
  (* Paths of depth 1 *)
  (* .b3 *)
  let actual = r.b3 in
  let expected = 1 in
  mark_test_run 26;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 26 failed";
  (* Paths of depth 1 *)
  (* .c3 *)
  let actual = r.c3 in
  let expected = #2l in
  mark_test_run 27;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 27 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31; b3 = b31; c3 = c31 } { a3 = a32; b3 = b32; c3 = c32 } -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let next_r = { a3 = 100; b3 = 101; c3 = #102l } in
  let r_expected = { a3 = 0; b3 = 1; c3 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 28;
  let test = eq r r_expected in
  if not test then failwithf "test 28 failed";
  Gc.compact ();
  (* .b3 *)
  r.b3 <- next_r.b3;
  let r_expected = { r_expected with b3 = next_r.b3 } in
  mark_test_run 29;
  let test = eq r r_expected in
  if not test then failwithf "test 29 failed";
  Gc.compact ();
  (* .c3 *)
  r.c3 <- next_r.c3;
  let r_expected = { r_expected with c3 = next_r.c3 } in
  mark_test_run 30;
  let test = eq r r_expected in
  if not test then failwithf "test 30 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3; b3; c3 } = r in
  let expected_a3 = 100 in
  mark_test_run 31;
  let test = (fun a b -> Int.equal a b) expected_a3 a3 in
  if not test then failwithf "test 31 failed";
  let expected_b3 = 101 in
  mark_test_run 32;
  let test = (fun a b -> Int.equal a b) expected_b3 b3 in
  if not test then failwithf "test 32 failed";
  let expected_c3 = #102l in
  mark_test_run 33;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c3 c3 in
  if not test then failwithf "test 33 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3; b3; c3 } = r in
  let expected_a3 = 100 in
  mark_test_run 34;
  let test = (fun a b -> Int.equal a b) expected_a3 a3 in
  if not test then failwithf "test 34 failed";
  let expected_b3 = 101 in
  mark_test_run 35;
  let test = (fun a b -> Int.equal a b) expected_b3 b3 in
  if not test then failwithf "test 35 failed";
  let expected_c3 = #102l in
  mark_test_run 36;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c3 c3 in
  if not test then failwithf "test 36 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t4 = { int; int; float }   *)
  (********************************)
  let r = { a4 = 0; b4 = 1; c4 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a4 *)
  let actual = r.a4 in
  let expected = 0 in
  mark_test_run 37;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 37 failed";
  (* Paths of depth 1 *)
  (* .b4 *)
  let actual = r.b4 in
  let expected = 1 in
  mark_test_run 38;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 38 failed";
  (* Paths of depth 1 *)
  (* .c4 *)
  let actual = r.c4 in
  let expected = 2. in
  mark_test_run 39;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 39 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a4 = a41; b4 = b41; c4 = c41 } { a4 = a42; b4 = b42; c4 = c42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let next_r = { a4 = 100; b4 = 101; c4 = 102. } in
  let r_expected = { a4 = 0; b4 = 1; c4 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a4 *)
  r.a4 <- next_r.a4;
  let r_expected = { r_expected with a4 = next_r.a4 } in
  mark_test_run 40;
  let test = eq r r_expected in
  if not test then failwithf "test 40 failed";
  Gc.compact ();
  (* .b4 *)
  r.b4 <- next_r.b4;
  let r_expected = { r_expected with b4 = next_r.b4 } in
  mark_test_run 41;
  let test = eq r r_expected in
  if not test then failwithf "test 41 failed";
  Gc.compact ();
  (* .c4 *)
  r.c4 <- next_r.c4;
  let r_expected = { r_expected with c4 = next_r.c4 } in
  mark_test_run 42;
  let test = eq r r_expected in
  if not test then failwithf "test 42 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a4; b4; c4 } = r in
  let expected_a4 = 100 in
  mark_test_run 43;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 43 failed";
  let expected_b4 = 101 in
  mark_test_run 44;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 44 failed";
  let expected_c4 = 102. in
  mark_test_run 45;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c4 c4 in
  if not test then failwithf "test 45 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a4; b4; c4 } = r in
  let expected_a4 = 100 in
  mark_test_run 46;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 46 failed";
  let expected_b4 = 101 in
  mark_test_run 47;
  let test = (fun a b -> Int.equal a b) expected_b4 b4 in
  if not test then failwithf "test 47 failed";
  let expected_c4 = 102. in
  mark_test_run 48;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c4 c4 in
  if not test then failwithf "test 48 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t5 = { int; int; int64x2# }   *)
  (***********************************)
  let r = { a5 = 0; b5 = 1; c5 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = 0 in
  mark_test_run 49;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 49 failed";
  (* Paths of depth 1 *)
  (* .b5 *)
  let actual = r.b5 in
  let expected = 1 in
  mark_test_run 50;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 50 failed";
  (* Paths of depth 1 *)
  (* .c5 *)
  let actual = r.c5 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 51;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 51 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51; b5 = b51; c5 = c51 } { a5 = a52; b5 = b52; c5 = c52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52 && int64x2_u_equal c51 c52) in
  let next_r = { a5 = 100; b5 = 101; c5 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  let r_expected = { a5 = 0; b5 = 1; c5 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 52;
  let test = eq r r_expected in
  if not test then failwithf "test 52 failed";
  Gc.compact ();
  (* .b5 *)
  r.b5 <- next_r.b5;
  let r_expected = { r_expected with b5 = next_r.b5 } in
  mark_test_run 53;
  let test = eq r r_expected in
  if not test then failwithf "test 53 failed";
  Gc.compact ();
  (* .c5 *)
  r.c5 <- next_r.c5;
  let r_expected = { r_expected with c5 = next_r.c5 } in
  mark_test_run 54;
  let test = eq r r_expected in
  if not test then failwithf "test 54 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5; b5; c5 } = r in
  let expected_a5 = 100 in
  mark_test_run 55;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 55 failed";
  let expected_b5 = 101 in
  mark_test_run 56;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 56 failed";
  let expected_c5 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 57;
  let test = int64x2_u_equal expected_c5 c5 in
  if not test then failwithf "test 57 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5; b5; c5 } = r in
  let expected_a5 = 100 in
  mark_test_run 58;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 58 failed";
  let expected_b5 = 101 in
  mark_test_run 59;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 59 failed";
  let expected_c5 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 60;
  let test = int64x2_u_equal expected_c5 c5 in
  if not test then failwithf "test 60 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************)
  (*   t6 = { int; int64 }   *)
  (***************************)
  let r = { a6 = 0; b6 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 61;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 61 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = 1L in
  mark_test_run 62;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 62 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61 } { a6 = a62; b6 = b62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int64.equal (globalize a) (globalize b)) b61 b62) in
  let next_r = { a6 = 100; b6 = 101L } in
  let r_expected = { a6 = 0; b6 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 63;
  let test = eq r r_expected in
  if not test then failwithf "test 63 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 64;
  let test = eq r r_expected in
  if not test then failwithf "test 64 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6 } = r in
  let expected_a6 = 100 in
  mark_test_run 65;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 65 failed";
  let expected_b6 = 101L in
  mark_test_run 66;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b6 b6 in
  if not test then failwithf "test 66 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6 } = r in
  let expected_a6 = 100 in
  mark_test_run 67;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 67 failed";
  let expected_b6 = 101L in
  mark_test_run 68;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b6 b6 in
  if not test then failwithf "test 68 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t7 = { int; int64# }   *)
  (****************************)
  let r = { a7 = 0; b7 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = 0 in
  mark_test_run 69;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 69 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #1L in
  mark_test_run 70;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 70 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b71 b72) in
  let next_r = { a7 = 100; b7 = #101L } in
  let r_expected = { a7 = 0; b7 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 71;
  let test = eq r r_expected in
  if not test then failwithf "test 71 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 72;
  let test = eq r r_expected in
  if not test then failwithf "test 72 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 73;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 73 failed";
  let expected_b7 = #101L in
  mark_test_run 74;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b7 b7 in
  if not test then failwithf "test 74 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = 100 in
  mark_test_run 75;
  let test = (fun a b -> Int.equal a b) expected_a7 a7 in
  if not test then failwithf "test 75 failed";
  let expected_b7 = #101L in
  mark_test_run 76;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b7 b7 in
  if not test then failwithf "test 76 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t8 = { int; int32# }   *)
  (****************************)
  let r = { a8 = 0; b8 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 77;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 77 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #1l in
  mark_test_run 78;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 78 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b81 b82) in
  let next_r = { a8 = 100; b8 = #101l } in
  let r_expected = { a8 = 0; b8 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 79;
  let test = eq r r_expected in
  if not test then failwithf "test 79 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 80;
  let test = eq r r_expected in
  if not test then failwithf "test 80 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 81;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 81 failed";
  let expected_b8 = #101l in
  mark_test_run 82;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b8 b8 in
  if not test then failwithf "test 82 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 83;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 83 failed";
  let expected_b8 = #101l in
  mark_test_run 84;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b8 b8 in
  if not test then failwithf "test 84 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t9 = { int; int32#; int }   *)
  (*********************************)
  let r = { a9 = 0; b9 = #1l; c9 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = 0 in
  mark_test_run 85;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 85 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = #1l in
  mark_test_run 86;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 86 failed";
  (* Paths of depth 1 *)
  (* .c9 *)
  let actual = r.c9 in
  let expected = 2 in
  mark_test_run 87;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 87 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91; c9 = c91 } { a9 = a92; b9 = b92; c9 = c92 } -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b91 b92 && (fun a b -> Int.equal a b) c91 c92) in
  let next_r = { a9 = 100; b9 = #101l; c9 = 102 } in
  let r_expected = { a9 = 0; b9 = #1l; c9 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 88;
  let test = eq r r_expected in
  if not test then failwithf "test 88 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 89;
  let test = eq r r_expected in
  if not test then failwithf "test 89 failed";
  Gc.compact ();
  (* .c9 *)
  r.c9 <- next_r.c9;
  let r_expected = { r_expected with c9 = next_r.c9 } in
  mark_test_run 90;
  let test = eq r r_expected in
  if not test then failwithf "test 90 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9; b9; c9 } = r in
  let expected_a9 = 100 in
  mark_test_run 91;
  let test = (fun a b -> Int.equal a b) expected_a9 a9 in
  if not test then failwithf "test 91 failed";
  let expected_b9 = #101l in
  mark_test_run 92;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b9 b9 in
  if not test then failwithf "test 92 failed";
  let expected_c9 = 102 in
  mark_test_run 93;
  let test = (fun a b -> Int.equal a b) expected_c9 c9 in
  if not test then failwithf "test 93 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9; c9 } = r in
  let expected_a9 = 100 in
  mark_test_run 94;
  let test = (fun a b -> Int.equal a b) expected_a9 a9 in
  if not test then failwithf "test 94 failed";
  let expected_b9 = #101l in
  mark_test_run 95;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b9 b9 in
  if not test then failwithf "test 95 failed";
  let expected_c9 = 102 in
  mark_test_run 96;
  let test = (fun a b -> Int.equal a b) expected_c9 c9 in
  if not test then failwithf "test 96 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t10 = { int; int32#; int32# }   *)
  (*************************************)
  let r = { a10 = 0; b10 = #1l; c10 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = 0 in
  mark_test_run 97;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 97 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = #1l in
  mark_test_run 98;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 98 failed";
  (* Paths of depth 1 *)
  (* .c10 *)
  let actual = r.c10 in
  let expected = #2l in
  mark_test_run 99;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 99 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101; c10 = c101 } { a10 = a102; b10 = b102; c10 = c102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b101 b102 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c101 c102) in
  let next_r = { a10 = 100; b10 = #101l; c10 = #102l } in
  let r_expected = { a10 = 0; b10 = #1l; c10 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 100;
  let test = eq r r_expected in
  if not test then failwithf "test 100 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 101;
  let test = eq r r_expected in
  if not test then failwithf "test 101 failed";
  Gc.compact ();
  (* .c10 *)
  r.c10 <- next_r.c10;
  let r_expected = { r_expected with c10 = next_r.c10 } in
  mark_test_run 102;
  let test = eq r r_expected in
  if not test then failwithf "test 102 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10; b10; c10 } = r in
  let expected_a10 = 100 in
  mark_test_run 103;
  let test = (fun a b -> Int.equal a b) expected_a10 a10 in
  if not test then failwithf "test 103 failed";
  let expected_b10 = #101l in
  mark_test_run 104;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b10 b10 in
  if not test then failwithf "test 104 failed";
  let expected_c10 = #102l in
  mark_test_run 105;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c10 c10 in
  if not test then failwithf "test 105 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10; c10 } = r in
  let expected_a10 = 100 in
  mark_test_run 106;
  let test = (fun a b -> Int.equal a b) expected_a10 a10 in
  if not test then failwithf "test 106 failed";
  let expected_b10 = #101l in
  mark_test_run 107;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b10 b10 in
  if not test then failwithf "test 107 failed";
  let expected_c10 = #102l in
  mark_test_run 108;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c10 c10 in
  if not test then failwithf "test 108 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t11 = { int; nativeint# }   *)
  (*********************************)
  let r = { a11 = 0; b11 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a11 *)
  let actual = r.a11 in
  let expected = 0 in
  mark_test_run 109;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 109 failed";
  (* Paths of depth 1 *)
  (* .b11 *)
  let actual = r.b11 in
  let expected = #1n in
  mark_test_run 110;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 110 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a11 = a111; b11 = b111 } { a11 = a112; b11 = b112 } -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b111 b112) in
  let next_r = { a11 = 100; b11 = #101n } in
  let r_expected = { a11 = 0; b11 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a11 *)
  r.a11 <- next_r.a11;
  let r_expected = { r_expected with a11 = next_r.a11 } in
  mark_test_run 111;
  let test = eq r r_expected in
  if not test then failwithf "test 111 failed";
  Gc.compact ();
  (* .b11 *)
  r.b11 <- next_r.b11;
  let r_expected = { r_expected with b11 = next_r.b11 } in
  mark_test_run 112;
  let test = eq r r_expected in
  if not test then failwithf "test 112 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a11; b11 } = r in
  let expected_a11 = 100 in
  mark_test_run 113;
  let test = (fun a b -> Int.equal a b) expected_a11 a11 in
  if not test then failwithf "test 113 failed";
  let expected_b11 = #101n in
  mark_test_run 114;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b11 b11 in
  if not test then failwithf "test 114 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a11; b11 } = r in
  let expected_a11 = 100 in
  mark_test_run 115;
  let test = (fun a b -> Int.equal a b) expected_a11 a11 in
  if not test then failwithf "test 115 failed";
  let expected_b11 = #101n in
  mark_test_run 116;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b11 b11 in
  if not test then failwithf "test 116 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t12 = { int; unit_u }   *)
  (*****************************)
  let r = { a12 = 0; b12 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a12 *)
  let actual = r.a12 in
  let expected = 0 in
  mark_test_run 117;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 117 failed";
  (* Paths of depth 1 *)
  (* .b12 *)
  let actual = r.b12 in
  let expected = (unbox_unit ()) in
  mark_test_run 118;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 118 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a12 = a121; b12 = b121 } { a12 = a122; b12 = b122 } -> (fun a b -> Int.equal a b) a121 a122 && (fun _ _ -> true) b121 b122) in
  let next_r = { a12 = 100; b12 = (unbox_unit ()) } in
  let r_expected = { a12 = 0; b12 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a12 *)
  r.a12 <- next_r.a12;
  let r_expected = { r_expected with a12 = next_r.a12 } in
  mark_test_run 119;
  let test = eq r r_expected in
  if not test then failwithf "test 119 failed";
  Gc.compact ();
  (* .b12 *)
  r.b12 <- next_r.b12;
  let r_expected = { r_expected with b12 = next_r.b12 } in
  mark_test_run 120;
  let test = eq r r_expected in
  if not test then failwithf "test 120 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a12; b12 } = r in
  let expected_a12 = 100 in
  mark_test_run 121;
  let test = (fun a b -> Int.equal a b) expected_a12 a12 in
  if not test then failwithf "test 121 failed";
  let expected_b12 = (unbox_unit ()) in
  mark_test_run 122;
  let test = (fun _ _ -> true) expected_b12 b12 in
  if not test then failwithf "test 122 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a12; b12 } = r in
  let expected_a12 = 100 in
  mark_test_run 123;
  let test = (fun a b -> Int.equal a b) expected_a12 a12 in
  if not test then failwithf "test 123 failed";
  let expected_b12 = (unbox_unit ()) in
  mark_test_run 124;
  let test = (fun _ _ -> true) expected_b12 b12 in
  if not test then failwithf "test 124 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t13 = { int; float }   *)
  (****************************)
  let r = { a13 = 0; b13 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a13 *)
  let actual = r.a13 in
  let expected = 0 in
  mark_test_run 125;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 125 failed";
  (* Paths of depth 1 *)
  (* .b13 *)
  let actual = r.b13 in
  let expected = 1. in
  mark_test_run 126;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 126 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a13 = a131; b13 = b131 } { a13 = a132; b13 = b132 } -> (fun a b -> Int.equal a b) a131 a132 && (fun a b -> Float.equal (globalize a) (globalize b)) b131 b132) in
  let next_r = { a13 = 100; b13 = 101. } in
  let r_expected = { a13 = 0; b13 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a13 *)
  r.a13 <- next_r.a13;
  let r_expected = { r_expected with a13 = next_r.a13 } in
  mark_test_run 127;
  let test = eq r r_expected in
  if not test then failwithf "test 127 failed";
  Gc.compact ();
  (* .b13 *)
  r.b13 <- next_r.b13;
  let r_expected = { r_expected with b13 = next_r.b13 } in
  mark_test_run 128;
  let test = eq r r_expected in
  if not test then failwithf "test 128 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a13; b13 } = r in
  let expected_a13 = 100 in
  mark_test_run 129;
  let test = (fun a b -> Int.equal a b) expected_a13 a13 in
  if not test then failwithf "test 129 failed";
  let expected_b13 = 101. in
  mark_test_run 130;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b13 b13 in
  if not test then failwithf "test 130 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a13; b13 } = r in
  let expected_a13 = 100 in
  mark_test_run 131;
  let test = (fun a b -> Int.equal a b) expected_a13 a13 in
  if not test then failwithf "test 131 failed";
  let expected_b13 = 101. in
  mark_test_run 132;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b13 b13 in
  if not test then failwithf "test 132 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t14 = { int; float; int }   *)
  (*********************************)
  let r = { a14 = 0; b14 = 1.; c14 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a14 *)
  let actual = r.a14 in
  let expected = 0 in
  mark_test_run 133;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 133 failed";
  (* Paths of depth 1 *)
  (* .b14 *)
  let actual = r.b14 in
  let expected = 1. in
  mark_test_run 134;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 134 failed";
  (* Paths of depth 1 *)
  (* .c14 *)
  let actual = r.c14 in
  let expected = 2 in
  mark_test_run 135;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 135 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a14 = a141; b14 = b141; c14 = c141 } { a14 = a142; b14 = b142; c14 = c142 } -> (fun a b -> Int.equal a b) a141 a142 && (fun a b -> Float.equal (globalize a) (globalize b)) b141 b142 && (fun a b -> Int.equal a b) c141 c142) in
  let next_r = { a14 = 100; b14 = 101.; c14 = 102 } in
  let r_expected = { a14 = 0; b14 = 1.; c14 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a14 *)
  r.a14 <- next_r.a14;
  let r_expected = { r_expected with a14 = next_r.a14 } in
  mark_test_run 136;
  let test = eq r r_expected in
  if not test then failwithf "test 136 failed";
  Gc.compact ();
  (* .b14 *)
  r.b14 <- next_r.b14;
  let r_expected = { r_expected with b14 = next_r.b14 } in
  mark_test_run 137;
  let test = eq r r_expected in
  if not test then failwithf "test 137 failed";
  Gc.compact ();
  (* .c14 *)
  r.c14 <- next_r.c14;
  let r_expected = { r_expected with c14 = next_r.c14 } in
  mark_test_run 138;
  let test = eq r r_expected in
  if not test then failwithf "test 138 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a14; b14; c14 } = r in
  let expected_a14 = 100 in
  mark_test_run 139;
  let test = (fun a b -> Int.equal a b) expected_a14 a14 in
  if not test then failwithf "test 139 failed";
  let expected_b14 = 101. in
  mark_test_run 140;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b14 b14 in
  if not test then failwithf "test 140 failed";
  let expected_c14 = 102 in
  mark_test_run 141;
  let test = (fun a b -> Int.equal a b) expected_c14 c14 in
  if not test then failwithf "test 141 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a14; b14; c14 } = r in
  let expected_a14 = 100 in
  mark_test_run 142;
  let test = (fun a b -> Int.equal a b) expected_a14 a14 in
  if not test then failwithf "test 142 failed";
  let expected_b14 = 101. in
  mark_test_run 143;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b14 b14 in
  if not test then failwithf "test 143 failed";
  let expected_c14 = 102 in
  mark_test_run 144;
  let test = (fun a b -> Int.equal a b) expected_c14 c14 in
  if not test then failwithf "test 144 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t15 = { int; float; float }   *)
  (***********************************)
  let r = { a15 = 0; b15 = 1.; c15 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a15 *)
  let actual = r.a15 in
  let expected = 0 in
  mark_test_run 145;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 145 failed";
  (* Paths of depth 1 *)
  (* .b15 *)
  let actual = r.b15 in
  let expected = 1. in
  mark_test_run 146;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 146 failed";
  (* Paths of depth 1 *)
  (* .c15 *)
  let actual = r.c15 in
  let expected = 2. in
  mark_test_run 147;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 147 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a15 = a151; b15 = b151; c15 = c151 } { a15 = a152; b15 = b152; c15 = c152 } -> (fun a b -> Int.equal a b) a151 a152 && (fun a b -> Float.equal (globalize a) (globalize b)) b151 b152 && (fun a b -> Float.equal (globalize a) (globalize b)) c151 c152) in
  let next_r = { a15 = 100; b15 = 101.; c15 = 102. } in
  let r_expected = { a15 = 0; b15 = 1.; c15 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a15 *)
  r.a15 <- next_r.a15;
  let r_expected = { r_expected with a15 = next_r.a15 } in
  mark_test_run 148;
  let test = eq r r_expected in
  if not test then failwithf "test 148 failed";
  Gc.compact ();
  (* .b15 *)
  r.b15 <- next_r.b15;
  let r_expected = { r_expected with b15 = next_r.b15 } in
  mark_test_run 149;
  let test = eq r r_expected in
  if not test then failwithf "test 149 failed";
  Gc.compact ();
  (* .c15 *)
  r.c15 <- next_r.c15;
  let r_expected = { r_expected with c15 = next_r.c15 } in
  mark_test_run 150;
  let test = eq r r_expected in
  if not test then failwithf "test 150 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a15; b15; c15 } = r in
  let expected_a15 = 100 in
  mark_test_run 151;
  let test = (fun a b -> Int.equal a b) expected_a15 a15 in
  if not test then failwithf "test 151 failed";
  let expected_b15 = 101. in
  mark_test_run 152;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b15 b15 in
  if not test then failwithf "test 152 failed";
  let expected_c15 = 102. in
  mark_test_run 153;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c15 c15 in
  if not test then failwithf "test 153 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a15; b15; c15 } = r in
  let expected_a15 = 100 in
  mark_test_run 154;
  let test = (fun a b -> Int.equal a b) expected_a15 a15 in
  if not test then failwithf "test 154 failed";
  let expected_b15 = 101. in
  mark_test_run 155;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b15 b15 in
  if not test then failwithf "test 155 failed";
  let expected_c15 = 102. in
  mark_test_run 156;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c15 c15 in
  if not test then failwithf "test 156 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t16 = { int; int64x2# }   *)
  (*******************************)
  let r = { a16 = 0; b16 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a16 *)
  let actual = r.a16 in
  let expected = 0 in
  mark_test_run 157;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 157 failed";
  (* Paths of depth 1 *)
  (* .b16 *)
  let actual = r.b16 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 158;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 158 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a16 = a161; b16 = b161 } { a16 = a162; b16 = b162 } -> (fun a b -> Int.equal a b) a161 a162 && int64x2_u_equal b161 b162) in
  let next_r = { a16 = 100; b16 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  let r_expected = { a16 = 0; b16 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a16 *)
  r.a16 <- next_r.a16;
  let r_expected = { r_expected with a16 = next_r.a16 } in
  mark_test_run 159;
  let test = eq r r_expected in
  if not test then failwithf "test 159 failed";
  Gc.compact ();
  (* .b16 *)
  r.b16 <- next_r.b16;
  let r_expected = { r_expected with b16 = next_r.b16 } in
  mark_test_run 160;
  let test = eq r r_expected in
  if not test then failwithf "test 160 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a16; b16 } = r in
  let expected_a16 = 100 in
  mark_test_run 161;
  let test = (fun a b -> Int.equal a b) expected_a16 a16 in
  if not test then failwithf "test 161 failed";
  let expected_b16 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 162;
  let test = int64x2_u_equal expected_b16 b16 in
  if not test then failwithf "test 162 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a16; b16 } = r in
  let expected_a16 = 100 in
  mark_test_run 163;
  let test = (fun a b -> Int.equal a b) expected_a16 a16 in
  if not test then failwithf "test 163 failed";
  let expected_b16 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 164;
  let test = int64x2_u_equal expected_b16 b16 in
  if not test then failwithf "test 164 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t17 = { int; int64x2#; int }   *)
  (************************************)
  let r = { a17 = 0; b17 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c17 = 3 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a17 *)
  let actual = r.a17 in
  let expected = 0 in
  mark_test_run 165;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 165 failed";
  (* Paths of depth 1 *)
  (* .b17 *)
  let actual = r.b17 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 166;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 166 failed";
  (* Paths of depth 1 *)
  (* .c17 *)
  let actual = r.c17 in
  let expected = 3 in
  mark_test_run 167;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 167 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a17 = a171; b17 = b171; c17 = c171 } { a17 = a172; b17 = b172; c17 = c172 } -> (fun a b -> Int.equal a b) a171 a172 && int64x2_u_equal b171 b172 && (fun a b -> Int.equal a b) c171 c172) in
  let next_r = { a17 = 100; b17 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); c17 = 103 } in
  let r_expected = { a17 = 0; b17 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c17 = 3 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a17 *)
  r.a17 <- next_r.a17;
  let r_expected = { r_expected with a17 = next_r.a17 } in
  mark_test_run 168;
  let test = eq r r_expected in
  if not test then failwithf "test 168 failed";
  Gc.compact ();
  (* .b17 *)
  r.b17 <- next_r.b17;
  let r_expected = { r_expected with b17 = next_r.b17 } in
  mark_test_run 169;
  let test = eq r r_expected in
  if not test then failwithf "test 169 failed";
  Gc.compact ();
  (* .c17 *)
  r.c17 <- next_r.c17;
  let r_expected = { r_expected with c17 = next_r.c17 } in
  mark_test_run 170;
  let test = eq r r_expected in
  if not test then failwithf "test 170 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a17; b17; c17 } = r in
  let expected_a17 = 100 in
  mark_test_run 171;
  let test = (fun a b -> Int.equal a b) expected_a17 a17 in
  if not test then failwithf "test 171 failed";
  let expected_b17 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 172;
  let test = int64x2_u_equal expected_b17 b17 in
  if not test then failwithf "test 172 failed";
  let expected_c17 = 103 in
  mark_test_run 173;
  let test = (fun a b -> Int.equal a b) expected_c17 c17 in
  if not test then failwithf "test 173 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a17; b17; c17 } = r in
  let expected_a17 = 100 in
  mark_test_run 174;
  let test = (fun a b -> Int.equal a b) expected_a17 a17 in
  if not test then failwithf "test 174 failed";
  let expected_b17 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 175;
  let test = int64x2_u_equal expected_b17 b17 in
  if not test then failwithf "test 175 failed";
  let expected_c17 = 103 in
  mark_test_run 176;
  let test = (fun a b -> Int.equal a b) expected_c17 c17 in
  if not test then failwithf "test 176 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t18 = { int; int64x2#; int64x2# }   *)
  (*****************************************)
  let r = { a18 = 0; b18 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c18 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a18 *)
  let actual = r.a18 in
  let expected = 0 in
  mark_test_run 177;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 177 failed";
  (* Paths of depth 1 *)
  (* .b18 *)
  let actual = r.b18 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 178;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 178 failed";
  (* Paths of depth 1 *)
  (* .c18 *)
  let actual = r.c18 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 179;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 179 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a18 = a181; b18 = b181; c18 = c181 } { a18 = a182; b18 = b182; c18 = c182 } -> (fun a b -> Int.equal a b) a181 a182 && int64x2_u_equal b181 b182 && int64x2_u_equal c181 c182) in
  let next_r = { a18 = 100; b18 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); c18 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  let r_expected = { a18 = 0; b18 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c18 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a18 *)
  r.a18 <- next_r.a18;
  let r_expected = { r_expected with a18 = next_r.a18 } in
  mark_test_run 180;
  let test = eq r r_expected in
  if not test then failwithf "test 180 failed";
  Gc.compact ();
  (* .b18 *)
  r.b18 <- next_r.b18;
  let r_expected = { r_expected with b18 = next_r.b18 } in
  mark_test_run 181;
  let test = eq r r_expected in
  if not test then failwithf "test 181 failed";
  Gc.compact ();
  (* .c18 *)
  r.c18 <- next_r.c18;
  let r_expected = { r_expected with c18 = next_r.c18 } in
  mark_test_run 182;
  let test = eq r r_expected in
  if not test then failwithf "test 182 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a18; b18; c18 } = r in
  let expected_a18 = 100 in
  mark_test_run 183;
  let test = (fun a b -> Int.equal a b) expected_a18 a18 in
  if not test then failwithf "test 183 failed";
  let expected_b18 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 184;
  let test = int64x2_u_equal expected_b18 b18 in
  if not test then failwithf "test 184 failed";
  let expected_c18 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 185;
  let test = int64x2_u_equal expected_c18 c18 in
  if not test then failwithf "test 185 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a18; b18; c18 } = r in
  let expected_a18 = 100 in
  mark_test_run 186;
  let test = (fun a b -> Int.equal a b) expected_a18 a18 in
  if not test then failwithf "test 186 failed";
  let expected_b18 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 187;
  let test = int64x2_u_equal expected_b18 b18 in
  if not test then failwithf "test 187 failed";
  let expected_c18 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 188;
  let test = int64x2_u_equal expected_c18 c18 in
  if not test then failwithf "test 188 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t20 = { int; (| unit_u) }   *)
  (*********************************)
  let r = { a20 = 0; b20 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a20 *)
  let actual = r.a20 in
  let expected = 0 in
  mark_test_run 189;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 189 failed";
  (* Paths of depth 1 *)
  (* .b20 *)
  let actual = r.b20 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 190;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 190 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a20 = a201; b20 = b201 } { a20 = a202; b20 = b202 } -> (fun a b -> Int.equal a b) a201 a202 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b201 b202) in
  let next_r = { a20 = 100; b20 = C19_0((unbox_unit ())) } in
  let r_expected = { a20 = 0; b20 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a20 *)
  r.a20 <- next_r.a20;
  let r_expected = { r_expected with a20 = next_r.a20 } in
  mark_test_run 191;
  let test = eq r r_expected in
  if not test then failwithf "test 191 failed";
  Gc.compact ();
  (* .b20 *)
  r.b20 <- next_r.b20;
  let r_expected = { r_expected with b20 = next_r.b20 } in
  mark_test_run 192;
  let test = eq r r_expected in
  if not test then failwithf "test 192 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a20; b20 } = r in
  let expected_a20 = 100 in
  mark_test_run 193;
  let test = (fun a b -> Int.equal a b) expected_a20 a20 in
  if not test then failwithf "test 193 failed";
  let expected_b20 = C19_0((unbox_unit ())) in
  mark_test_run 194;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b20 b20 in
  if not test then failwithf "test 194 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a20; b20 } = r in
  let expected_a20 = 100 in
  mark_test_run 195;
  let test = (fun a b -> Int.equal a b) expected_a20 a20 in
  if not test then failwithf "test 195 failed";
  let expected_b20 = C19_0((unbox_unit ())) in
  mark_test_run 196;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b20 b20 in
  if not test then failwithf "test 196 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************************************)
  (*   t22 = { int; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (***********************************************************************)
  let r = { a22 = 0; b22 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a22 *)
  let actual = r.a22 in
  let expected = 0 in
  mark_test_run 197;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 197 failed";
  (* Paths of depth 1 *)
  (* .b22 *)
  let actual = r.b22 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 198;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 198 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a22 = a221; b22 = b221 } { a22 = a222; b22 = b222 } -> (fun a b -> Int.equal a b) a221 a222 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b221 b222) in
  let next_r = { a22 = 100; b22 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a22 = 0; b22 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a22 *)
  r.a22 <- next_r.a22;
  let r_expected = { r_expected with a22 = next_r.a22 } in
  mark_test_run 199;
  let test = eq r r_expected in
  if not test then failwithf "test 199 failed";
  Gc.compact ();
  (* .b22 *)
  r.b22 <- next_r.b22;
  let r_expected = { r_expected with b22 = next_r.b22 } in
  mark_test_run 200;
  let test = eq r r_expected in
  if not test then failwithf "test 200 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a22; b22 } = r in
  let expected_a22 = 100 in
  mark_test_run 201;
  let test = (fun a b -> Int.equal a b) expected_a22 a22 in
  if not test then failwithf "test 201 failed";
  let expected_b22 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 202;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b22 b22 in
  if not test then failwithf "test 202 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a22; b22 } = r in
  let expected_a22 = 100 in
  mark_test_run 203;
  let test = (fun a b -> Int.equal a b) expected_a22 a22 in
  if not test then failwithf "test 203 failed";
  let expected_b22 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 204;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b22 b22 in
  if not test then failwithf "test 204 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t23 = { int; #(unit_u, int) }   *)
  (*************************************)
  let r = { a23 = 0; b23 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a23 *)
  let actual = r.a23 in
  let expected = 0 in
  mark_test_run 205;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 205 failed";
  (* Paths of depth 1 *)
  (* .b23 *)
  let actual = r.b23 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 206;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 206 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a23 = a231; b23 = b231 } { a23 = a232; b23 = b232 } -> (fun a b -> Int.equal a b) a231 a232 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b231 b232) in
  let next_r = { a23 = 100; b23 = #((unbox_unit ()), 101) } in
  let r_expected = { a23 = 0; b23 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a23 *)
  r.a23 <- next_r.a23;
  let r_expected = { r_expected with a23 = next_r.a23 } in
  mark_test_run 207;
  let test = eq r r_expected in
  if not test then failwithf "test 207 failed";
  Gc.compact ();
  (* .b23 *)
  r.b23 <- next_r.b23;
  let r_expected = { r_expected with b23 = next_r.b23 } in
  mark_test_run 208;
  let test = eq r r_expected in
  if not test then failwithf "test 208 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a23; b23 } = r in
  let expected_a23 = 100 in
  mark_test_run 209;
  let test = (fun a b -> Int.equal a b) expected_a23 a23 in
  if not test then failwithf "test 209 failed";
  let expected_b23 = #((unbox_unit ()), 101) in
  mark_test_run 210;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b23 b23 in
  if not test then failwithf "test 210 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a23; b23 } = r in
  let expected_a23 = 100 in
  mark_test_run 211;
  let test = (fun a b -> Int.equal a b) expected_a23 a23 in
  if not test then failwithf "test 211 failed";
  let expected_b23 = #((unbox_unit ()), 101) in
  mark_test_run 212;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b23 b23 in
  if not test then failwithf "test 212 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t24 = { int; #(unit_u, int64#) }   *)
  (****************************************)
  let r = { a24 = 0; b24 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a24 *)
  let actual = r.a24 in
  let expected = 0 in
  mark_test_run 213;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 213 failed";
  (* Paths of depth 1 *)
  (* .b24 *)
  let actual = r.b24 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 214;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 214 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a24 = a241; b24 = b241 } { a24 = a242; b24 = b242 } -> (fun a b -> Int.equal a b) a241 a242 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b241 b242) in
  let next_r = { a24 = 100; b24 = #((unbox_unit ()), #101L) } in
  let r_expected = { a24 = 0; b24 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a24 *)
  r.a24 <- next_r.a24;
  let r_expected = { r_expected with a24 = next_r.a24 } in
  mark_test_run 215;
  let test = eq r r_expected in
  if not test then failwithf "test 215 failed";
  Gc.compact ();
  (* .b24 *)
  r.b24 <- next_r.b24;
  let r_expected = { r_expected with b24 = next_r.b24 } in
  mark_test_run 216;
  let test = eq r r_expected in
  if not test then failwithf "test 216 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a24; b24 } = r in
  let expected_a24 = 100 in
  mark_test_run 217;
  let test = (fun a b -> Int.equal a b) expected_a24 a24 in
  if not test then failwithf "test 217 failed";
  let expected_b24 = #((unbox_unit ()), #101L) in
  mark_test_run 218;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b24 b24 in
  if not test then failwithf "test 218 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a24; b24 } = r in
  let expected_a24 = 100 in
  mark_test_run 219;
  let test = (fun a b -> Int.equal a b) expected_a24 a24 in
  if not test then failwithf "test 219 failed";
  let expected_b24 = #((unbox_unit ()), #101L) in
  mark_test_run 220;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b24 b24 in
  if not test then failwithf "test 220 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t25 = { int; #(unit_u, unit_u) }   *)
  (****************************************)
  let r = { a25 = 0; b25 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a25 *)
  let actual = r.a25 in
  let expected = 0 in
  mark_test_run 221;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 221 failed";
  (* Paths of depth 1 *)
  (* .b25 *)
  let actual = r.b25 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 222;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 222 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a25 = a251; b25 = b251 } { a25 = a252; b25 = b252 } -> (fun a b -> Int.equal a b) a251 a252 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b251 b252) in
  let next_r = { a25 = 100; b25 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a25 = 0; b25 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a25 *)
  r.a25 <- next_r.a25;
  let r_expected = { r_expected with a25 = next_r.a25 } in
  mark_test_run 223;
  let test = eq r r_expected in
  if not test then failwithf "test 223 failed";
  Gc.compact ();
  (* .b25 *)
  r.b25 <- next_r.b25;
  let r_expected = { r_expected with b25 = next_r.b25 } in
  mark_test_run 224;
  let test = eq r r_expected in
  if not test then failwithf "test 224 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a25; b25 } = r in
  let expected_a25 = 100 in
  mark_test_run 225;
  let test = (fun a b -> Int.equal a b) expected_a25 a25 in
  if not test then failwithf "test 225 failed";
  let expected_b25 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 226;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b25 b25 in
  if not test then failwithf "test 226 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a25; b25 } = r in
  let expected_a25 = 100 in
  mark_test_run 227;
  let test = (fun a b -> Int.equal a b) expected_a25 a25 in
  if not test then failwithf "test 227 failed";
  let expected_b25 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 228;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b25 b25 in
  if not test then failwithf "test 228 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t26 = { int; #(unit_u, string) }   *)
  (****************************************)
  let r = { a26 = 0; b26 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a26 *)
  let actual = r.a26 in
  let expected = 0 in
  mark_test_run 229;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 229 failed";
  (* Paths of depth 1 *)
  (* .b26 *)
  let actual = r.b26 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 230;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 230 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a26 = a261; b26 = b261 } { a26 = a262; b26 = b262 } -> (fun a b -> Int.equal a b) a261 a262 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b261 b262) in
  let next_r = { a26 = 100; b26 = #((unbox_unit ()), "101") } in
  let r_expected = { a26 = 0; b26 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a26 *)
  r.a26 <- next_r.a26;
  let r_expected = { r_expected with a26 = next_r.a26 } in
  mark_test_run 231;
  let test = eq r r_expected in
  if not test then failwithf "test 231 failed";
  Gc.compact ();
  (* .b26 *)
  r.b26 <- next_r.b26;
  let r_expected = { r_expected with b26 = next_r.b26 } in
  mark_test_run 232;
  let test = eq r r_expected in
  if not test then failwithf "test 232 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a26; b26 } = r in
  let expected_a26 = 100 in
  mark_test_run 233;
  let test = (fun a b -> Int.equal a b) expected_a26 a26 in
  if not test then failwithf "test 233 failed";
  let expected_b26 = #((unbox_unit ()), "101") in
  mark_test_run 234;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b26 b26 in
  if not test then failwithf "test 234 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a26; b26 } = r in
  let expected_a26 = 100 in
  mark_test_run 235;
  let test = (fun a b -> Int.equal a b) expected_a26 a26 in
  if not test then failwithf "test 235 failed";
  let expected_b26 = #((unbox_unit ()), "101") in
  mark_test_run 236;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b26 b26 in
  if not test then failwithf "test 236 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t28 = { int; #{ int } }   *)
  (*******************************)
  let r = { a28 = 0; b28 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a28 *)
  let actual = r.a28 in
  let expected = 0 in
  mark_test_run 237;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 237 failed";
  (* Paths of depth 1 *)
  (* .b28 *)
  let actual = r.b28 in
  let expected = #{ a27 = 1 } in
  mark_test_run 238;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 238 failed";
  (* Paths of depth 2 *)
  (* .b28.#a27 *)
  let actual = r.b28.#a27 in
  let expected = 1 in
  mark_test_run 239;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 239 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a28 = a281; b28 = b281 } { a28 = a282; b28 = b282 } -> (fun a b -> Int.equal a b) a281 a282 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b281 b282) in
  let next_r = { a28 = 100; b28 = #{ a27 = 101 } } in
  let r_expected = { a28 = 0; b28 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a28 *)
  r.a28 <- next_r.a28;
  let r_expected = { r_expected with a28 = next_r.a28 } in
  mark_test_run 240;
  let test = eq r r_expected in
  if not test then failwithf "test 240 failed";
  Gc.compact ();
  (* .b28 *)
  r.b28 <- next_r.b28;
  let r_expected = { r_expected with b28 = next_r.b28 } in
  mark_test_run 241;
  let test = eq r r_expected in
  if not test then failwithf "test 241 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a28; b28 = #{ a27 } } = r in
  let expected_a28 = 100 in
  mark_test_run 242;
  let test = (fun a b -> Int.equal a b) expected_a28 a28 in
  if not test then failwithf "test 242 failed";
  let expected_a27 = 101 in
  mark_test_run 243;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 243 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a28; b28 } = r in
  let expected_a28 = 100 in
  mark_test_run 244;
  let test = (fun a b -> Int.equal a b) expected_a28 a28 in
  if not test then failwithf "test 244 failed";
  let expected_b28 = #{ a27 = 101 } in
  mark_test_run 245;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_b28 b28 in
  if not test then failwithf "test 245 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t30 = { int; #{ int; int } }   *)
  (************************************)
  let r = { a30 = 0; b30 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a30 *)
  let actual = r.a30 in
  let expected = 0 in
  mark_test_run 246;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 246 failed";
  (* Paths of depth 1 *)
  (* .b30 *)
  let actual = r.b30 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 247;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 247 failed";
  (* Paths of depth 2 *)
  (* .b30.#a29 *)
  let actual = r.b30.#a29 in
  let expected = 1 in
  mark_test_run 248;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 248 failed";
  (* .b30.#b29 *)
  let actual = r.b30.#b29 in
  let expected = 2 in
  mark_test_run 249;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 249 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a30 = a301; b30 = b301 } { a30 = a302; b30 = b302 } -> (fun a b -> Int.equal a b) a301 a302 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b301 b302) in
  let next_r = { a30 = 100; b30 = #{ a29 = 101; b29 = 102 } } in
  let r_expected = { a30 = 0; b30 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a30 *)
  r.a30 <- next_r.a30;
  let r_expected = { r_expected with a30 = next_r.a30 } in
  mark_test_run 250;
  let test = eq r r_expected in
  if not test then failwithf "test 250 failed";
  Gc.compact ();
  (* .b30 *)
  r.b30 <- next_r.b30;
  let r_expected = { r_expected with b30 = next_r.b30 } in
  mark_test_run 251;
  let test = eq r r_expected in
  if not test then failwithf "test 251 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a30; b30 = #{ a29; b29 } } = r in
  let expected_a30 = 100 in
  mark_test_run 252;
  let test = (fun a b -> Int.equal a b) expected_a30 a30 in
  if not test then failwithf "test 252 failed";
  let expected_a29 = 101 in
  mark_test_run 253;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 253 failed";
  let expected_b29 = 102 in
  mark_test_run 254;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 254 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a30; b30 } = r in
  let expected_a30 = 100 in
  mark_test_run 255;
  let test = (fun a b -> Int.equal a b) expected_a30 a30 in
  if not test then failwithf "test 255 failed";
  let expected_b30 = #{ a29 = 101; b29 = 102 } in
  mark_test_run 256;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_b30 b30 in
  if not test then failwithf "test 256 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t32 = { int; #{ int; int32# } }   *)
  (***************************************)
  let r = { a32 = 0; b32 = #{ a31 = 1; b31 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a32 *)
  let actual = r.a32 in
  let expected = 0 in
  mark_test_run 257;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 257 failed";
  (* Paths of depth 1 *)
  (* .b32 *)
  let actual = r.b32 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 258;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 258 failed";
  (* Paths of depth 2 *)
  (* .b32.#a31 *)
  let actual = r.b32.#a31 in
  let expected = 1 in
  mark_test_run 259;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 259 failed";
  (* .b32.#b31 *)
  let actual = r.b32.#b31 in
  let expected = #2l in
  mark_test_run 260;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 260 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a32 = a321; b32 = b321 } { a32 = a322; b32 = b322 } -> (fun a b -> Int.equal a b) a321 a322 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b321 b322) in
  let next_r = { a32 = 100; b32 = #{ a31 = 101; b31 = #102l } } in
  let r_expected = { a32 = 0; b32 = #{ a31 = 1; b31 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a32 *)
  r.a32 <- next_r.a32;
  let r_expected = { r_expected with a32 = next_r.a32 } in
  mark_test_run 261;
  let test = eq r r_expected in
  if not test then failwithf "test 261 failed";
  Gc.compact ();
  (* .b32 *)
  r.b32 <- next_r.b32;
  let r_expected = { r_expected with b32 = next_r.b32 } in
  mark_test_run 262;
  let test = eq r r_expected in
  if not test then failwithf "test 262 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a32; b32 = #{ a31; b31 } } = r in
  let expected_a32 = 100 in
  mark_test_run 263;
  let test = (fun a b -> Int.equal a b) expected_a32 a32 in
  if not test then failwithf "test 263 failed";
  let expected_a31 = 101 in
  mark_test_run 264;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 264 failed";
  let expected_b31 = #102l in
  mark_test_run 265;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 265 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a32; b32 } = r in
  let expected_a32 = 100 in
  mark_test_run 266;
  let test = (fun a b -> Int.equal a b) expected_a32 a32 in
  if not test then failwithf "test 266 failed";
  let expected_b32 = #{ a31 = 101; b31 = #102l } in
  mark_test_run 267;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) expected_b32 b32 in
  if not test then failwithf "test 267 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t34 = { int; #{ int; float } }   *)
  (**************************************)
  let r = { a34 = 0; b34 = #{ a33 = 1; b33 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a34 *)
  let actual = r.a34 in
  let expected = 0 in
  mark_test_run 268;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 268 failed";
  (* Paths of depth 1 *)
  (* .b34 *)
  let actual = r.b34 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 269;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 269 failed";
  (* Paths of depth 2 *)
  (* .b34.#a33 *)
  let actual = r.b34.#a33 in
  let expected = 1 in
  mark_test_run 270;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 270 failed";
  (* .b34.#b33 *)
  let actual = r.b34.#b33 in
  let expected = 2. in
  mark_test_run 271;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 271 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a34 = a341; b34 = b341 } { a34 = a342; b34 = b342 } -> (fun a b -> Int.equal a b) a341 a342 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b341 b342) in
  let next_r = { a34 = 100; b34 = #{ a33 = 101; b33 = 102. } } in
  let r_expected = { a34 = 0; b34 = #{ a33 = 1; b33 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a34 *)
  r.a34 <- next_r.a34;
  let r_expected = { r_expected with a34 = next_r.a34 } in
  mark_test_run 272;
  let test = eq r r_expected in
  if not test then failwithf "test 272 failed";
  Gc.compact ();
  (* .b34 *)
  r.b34 <- next_r.b34;
  let r_expected = { r_expected with b34 = next_r.b34 } in
  mark_test_run 273;
  let test = eq r r_expected in
  if not test then failwithf "test 273 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a34; b34 = #{ a33; b33 } } = r in
  let expected_a34 = 100 in
  mark_test_run 274;
  let test = (fun a b -> Int.equal a b) expected_a34 a34 in
  if not test then failwithf "test 274 failed";
  let expected_a33 = 101 in
  mark_test_run 275;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 275 failed";
  let expected_b33 = 102. in
  mark_test_run 276;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 276 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a34; b34 } = r in
  let expected_a34 = 100 in
  mark_test_run 277;
  let test = (fun a b -> Int.equal a b) expected_a34 a34 in
  if not test then failwithf "test 277 failed";
  let expected_b34 = #{ a33 = 101; b33 = 102. } in
  mark_test_run 278;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) expected_b34 b34 in
  if not test then failwithf "test 278 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t36 = { int; #{ int; int64x2# } }   *)
  (*****************************************)
  let r = { a36 = 0; b36 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a36 *)
  let actual = r.a36 in
  let expected = 0 in
  mark_test_run 279;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 279 failed";
  (* Paths of depth 1 *)
  (* .b36 *)
  let actual = r.b36 in
  let expected = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 280;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 280 failed";
  (* Paths of depth 2 *)
  (* .b36.#a35 *)
  let actual = r.b36.#a35 in
  let expected = 1 in
  mark_test_run 281;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 281 failed";
  (* .b36.#b35 *)
  let actual = r.b36.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 282;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 282 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a36 = a361; b36 = b361 } { a36 = a362; b36 = b362 } -> (fun a b -> Int.equal a b) a361 a362 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b361 b362) in
  let next_r = { a36 = 100; b36 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  let r_expected = { a36 = 0; b36 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a36 *)
  r.a36 <- next_r.a36;
  let r_expected = { r_expected with a36 = next_r.a36 } in
  mark_test_run 283;
  let test = eq r r_expected in
  if not test then failwithf "test 283 failed";
  Gc.compact ();
  (* .b36 *)
  r.b36 <- next_r.b36;
  let r_expected = { r_expected with b36 = next_r.b36 } in
  mark_test_run 284;
  let test = eq r r_expected in
  if not test then failwithf "test 284 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a36; b36 = #{ a35; b35 } } = r in
  let expected_a36 = 100 in
  mark_test_run 285;
  let test = (fun a b -> Int.equal a b) expected_a36 a36 in
  if not test then failwithf "test 285 failed";
  let expected_a35 = 101 in
  mark_test_run 286;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 286 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 287;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 287 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a36; b36 } = r in
  let expected_a36 = 100 in
  mark_test_run 288;
  let test = (fun a b -> Int.equal a b) expected_a36 a36 in
  if not test then failwithf "test 288 failed";
  let expected_b36 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 289;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) expected_b36 b36 in
  if not test then failwithf "test 289 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t38 = { int; #{ int; #{ int } } }   *)
  (*****************************************)
  let r = { a38 = 0; b38 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a38 *)
  let actual = r.a38 in
  let expected = 0 in
  mark_test_run 290;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 290 failed";
  (* Paths of depth 1 *)
  (* .b38 *)
  let actual = r.b38 in
  let expected = #{ a37 = 1; b37 = #{ a27 = 2 } } in
  mark_test_run 291;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) actual expected in
  if not test then failwithf "test 291 failed";
  (* Paths of depth 2 *)
  (* .b38.#a37 *)
  let actual = r.b38.#a37 in
  let expected = 1 in
  mark_test_run 292;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 292 failed";
  (* .b38.#b37 *)
  let actual = r.b38.#b37 in
  let expected = #{ a27 = 2 } in
  mark_test_run 293;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 293 failed";
  (* Paths of depth 3 *)
  (* .b38.#b37.#a27 *)
  let actual = r.b38.#b37.#a27 in
  let expected = 2 in
  mark_test_run 294;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 294 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a38 = a381; b38 = b381 } { a38 = a382; b38 = b382 } -> (fun a b -> Int.equal a b) a381 a382 && (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) b381 b382) in
  let next_r = { a38 = 100; b38 = #{ a37 = 101; b37 = #{ a27 = 102 } } } in
  let r_expected = { a38 = 0; b38 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a38 *)
  r.a38 <- next_r.a38;
  let r_expected = { r_expected with a38 = next_r.a38 } in
  mark_test_run 295;
  let test = eq r r_expected in
  if not test then failwithf "test 295 failed";
  Gc.compact ();
  (* .b38 *)
  r.b38 <- next_r.b38;
  let r_expected = { r_expected with b38 = next_r.b38 } in
  mark_test_run 296;
  let test = eq r r_expected in
  if not test then failwithf "test 296 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a38; b38 = #{ a37; b37 = #{ a27 } } } = r in
  let expected_a38 = 100 in
  mark_test_run 297;
  let test = (fun a b -> Int.equal a b) expected_a38 a38 in
  if not test then failwithf "test 297 failed";
  let expected_a37 = 101 in
  mark_test_run 298;
  let test = (fun a b -> Int.equal a b) expected_a37 a37 in
  if not test then failwithf "test 298 failed";
  let expected_a27 = 102 in
  mark_test_run 299;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 299 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a38; b38 } = r in
  let expected_a38 = 100 in
  mark_test_run 300;
  let test = (fun a b -> Int.equal a b) expected_a38 a38 in
  if not test then failwithf "test 300 failed";
  let expected_b38 = #{ a37 = 101; b37 = #{ a27 = 102 } } in
  mark_test_run 301;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) expected_b38 b38 in
  if not test then failwithf "test 301 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t41 = { int; #{ int; #{ int32# } } }   *)
  (********************************************)
  let r = { a41 = 0; b41 = #{ a40 = 1; b40 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a41 *)
  let actual = r.a41 in
  let expected = 0 in
  mark_test_run 302;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 302 failed";
  (* Paths of depth 1 *)
  (* .b41 *)
  let actual = r.b41 in
  let expected = #{ a40 = 1; b40 = #{ a39 = #2l } } in
  mark_test_run 303;
  let test = (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) actual expected in
  if not test then failwithf "test 303 failed";
  (* Paths of depth 2 *)
  (* .b41.#a40 *)
  let actual = r.b41.#a40 in
  let expected = 1 in
  mark_test_run 304;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 304 failed";
  (* .b41.#b40 *)
  let actual = r.b41.#b40 in
  let expected = #{ a39 = #2l } in
  mark_test_run 305;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 305 failed";
  (* Paths of depth 3 *)
  (* .b41.#b40.#a39 *)
  let actual = r.b41.#b40.#a39 in
  let expected = #2l in
  mark_test_run 306;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 306 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a41 = a411; b41 = b411 } { a41 = a412; b41 = b412 } -> (fun a b -> Int.equal a b) a411 a412 && (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) b411 b412) in
  let next_r = { a41 = 100; b41 = #{ a40 = 101; b40 = #{ a39 = #102l } } } in
  let r_expected = { a41 = 0; b41 = #{ a40 = 1; b40 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a41 *)
  r.a41 <- next_r.a41;
  let r_expected = { r_expected with a41 = next_r.a41 } in
  mark_test_run 307;
  let test = eq r r_expected in
  if not test then failwithf "test 307 failed";
  Gc.compact ();
  (* .b41 *)
  r.b41 <- next_r.b41;
  let r_expected = { r_expected with b41 = next_r.b41 } in
  mark_test_run 308;
  let test = eq r r_expected in
  if not test then failwithf "test 308 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a41; b41 = #{ a40; b40 = #{ a39 } } } = r in
  let expected_a41 = 100 in
  mark_test_run 309;
  let test = (fun a b -> Int.equal a b) expected_a41 a41 in
  if not test then failwithf "test 309 failed";
  let expected_a40 = 101 in
  mark_test_run 310;
  let test = (fun a b -> Int.equal a b) expected_a40 a40 in
  if not test then failwithf "test 310 failed";
  let expected_a39 = #102l in
  mark_test_run 311;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 311 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a41; b41 } = r in
  let expected_a41 = 100 in
  mark_test_run 312;
  let test = (fun a b -> Int.equal a b) expected_a41 a41 in
  if not test then failwithf "test 312 failed";
  let expected_b41 = #{ a40 = 101; b40 = #{ a39 = #102l } } in
  mark_test_run 313;
  let test = (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) expected_b41 b41 in
  if not test then failwithf "test 313 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t44 = { int; #{ int; #{ float } } }   *)
  (*******************************************)
  let r = { a44 = 0; b44 = #{ a43 = 1; b43 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a44 *)
  let actual = r.a44 in
  let expected = 0 in
  mark_test_run 314;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 314 failed";
  (* Paths of depth 1 *)
  (* .b44 *)
  let actual = r.b44 in
  let expected = #{ a43 = 1; b43 = #{ a42 = 2. } } in
  mark_test_run 315;
  let test = (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) actual expected in
  if not test then failwithf "test 315 failed";
  (* Paths of depth 2 *)
  (* .b44.#a43 *)
  let actual = r.b44.#a43 in
  let expected = 1 in
  mark_test_run 316;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 316 failed";
  (* .b44.#b43 *)
  let actual = r.b44.#b43 in
  let expected = #{ a42 = 2. } in
  mark_test_run 317;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 317 failed";
  (* Paths of depth 3 *)
  (* .b44.#b43.#a42 *)
  let actual = r.b44.#b43.#a42 in
  let expected = 2. in
  mark_test_run 318;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 318 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a44 = a441; b44 = b441 } { a44 = a442; b44 = b442 } -> (fun a b -> Int.equal a b) a441 a442 && (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) b441 b442) in
  let next_r = { a44 = 100; b44 = #{ a43 = 101; b43 = #{ a42 = 102. } } } in
  let r_expected = { a44 = 0; b44 = #{ a43 = 1; b43 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a44 *)
  r.a44 <- next_r.a44;
  let r_expected = { r_expected with a44 = next_r.a44 } in
  mark_test_run 319;
  let test = eq r r_expected in
  if not test then failwithf "test 319 failed";
  Gc.compact ();
  (* .b44 *)
  r.b44 <- next_r.b44;
  let r_expected = { r_expected with b44 = next_r.b44 } in
  mark_test_run 320;
  let test = eq r r_expected in
  if not test then failwithf "test 320 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a44; b44 = #{ a43; b43 = #{ a42 } } } = r in
  let expected_a44 = 100 in
  mark_test_run 321;
  let test = (fun a b -> Int.equal a b) expected_a44 a44 in
  if not test then failwithf "test 321 failed";
  let expected_a43 = 101 in
  mark_test_run 322;
  let test = (fun a b -> Int.equal a b) expected_a43 a43 in
  if not test then failwithf "test 322 failed";
  let expected_a42 = 102. in
  mark_test_run 323;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 323 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a44; b44 } = r in
  let expected_a44 = 100 in
  mark_test_run 324;
  let test = (fun a b -> Int.equal a b) expected_a44 a44 in
  if not test then failwithf "test 324 failed";
  let expected_b44 = #{ a43 = 101; b43 = #{ a42 = 102. } } in
  mark_test_run 325;
  let test = (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) expected_b44 b44 in
  if not test then failwithf "test 325 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t47 = { int; #{ int; #{ int64x2# } } }   *)
  (**********************************************)
  let r = { a47 = 0; b47 = #{ a46 = 1; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a47 *)
  let actual = r.a47 in
  let expected = 0 in
  mark_test_run 326;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 326 failed";
  (* Paths of depth 1 *)
  (* .b47 *)
  let actual = r.b47 in
  let expected = #{ a46 = 1; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  mark_test_run 327;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) actual expected in
  if not test then failwithf "test 327 failed";
  (* Paths of depth 2 *)
  (* .b47.#a46 *)
  let actual = r.b47.#a46 in
  let expected = 1 in
  mark_test_run 328;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 328 failed";
  (* .b47.#b46 *)
  let actual = r.b47.#b46 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 329;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 329 failed";
  (* Paths of depth 3 *)
  (* .b47.#b46.#a45 *)
  let actual = r.b47.#b46.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 330;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 330 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a47 = a471; b47 = b471 } { a47 = a472; b47 = b472 } -> (fun a b -> Int.equal a b) a471 a472 && (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) b471 b472) in
  let next_r = { a47 = 100; b47 = #{ a46 = 101; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } } in
  let r_expected = { a47 = 0; b47 = #{ a46 = 1; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a47 *)
  r.a47 <- next_r.a47;
  let r_expected = { r_expected with a47 = next_r.a47 } in
  mark_test_run 331;
  let test = eq r r_expected in
  if not test then failwithf "test 331 failed";
  Gc.compact ();
  (* .b47 *)
  r.b47 <- next_r.b47;
  let r_expected = { r_expected with b47 = next_r.b47 } in
  mark_test_run 332;
  let test = eq r r_expected in
  if not test then failwithf "test 332 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a47; b47 = #{ a46; b46 = #{ a45 } } } = r in
  let expected_a47 = 100 in
  mark_test_run 333;
  let test = (fun a b -> Int.equal a b) expected_a47 a47 in
  if not test then failwithf "test 333 failed";
  let expected_a46 = 101 in
  mark_test_run 334;
  let test = (fun a b -> Int.equal a b) expected_a46 a46 in
  if not test then failwithf "test 334 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 335;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 335 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a47; b47 } = r in
  let expected_a47 = 100 in
  mark_test_run 336;
  let test = (fun a b -> Int.equal a b) expected_a47 a47 in
  if not test then failwithf "test 336 failed";
  let expected_b47 = #{ a46 = 101; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  mark_test_run 337;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) expected_b47 b47 in
  if not test then failwithf "test 337 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t48 = { int; #{ int32# } }   *)
  (**********************************)
  let r = { a48 = 0; b48 = #{ a39 = #1l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a48 *)
  let actual = r.a48 in
  let expected = 0 in
  mark_test_run 338;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 338 failed";
  (* Paths of depth 1 *)
  (* .b48 *)
  let actual = r.b48 in
  let expected = #{ a39 = #1l } in
  mark_test_run 339;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 339 failed";
  (* Paths of depth 2 *)
  (* .b48.#a39 *)
  let actual = r.b48.#a39 in
  let expected = #1l in
  mark_test_run 340;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 340 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a48 = a481; b48 = b481 } { a48 = a482; b48 = b482 } -> (fun a b -> Int.equal a b) a481 a482 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b481 b482) in
  let next_r = { a48 = 100; b48 = #{ a39 = #101l } } in
  let r_expected = { a48 = 0; b48 = #{ a39 = #1l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a48 *)
  r.a48 <- next_r.a48;
  let r_expected = { r_expected with a48 = next_r.a48 } in
  mark_test_run 341;
  let test = eq r r_expected in
  if not test then failwithf "test 341 failed";
  Gc.compact ();
  (* .b48 *)
  r.b48 <- next_r.b48;
  let r_expected = { r_expected with b48 = next_r.b48 } in
  mark_test_run 342;
  let test = eq r r_expected in
  if not test then failwithf "test 342 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a48; b48 = #{ a39 } } = r in
  let expected_a48 = 100 in
  mark_test_run 343;
  let test = (fun a b -> Int.equal a b) expected_a48 a48 in
  if not test then failwithf "test 343 failed";
  let expected_a39 = #101l in
  mark_test_run 344;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 344 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a48; b48 } = r in
  let expected_a48 = 100 in
  mark_test_run 345;
  let test = (fun a b -> Int.equal a b) expected_a48 a48 in
  if not test then failwithf "test 345 failed";
  let expected_b48 = #{ a39 = #101l } in
  mark_test_run 346;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) expected_b48 b48 in
  if not test then failwithf "test 346 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t50 = { int; #{ int32#; int } }   *)
  (***************************************)
  let r = { a50 = 0; b50 = #{ a49 = #1l; b49 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a50 *)
  let actual = r.a50 in
  let expected = 0 in
  mark_test_run 347;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 347 failed";
  (* Paths of depth 1 *)
  (* .b50 *)
  let actual = r.b50 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 348;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 348 failed";
  (* Paths of depth 2 *)
  (* .b50.#a49 *)
  let actual = r.b50.#a49 in
  let expected = #1l in
  mark_test_run 349;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 349 failed";
  (* .b50.#b49 *)
  let actual = r.b50.#b49 in
  let expected = 2 in
  mark_test_run 350;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 350 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a50 = a501; b50 = b501 } { a50 = a502; b50 = b502 } -> (fun a b -> Int.equal a b) a501 a502 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b501 b502) in
  let next_r = { a50 = 100; b50 = #{ a49 = #101l; b49 = 102 } } in
  let r_expected = { a50 = 0; b50 = #{ a49 = #1l; b49 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a50 *)
  r.a50 <- next_r.a50;
  let r_expected = { r_expected with a50 = next_r.a50 } in
  mark_test_run 351;
  let test = eq r r_expected in
  if not test then failwithf "test 351 failed";
  Gc.compact ();
  (* .b50 *)
  r.b50 <- next_r.b50;
  let r_expected = { r_expected with b50 = next_r.b50 } in
  mark_test_run 352;
  let test = eq r r_expected in
  if not test then failwithf "test 352 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a50; b50 = #{ a49; b49 } } = r in
  let expected_a50 = 100 in
  mark_test_run 353;
  let test = (fun a b -> Int.equal a b) expected_a50 a50 in
  if not test then failwithf "test 353 failed";
  let expected_a49 = #101l in
  mark_test_run 354;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 354 failed";
  let expected_b49 = 102 in
  mark_test_run 355;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 355 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a50; b50 } = r in
  let expected_a50 = 100 in
  mark_test_run 356;
  let test = (fun a b -> Int.equal a b) expected_a50 a50 in
  if not test then failwithf "test 356 failed";
  let expected_b50 = #{ a49 = #101l; b49 = 102 } in
  mark_test_run 357;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) expected_b50 b50 in
  if not test then failwithf "test 357 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t52 = { int; #{ int32#; int32# } }   *)
  (******************************************)
  let r = { a52 = 0; b52 = #{ a51 = #1l; b51 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a52 *)
  let actual = r.a52 in
  let expected = 0 in
  mark_test_run 358;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 358 failed";
  (* Paths of depth 1 *)
  (* .b52 *)
  let actual = r.b52 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 359;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 359 failed";
  (* Paths of depth 2 *)
  (* .b52.#a51 *)
  let actual = r.b52.#a51 in
  let expected = #1l in
  mark_test_run 360;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 360 failed";
  (* .b52.#b51 *)
  let actual = r.b52.#b51 in
  let expected = #2l in
  mark_test_run 361;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 361 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a52 = a521; b52 = b521 } { a52 = a522; b52 = b522 } -> (fun a b -> Int.equal a b) a521 a522 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b521 b522) in
  let next_r = { a52 = 100; b52 = #{ a51 = #101l; b51 = #102l } } in
  let r_expected = { a52 = 0; b52 = #{ a51 = #1l; b51 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a52 *)
  r.a52 <- next_r.a52;
  let r_expected = { r_expected with a52 = next_r.a52 } in
  mark_test_run 362;
  let test = eq r r_expected in
  if not test then failwithf "test 362 failed";
  Gc.compact ();
  (* .b52 *)
  r.b52 <- next_r.b52;
  let r_expected = { r_expected with b52 = next_r.b52 } in
  mark_test_run 363;
  let test = eq r r_expected in
  if not test then failwithf "test 363 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a52; b52 = #{ a51; b51 } } = r in
  let expected_a52 = 100 in
  mark_test_run 364;
  let test = (fun a b -> Int.equal a b) expected_a52 a52 in
  if not test then failwithf "test 364 failed";
  let expected_a51 = #101l in
  mark_test_run 365;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 365 failed";
  let expected_b51 = #102l in
  mark_test_run 366;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 366 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a52; b52 } = r in
  let expected_a52 = 100 in
  mark_test_run 367;
  let test = (fun a b -> Int.equal a b) expected_a52 a52 in
  if not test then failwithf "test 367 failed";
  let expected_b52 = #{ a51 = #101l; b51 = #102l } in
  mark_test_run 368;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) expected_b52 b52 in
  if not test then failwithf "test 368 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t54 = { int; #{ int32#; #{ int } } }   *)
  (********************************************)
  let r = { a54 = 0; b54 = #{ a53 = #1l; b53 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a54 *)
  let actual = r.a54 in
  let expected = 0 in
  mark_test_run 369;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 369 failed";
  (* Paths of depth 1 *)
  (* .b54 *)
  let actual = r.b54 in
  let expected = #{ a53 = #1l; b53 = #{ a27 = 2 } } in
  mark_test_run 370;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) actual expected in
  if not test then failwithf "test 370 failed";
  (* Paths of depth 2 *)
  (* .b54.#a53 *)
  let actual = r.b54.#a53 in
  let expected = #1l in
  mark_test_run 371;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 371 failed";
  (* .b54.#b53 *)
  let actual = r.b54.#b53 in
  let expected = #{ a27 = 2 } in
  mark_test_run 372;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 372 failed";
  (* Paths of depth 3 *)
  (* .b54.#b53.#a27 *)
  let actual = r.b54.#b53.#a27 in
  let expected = 2 in
  mark_test_run 373;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 373 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a54 = a541; b54 = b541 } { a54 = a542; b54 = b542 } -> (fun a b -> Int.equal a b) a541 a542 && (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) b541 b542) in
  let next_r = { a54 = 100; b54 = #{ a53 = #101l; b53 = #{ a27 = 102 } } } in
  let r_expected = { a54 = 0; b54 = #{ a53 = #1l; b53 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a54 *)
  r.a54 <- next_r.a54;
  let r_expected = { r_expected with a54 = next_r.a54 } in
  mark_test_run 374;
  let test = eq r r_expected in
  if not test then failwithf "test 374 failed";
  Gc.compact ();
  (* .b54 *)
  r.b54 <- next_r.b54;
  let r_expected = { r_expected with b54 = next_r.b54 } in
  mark_test_run 375;
  let test = eq r r_expected in
  if not test then failwithf "test 375 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a54; b54 = #{ a53; b53 = #{ a27 } } } = r in
  let expected_a54 = 100 in
  mark_test_run 376;
  let test = (fun a b -> Int.equal a b) expected_a54 a54 in
  if not test then failwithf "test 376 failed";
  let expected_a53 = #101l in
  mark_test_run 377;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a53 a53 in
  if not test then failwithf "test 377 failed";
  let expected_a27 = 102 in
  mark_test_run 378;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 378 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a54; b54 } = r in
  let expected_a54 = 100 in
  mark_test_run 379;
  let test = (fun a b -> Int.equal a b) expected_a54 a54 in
  if not test then failwithf "test 379 failed";
  let expected_b54 = #{ a53 = #101l; b53 = #{ a27 = 102 } } in
  mark_test_run 380;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) expected_b54 b54 in
  if not test then failwithf "test 380 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t56 = { int; #{ int32#; #{ int32# } } }   *)
  (***********************************************)
  let r = { a56 = 0; b56 = #{ a55 = #1l; b55 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a56 *)
  let actual = r.a56 in
  let expected = 0 in
  mark_test_run 381;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 381 failed";
  (* Paths of depth 1 *)
  (* .b56 *)
  let actual = r.b56 in
  let expected = #{ a55 = #1l; b55 = #{ a39 = #2l } } in
  mark_test_run 382;
  let test = (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) actual expected in
  if not test then failwithf "test 382 failed";
  (* Paths of depth 2 *)
  (* .b56.#a55 *)
  let actual = r.b56.#a55 in
  let expected = #1l in
  mark_test_run 383;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 383 failed";
  (* .b56.#b55 *)
  let actual = r.b56.#b55 in
  let expected = #{ a39 = #2l } in
  mark_test_run 384;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 384 failed";
  (* Paths of depth 3 *)
  (* .b56.#b55.#a39 *)
  let actual = r.b56.#b55.#a39 in
  let expected = #2l in
  mark_test_run 385;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 385 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a56 = a561; b56 = b561 } { a56 = a562; b56 = b562 } -> (fun a b -> Int.equal a b) a561 a562 && (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) b561 b562) in
  let next_r = { a56 = 100; b56 = #{ a55 = #101l; b55 = #{ a39 = #102l } } } in
  let r_expected = { a56 = 0; b56 = #{ a55 = #1l; b55 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a56 *)
  r.a56 <- next_r.a56;
  let r_expected = { r_expected with a56 = next_r.a56 } in
  mark_test_run 386;
  let test = eq r r_expected in
  if not test then failwithf "test 386 failed";
  Gc.compact ();
  (* .b56 *)
  r.b56 <- next_r.b56;
  let r_expected = { r_expected with b56 = next_r.b56 } in
  mark_test_run 387;
  let test = eq r r_expected in
  if not test then failwithf "test 387 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a56; b56 = #{ a55; b55 = #{ a39 } } } = r in
  let expected_a56 = 100 in
  mark_test_run 388;
  let test = (fun a b -> Int.equal a b) expected_a56 a56 in
  if not test then failwithf "test 388 failed";
  let expected_a55 = #101l in
  mark_test_run 389;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a55 a55 in
  if not test then failwithf "test 389 failed";
  let expected_a39 = #102l in
  mark_test_run 390;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 390 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a56; b56 } = r in
  let expected_a56 = 100 in
  mark_test_run 391;
  let test = (fun a b -> Int.equal a b) expected_a56 a56 in
  if not test then failwithf "test 391 failed";
  let expected_b56 = #{ a55 = #101l; b55 = #{ a39 = #102l } } in
  mark_test_run 392;
  let test = (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) expected_b56 b56 in
  if not test then failwithf "test 392 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t57 = { int; #{ float } }   *)
  (*********************************)
  let r = { a57 = 0; b57 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a57 *)
  let actual = r.a57 in
  let expected = 0 in
  mark_test_run 393;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 393 failed";
  (* Paths of depth 1 *)
  (* .b57 *)
  let actual = r.b57 in
  let expected = #{ a42 = 1. } in
  mark_test_run 394;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 394 failed";
  (* Paths of depth 2 *)
  (* .b57.#a42 *)
  let actual = r.b57.#a42 in
  let expected = 1. in
  mark_test_run 395;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 395 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a57 = a571; b57 = b571 } { a57 = a572; b57 = b572 } -> (fun a b -> Int.equal a b) a571 a572 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b571 b572) in
  let next_r = { a57 = 100; b57 = #{ a42 = 101. } } in
  let r_expected = { a57 = 0; b57 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a57 *)
  r.a57 <- next_r.a57;
  let r_expected = { r_expected with a57 = next_r.a57 } in
  mark_test_run 396;
  let test = eq r r_expected in
  if not test then failwithf "test 396 failed";
  Gc.compact ();
  (* .b57 *)
  r.b57 <- next_r.b57;
  let r_expected = { r_expected with b57 = next_r.b57 } in
  mark_test_run 397;
  let test = eq r r_expected in
  if not test then failwithf "test 397 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a57; b57 = #{ a42 } } = r in
  let expected_a57 = 100 in
  mark_test_run 398;
  let test = (fun a b -> Int.equal a b) expected_a57 a57 in
  if not test then failwithf "test 398 failed";
  let expected_a42 = 101. in
  mark_test_run 399;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 399 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a57; b57 } = r in
  let expected_a57 = 100 in
  mark_test_run 400;
  let test = (fun a b -> Int.equal a b) expected_a57 a57 in
  if not test then failwithf "test 400 failed";
  let expected_b57 = #{ a42 = 101. } in
  mark_test_run 401;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_b57 b57 in
  if not test then failwithf "test 401 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t59 = { int; #{ float; int } }   *)
  (**************************************)
  let r = { a59 = 0; b59 = #{ a58 = 1.; b58 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a59 *)
  let actual = r.a59 in
  let expected = 0 in
  mark_test_run 402;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 402 failed";
  (* Paths of depth 1 *)
  (* .b59 *)
  let actual = r.b59 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 403;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 403 failed";
  (* Paths of depth 2 *)
  (* .b59.#a58 *)
  let actual = r.b59.#a58 in
  let expected = 1. in
  mark_test_run 404;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 404 failed";
  (* .b59.#b58 *)
  let actual = r.b59.#b58 in
  let expected = 2 in
  mark_test_run 405;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 405 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a59 = a591; b59 = b591 } { a59 = a592; b59 = b592 } -> (fun a b -> Int.equal a b) a591 a592 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b591 b592) in
  let next_r = { a59 = 100; b59 = #{ a58 = 101.; b58 = 102 } } in
  let r_expected = { a59 = 0; b59 = #{ a58 = 1.; b58 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a59 *)
  r.a59 <- next_r.a59;
  let r_expected = { r_expected with a59 = next_r.a59 } in
  mark_test_run 406;
  let test = eq r r_expected in
  if not test then failwithf "test 406 failed";
  Gc.compact ();
  (* .b59 *)
  r.b59 <- next_r.b59;
  let r_expected = { r_expected with b59 = next_r.b59 } in
  mark_test_run 407;
  let test = eq r r_expected in
  if not test then failwithf "test 407 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a59; b59 = #{ a58; b58 } } = r in
  let expected_a59 = 100 in
  mark_test_run 408;
  let test = (fun a b -> Int.equal a b) expected_a59 a59 in
  if not test then failwithf "test 408 failed";
  let expected_a58 = 101. in
  mark_test_run 409;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 409 failed";
  let expected_b58 = 102 in
  mark_test_run 410;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 410 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a59; b59 } = r in
  let expected_a59 = 100 in
  mark_test_run 411;
  let test = (fun a b -> Int.equal a b) expected_a59 a59 in
  if not test then failwithf "test 411 failed";
  let expected_b59 = #{ a58 = 101.; b58 = 102 } in
  mark_test_run 412;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) expected_b59 b59 in
  if not test then failwithf "test 412 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t61 = { int; #{ float; float } }   *)
  (****************************************)
  let r = { a61 = 0; b61 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a61 *)
  let actual = r.a61 in
  let expected = 0 in
  mark_test_run 413;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 413 failed";
  (* Paths of depth 1 *)
  (* .b61 *)
  let actual = r.b61 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 414;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 414 failed";
  (* Paths of depth 2 *)
  (* .b61.#a60 *)
  let actual = r.b61.#a60 in
  let expected = 1. in
  mark_test_run 415;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 415 failed";
  (* .b61.#b60 *)
  let actual = r.b61.#b60 in
  let expected = 2. in
  mark_test_run 416;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 416 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a61 = a611; b61 = b611 } { a61 = a612; b61 = b612 } -> (fun a b -> Int.equal a b) a611 a612 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b611 b612) in
  let next_r = { a61 = 100; b61 = #{ a60 = 101.; b60 = 102. } } in
  let r_expected = { a61 = 0; b61 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a61 *)
  r.a61 <- next_r.a61;
  let r_expected = { r_expected with a61 = next_r.a61 } in
  mark_test_run 417;
  let test = eq r r_expected in
  if not test then failwithf "test 417 failed";
  Gc.compact ();
  (* .b61 *)
  r.b61 <- next_r.b61;
  let r_expected = { r_expected with b61 = next_r.b61 } in
  mark_test_run 418;
  let test = eq r r_expected in
  if not test then failwithf "test 418 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a61; b61 = #{ a60; b60 } } = r in
  let expected_a61 = 100 in
  mark_test_run 419;
  let test = (fun a b -> Int.equal a b) expected_a61 a61 in
  if not test then failwithf "test 419 failed";
  let expected_a60 = 101. in
  mark_test_run 420;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 420 failed";
  let expected_b60 = 102. in
  mark_test_run 421;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 421 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a61; b61 } = r in
  let expected_a61 = 100 in
  mark_test_run 422;
  let test = (fun a b -> Int.equal a b) expected_a61 a61 in
  if not test then failwithf "test 422 failed";
  let expected_b61 = #{ a60 = 101.; b60 = 102. } in
  mark_test_run 423;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_b61 b61 in
  if not test then failwithf "test 423 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t63 = { int; #{ float; #{ int } } }   *)
  (*******************************************)
  let r = { a63 = 0; b63 = #{ a62 = 1.; b62 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a63 *)
  let actual = r.a63 in
  let expected = 0 in
  mark_test_run 424;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 424 failed";
  (* Paths of depth 1 *)
  (* .b63 *)
  let actual = r.b63 in
  let expected = #{ a62 = 1.; b62 = #{ a27 = 2 } } in
  mark_test_run 425;
  let test = (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) actual expected in
  if not test then failwithf "test 425 failed";
  (* Paths of depth 2 *)
  (* .b63.#a62 *)
  let actual = r.b63.#a62 in
  let expected = 1. in
  mark_test_run 426;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 426 failed";
  (* .b63.#b62 *)
  let actual = r.b63.#b62 in
  let expected = #{ a27 = 2 } in
  mark_test_run 427;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 427 failed";
  (* Paths of depth 3 *)
  (* .b63.#b62.#a27 *)
  let actual = r.b63.#b62.#a27 in
  let expected = 2 in
  mark_test_run 428;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 428 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a63 = a631; b63 = b631 } { a63 = a632; b63 = b632 } -> (fun a b -> Int.equal a b) a631 a632 && (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) b631 b632) in
  let next_r = { a63 = 100; b63 = #{ a62 = 101.; b62 = #{ a27 = 102 } } } in
  let r_expected = { a63 = 0; b63 = #{ a62 = 1.; b62 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a63 *)
  r.a63 <- next_r.a63;
  let r_expected = { r_expected with a63 = next_r.a63 } in
  mark_test_run 429;
  let test = eq r r_expected in
  if not test then failwithf "test 429 failed";
  Gc.compact ();
  (* .b63 *)
  r.b63 <- next_r.b63;
  let r_expected = { r_expected with b63 = next_r.b63 } in
  mark_test_run 430;
  let test = eq r r_expected in
  if not test then failwithf "test 430 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a63; b63 = #{ a62; b62 = #{ a27 } } } = r in
  let expected_a63 = 100 in
  mark_test_run 431;
  let test = (fun a b -> Int.equal a b) expected_a63 a63 in
  if not test then failwithf "test 431 failed";
  let expected_a62 = 101. in
  mark_test_run 432;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a62 a62 in
  if not test then failwithf "test 432 failed";
  let expected_a27 = 102 in
  mark_test_run 433;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 433 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a63; b63 } = r in
  let expected_a63 = 100 in
  mark_test_run 434;
  let test = (fun a b -> Int.equal a b) expected_a63 a63 in
  if not test then failwithf "test 434 failed";
  let expected_b63 = #{ a62 = 101.; b62 = #{ a27 = 102 } } in
  mark_test_run 435;
  let test = (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) expected_b63 b63 in
  if not test then failwithf "test 435 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t65 = { int; #{ float; #{ float } } }   *)
  (*********************************************)
  let r = { a65 = 0; b65 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a65 *)
  let actual = r.a65 in
  let expected = 0 in
  mark_test_run 436;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 436 failed";
  (* Paths of depth 1 *)
  (* .b65 *)
  let actual = r.b65 in
  let expected = #{ a64 = 1.; b64 = #{ a42 = 2. } } in
  mark_test_run 437;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) actual expected in
  if not test then failwithf "test 437 failed";
  (* Paths of depth 2 *)
  (* .b65.#a64 *)
  let actual = r.b65.#a64 in
  let expected = 1. in
  mark_test_run 438;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 438 failed";
  (* .b65.#b64 *)
  let actual = r.b65.#b64 in
  let expected = #{ a42 = 2. } in
  mark_test_run 439;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 439 failed";
  (* Paths of depth 3 *)
  (* .b65.#b64.#a42 *)
  let actual = r.b65.#b64.#a42 in
  let expected = 2. in
  mark_test_run 440;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 440 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a65 = a651; b65 = b651 } { a65 = a652; b65 = b652 } -> (fun a b -> Int.equal a b) a651 a652 && (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) b651 b652) in
  let next_r = { a65 = 100; b65 = #{ a64 = 101.; b64 = #{ a42 = 102. } } } in
  let r_expected = { a65 = 0; b65 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a65 *)
  r.a65 <- next_r.a65;
  let r_expected = { r_expected with a65 = next_r.a65 } in
  mark_test_run 441;
  let test = eq r r_expected in
  if not test then failwithf "test 441 failed";
  Gc.compact ();
  (* .b65 *)
  r.b65 <- next_r.b65;
  let r_expected = { r_expected with b65 = next_r.b65 } in
  mark_test_run 442;
  let test = eq r r_expected in
  if not test then failwithf "test 442 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a65; b65 = #{ a64; b64 = #{ a42 } } } = r in
  let expected_a65 = 100 in
  mark_test_run 443;
  let test = (fun a b -> Int.equal a b) expected_a65 a65 in
  if not test then failwithf "test 443 failed";
  let expected_a64 = 101. in
  mark_test_run 444;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a64 a64 in
  if not test then failwithf "test 444 failed";
  let expected_a42 = 102. in
  mark_test_run 445;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 445 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a65; b65 } = r in
  let expected_a65 = 100 in
  mark_test_run 446;
  let test = (fun a b -> Int.equal a b) expected_a65 a65 in
  if not test then failwithf "test 446 failed";
  let expected_b65 = #{ a64 = 101.; b64 = #{ a42 = 102. } } in
  mark_test_run 447;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) expected_b65 b65 in
  if not test then failwithf "test 447 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t66 = { int; #{ int64x2# } }   *)
  (************************************)
  let r = { a66 = 0; b66 = #{ a45 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a66 *)
  let actual = r.a66 in
  let expected = 0 in
  mark_test_run 448;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 448 failed";
  (* Paths of depth 1 *)
  (* .b66 *)
  let actual = r.b66 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 449;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 449 failed";
  (* Paths of depth 2 *)
  (* .b66.#a45 *)
  let actual = r.b66.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 450;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 450 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a66 = a661; b66 = b661 } { a66 = a662; b66 = b662 } -> (fun a b -> Int.equal a b) a661 a662 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b661 b662) in
  let next_r = { a66 = 100; b66 = #{ a45 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } } in
  let r_expected = { a66 = 0; b66 = #{ a45 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a66 *)
  r.a66 <- next_r.a66;
  let r_expected = { r_expected with a66 = next_r.a66 } in
  mark_test_run 451;
  let test = eq r r_expected in
  if not test then failwithf "test 451 failed";
  Gc.compact ();
  (* .b66 *)
  r.b66 <- next_r.b66;
  let r_expected = { r_expected with b66 = next_r.b66 } in
  mark_test_run 452;
  let test = eq r r_expected in
  if not test then failwithf "test 452 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a66; b66 = #{ a45 } } = r in
  let expected_a66 = 100 in
  mark_test_run 453;
  let test = (fun a b -> Int.equal a b) expected_a66 a66 in
  if not test then failwithf "test 453 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 454;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 454 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a66; b66 } = r in
  let expected_a66 = 100 in
  mark_test_run 455;
  let test = (fun a b -> Int.equal a b) expected_a66 a66 in
  if not test then failwithf "test 455 failed";
  let expected_b66 = #{ a45 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  mark_test_run 456;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) expected_b66 b66 in
  if not test then failwithf "test 456 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t68 = { int; #{ int64x2#; int } }   *)
  (*****************************************)
  let r = { a68 = 0; b68 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a68 *)
  let actual = r.a68 in
  let expected = 0 in
  mark_test_run 457;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 457 failed";
  (* Paths of depth 1 *)
  (* .b68 *)
  let actual = r.b68 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } in
  mark_test_run 458;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 458 failed";
  (* Paths of depth 2 *)
  (* .b68.#a67 *)
  let actual = r.b68.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 459;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 459 failed";
  (* .b68.#b67 *)
  let actual = r.b68.#b67 in
  let expected = 3 in
  mark_test_run 460;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 460 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a68 = a681; b68 = b681 } { a68 = a682; b68 = b682 } -> (fun a b -> Int.equal a b) a681 a682 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b681 b682) in
  let next_r = { a68 = 100; b68 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } } in
  let r_expected = { a68 = 0; b68 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a68 *)
  r.a68 <- next_r.a68;
  let r_expected = { r_expected with a68 = next_r.a68 } in
  mark_test_run 461;
  let test = eq r r_expected in
  if not test then failwithf "test 461 failed";
  Gc.compact ();
  (* .b68 *)
  r.b68 <- next_r.b68;
  let r_expected = { r_expected with b68 = next_r.b68 } in
  mark_test_run 462;
  let test = eq r r_expected in
  if not test then failwithf "test 462 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a68; b68 = #{ a67; b67 } } = r in
  let expected_a68 = 100 in
  mark_test_run 463;
  let test = (fun a b -> Int.equal a b) expected_a68 a68 in
  if not test then failwithf "test 463 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 464;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 464 failed";
  let expected_b67 = 103 in
  mark_test_run 465;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 465 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a68; b68 } = r in
  let expected_a68 = 100 in
  mark_test_run 466;
  let test = (fun a b -> Int.equal a b) expected_a68 a68 in
  if not test then failwithf "test 466 failed";
  let expected_b68 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } in
  mark_test_run 467;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) expected_b68 b68 in
  if not test then failwithf "test 467 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t70 = { int; #{ int64x2#; int64x2# } }   *)
  (**********************************************)
  let r = { a70 = 0; b70 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a70 *)
  let actual = r.a70 in
  let expected = 0 in
  mark_test_run 468;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 468 failed";
  (* Paths of depth 1 *)
  (* .b70 *)
  let actual = r.b70 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 469;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 469 failed";
  (* Paths of depth 2 *)
  (* .b70.#a69 *)
  let actual = r.b70.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 470;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 470 failed";
  (* .b70.#b69 *)
  let actual = r.b70.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 471;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 471 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a70 = a701; b70 = b701 } { a70 = a702; b70 = b702 } -> (fun a b -> Int.equal a b) a701 a702 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b701 b702) in
  let next_r = { a70 = 100; b70 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  let r_expected = { a70 = 0; b70 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a70 *)
  r.a70 <- next_r.a70;
  let r_expected = { r_expected with a70 = next_r.a70 } in
  mark_test_run 472;
  let test = eq r r_expected in
  if not test then failwithf "test 472 failed";
  Gc.compact ();
  (* .b70 *)
  r.b70 <- next_r.b70;
  let r_expected = { r_expected with b70 = next_r.b70 } in
  mark_test_run 473;
  let test = eq r r_expected in
  if not test then failwithf "test 473 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a70; b70 = #{ a69; b69 } } = r in
  let expected_a70 = 100 in
  mark_test_run 474;
  let test = (fun a b -> Int.equal a b) expected_a70 a70 in
  if not test then failwithf "test 474 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 475;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 475 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 476;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 476 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a70; b70 } = r in
  let expected_a70 = 100 in
  mark_test_run 477;
  let test = (fun a b -> Int.equal a b) expected_a70 a70 in
  if not test then failwithf "test 477 failed";
  let expected_b70 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  mark_test_run 478;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) expected_b70 b70 in
  if not test then failwithf "test 478 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t72 = { int; #{ int64x2#; #{ int } } }   *)
  (**********************************************)
  let r = { a72 = 0; b72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b71 = #{ a27 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a72 *)
  let actual = r.a72 in
  let expected = 0 in
  mark_test_run 479;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 479 failed";
  (* Paths of depth 1 *)
  (* .b72 *)
  let actual = r.b72 in
  let expected = #{ a71 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b71 = #{ a27 = 3 } } in
  mark_test_run 480;
  let test = (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) actual expected in
  if not test then failwithf "test 480 failed";
  (* Paths of depth 2 *)
  (* .b72.#a71 *)
  let actual = r.b72.#a71 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 481;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 481 failed";
  (* .b72.#b71 *)
  let actual = r.b72.#b71 in
  let expected = #{ a27 = 3 } in
  mark_test_run 482;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 482 failed";
  (* Paths of depth 3 *)
  (* .b72.#b71.#a27 *)
  let actual = r.b72.#b71.#a27 in
  let expected = 3 in
  mark_test_run 483;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 483 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a72 = a721; b72 = b721 } { a72 = a722; b72 = b722 } -> (fun a b -> Int.equal a b) a721 a722 && (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) b721 b722) in
  let next_r = { a72 = 100; b72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b71 = #{ a27 = 103 } } } in
  let r_expected = { a72 = 0; b72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b71 = #{ a27 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a72 *)
  r.a72 <- next_r.a72;
  let r_expected = { r_expected with a72 = next_r.a72 } in
  mark_test_run 484;
  let test = eq r r_expected in
  if not test then failwithf "test 484 failed";
  Gc.compact ();
  (* .b72 *)
  r.b72 <- next_r.b72;
  let r_expected = { r_expected with b72 = next_r.b72 } in
  mark_test_run 485;
  let test = eq r r_expected in
  if not test then failwithf "test 485 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a72; b72 = #{ a71; b71 = #{ a27 } } } = r in
  let expected_a72 = 100 in
  mark_test_run 486;
  let test = (fun a b -> Int.equal a b) expected_a72 a72 in
  if not test then failwithf "test 486 failed";
  let expected_a71 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 487;
  let test = int64x2_u_equal expected_a71 a71 in
  if not test then failwithf "test 487 failed";
  let expected_a27 = 103 in
  mark_test_run 488;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 488 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a72; b72 } = r in
  let expected_a72 = 100 in
  mark_test_run 489;
  let test = (fun a b -> Int.equal a b) expected_a72 a72 in
  if not test then failwithf "test 489 failed";
  let expected_b72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b71 = #{ a27 = 103 } } in
  mark_test_run 490;
  let test = (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) expected_b72 b72 in
  if not test then failwithf "test 490 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t74 = { int; #{ int64x2#; #{ int64x2# } } }   *)
  (***************************************************)
  let r = { a74 = 0; b74 = #{ a73 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a74 *)
  let actual = r.a74 in
  let expected = 0 in
  mark_test_run 491;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 491 failed";
  (* Paths of depth 1 *)
  (* .b74 *)
  let actual = r.b74 in
  let expected = #{ a73 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 492;
  let test = (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) actual expected in
  if not test then failwithf "test 492 failed";
  (* Paths of depth 2 *)
  (* .b74.#a73 *)
  let actual = r.b74.#a73 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 493;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 493 failed";
  (* .b74.#b73 *)
  let actual = r.b74.#b73 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 494;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 494 failed";
  (* Paths of depth 3 *)
  (* .b74.#b73.#a45 *)
  let actual = r.b74.#b73.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 495;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 495 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a74 = a741; b74 = b741 } { a74 = a742; b74 = b742 } -> (fun a b -> Int.equal a b) a741 a742 && (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) b741 b742) in
  let next_r = { a74 = 100; b74 = #{ a73 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a74 = 0; b74 = #{ a73 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a74 *)
  r.a74 <- next_r.a74;
  let r_expected = { r_expected with a74 = next_r.a74 } in
  mark_test_run 496;
  let test = eq r r_expected in
  if not test then failwithf "test 496 failed";
  Gc.compact ();
  (* .b74 *)
  r.b74 <- next_r.b74;
  let r_expected = { r_expected with b74 = next_r.b74 } in
  mark_test_run 497;
  let test = eq r r_expected in
  if not test then failwithf "test 497 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a74; b74 = #{ a73; b73 = #{ a45 } } } = r in
  let expected_a74 = 100 in
  mark_test_run 498;
  let test = (fun a b -> Int.equal a b) expected_a74 a74 in
  if not test then failwithf "test 498 failed";
  let expected_a73 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 499;
  let test = int64x2_u_equal expected_a73 a73 in
  if not test then failwithf "test 499 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 500;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 500 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a74; b74 } = r in
  let expected_a74 = 100 in
  mark_test_run 501;
  let test = (fun a b -> Int.equal a b) expected_a74 a74 in
  if not test then failwithf "test 501 failed";
  let expected_b74 = #{ a73 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 502;
  let test = (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) expected_b74 b74 in
  if not test then failwithf "test 502 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t76 = { int; #{ #{ int; int } } }   *)
  (*****************************************)
  let r = { a76 = 0; b76 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a76 *)
  let actual = r.a76 in
  let expected = 0 in
  mark_test_run 503;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 503 failed";
  (* Paths of depth 1 *)
  (* .b76 *)
  let actual = r.b76 in
  let expected = #{ a75 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 504;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) actual expected in
  if not test then failwithf "test 504 failed";
  (* Paths of depth 2 *)
  (* .b76.#a75 *)
  let actual = r.b76.#a75 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 505;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 505 failed";
  (* Paths of depth 3 *)
  (* .b76.#a75.#a29 *)
  let actual = r.b76.#a75.#a29 in
  let expected = 1 in
  mark_test_run 506;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 506 failed";
  (* .b76.#a75.#b29 *)
  let actual = r.b76.#a75.#b29 in
  let expected = 2 in
  mark_test_run 507;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 507 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a76 = a761; b76 = b761 } { a76 = a762; b76 = b762 } -> (fun a b -> Int.equal a b) a761 a762 && (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) b761 b762) in
  let next_r = { a76 = 100; b76 = #{ a75 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a76 = 0; b76 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a76 *)
  r.a76 <- next_r.a76;
  let r_expected = { r_expected with a76 = next_r.a76 } in
  mark_test_run 508;
  let test = eq r r_expected in
  if not test then failwithf "test 508 failed";
  Gc.compact ();
  (* .b76 *)
  r.b76 <- next_r.b76;
  let r_expected = { r_expected with b76 = next_r.b76 } in
  mark_test_run 509;
  let test = eq r r_expected in
  if not test then failwithf "test 509 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a76; b76 = #{ a75 = #{ a29; b29 } } } = r in
  let expected_a76 = 100 in
  mark_test_run 510;
  let test = (fun a b -> Int.equal a b) expected_a76 a76 in
  if not test then failwithf "test 510 failed";
  let expected_a29 = 101 in
  mark_test_run 511;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 511 failed";
  let expected_b29 = 102 in
  mark_test_run 512;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 512 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a76; b76 } = r in
  let expected_a76 = 100 in
  mark_test_run 513;
  let test = (fun a b -> Int.equal a b) expected_a76 a76 in
  if not test then failwithf "test 513 failed";
  let expected_b76 = #{ a75 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 514;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) expected_b76 b76 in
  if not test then failwithf "test 514 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t78 = { int; #{ #{ int; int32# } } }   *)
  (********************************************)
  let r = { a78 = 0; b78 = #{ a77 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a78 *)
  let actual = r.a78 in
  let expected = 0 in
  mark_test_run 515;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 515 failed";
  (* Paths of depth 1 *)
  (* .b78 *)
  let actual = r.b78 in
  let expected = #{ a77 = #{ a31 = 1; b31 = #2l } } in
  mark_test_run 516;
  let test = (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) actual expected in
  if not test then failwithf "test 516 failed";
  (* Paths of depth 2 *)
  (* .b78.#a77 *)
  let actual = r.b78.#a77 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 517;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 517 failed";
  (* Paths of depth 3 *)
  (* .b78.#a77.#a31 *)
  let actual = r.b78.#a77.#a31 in
  let expected = 1 in
  mark_test_run 518;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 518 failed";
  (* .b78.#a77.#b31 *)
  let actual = r.b78.#a77.#b31 in
  let expected = #2l in
  mark_test_run 519;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 519 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a78 = a781; b78 = b781 } { a78 = a782; b78 = b782 } -> (fun a b -> Int.equal a b) a781 a782 && (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) b781 b782) in
  let next_r = { a78 = 100; b78 = #{ a77 = #{ a31 = 101; b31 = #102l } } } in
  let r_expected = { a78 = 0; b78 = #{ a77 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a78 *)
  r.a78 <- next_r.a78;
  let r_expected = { r_expected with a78 = next_r.a78 } in
  mark_test_run 520;
  let test = eq r r_expected in
  if not test then failwithf "test 520 failed";
  Gc.compact ();
  (* .b78 *)
  r.b78 <- next_r.b78;
  let r_expected = { r_expected with b78 = next_r.b78 } in
  mark_test_run 521;
  let test = eq r r_expected in
  if not test then failwithf "test 521 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a78; b78 = #{ a77 = #{ a31; b31 } } } = r in
  let expected_a78 = 100 in
  mark_test_run 522;
  let test = (fun a b -> Int.equal a b) expected_a78 a78 in
  if not test then failwithf "test 522 failed";
  let expected_a31 = 101 in
  mark_test_run 523;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 523 failed";
  let expected_b31 = #102l in
  mark_test_run 524;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 524 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a78; b78 } = r in
  let expected_a78 = 100 in
  mark_test_run 525;
  let test = (fun a b -> Int.equal a b) expected_a78 a78 in
  if not test then failwithf "test 525 failed";
  let expected_b78 = #{ a77 = #{ a31 = 101; b31 = #102l } } in
  mark_test_run 526;
  let test = (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) expected_b78 b78 in
  if not test then failwithf "test 526 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t80 = { int; #{ #{ int; float } } }   *)
  (*******************************************)
  let r = { a80 = 0; b80 = #{ a79 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a80 *)
  let actual = r.a80 in
  let expected = 0 in
  mark_test_run 527;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 527 failed";
  (* Paths of depth 1 *)
  (* .b80 *)
  let actual = r.b80 in
  let expected = #{ a79 = #{ a33 = 1; b33 = 2. } } in
  mark_test_run 528;
  let test = (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) actual expected in
  if not test then failwithf "test 528 failed";
  (* Paths of depth 2 *)
  (* .b80.#a79 *)
  let actual = r.b80.#a79 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 529;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 529 failed";
  (* Paths of depth 3 *)
  (* .b80.#a79.#a33 *)
  let actual = r.b80.#a79.#a33 in
  let expected = 1 in
  mark_test_run 530;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 530 failed";
  (* .b80.#a79.#b33 *)
  let actual = r.b80.#a79.#b33 in
  let expected = 2. in
  mark_test_run 531;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 531 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a80 = a801; b80 = b801 } { a80 = a802; b80 = b802 } -> (fun a b -> Int.equal a b) a801 a802 && (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) b801 b802) in
  let next_r = { a80 = 100; b80 = #{ a79 = #{ a33 = 101; b33 = 102. } } } in
  let r_expected = { a80 = 0; b80 = #{ a79 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a80 *)
  r.a80 <- next_r.a80;
  let r_expected = { r_expected with a80 = next_r.a80 } in
  mark_test_run 532;
  let test = eq r r_expected in
  if not test then failwithf "test 532 failed";
  Gc.compact ();
  (* .b80 *)
  r.b80 <- next_r.b80;
  let r_expected = { r_expected with b80 = next_r.b80 } in
  mark_test_run 533;
  let test = eq r r_expected in
  if not test then failwithf "test 533 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a80; b80 = #{ a79 = #{ a33; b33 } } } = r in
  let expected_a80 = 100 in
  mark_test_run 534;
  let test = (fun a b -> Int.equal a b) expected_a80 a80 in
  if not test then failwithf "test 534 failed";
  let expected_a33 = 101 in
  mark_test_run 535;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 535 failed";
  let expected_b33 = 102. in
  mark_test_run 536;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 536 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a80; b80 } = r in
  let expected_a80 = 100 in
  mark_test_run 537;
  let test = (fun a b -> Int.equal a b) expected_a80 a80 in
  if not test then failwithf "test 537 failed";
  let expected_b80 = #{ a79 = #{ a33 = 101; b33 = 102. } } in
  mark_test_run 538;
  let test = (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) expected_b80 b80 in
  if not test then failwithf "test 538 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t82 = { int; #{ #{ int; int64x2# } } }   *)
  (**********************************************)
  let r = { a82 = 0; b82 = #{ a81 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a82 *)
  let actual = r.a82 in
  let expected = 0 in
  mark_test_run 539;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 539 failed";
  (* Paths of depth 1 *)
  (* .b82 *)
  let actual = r.b82 in
  let expected = #{ a81 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  mark_test_run 540;
  let test = (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) actual expected in
  if not test then failwithf "test 540 failed";
  (* Paths of depth 2 *)
  (* .b82.#a81 *)
  let actual = r.b82.#a81 in
  let expected = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 541;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 541 failed";
  (* Paths of depth 3 *)
  (* .b82.#a81.#a35 *)
  let actual = r.b82.#a81.#a35 in
  let expected = 1 in
  mark_test_run 542;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 542 failed";
  (* .b82.#a81.#b35 *)
  let actual = r.b82.#a81.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 543;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 543 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a82 = a821; b82 = b821 } { a82 = a822; b82 = b822 } -> (fun a b -> Int.equal a b) a821 a822 && (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) b821 b822) in
  let next_r = { a82 = 100; b82 = #{ a81 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } } in
  let r_expected = { a82 = 0; b82 = #{ a81 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a82 *)
  r.a82 <- next_r.a82;
  let r_expected = { r_expected with a82 = next_r.a82 } in
  mark_test_run 544;
  let test = eq r r_expected in
  if not test then failwithf "test 544 failed";
  Gc.compact ();
  (* .b82 *)
  r.b82 <- next_r.b82;
  let r_expected = { r_expected with b82 = next_r.b82 } in
  mark_test_run 545;
  let test = eq r r_expected in
  if not test then failwithf "test 545 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a82; b82 = #{ a81 = #{ a35; b35 } } } = r in
  let expected_a82 = 100 in
  mark_test_run 546;
  let test = (fun a b -> Int.equal a b) expected_a82 a82 in
  if not test then failwithf "test 546 failed";
  let expected_a35 = 101 in
  mark_test_run 547;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 547 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 548;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 548 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a82; b82 } = r in
  let expected_a82 = 100 in
  mark_test_run 549;
  let test = (fun a b -> Int.equal a b) expected_a82 a82 in
  if not test then failwithf "test 549 failed";
  let expected_b82 = #{ a81 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  mark_test_run 550;
  let test = (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) expected_b82 b82 in
  if not test then failwithf "test 550 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t84 = { int; #{ #{ int32#; int } } }   *)
  (********************************************)
  let r = { a84 = 0; b84 = #{ a83 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a84 *)
  let actual = r.a84 in
  let expected = 0 in
  mark_test_run 551;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 551 failed";
  (* Paths of depth 1 *)
  (* .b84 *)
  let actual = r.b84 in
  let expected = #{ a83 = #{ a49 = #1l; b49 = 2 } } in
  mark_test_run 552;
  let test = (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) actual expected in
  if not test then failwithf "test 552 failed";
  (* Paths of depth 2 *)
  (* .b84.#a83 *)
  let actual = r.b84.#a83 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 553;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 553 failed";
  (* Paths of depth 3 *)
  (* .b84.#a83.#a49 *)
  let actual = r.b84.#a83.#a49 in
  let expected = #1l in
  mark_test_run 554;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 554 failed";
  (* .b84.#a83.#b49 *)
  let actual = r.b84.#a83.#b49 in
  let expected = 2 in
  mark_test_run 555;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 555 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a84 = a841; b84 = b841 } { a84 = a842; b84 = b842 } -> (fun a b -> Int.equal a b) a841 a842 && (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) b841 b842) in
  let next_r = { a84 = 100; b84 = #{ a83 = #{ a49 = #101l; b49 = 102 } } } in
  let r_expected = { a84 = 0; b84 = #{ a83 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a84 *)
  r.a84 <- next_r.a84;
  let r_expected = { r_expected with a84 = next_r.a84 } in
  mark_test_run 556;
  let test = eq r r_expected in
  if not test then failwithf "test 556 failed";
  Gc.compact ();
  (* .b84 *)
  r.b84 <- next_r.b84;
  let r_expected = { r_expected with b84 = next_r.b84 } in
  mark_test_run 557;
  let test = eq r r_expected in
  if not test then failwithf "test 557 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a84; b84 = #{ a83 = #{ a49; b49 } } } = r in
  let expected_a84 = 100 in
  mark_test_run 558;
  let test = (fun a b -> Int.equal a b) expected_a84 a84 in
  if not test then failwithf "test 558 failed";
  let expected_a49 = #101l in
  mark_test_run 559;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 559 failed";
  let expected_b49 = 102 in
  mark_test_run 560;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 560 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a84; b84 } = r in
  let expected_a84 = 100 in
  mark_test_run 561;
  let test = (fun a b -> Int.equal a b) expected_a84 a84 in
  if not test then failwithf "test 561 failed";
  let expected_b84 = #{ a83 = #{ a49 = #101l; b49 = 102 } } in
  mark_test_run 562;
  let test = (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) expected_b84 b84 in
  if not test then failwithf "test 562 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t86 = { int; #{ #{ int32#; int32# } } }   *)
  (***********************************************)
  let r = { a86 = 0; b86 = #{ a85 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a86 *)
  let actual = r.a86 in
  let expected = 0 in
  mark_test_run 563;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 563 failed";
  (* Paths of depth 1 *)
  (* .b86 *)
  let actual = r.b86 in
  let expected = #{ a85 = #{ a51 = #1l; b51 = #2l } } in
  mark_test_run 564;
  let test = (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) actual expected in
  if not test then failwithf "test 564 failed";
  (* Paths of depth 2 *)
  (* .b86.#a85 *)
  let actual = r.b86.#a85 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 565;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 565 failed";
  (* Paths of depth 3 *)
  (* .b86.#a85.#a51 *)
  let actual = r.b86.#a85.#a51 in
  let expected = #1l in
  mark_test_run 566;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 566 failed";
  (* .b86.#a85.#b51 *)
  let actual = r.b86.#a85.#b51 in
  let expected = #2l in
  mark_test_run 567;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 567 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a86 = a861; b86 = b861 } { a86 = a862; b86 = b862 } -> (fun a b -> Int.equal a b) a861 a862 && (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) b861 b862) in
  let next_r = { a86 = 100; b86 = #{ a85 = #{ a51 = #101l; b51 = #102l } } } in
  let r_expected = { a86 = 0; b86 = #{ a85 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a86 *)
  r.a86 <- next_r.a86;
  let r_expected = { r_expected with a86 = next_r.a86 } in
  mark_test_run 568;
  let test = eq r r_expected in
  if not test then failwithf "test 568 failed";
  Gc.compact ();
  (* .b86 *)
  r.b86 <- next_r.b86;
  let r_expected = { r_expected with b86 = next_r.b86 } in
  mark_test_run 569;
  let test = eq r r_expected in
  if not test then failwithf "test 569 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a86; b86 = #{ a85 = #{ a51; b51 } } } = r in
  let expected_a86 = 100 in
  mark_test_run 570;
  let test = (fun a b -> Int.equal a b) expected_a86 a86 in
  if not test then failwithf "test 570 failed";
  let expected_a51 = #101l in
  mark_test_run 571;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 571 failed";
  let expected_b51 = #102l in
  mark_test_run 572;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 572 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a86; b86 } = r in
  let expected_a86 = 100 in
  mark_test_run 573;
  let test = (fun a b -> Int.equal a b) expected_a86 a86 in
  if not test then failwithf "test 573 failed";
  let expected_b86 = #{ a85 = #{ a51 = #101l; b51 = #102l } } in
  mark_test_run 574;
  let test = (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) expected_b86 b86 in
  if not test then failwithf "test 574 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t88 = { int; #{ #{ float; int } } }   *)
  (*******************************************)
  let r = { a88 = 0; b88 = #{ a87 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a88 *)
  let actual = r.a88 in
  let expected = 0 in
  mark_test_run 575;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 575 failed";
  (* Paths of depth 1 *)
  (* .b88 *)
  let actual = r.b88 in
  let expected = #{ a87 = #{ a58 = 1.; b58 = 2 } } in
  mark_test_run 576;
  let test = (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) actual expected in
  if not test then failwithf "test 576 failed";
  (* Paths of depth 2 *)
  (* .b88.#a87 *)
  let actual = r.b88.#a87 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 577;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 577 failed";
  (* Paths of depth 3 *)
  (* .b88.#a87.#a58 *)
  let actual = r.b88.#a87.#a58 in
  let expected = 1. in
  mark_test_run 578;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 578 failed";
  (* .b88.#a87.#b58 *)
  let actual = r.b88.#a87.#b58 in
  let expected = 2 in
  mark_test_run 579;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 579 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a88 = a881; b88 = b881 } { a88 = a882; b88 = b882 } -> (fun a b -> Int.equal a b) a881 a882 && (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) b881 b882) in
  let next_r = { a88 = 100; b88 = #{ a87 = #{ a58 = 101.; b58 = 102 } } } in
  let r_expected = { a88 = 0; b88 = #{ a87 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a88 *)
  r.a88 <- next_r.a88;
  let r_expected = { r_expected with a88 = next_r.a88 } in
  mark_test_run 580;
  let test = eq r r_expected in
  if not test then failwithf "test 580 failed";
  Gc.compact ();
  (* .b88 *)
  r.b88 <- next_r.b88;
  let r_expected = { r_expected with b88 = next_r.b88 } in
  mark_test_run 581;
  let test = eq r r_expected in
  if not test then failwithf "test 581 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a88; b88 = #{ a87 = #{ a58; b58 } } } = r in
  let expected_a88 = 100 in
  mark_test_run 582;
  let test = (fun a b -> Int.equal a b) expected_a88 a88 in
  if not test then failwithf "test 582 failed";
  let expected_a58 = 101. in
  mark_test_run 583;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 583 failed";
  let expected_b58 = 102 in
  mark_test_run 584;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 584 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a88; b88 } = r in
  let expected_a88 = 100 in
  mark_test_run 585;
  let test = (fun a b -> Int.equal a b) expected_a88 a88 in
  if not test then failwithf "test 585 failed";
  let expected_b88 = #{ a87 = #{ a58 = 101.; b58 = 102 } } in
  mark_test_run 586;
  let test = (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) expected_b88 b88 in
  if not test then failwithf "test 586 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t90 = { int; #{ #{ float; float } } }   *)
  (*********************************************)
  let r = { a90 = 0; b90 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a90 *)
  let actual = r.a90 in
  let expected = 0 in
  mark_test_run 587;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 587 failed";
  (* Paths of depth 1 *)
  (* .b90 *)
  let actual = r.b90 in
  let expected = #{ a89 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 588;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) actual expected in
  if not test then failwithf "test 588 failed";
  (* Paths of depth 2 *)
  (* .b90.#a89 *)
  let actual = r.b90.#a89 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 589;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 589 failed";
  (* Paths of depth 3 *)
  (* .b90.#a89.#a60 *)
  let actual = r.b90.#a89.#a60 in
  let expected = 1. in
  mark_test_run 590;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 590 failed";
  (* .b90.#a89.#b60 *)
  let actual = r.b90.#a89.#b60 in
  let expected = 2. in
  mark_test_run 591;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 591 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a90 = a901; b90 = b901 } { a90 = a902; b90 = b902 } -> (fun a b -> Int.equal a b) a901 a902 && (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) b901 b902) in
  let next_r = { a90 = 100; b90 = #{ a89 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a90 = 0; b90 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a90 *)
  r.a90 <- next_r.a90;
  let r_expected = { r_expected with a90 = next_r.a90 } in
  mark_test_run 592;
  let test = eq r r_expected in
  if not test then failwithf "test 592 failed";
  Gc.compact ();
  (* .b90 *)
  r.b90 <- next_r.b90;
  let r_expected = { r_expected with b90 = next_r.b90 } in
  mark_test_run 593;
  let test = eq r r_expected in
  if not test then failwithf "test 593 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a90; b90 = #{ a89 = #{ a60; b60 } } } = r in
  let expected_a90 = 100 in
  mark_test_run 594;
  let test = (fun a b -> Int.equal a b) expected_a90 a90 in
  if not test then failwithf "test 594 failed";
  let expected_a60 = 101. in
  mark_test_run 595;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 595 failed";
  let expected_b60 = 102. in
  mark_test_run 596;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 596 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a90; b90 } = r in
  let expected_a90 = 100 in
  mark_test_run 597;
  let test = (fun a b -> Int.equal a b) expected_a90 a90 in
  if not test then failwithf "test 597 failed";
  let expected_b90 = #{ a89 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 598;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) expected_b90 b90 in
  if not test then failwithf "test 598 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t92 = { int; #{ #{ int64x2#; int } } }   *)
  (**********************************************)
  let r = { a92 = 0; b92 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a92 *)
  let actual = r.a92 in
  let expected = 0 in
  mark_test_run 599;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 599 failed";
  (* Paths of depth 1 *)
  (* .b92 *)
  let actual = r.b92 in
  let expected = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } in
  mark_test_run 600;
  let test = (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) actual expected in
  if not test then failwithf "test 600 failed";
  (* Paths of depth 2 *)
  (* .b92.#a91 *)
  let actual = r.b92.#a91 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } in
  mark_test_run 601;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 601 failed";
  (* Paths of depth 3 *)
  (* .b92.#a91.#a67 *)
  let actual = r.b92.#a91.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 602;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 602 failed";
  (* .b92.#a91.#b67 *)
  let actual = r.b92.#a91.#b67 in
  let expected = 3 in
  mark_test_run 603;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 603 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a92 = a921; b92 = b921 } { a92 = a922; b92 = b922 } -> (fun a b -> Int.equal a b) a921 a922 && (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) b921 b922) in
  let next_r = { a92 = 100; b92 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } } } in
  let r_expected = { a92 = 0; b92 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a92 *)
  r.a92 <- next_r.a92;
  let r_expected = { r_expected with a92 = next_r.a92 } in
  mark_test_run 604;
  let test = eq r r_expected in
  if not test then failwithf "test 604 failed";
  Gc.compact ();
  (* .b92 *)
  r.b92 <- next_r.b92;
  let r_expected = { r_expected with b92 = next_r.b92 } in
  mark_test_run 605;
  let test = eq r r_expected in
  if not test then failwithf "test 605 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a92; b92 = #{ a91 = #{ a67; b67 } } } = r in
  let expected_a92 = 100 in
  mark_test_run 606;
  let test = (fun a b -> Int.equal a b) expected_a92 a92 in
  if not test then failwithf "test 606 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 607;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 607 failed";
  let expected_b67 = 103 in
  mark_test_run 608;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 608 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a92; b92 } = r in
  let expected_a92 = 100 in
  mark_test_run 609;
  let test = (fun a b -> Int.equal a b) expected_a92 a92 in
  if not test then failwithf "test 609 failed";
  let expected_b92 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } } in
  mark_test_run 610;
  let test = (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) expected_b92 b92 in
  if not test then failwithf "test 610 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t94 = { int; #{ #{ int64x2#; int64x2# } } }   *)
  (***************************************************)
  let r = { a94 = 0; b94 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a94 *)
  let actual = r.a94 in
  let expected = 0 in
  mark_test_run 611;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 611 failed";
  (* Paths of depth 1 *)
  (* .b94 *)
  let actual = r.b94 in
  let expected = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 612;
  let test = (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) actual expected in
  if not test then failwithf "test 612 failed";
  (* Paths of depth 2 *)
  (* .b94.#a93 *)
  let actual = r.b94.#a93 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 613;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 613 failed";
  (* Paths of depth 3 *)
  (* .b94.#a93.#a69 *)
  let actual = r.b94.#a93.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 614;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 614 failed";
  (* .b94.#a93.#b69 *)
  let actual = r.b94.#a93.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 615;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 615 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a94 = a941; b94 = b941 } { a94 = a942; b94 = b942 } -> (fun a b -> Int.equal a b) a941 a942 && (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) b941 b942) in
  let next_r = { a94 = 100; b94 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a94 = 0; b94 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a94 *)
  r.a94 <- next_r.a94;
  let r_expected = { r_expected with a94 = next_r.a94 } in
  mark_test_run 616;
  let test = eq r r_expected in
  if not test then failwithf "test 616 failed";
  Gc.compact ();
  (* .b94 *)
  r.b94 <- next_r.b94;
  let r_expected = { r_expected with b94 = next_r.b94 } in
  mark_test_run 617;
  let test = eq r r_expected in
  if not test then failwithf "test 617 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a94; b94 = #{ a93 = #{ a69; b69 } } } = r in
  let expected_a94 = 100 in
  mark_test_run 618;
  let test = (fun a b -> Int.equal a b) expected_a94 a94 in
  if not test then failwithf "test 618 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 619;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 619 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 620;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 620 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a94; b94 } = r in
  let expected_a94 = 100 in
  mark_test_run 621;
  let test = (fun a b -> Int.equal a b) expected_a94 a94 in
  if not test then failwithf "test 621 failed";
  let expected_b94 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 622;
  let test = (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) expected_b94 b94 in
  if not test then failwithf "test 622 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************)
  (*   t95 = { int64 }   *)
  (***********************)
  let r = { a95 = 0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a95 *)
  let actual = r.a95 in
  let expected = 0L in
  mark_test_run 623;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 623 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a95 = a951 } { a95 = a952 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a951 a952) in
  let next_r = { a95 = 100L } in
  let r_expected = { a95 = 0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a95 *)
  r.a95 <- next_r.a95;
  let r_expected = { r_expected with a95 = next_r.a95 } in
  mark_test_run 624;
  let test = eq r r_expected in
  if not test then failwithf "test 624 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a95 } = r in
  let expected_a95 = 100L in
  mark_test_run 625;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a95 a95 in
  if not test then failwithf "test 625 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a95 } = r in
  let expected_a95 = 100L in
  mark_test_run 626;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a95 a95 in
  if not test then failwithf "test 626 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t96 = { int64; int }   *)
  (****************************)
  let r = { a96 = 0L; b96 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a96 *)
  let actual = r.a96 in
  let expected = 0L in
  mark_test_run 627;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 627 failed";
  (* Paths of depth 1 *)
  (* .b96 *)
  let actual = r.b96 in
  let expected = 1 in
  mark_test_run 628;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 628 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a96 = a961; b96 = b961 } { a96 = a962; b96 = b962 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a961 a962 && (fun a b -> Int.equal a b) b961 b962) in
  let next_r = { a96 = 100L; b96 = 101 } in
  let r_expected = { a96 = 0L; b96 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a96 *)
  r.a96 <- next_r.a96;
  let r_expected = { r_expected with a96 = next_r.a96 } in
  mark_test_run 629;
  let test = eq r r_expected in
  if not test then failwithf "test 629 failed";
  Gc.compact ();
  (* .b96 *)
  r.b96 <- next_r.b96;
  let r_expected = { r_expected with b96 = next_r.b96 } in
  mark_test_run 630;
  let test = eq r r_expected in
  if not test then failwithf "test 630 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a96; b96 } = r in
  let expected_a96 = 100L in
  mark_test_run 631;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a96 a96 in
  if not test then failwithf "test 631 failed";
  let expected_b96 = 101 in
  mark_test_run 632;
  let test = (fun a b -> Int.equal a b) expected_b96 b96 in
  if not test then failwithf "test 632 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a96; b96 } = r in
  let expected_a96 = 100L in
  mark_test_run 633;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a96 a96 in
  if not test then failwithf "test 633 failed";
  let expected_b96 = 101 in
  mark_test_run 634;
  let test = (fun a b -> Int.equal a b) expected_b96 b96 in
  if not test then failwithf "test 634 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t97 = { int64; int64 }   *)
  (******************************)
  let r = { a97 = 0L; b97 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a97 *)
  let actual = r.a97 in
  let expected = 0L in
  mark_test_run 635;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 635 failed";
  (* Paths of depth 1 *)
  (* .b97 *)
  let actual = r.b97 in
  let expected = 1L in
  mark_test_run 636;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 636 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a97 = a971; b97 = b971 } { a97 = a972; b97 = b972 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a971 a972 && (fun a b -> Int64.equal (globalize a) (globalize b)) b971 b972) in
  let next_r = { a97 = 100L; b97 = 101L } in
  let r_expected = { a97 = 0L; b97 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a97 *)
  r.a97 <- next_r.a97;
  let r_expected = { r_expected with a97 = next_r.a97 } in
  mark_test_run 637;
  let test = eq r r_expected in
  if not test then failwithf "test 637 failed";
  Gc.compact ();
  (* .b97 *)
  r.b97 <- next_r.b97;
  let r_expected = { r_expected with b97 = next_r.b97 } in
  mark_test_run 638;
  let test = eq r r_expected in
  if not test then failwithf "test 638 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a97; b97 } = r in
  let expected_a97 = 100L in
  mark_test_run 639;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a97 a97 in
  if not test then failwithf "test 639 failed";
  let expected_b97 = 101L in
  mark_test_run 640;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b97 b97 in
  if not test then failwithf "test 640 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a97; b97 } = r in
  let expected_a97 = 100L in
  mark_test_run 641;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a97 a97 in
  if not test then failwithf "test 641 failed";
  let expected_b97 = 101L in
  mark_test_run 642;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b97 b97 in
  if not test then failwithf "test 642 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t98 = { int64; int64# }   *)
  (*******************************)
  let r = { a98 = 0L; b98 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a98 *)
  let actual = r.a98 in
  let expected = 0L in
  mark_test_run 643;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 643 failed";
  (* Paths of depth 1 *)
  (* .b98 *)
  let actual = r.b98 in
  let expected = #1L in
  mark_test_run 644;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 644 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a98 = a981; b98 = b981 } { a98 = a982; b98 = b982 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a981 a982 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b981 b982) in
  let next_r = { a98 = 100L; b98 = #101L } in
  let r_expected = { a98 = 0L; b98 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a98 *)
  r.a98 <- next_r.a98;
  let r_expected = { r_expected with a98 = next_r.a98 } in
  mark_test_run 645;
  let test = eq r r_expected in
  if not test then failwithf "test 645 failed";
  Gc.compact ();
  (* .b98 *)
  r.b98 <- next_r.b98;
  let r_expected = { r_expected with b98 = next_r.b98 } in
  mark_test_run 646;
  let test = eq r r_expected in
  if not test then failwithf "test 646 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a98; b98 } = r in
  let expected_a98 = 100L in
  mark_test_run 647;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a98 a98 in
  if not test then failwithf "test 647 failed";
  let expected_b98 = #101L in
  mark_test_run 648;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b98 b98 in
  if not test then failwithf "test 648 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a98; b98 } = r in
  let expected_a98 = 100L in
  mark_test_run 649;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a98 a98 in
  if not test then failwithf "test 649 failed";
  let expected_b98 = #101L in
  mark_test_run 650;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b98 b98 in
  if not test then failwithf "test 650 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t99 = { int64; int32# }   *)
  (*******************************)
  let r = { a99 = 0L; b99 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a99 *)
  let actual = r.a99 in
  let expected = 0L in
  mark_test_run 651;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 651 failed";
  (* Paths of depth 1 *)
  (* .b99 *)
  let actual = r.b99 in
  let expected = #1l in
  mark_test_run 652;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 652 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a99 = a991; b99 = b991 } { a99 = a992; b99 = b992 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a991 a992 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b991 b992) in
  let next_r = { a99 = 100L; b99 = #101l } in
  let r_expected = { a99 = 0L; b99 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a99 *)
  r.a99 <- next_r.a99;
  let r_expected = { r_expected with a99 = next_r.a99 } in
  mark_test_run 653;
  let test = eq r r_expected in
  if not test then failwithf "test 653 failed";
  Gc.compact ();
  (* .b99 *)
  r.b99 <- next_r.b99;
  let r_expected = { r_expected with b99 = next_r.b99 } in
  mark_test_run 654;
  let test = eq r r_expected in
  if not test then failwithf "test 654 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a99; b99 } = r in
  let expected_a99 = 100L in
  mark_test_run 655;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a99 a99 in
  if not test then failwithf "test 655 failed";
  let expected_b99 = #101l in
  mark_test_run 656;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b99 b99 in
  if not test then failwithf "test 656 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a99; b99 } = r in
  let expected_a99 = 100L in
  mark_test_run 657;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a99 a99 in
  if not test then failwithf "test 657 failed";
  let expected_b99 = #101l in
  mark_test_run 658;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b99 b99 in
  if not test then failwithf "test 658 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t100 = { int64; nativeint# }   *)
  (************************************)
  let r = { a100 = 0L; b100 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a100 *)
  let actual = r.a100 in
  let expected = 0L in
  mark_test_run 659;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 659 failed";
  (* Paths of depth 1 *)
  (* .b100 *)
  let actual = r.b100 in
  let expected = #1n in
  mark_test_run 660;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 660 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a100 = a1001; b100 = b1001 } { a100 = a1002; b100 = b1002 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1001 a1002 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1001 b1002) in
  let next_r = { a100 = 100L; b100 = #101n } in
  let r_expected = { a100 = 0L; b100 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a100 *)
  r.a100 <- next_r.a100;
  let r_expected = { r_expected with a100 = next_r.a100 } in
  mark_test_run 661;
  let test = eq r r_expected in
  if not test then failwithf "test 661 failed";
  Gc.compact ();
  (* .b100 *)
  r.b100 <- next_r.b100;
  let r_expected = { r_expected with b100 = next_r.b100 } in
  mark_test_run 662;
  let test = eq r r_expected in
  if not test then failwithf "test 662 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a100; b100 } = r in
  let expected_a100 = 100L in
  mark_test_run 663;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a100 a100 in
  if not test then failwithf "test 663 failed";
  let expected_b100 = #101n in
  mark_test_run 664;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b100 b100 in
  if not test then failwithf "test 664 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a100; b100 } = r in
  let expected_a100 = 100L in
  mark_test_run 665;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a100 a100 in
  if not test then failwithf "test 665 failed";
  let expected_b100 = #101n in
  mark_test_run 666;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b100 b100 in
  if not test then failwithf "test 666 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t101 = { int64; unit_u }   *)
  (********************************)
  let r = { a101 = 0L; b101 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a101 *)
  let actual = r.a101 in
  let expected = 0L in
  mark_test_run 667;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 667 failed";
  (* Paths of depth 1 *)
  (* .b101 *)
  let actual = r.b101 in
  let expected = (unbox_unit ()) in
  mark_test_run 668;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 668 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a101 = a1011; b101 = b1011 } { a101 = a1012; b101 = b1012 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1011 a1012 && (fun _ _ -> true) b1011 b1012) in
  let next_r = { a101 = 100L; b101 = (unbox_unit ()) } in
  let r_expected = { a101 = 0L; b101 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a101 *)
  r.a101 <- next_r.a101;
  let r_expected = { r_expected with a101 = next_r.a101 } in
  mark_test_run 669;
  let test = eq r r_expected in
  if not test then failwithf "test 669 failed";
  Gc.compact ();
  (* .b101 *)
  r.b101 <- next_r.b101;
  let r_expected = { r_expected with b101 = next_r.b101 } in
  mark_test_run 670;
  let test = eq r r_expected in
  if not test then failwithf "test 670 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a101; b101 } = r in
  let expected_a101 = 100L in
  mark_test_run 671;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a101 a101 in
  if not test then failwithf "test 671 failed";
  let expected_b101 = (unbox_unit ()) in
  mark_test_run 672;
  let test = (fun _ _ -> true) expected_b101 b101 in
  if not test then failwithf "test 672 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a101; b101 } = r in
  let expected_a101 = 100L in
  mark_test_run 673;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a101 a101 in
  if not test then failwithf "test 673 failed";
  let expected_b101 = (unbox_unit ()) in
  mark_test_run 674;
  let test = (fun _ _ -> true) expected_b101 b101 in
  if not test then failwithf "test 674 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t102 = { int64; float }   *)
  (*******************************)
  let r = { a102 = 0L; b102 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a102 *)
  let actual = r.a102 in
  let expected = 0L in
  mark_test_run 675;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 675 failed";
  (* Paths of depth 1 *)
  (* .b102 *)
  let actual = r.b102 in
  let expected = 1. in
  mark_test_run 676;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 676 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a102 = a1021; b102 = b1021 } { a102 = a1022; b102 = b1022 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1021 a1022 && (fun a b -> Float.equal (globalize a) (globalize b)) b1021 b1022) in
  let next_r = { a102 = 100L; b102 = 101. } in
  let r_expected = { a102 = 0L; b102 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a102 *)
  r.a102 <- next_r.a102;
  let r_expected = { r_expected with a102 = next_r.a102 } in
  mark_test_run 677;
  let test = eq r r_expected in
  if not test then failwithf "test 677 failed";
  Gc.compact ();
  (* .b102 *)
  r.b102 <- next_r.b102;
  let r_expected = { r_expected with b102 = next_r.b102 } in
  mark_test_run 678;
  let test = eq r r_expected in
  if not test then failwithf "test 678 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a102; b102 } = r in
  let expected_a102 = 100L in
  mark_test_run 679;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a102 a102 in
  if not test then failwithf "test 679 failed";
  let expected_b102 = 101. in
  mark_test_run 680;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b102 b102 in
  if not test then failwithf "test 680 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a102; b102 } = r in
  let expected_a102 = 100L in
  mark_test_run 681;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a102 a102 in
  if not test then failwithf "test 681 failed";
  let expected_b102 = 101. in
  mark_test_run 682;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b102 b102 in
  if not test then failwithf "test 682 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t103 = { int64; (| unit_u) }   *)
  (************************************)
  let r = { a103 = 0L; b103 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a103 *)
  let actual = r.a103 in
  let expected = 0L in
  mark_test_run 683;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 683 failed";
  (* Paths of depth 1 *)
  (* .b103 *)
  let actual = r.b103 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 684;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 684 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a103 = a1031; b103 = b1031 } { a103 = a1032; b103 = b1032 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1031 a1032 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b1031 b1032) in
  let next_r = { a103 = 100L; b103 = C19_0((unbox_unit ())) } in
  let r_expected = { a103 = 0L; b103 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a103 *)
  r.a103 <- next_r.a103;
  let r_expected = { r_expected with a103 = next_r.a103 } in
  mark_test_run 685;
  let test = eq r r_expected in
  if not test then failwithf "test 685 failed";
  Gc.compact ();
  (* .b103 *)
  r.b103 <- next_r.b103;
  let r_expected = { r_expected with b103 = next_r.b103 } in
  mark_test_run 686;
  let test = eq r r_expected in
  if not test then failwithf "test 686 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a103; b103 } = r in
  let expected_a103 = 100L in
  mark_test_run 687;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a103 a103 in
  if not test then failwithf "test 687 failed";
  let expected_b103 = C19_0((unbox_unit ())) in
  mark_test_run 688;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b103 b103 in
  if not test then failwithf "test 688 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a103; b103 } = r in
  let expected_a103 = 100L in
  mark_test_run 689;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a103 a103 in
  if not test then failwithf "test 689 failed";
  let expected_b103 = C19_0((unbox_unit ())) in
  mark_test_run 690;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b103 b103 in
  if not test then failwithf "test 690 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************)
  (*   t104 = { int64; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (**************************************************************************)
  let r = { a104 = 0L; b104 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a104 *)
  let actual = r.a104 in
  let expected = 0L in
  mark_test_run 691;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 691 failed";
  (* Paths of depth 1 *)
  (* .b104 *)
  let actual = r.b104 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 692;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 692 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a104 = a1041; b104 = b1041 } { a104 = a1042; b104 = b1042 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1041 a1042 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b1041 b1042) in
  let next_r = { a104 = 100L; b104 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a104 = 0L; b104 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a104 *)
  r.a104 <- next_r.a104;
  let r_expected = { r_expected with a104 = next_r.a104 } in
  mark_test_run 693;
  let test = eq r r_expected in
  if not test then failwithf "test 693 failed";
  Gc.compact ();
  (* .b104 *)
  r.b104 <- next_r.b104;
  let r_expected = { r_expected with b104 = next_r.b104 } in
  mark_test_run 694;
  let test = eq r r_expected in
  if not test then failwithf "test 694 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a104; b104 } = r in
  let expected_a104 = 100L in
  mark_test_run 695;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a104 a104 in
  if not test then failwithf "test 695 failed";
  let expected_b104 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 696;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b104 b104 in
  if not test then failwithf "test 696 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a104; b104 } = r in
  let expected_a104 = 100L in
  mark_test_run 697;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a104 a104 in
  if not test then failwithf "test 697 failed";
  let expected_b104 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 698;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b104 b104 in
  if not test then failwithf "test 698 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t105 = { int64; #(unit_u, int) }   *)
  (****************************************)
  let r = { a105 = 0L; b105 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a105 *)
  let actual = r.a105 in
  let expected = 0L in
  mark_test_run 699;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 699 failed";
  (* Paths of depth 1 *)
  (* .b105 *)
  let actual = r.b105 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 700;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 700 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a105 = a1051; b105 = b1051 } { a105 = a1052; b105 = b1052 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1051 a1052 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b1051 b1052) in
  let next_r = { a105 = 100L; b105 = #((unbox_unit ()), 101) } in
  let r_expected = { a105 = 0L; b105 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a105 *)
  r.a105 <- next_r.a105;
  let r_expected = { r_expected with a105 = next_r.a105 } in
  mark_test_run 701;
  let test = eq r r_expected in
  if not test then failwithf "test 701 failed";
  Gc.compact ();
  (* .b105 *)
  r.b105 <- next_r.b105;
  let r_expected = { r_expected with b105 = next_r.b105 } in
  mark_test_run 702;
  let test = eq r r_expected in
  if not test then failwithf "test 702 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a105; b105 } = r in
  let expected_a105 = 100L in
  mark_test_run 703;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a105 a105 in
  if not test then failwithf "test 703 failed";
  let expected_b105 = #((unbox_unit ()), 101) in
  mark_test_run 704;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b105 b105 in
  if not test then failwithf "test 704 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a105; b105 } = r in
  let expected_a105 = 100L in
  mark_test_run 705;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a105 a105 in
  if not test then failwithf "test 705 failed";
  let expected_b105 = #((unbox_unit ()), 101) in
  mark_test_run 706;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b105 b105 in
  if not test then failwithf "test 706 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t106 = { int64; #(unit_u, int64#) }   *)
  (*******************************************)
  let r = { a106 = 0L; b106 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a106 *)
  let actual = r.a106 in
  let expected = 0L in
  mark_test_run 707;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 707 failed";
  (* Paths of depth 1 *)
  (* .b106 *)
  let actual = r.b106 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 708;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 708 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a106 = a1061; b106 = b1061 } { a106 = a1062; b106 = b1062 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1061 a1062 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b1061 b1062) in
  let next_r = { a106 = 100L; b106 = #((unbox_unit ()), #101L) } in
  let r_expected = { a106 = 0L; b106 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a106 *)
  r.a106 <- next_r.a106;
  let r_expected = { r_expected with a106 = next_r.a106 } in
  mark_test_run 709;
  let test = eq r r_expected in
  if not test then failwithf "test 709 failed";
  Gc.compact ();
  (* .b106 *)
  r.b106 <- next_r.b106;
  let r_expected = { r_expected with b106 = next_r.b106 } in
  mark_test_run 710;
  let test = eq r r_expected in
  if not test then failwithf "test 710 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a106; b106 } = r in
  let expected_a106 = 100L in
  mark_test_run 711;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a106 a106 in
  if not test then failwithf "test 711 failed";
  let expected_b106 = #((unbox_unit ()), #101L) in
  mark_test_run 712;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b106 b106 in
  if not test then failwithf "test 712 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a106; b106 } = r in
  let expected_a106 = 100L in
  mark_test_run 713;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a106 a106 in
  if not test then failwithf "test 713 failed";
  let expected_b106 = #((unbox_unit ()), #101L) in
  mark_test_run 714;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b106 b106 in
  if not test then failwithf "test 714 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t107 = { int64; #(unit_u, unit_u) }   *)
  (*******************************************)
  let r = { a107 = 0L; b107 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a107 *)
  let actual = r.a107 in
  let expected = 0L in
  mark_test_run 715;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 715 failed";
  (* Paths of depth 1 *)
  (* .b107 *)
  let actual = r.b107 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 716;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 716 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a107 = a1071; b107 = b1071 } { a107 = a1072; b107 = b1072 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1071 a1072 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b1071 b1072) in
  let next_r = { a107 = 100L; b107 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a107 = 0L; b107 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a107 *)
  r.a107 <- next_r.a107;
  let r_expected = { r_expected with a107 = next_r.a107 } in
  mark_test_run 717;
  let test = eq r r_expected in
  if not test then failwithf "test 717 failed";
  Gc.compact ();
  (* .b107 *)
  r.b107 <- next_r.b107;
  let r_expected = { r_expected with b107 = next_r.b107 } in
  mark_test_run 718;
  let test = eq r r_expected in
  if not test then failwithf "test 718 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a107; b107 } = r in
  let expected_a107 = 100L in
  mark_test_run 719;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a107 a107 in
  if not test then failwithf "test 719 failed";
  let expected_b107 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 720;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b107 b107 in
  if not test then failwithf "test 720 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a107; b107 } = r in
  let expected_a107 = 100L in
  mark_test_run 721;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a107 a107 in
  if not test then failwithf "test 721 failed";
  let expected_b107 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 722;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b107 b107 in
  if not test then failwithf "test 722 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t108 = { int64; #(unit_u, string) }   *)
  (*******************************************)
  let r = { a108 = 0L; b108 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a108 *)
  let actual = r.a108 in
  let expected = 0L in
  mark_test_run 723;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 723 failed";
  (* Paths of depth 1 *)
  (* .b108 *)
  let actual = r.b108 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 724;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 724 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a108 = a1081; b108 = b1081 } { a108 = a1082; b108 = b1082 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1081 a1082 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b1081 b1082) in
  let next_r = { a108 = 100L; b108 = #((unbox_unit ()), "101") } in
  let r_expected = { a108 = 0L; b108 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a108 *)
  r.a108 <- next_r.a108;
  let r_expected = { r_expected with a108 = next_r.a108 } in
  mark_test_run 725;
  let test = eq r r_expected in
  if not test then failwithf "test 725 failed";
  Gc.compact ();
  (* .b108 *)
  r.b108 <- next_r.b108;
  let r_expected = { r_expected with b108 = next_r.b108 } in
  mark_test_run 726;
  let test = eq r r_expected in
  if not test then failwithf "test 726 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a108; b108 } = r in
  let expected_a108 = 100L in
  mark_test_run 727;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a108 a108 in
  if not test then failwithf "test 727 failed";
  let expected_b108 = #((unbox_unit ()), "101") in
  mark_test_run 728;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b108 b108 in
  if not test then failwithf "test 728 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a108; b108 } = r in
  let expected_a108 = 100L in
  mark_test_run 729;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a108 a108 in
  if not test then failwithf "test 729 failed";
  let expected_b108 = #((unbox_unit ()), "101") in
  mark_test_run 730;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b108 b108 in
  if not test then failwithf "test 730 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t109 = { int64# }   *)
  (*************************)
  let r = { a109 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a109 *)
  let actual = r.a109 in
  let expected = #0L in
  mark_test_run 731;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 731 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a109 = a1091 } { a109 = a1092 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1091 a1092) in
  let next_r = { a109 = #100L } in
  let r_expected = { a109 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a109 *)
  r.a109 <- next_r.a109;
  let r_expected = { r_expected with a109 = next_r.a109 } in
  mark_test_run 732;
  let test = eq r r_expected in
  if not test then failwithf "test 732 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a109 } = r in
  let expected_a109 = #100L in
  mark_test_run 733;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a109 a109 in
  if not test then failwithf "test 733 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a109 } = r in
  let expected_a109 = #100L in
  mark_test_run 734;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a109 a109 in
  if not test then failwithf "test 734 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t110 = { int64#; int }   *)
  (******************************)
  let r = { a110 = #0L; b110 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a110 *)
  let actual = r.a110 in
  let expected = #0L in
  mark_test_run 735;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 735 failed";
  (* Paths of depth 1 *)
  (* .b110 *)
  let actual = r.b110 in
  let expected = 1 in
  mark_test_run 736;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 736 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a110 = a1101; b110 = b1101 } { a110 = a1102; b110 = b1102 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1101 a1102 && (fun a b -> Int.equal a b) b1101 b1102) in
  let next_r = { a110 = #100L; b110 = 101 } in
  let r_expected = { a110 = #0L; b110 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a110 *)
  r.a110 <- next_r.a110;
  let r_expected = { r_expected with a110 = next_r.a110 } in
  mark_test_run 737;
  let test = eq r r_expected in
  if not test then failwithf "test 737 failed";
  Gc.compact ();
  (* .b110 *)
  r.b110 <- next_r.b110;
  let r_expected = { r_expected with b110 = next_r.b110 } in
  mark_test_run 738;
  let test = eq r r_expected in
  if not test then failwithf "test 738 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a110; b110 } = r in
  let expected_a110 = #100L in
  mark_test_run 739;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a110 a110 in
  if not test then failwithf "test 739 failed";
  let expected_b110 = 101 in
  mark_test_run 740;
  let test = (fun a b -> Int.equal a b) expected_b110 b110 in
  if not test then failwithf "test 740 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a110; b110 } = r in
  let expected_a110 = #100L in
  mark_test_run 741;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a110 a110 in
  if not test then failwithf "test 741 failed";
  let expected_b110 = 101 in
  mark_test_run 742;
  let test = (fun a b -> Int.equal a b) expected_b110 b110 in
  if not test then failwithf "test 742 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t111 = { int64#; int64 }   *)
  (********************************)
  let r = { a111 = #0L; b111 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a111 *)
  let actual = r.a111 in
  let expected = #0L in
  mark_test_run 743;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 743 failed";
  (* Paths of depth 1 *)
  (* .b111 *)
  let actual = r.b111 in
  let expected = 1L in
  mark_test_run 744;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 744 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a111 = a1111; b111 = b1111 } { a111 = a1112; b111 = b1112 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1111 a1112 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1111 b1112) in
  let next_r = { a111 = #100L; b111 = 101L } in
  let r_expected = { a111 = #0L; b111 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a111 *)
  r.a111 <- next_r.a111;
  let r_expected = { r_expected with a111 = next_r.a111 } in
  mark_test_run 745;
  let test = eq r r_expected in
  if not test then failwithf "test 745 failed";
  Gc.compact ();
  (* .b111 *)
  r.b111 <- next_r.b111;
  let r_expected = { r_expected with b111 = next_r.b111 } in
  mark_test_run 746;
  let test = eq r r_expected in
  if not test then failwithf "test 746 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a111; b111 } = r in
  let expected_a111 = #100L in
  mark_test_run 747;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a111 a111 in
  if not test then failwithf "test 747 failed";
  let expected_b111 = 101L in
  mark_test_run 748;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b111 b111 in
  if not test then failwithf "test 748 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a111; b111 } = r in
  let expected_a111 = #100L in
  mark_test_run 749;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a111 a111 in
  if not test then failwithf "test 749 failed";
  let expected_b111 = 101L in
  mark_test_run 750;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b111 b111 in
  if not test then failwithf "test 750 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t112 = { int64#; int64# }   *)
  (*********************************)
  let r = { a112 = #0L; b112 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a112 *)
  let actual = r.a112 in
  let expected = #0L in
  mark_test_run 751;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 751 failed";
  (* Paths of depth 1 *)
  (* .b112 *)
  let actual = r.b112 in
  let expected = #1L in
  mark_test_run 752;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 752 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a112 = a1121; b112 = b1121 } { a112 = a1122; b112 = b1122 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1121 a1122 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1121 b1122) in
  let next_r = { a112 = #100L; b112 = #101L } in
  let r_expected = { a112 = #0L; b112 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a112 *)
  r.a112 <- next_r.a112;
  let r_expected = { r_expected with a112 = next_r.a112 } in
  mark_test_run 753;
  let test = eq r r_expected in
  if not test then failwithf "test 753 failed";
  Gc.compact ();
  (* .b112 *)
  r.b112 <- next_r.b112;
  let r_expected = { r_expected with b112 = next_r.b112 } in
  mark_test_run 754;
  let test = eq r r_expected in
  if not test then failwithf "test 754 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a112; b112 } = r in
  let expected_a112 = #100L in
  mark_test_run 755;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a112 a112 in
  if not test then failwithf "test 755 failed";
  let expected_b112 = #101L in
  mark_test_run 756;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b112 b112 in
  if not test then failwithf "test 756 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a112; b112 } = r in
  let expected_a112 = #100L in
  mark_test_run 757;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a112 a112 in
  if not test then failwithf "test 757 failed";
  let expected_b112 = #101L in
  mark_test_run 758;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b112 b112 in
  if not test then failwithf "test 758 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t113 = { int64#; int32# }   *)
  (*********************************)
  let r = { a113 = #0L; b113 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a113 *)
  let actual = r.a113 in
  let expected = #0L in
  mark_test_run 759;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 759 failed";
  (* Paths of depth 1 *)
  (* .b113 *)
  let actual = r.b113 in
  let expected = #1l in
  mark_test_run 760;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 760 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a113 = a1131; b113 = b1131 } { a113 = a1132; b113 = b1132 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1131 a1132 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1131 b1132) in
  let next_r = { a113 = #100L; b113 = #101l } in
  let r_expected = { a113 = #0L; b113 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a113 *)
  r.a113 <- next_r.a113;
  let r_expected = { r_expected with a113 = next_r.a113 } in
  mark_test_run 761;
  let test = eq r r_expected in
  if not test then failwithf "test 761 failed";
  Gc.compact ();
  (* .b113 *)
  r.b113 <- next_r.b113;
  let r_expected = { r_expected with b113 = next_r.b113 } in
  mark_test_run 762;
  let test = eq r r_expected in
  if not test then failwithf "test 762 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a113; b113 } = r in
  let expected_a113 = #100L in
  mark_test_run 763;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a113 a113 in
  if not test then failwithf "test 763 failed";
  let expected_b113 = #101l in
  mark_test_run 764;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b113 b113 in
  if not test then failwithf "test 764 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a113; b113 } = r in
  let expected_a113 = #100L in
  mark_test_run 765;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a113 a113 in
  if not test then failwithf "test 765 failed";
  let expected_b113 = #101l in
  mark_test_run 766;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b113 b113 in
  if not test then failwithf "test 766 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t114 = { int64#; nativeint# }   *)
  (*************************************)
  let r = { a114 = #0L; b114 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a114 *)
  let actual = r.a114 in
  let expected = #0L in
  mark_test_run 767;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 767 failed";
  (* Paths of depth 1 *)
  (* .b114 *)
  let actual = r.b114 in
  let expected = #1n in
  mark_test_run 768;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 768 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a114 = a1141; b114 = b1141 } { a114 = a1142; b114 = b1142 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1141 a1142 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1141 b1142) in
  let next_r = { a114 = #100L; b114 = #101n } in
  let r_expected = { a114 = #0L; b114 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a114 *)
  r.a114 <- next_r.a114;
  let r_expected = { r_expected with a114 = next_r.a114 } in
  mark_test_run 769;
  let test = eq r r_expected in
  if not test then failwithf "test 769 failed";
  Gc.compact ();
  (* .b114 *)
  r.b114 <- next_r.b114;
  let r_expected = { r_expected with b114 = next_r.b114 } in
  mark_test_run 770;
  let test = eq r r_expected in
  if not test then failwithf "test 770 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a114; b114 } = r in
  let expected_a114 = #100L in
  mark_test_run 771;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a114 a114 in
  if not test then failwithf "test 771 failed";
  let expected_b114 = #101n in
  mark_test_run 772;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b114 b114 in
  if not test then failwithf "test 772 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a114; b114 } = r in
  let expected_a114 = #100L in
  mark_test_run 773;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a114 a114 in
  if not test then failwithf "test 773 failed";
  let expected_b114 = #101n in
  mark_test_run 774;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b114 b114 in
  if not test then failwithf "test 774 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t115 = { int64#; unit_u }   *)
  (*********************************)
  let r = { a115 = #0L; b115 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a115 *)
  let actual = r.a115 in
  let expected = #0L in
  mark_test_run 775;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 775 failed";
  (* Paths of depth 1 *)
  (* .b115 *)
  let actual = r.b115 in
  let expected = (unbox_unit ()) in
  mark_test_run 776;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 776 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a115 = a1151; b115 = b1151 } { a115 = a1152; b115 = b1152 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1151 a1152 && (fun _ _ -> true) b1151 b1152) in
  let next_r = { a115 = #100L; b115 = (unbox_unit ()) } in
  let r_expected = { a115 = #0L; b115 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a115 *)
  r.a115 <- next_r.a115;
  let r_expected = { r_expected with a115 = next_r.a115 } in
  mark_test_run 777;
  let test = eq r r_expected in
  if not test then failwithf "test 777 failed";
  Gc.compact ();
  (* .b115 *)
  r.b115 <- next_r.b115;
  let r_expected = { r_expected with b115 = next_r.b115 } in
  mark_test_run 778;
  let test = eq r r_expected in
  if not test then failwithf "test 778 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a115; b115 } = r in
  let expected_a115 = #100L in
  mark_test_run 779;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a115 a115 in
  if not test then failwithf "test 779 failed";
  let expected_b115 = (unbox_unit ()) in
  mark_test_run 780;
  let test = (fun _ _ -> true) expected_b115 b115 in
  if not test then failwithf "test 780 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a115; b115 } = r in
  let expected_a115 = #100L in
  mark_test_run 781;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a115 a115 in
  if not test then failwithf "test 781 failed";
  let expected_b115 = (unbox_unit ()) in
  mark_test_run 782;
  let test = (fun _ _ -> true) expected_b115 b115 in
  if not test then failwithf "test 782 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t116 = { int64#; float }   *)
  (********************************)
  let r = { a116 = #0L; b116 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a116 *)
  let actual = r.a116 in
  let expected = #0L in
  mark_test_run 783;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 783 failed";
  (* Paths of depth 1 *)
  (* .b116 *)
  let actual = r.b116 in
  let expected = 1. in
  mark_test_run 784;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 784 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a116 = a1161; b116 = b1161 } { a116 = a1162; b116 = b1162 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1161 a1162 && (fun a b -> Float.equal (globalize a) (globalize b)) b1161 b1162) in
  let next_r = { a116 = #100L; b116 = 101. } in
  let r_expected = { a116 = #0L; b116 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a116 *)
  r.a116 <- next_r.a116;
  let r_expected = { r_expected with a116 = next_r.a116 } in
  mark_test_run 785;
  let test = eq r r_expected in
  if not test then failwithf "test 785 failed";
  Gc.compact ();
  (* .b116 *)
  r.b116 <- next_r.b116;
  let r_expected = { r_expected with b116 = next_r.b116 } in
  mark_test_run 786;
  let test = eq r r_expected in
  if not test then failwithf "test 786 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a116; b116 } = r in
  let expected_a116 = #100L in
  mark_test_run 787;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a116 a116 in
  if not test then failwithf "test 787 failed";
  let expected_b116 = 101. in
  mark_test_run 788;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b116 b116 in
  if not test then failwithf "test 788 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a116; b116 } = r in
  let expected_a116 = #100L in
  mark_test_run 789;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a116 a116 in
  if not test then failwithf "test 789 failed";
  let expected_b116 = 101. in
  mark_test_run 790;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b116 b116 in
  if not test then failwithf "test 790 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t117 = { int64#; (| unit_u) }   *)
  (*************************************)
  let r = { a117 = #0L; b117 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a117 *)
  let actual = r.a117 in
  let expected = #0L in
  mark_test_run 791;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 791 failed";
  (* Paths of depth 1 *)
  (* .b117 *)
  let actual = r.b117 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 792;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 792 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a117 = a1171; b117 = b1171 } { a117 = a1172; b117 = b1172 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1171 a1172 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b1171 b1172) in
  let next_r = { a117 = #100L; b117 = C19_0((unbox_unit ())) } in
  let r_expected = { a117 = #0L; b117 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a117 *)
  r.a117 <- next_r.a117;
  let r_expected = { r_expected with a117 = next_r.a117 } in
  mark_test_run 793;
  let test = eq r r_expected in
  if not test then failwithf "test 793 failed";
  Gc.compact ();
  (* .b117 *)
  r.b117 <- next_r.b117;
  let r_expected = { r_expected with b117 = next_r.b117 } in
  mark_test_run 794;
  let test = eq r r_expected in
  if not test then failwithf "test 794 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a117; b117 } = r in
  let expected_a117 = #100L in
  mark_test_run 795;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a117 a117 in
  if not test then failwithf "test 795 failed";
  let expected_b117 = C19_0((unbox_unit ())) in
  mark_test_run 796;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b117 b117 in
  if not test then failwithf "test 796 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a117; b117 } = r in
  let expected_a117 = #100L in
  mark_test_run 797;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a117 a117 in
  if not test then failwithf "test 797 failed";
  let expected_b117 = C19_0((unbox_unit ())) in
  mark_test_run 798;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b117 b117 in
  if not test then failwithf "test 798 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t118 = { int64#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (***************************************************************************)
  let r = { a118 = #0L; b118 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a118 *)
  let actual = r.a118 in
  let expected = #0L in
  mark_test_run 799;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 799 failed";
  (* Paths of depth 1 *)
  (* .b118 *)
  let actual = r.b118 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 800;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 800 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a118 = a1181; b118 = b1181 } { a118 = a1182; b118 = b1182 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1181 a1182 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b1181 b1182) in
  let next_r = { a118 = #100L; b118 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a118 = #0L; b118 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a118 *)
  r.a118 <- next_r.a118;
  let r_expected = { r_expected with a118 = next_r.a118 } in
  mark_test_run 801;
  let test = eq r r_expected in
  if not test then failwithf "test 801 failed";
  Gc.compact ();
  (* .b118 *)
  r.b118 <- next_r.b118;
  let r_expected = { r_expected with b118 = next_r.b118 } in
  mark_test_run 802;
  let test = eq r r_expected in
  if not test then failwithf "test 802 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a118; b118 } = r in
  let expected_a118 = #100L in
  mark_test_run 803;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a118 a118 in
  if not test then failwithf "test 803 failed";
  let expected_b118 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 804;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b118 b118 in
  if not test then failwithf "test 804 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a118; b118 } = r in
  let expected_a118 = #100L in
  mark_test_run 805;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a118 a118 in
  if not test then failwithf "test 805 failed";
  let expected_b118 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 806;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b118 b118 in
  if not test then failwithf "test 806 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t119 = { int64#; #(unit_u, int) }   *)
  (*****************************************)
  let r = { a119 = #0L; b119 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a119 *)
  let actual = r.a119 in
  let expected = #0L in
  mark_test_run 807;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 807 failed";
  (* Paths of depth 1 *)
  (* .b119 *)
  let actual = r.b119 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 808;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 808 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a119 = a1191; b119 = b1191 } { a119 = a1192; b119 = b1192 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1191 a1192 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b1191 b1192) in
  let next_r = { a119 = #100L; b119 = #((unbox_unit ()), 101) } in
  let r_expected = { a119 = #0L; b119 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a119 *)
  r.a119 <- next_r.a119;
  let r_expected = { r_expected with a119 = next_r.a119 } in
  mark_test_run 809;
  let test = eq r r_expected in
  if not test then failwithf "test 809 failed";
  Gc.compact ();
  (* .b119 *)
  r.b119 <- next_r.b119;
  let r_expected = { r_expected with b119 = next_r.b119 } in
  mark_test_run 810;
  let test = eq r r_expected in
  if not test then failwithf "test 810 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a119; b119 } = r in
  let expected_a119 = #100L in
  mark_test_run 811;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a119 a119 in
  if not test then failwithf "test 811 failed";
  let expected_b119 = #((unbox_unit ()), 101) in
  mark_test_run 812;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b119 b119 in
  if not test then failwithf "test 812 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a119; b119 } = r in
  let expected_a119 = #100L in
  mark_test_run 813;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a119 a119 in
  if not test then failwithf "test 813 failed";
  let expected_b119 = #((unbox_unit ()), 101) in
  mark_test_run 814;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b119 b119 in
  if not test then failwithf "test 814 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t120 = { int64#; #(unit_u, int64#) }   *)
  (********************************************)
  let r = { a120 = #0L; b120 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a120 *)
  let actual = r.a120 in
  let expected = #0L in
  mark_test_run 815;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 815 failed";
  (* Paths of depth 1 *)
  (* .b120 *)
  let actual = r.b120 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 816;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 816 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a120 = a1201; b120 = b1201 } { a120 = a1202; b120 = b1202 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1201 a1202 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b1201 b1202) in
  let next_r = { a120 = #100L; b120 = #((unbox_unit ()), #101L) } in
  let r_expected = { a120 = #0L; b120 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a120 *)
  r.a120 <- next_r.a120;
  let r_expected = { r_expected with a120 = next_r.a120 } in
  mark_test_run 817;
  let test = eq r r_expected in
  if not test then failwithf "test 817 failed";
  Gc.compact ();
  (* .b120 *)
  r.b120 <- next_r.b120;
  let r_expected = { r_expected with b120 = next_r.b120 } in
  mark_test_run 818;
  let test = eq r r_expected in
  if not test then failwithf "test 818 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a120; b120 } = r in
  let expected_a120 = #100L in
  mark_test_run 819;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a120 a120 in
  if not test then failwithf "test 819 failed";
  let expected_b120 = #((unbox_unit ()), #101L) in
  mark_test_run 820;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b120 b120 in
  if not test then failwithf "test 820 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a120; b120 } = r in
  let expected_a120 = #100L in
  mark_test_run 821;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a120 a120 in
  if not test then failwithf "test 821 failed";
  let expected_b120 = #((unbox_unit ()), #101L) in
  mark_test_run 822;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b120 b120 in
  if not test then failwithf "test 822 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t121 = { int64#; #(unit_u, unit_u) }   *)
  (********************************************)
  let r = { a121 = #0L; b121 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a121 *)
  let actual = r.a121 in
  let expected = #0L in
  mark_test_run 823;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 823 failed";
  (* Paths of depth 1 *)
  (* .b121 *)
  let actual = r.b121 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 824;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 824 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a121 = a1211; b121 = b1211 } { a121 = a1212; b121 = b1212 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1211 a1212 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b1211 b1212) in
  let next_r = { a121 = #100L; b121 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a121 = #0L; b121 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a121 *)
  r.a121 <- next_r.a121;
  let r_expected = { r_expected with a121 = next_r.a121 } in
  mark_test_run 825;
  let test = eq r r_expected in
  if not test then failwithf "test 825 failed";
  Gc.compact ();
  (* .b121 *)
  r.b121 <- next_r.b121;
  let r_expected = { r_expected with b121 = next_r.b121 } in
  mark_test_run 826;
  let test = eq r r_expected in
  if not test then failwithf "test 826 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a121; b121 } = r in
  let expected_a121 = #100L in
  mark_test_run 827;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a121 a121 in
  if not test then failwithf "test 827 failed";
  let expected_b121 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 828;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b121 b121 in
  if not test then failwithf "test 828 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a121; b121 } = r in
  let expected_a121 = #100L in
  mark_test_run 829;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a121 a121 in
  if not test then failwithf "test 829 failed";
  let expected_b121 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 830;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b121 b121 in
  if not test then failwithf "test 830 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t122 = { int64#; #(unit_u, string) }   *)
  (********************************************)
  let r = { a122 = #0L; b122 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a122 *)
  let actual = r.a122 in
  let expected = #0L in
  mark_test_run 831;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 831 failed";
  (* Paths of depth 1 *)
  (* .b122 *)
  let actual = r.b122 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 832;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 832 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a122 = a1221; b122 = b1221 } { a122 = a1222; b122 = b1222 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1221 a1222 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b1221 b1222) in
  let next_r = { a122 = #100L; b122 = #((unbox_unit ()), "101") } in
  let r_expected = { a122 = #0L; b122 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a122 *)
  r.a122 <- next_r.a122;
  let r_expected = { r_expected with a122 = next_r.a122 } in
  mark_test_run 833;
  let test = eq r r_expected in
  if not test then failwithf "test 833 failed";
  Gc.compact ();
  (* .b122 *)
  r.b122 <- next_r.b122;
  let r_expected = { r_expected with b122 = next_r.b122 } in
  mark_test_run 834;
  let test = eq r r_expected in
  if not test then failwithf "test 834 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a122; b122 } = r in
  let expected_a122 = #100L in
  mark_test_run 835;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a122 a122 in
  if not test then failwithf "test 835 failed";
  let expected_b122 = #((unbox_unit ()), "101") in
  mark_test_run 836;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b122 b122 in
  if not test then failwithf "test 836 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a122; b122 } = r in
  let expected_a122 = #100L in
  mark_test_run 837;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a122 a122 in
  if not test then failwithf "test 837 failed";
  let expected_b122 = #((unbox_unit ()), "101") in
  mark_test_run 838;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b122 b122 in
  if not test then failwithf "test 838 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t123 = { int32# }   *)
  (*************************)
  let r = { a123 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a123 *)
  let actual = r.a123 in
  let expected = #0l in
  mark_test_run 839;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 839 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a123 = a1231 } { a123 = a1232 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1231 a1232) in
  let next_r = { a123 = #100l } in
  let r_expected = { a123 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a123 *)
  r.a123 <- next_r.a123;
  let r_expected = { r_expected with a123 = next_r.a123 } in
  mark_test_run 840;
  let test = eq r r_expected in
  if not test then failwithf "test 840 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a123 } = r in
  let expected_a123 = #100l in
  mark_test_run 841;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a123 a123 in
  if not test then failwithf "test 841 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a123 } = r in
  let expected_a123 = #100l in
  mark_test_run 842;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a123 a123 in
  if not test then failwithf "test 842 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t124 = { int32#; int }   *)
  (******************************)
  let r = { a124 = #0l; b124 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a124 *)
  let actual = r.a124 in
  let expected = #0l in
  mark_test_run 843;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 843 failed";
  (* Paths of depth 1 *)
  (* .b124 *)
  let actual = r.b124 in
  let expected = 1 in
  mark_test_run 844;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 844 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a124 = a1241; b124 = b1241 } { a124 = a1242; b124 = b1242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1241 a1242 && (fun a b -> Int.equal a b) b1241 b1242) in
  let next_r = { a124 = #100l; b124 = 101 } in
  let r_expected = { a124 = #0l; b124 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a124 *)
  r.a124 <- next_r.a124;
  let r_expected = { r_expected with a124 = next_r.a124 } in
  mark_test_run 845;
  let test = eq r r_expected in
  if not test then failwithf "test 845 failed";
  Gc.compact ();
  (* .b124 *)
  r.b124 <- next_r.b124;
  let r_expected = { r_expected with b124 = next_r.b124 } in
  mark_test_run 846;
  let test = eq r r_expected in
  if not test then failwithf "test 846 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a124; b124 } = r in
  let expected_a124 = #100l in
  mark_test_run 847;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a124 a124 in
  if not test then failwithf "test 847 failed";
  let expected_b124 = 101 in
  mark_test_run 848;
  let test = (fun a b -> Int.equal a b) expected_b124 b124 in
  if not test then failwithf "test 848 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a124; b124 } = r in
  let expected_a124 = #100l in
  mark_test_run 849;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a124 a124 in
  if not test then failwithf "test 849 failed";
  let expected_b124 = 101 in
  mark_test_run 850;
  let test = (fun a b -> Int.equal a b) expected_b124 b124 in
  if not test then failwithf "test 850 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t125 = { int32#; int; int }   *)
  (***********************************)
  let r = { a125 = #0l; b125 = 1; c125 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a125 *)
  let actual = r.a125 in
  let expected = #0l in
  mark_test_run 851;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 851 failed";
  (* Paths of depth 1 *)
  (* .b125 *)
  let actual = r.b125 in
  let expected = 1 in
  mark_test_run 852;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 852 failed";
  (* Paths of depth 1 *)
  (* .c125 *)
  let actual = r.c125 in
  let expected = 2 in
  mark_test_run 853;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 853 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a125 = a1251; b125 = b1251; c125 = c1251 } { a125 = a1252; b125 = b1252; c125 = c1252 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1251 a1252 && (fun a b -> Int.equal a b) b1251 b1252 && (fun a b -> Int.equal a b) c1251 c1252) in
  let next_r = { a125 = #100l; b125 = 101; c125 = 102 } in
  let r_expected = { a125 = #0l; b125 = 1; c125 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a125 *)
  r.a125 <- next_r.a125;
  let r_expected = { r_expected with a125 = next_r.a125 } in
  mark_test_run 854;
  let test = eq r r_expected in
  if not test then failwithf "test 854 failed";
  Gc.compact ();
  (* .b125 *)
  r.b125 <- next_r.b125;
  let r_expected = { r_expected with b125 = next_r.b125 } in
  mark_test_run 855;
  let test = eq r r_expected in
  if not test then failwithf "test 855 failed";
  Gc.compact ();
  (* .c125 *)
  r.c125 <- next_r.c125;
  let r_expected = { r_expected with c125 = next_r.c125 } in
  mark_test_run 856;
  let test = eq r r_expected in
  if not test then failwithf "test 856 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a125; b125; c125 } = r in
  let expected_a125 = #100l in
  mark_test_run 857;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a125 a125 in
  if not test then failwithf "test 857 failed";
  let expected_b125 = 101 in
  mark_test_run 858;
  let test = (fun a b -> Int.equal a b) expected_b125 b125 in
  if not test then failwithf "test 858 failed";
  let expected_c125 = 102 in
  mark_test_run 859;
  let test = (fun a b -> Int.equal a b) expected_c125 c125 in
  if not test then failwithf "test 859 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a125; b125; c125 } = r in
  let expected_a125 = #100l in
  mark_test_run 860;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a125 a125 in
  if not test then failwithf "test 860 failed";
  let expected_b125 = 101 in
  mark_test_run 861;
  let test = (fun a b -> Int.equal a b) expected_b125 b125 in
  if not test then failwithf "test 861 failed";
  let expected_c125 = 102 in
  mark_test_run 862;
  let test = (fun a b -> Int.equal a b) expected_c125 c125 in
  if not test then failwithf "test 862 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t126 = { int32#; int; int32# }   *)
  (**************************************)
  let r = { a126 = #0l; b126 = 1; c126 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a126 *)
  let actual = r.a126 in
  let expected = #0l in
  mark_test_run 863;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 863 failed";
  (* Paths of depth 1 *)
  (* .b126 *)
  let actual = r.b126 in
  let expected = 1 in
  mark_test_run 864;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 864 failed";
  (* Paths of depth 1 *)
  (* .c126 *)
  let actual = r.c126 in
  let expected = #2l in
  mark_test_run 865;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 865 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a126 = a1261; b126 = b1261; c126 = c1261 } { a126 = a1262; b126 = b1262; c126 = c1262 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1261 a1262 && (fun a b -> Int.equal a b) b1261 b1262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1261 c1262) in
  let next_r = { a126 = #100l; b126 = 101; c126 = #102l } in
  let r_expected = { a126 = #0l; b126 = 1; c126 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a126 *)
  r.a126 <- next_r.a126;
  let r_expected = { r_expected with a126 = next_r.a126 } in
  mark_test_run 866;
  let test = eq r r_expected in
  if not test then failwithf "test 866 failed";
  Gc.compact ();
  (* .b126 *)
  r.b126 <- next_r.b126;
  let r_expected = { r_expected with b126 = next_r.b126 } in
  mark_test_run 867;
  let test = eq r r_expected in
  if not test then failwithf "test 867 failed";
  Gc.compact ();
  (* .c126 *)
  r.c126 <- next_r.c126;
  let r_expected = { r_expected with c126 = next_r.c126 } in
  mark_test_run 868;
  let test = eq r r_expected in
  if not test then failwithf "test 868 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a126; b126; c126 } = r in
  let expected_a126 = #100l in
  mark_test_run 869;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a126 a126 in
  if not test then failwithf "test 869 failed";
  let expected_b126 = 101 in
  mark_test_run 870;
  let test = (fun a b -> Int.equal a b) expected_b126 b126 in
  if not test then failwithf "test 870 failed";
  let expected_c126 = #102l in
  mark_test_run 871;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c126 c126 in
  if not test then failwithf "test 871 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a126; b126; c126 } = r in
  let expected_a126 = #100l in
  mark_test_run 872;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a126 a126 in
  if not test then failwithf "test 872 failed";
  let expected_b126 = 101 in
  mark_test_run 873;
  let test = (fun a b -> Int.equal a b) expected_b126 b126 in
  if not test then failwithf "test 873 failed";
  let expected_c126 = #102l in
  mark_test_run 874;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c126 c126 in
  if not test then failwithf "test 874 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t127 = { int32#; int64 }   *)
  (********************************)
  let r = { a127 = #0l; b127 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a127 *)
  let actual = r.a127 in
  let expected = #0l in
  mark_test_run 875;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 875 failed";
  (* Paths of depth 1 *)
  (* .b127 *)
  let actual = r.b127 in
  let expected = 1L in
  mark_test_run 876;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 876 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a127 = a1271; b127 = b1271 } { a127 = a1272; b127 = b1272 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1271 a1272 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1271 b1272) in
  let next_r = { a127 = #100l; b127 = 101L } in
  let r_expected = { a127 = #0l; b127 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a127 *)
  r.a127 <- next_r.a127;
  let r_expected = { r_expected with a127 = next_r.a127 } in
  mark_test_run 877;
  let test = eq r r_expected in
  if not test then failwithf "test 877 failed";
  Gc.compact ();
  (* .b127 *)
  r.b127 <- next_r.b127;
  let r_expected = { r_expected with b127 = next_r.b127 } in
  mark_test_run 878;
  let test = eq r r_expected in
  if not test then failwithf "test 878 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a127; b127 } = r in
  let expected_a127 = #100l in
  mark_test_run 879;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a127 a127 in
  if not test then failwithf "test 879 failed";
  let expected_b127 = 101L in
  mark_test_run 880;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b127 b127 in
  if not test then failwithf "test 880 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a127; b127 } = r in
  let expected_a127 = #100l in
  mark_test_run 881;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a127 a127 in
  if not test then failwithf "test 881 failed";
  let expected_b127 = 101L in
  mark_test_run 882;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b127 b127 in
  if not test then failwithf "test 882 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t128 = { int32#; int64# }   *)
  (*********************************)
  let r = { a128 = #0l; b128 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a128 *)
  let actual = r.a128 in
  let expected = #0l in
  mark_test_run 883;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 883 failed";
  (* Paths of depth 1 *)
  (* .b128 *)
  let actual = r.b128 in
  let expected = #1L in
  mark_test_run 884;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 884 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a128 = a1281; b128 = b1281 } { a128 = a1282; b128 = b1282 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1281 a1282 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1281 b1282) in
  let next_r = { a128 = #100l; b128 = #101L } in
  let r_expected = { a128 = #0l; b128 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a128 *)
  r.a128 <- next_r.a128;
  let r_expected = { r_expected with a128 = next_r.a128 } in
  mark_test_run 885;
  let test = eq r r_expected in
  if not test then failwithf "test 885 failed";
  Gc.compact ();
  (* .b128 *)
  r.b128 <- next_r.b128;
  let r_expected = { r_expected with b128 = next_r.b128 } in
  mark_test_run 886;
  let test = eq r r_expected in
  if not test then failwithf "test 886 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a128; b128 } = r in
  let expected_a128 = #100l in
  mark_test_run 887;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a128 a128 in
  if not test then failwithf "test 887 failed";
  let expected_b128 = #101L in
  mark_test_run 888;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b128 b128 in
  if not test then failwithf "test 888 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a128; b128 } = r in
  let expected_a128 = #100l in
  mark_test_run 889;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a128 a128 in
  if not test then failwithf "test 889 failed";
  let expected_b128 = #101L in
  mark_test_run 890;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b128 b128 in
  if not test then failwithf "test 890 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t129 = { int32#; int32# }   *)
  (*********************************)
  let r = { a129 = #0l; b129 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a129 *)
  let actual = r.a129 in
  let expected = #0l in
  mark_test_run 891;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 891 failed";
  (* Paths of depth 1 *)
  (* .b129 *)
  let actual = r.b129 in
  let expected = #1l in
  mark_test_run 892;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 892 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a129 = a1291; b129 = b1291 } { a129 = a1292; b129 = b1292 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1291 a1292 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1291 b1292) in
  let next_r = { a129 = #100l; b129 = #101l } in
  let r_expected = { a129 = #0l; b129 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a129 *)
  r.a129 <- next_r.a129;
  let r_expected = { r_expected with a129 = next_r.a129 } in
  mark_test_run 893;
  let test = eq r r_expected in
  if not test then failwithf "test 893 failed";
  Gc.compact ();
  (* .b129 *)
  r.b129 <- next_r.b129;
  let r_expected = { r_expected with b129 = next_r.b129 } in
  mark_test_run 894;
  let test = eq r r_expected in
  if not test then failwithf "test 894 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a129; b129 } = r in
  let expected_a129 = #100l in
  mark_test_run 895;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a129 a129 in
  if not test then failwithf "test 895 failed";
  let expected_b129 = #101l in
  mark_test_run 896;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b129 b129 in
  if not test then failwithf "test 896 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a129; b129 } = r in
  let expected_a129 = #100l in
  mark_test_run 897;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a129 a129 in
  if not test then failwithf "test 897 failed";
  let expected_b129 = #101l in
  mark_test_run 898;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b129 b129 in
  if not test then failwithf "test 898 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t130 = { int32#; int32#; int }   *)
  (**************************************)
  let r = { a130 = #0l; b130 = #1l; c130 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a130 *)
  let actual = r.a130 in
  let expected = #0l in
  mark_test_run 899;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 899 failed";
  (* Paths of depth 1 *)
  (* .b130 *)
  let actual = r.b130 in
  let expected = #1l in
  mark_test_run 900;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 900 failed";
  (* Paths of depth 1 *)
  (* .c130 *)
  let actual = r.c130 in
  let expected = 2 in
  mark_test_run 901;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 901 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a130 = a1301; b130 = b1301; c130 = c1301 } { a130 = a1302; b130 = b1302; c130 = c1302 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1301 a1302 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1301 b1302 && (fun a b -> Int.equal a b) c1301 c1302) in
  let next_r = { a130 = #100l; b130 = #101l; c130 = 102 } in
  let r_expected = { a130 = #0l; b130 = #1l; c130 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a130 *)
  r.a130 <- next_r.a130;
  let r_expected = { r_expected with a130 = next_r.a130 } in
  mark_test_run 902;
  let test = eq r r_expected in
  if not test then failwithf "test 902 failed";
  Gc.compact ();
  (* .b130 *)
  r.b130 <- next_r.b130;
  let r_expected = { r_expected with b130 = next_r.b130 } in
  mark_test_run 903;
  let test = eq r r_expected in
  if not test then failwithf "test 903 failed";
  Gc.compact ();
  (* .c130 *)
  r.c130 <- next_r.c130;
  let r_expected = { r_expected with c130 = next_r.c130 } in
  mark_test_run 904;
  let test = eq r r_expected in
  if not test then failwithf "test 904 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a130; b130; c130 } = r in
  let expected_a130 = #100l in
  mark_test_run 905;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a130 a130 in
  if not test then failwithf "test 905 failed";
  let expected_b130 = #101l in
  mark_test_run 906;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b130 b130 in
  if not test then failwithf "test 906 failed";
  let expected_c130 = 102 in
  mark_test_run 907;
  let test = (fun a b -> Int.equal a b) expected_c130 c130 in
  if not test then failwithf "test 907 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a130; b130; c130 } = r in
  let expected_a130 = #100l in
  mark_test_run 908;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a130 a130 in
  if not test then failwithf "test 908 failed";
  let expected_b130 = #101l in
  mark_test_run 909;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b130 b130 in
  if not test then failwithf "test 909 failed";
  let expected_c130 = 102 in
  mark_test_run 910;
  let test = (fun a b -> Int.equal a b) expected_c130 c130 in
  if not test then failwithf "test 910 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t131 = { int32#; int32#; int32# }   *)
  (*****************************************)
  let r = { a131 = #0l; b131 = #1l; c131 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a131 *)
  let actual = r.a131 in
  let expected = #0l in
  mark_test_run 911;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 911 failed";
  (* Paths of depth 1 *)
  (* .b131 *)
  let actual = r.b131 in
  let expected = #1l in
  mark_test_run 912;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 912 failed";
  (* Paths of depth 1 *)
  (* .c131 *)
  let actual = r.c131 in
  let expected = #2l in
  mark_test_run 913;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 913 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a131 = a1311; b131 = b1311; c131 = c1311 } { a131 = a1312; b131 = b1312; c131 = c1312 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1311 a1312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1311 b1312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1311 c1312) in
  let next_r = { a131 = #100l; b131 = #101l; c131 = #102l } in
  let r_expected = { a131 = #0l; b131 = #1l; c131 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a131 *)
  r.a131 <- next_r.a131;
  let r_expected = { r_expected with a131 = next_r.a131 } in
  mark_test_run 914;
  let test = eq r r_expected in
  if not test then failwithf "test 914 failed";
  Gc.compact ();
  (* .b131 *)
  r.b131 <- next_r.b131;
  let r_expected = { r_expected with b131 = next_r.b131 } in
  mark_test_run 915;
  let test = eq r r_expected in
  if not test then failwithf "test 915 failed";
  Gc.compact ();
  (* .c131 *)
  r.c131 <- next_r.c131;
  let r_expected = { r_expected with c131 = next_r.c131 } in
  mark_test_run 916;
  let test = eq r r_expected in
  if not test then failwithf "test 916 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a131; b131; c131 } = r in
  let expected_a131 = #100l in
  mark_test_run 917;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a131 a131 in
  if not test then failwithf "test 917 failed";
  let expected_b131 = #101l in
  mark_test_run 918;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b131 b131 in
  if not test then failwithf "test 918 failed";
  let expected_c131 = #102l in
  mark_test_run 919;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c131 c131 in
  if not test then failwithf "test 919 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a131; b131; c131 } = r in
  let expected_a131 = #100l in
  mark_test_run 920;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a131 a131 in
  if not test then failwithf "test 920 failed";
  let expected_b131 = #101l in
  mark_test_run 921;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b131 b131 in
  if not test then failwithf "test 921 failed";
  let expected_c131 = #102l in
  mark_test_run 922;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c131 c131 in
  if not test then failwithf "test 922 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t132 = { int32#; nativeint# }   *)
  (*************************************)
  let r = { a132 = #0l; b132 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a132 *)
  let actual = r.a132 in
  let expected = #0l in
  mark_test_run 923;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 923 failed";
  (* Paths of depth 1 *)
  (* .b132 *)
  let actual = r.b132 in
  let expected = #1n in
  mark_test_run 924;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 924 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a132 = a1321; b132 = b1321 } { a132 = a1322; b132 = b1322 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1321 a1322 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1321 b1322) in
  let next_r = { a132 = #100l; b132 = #101n } in
  let r_expected = { a132 = #0l; b132 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a132 *)
  r.a132 <- next_r.a132;
  let r_expected = { r_expected with a132 = next_r.a132 } in
  mark_test_run 925;
  let test = eq r r_expected in
  if not test then failwithf "test 925 failed";
  Gc.compact ();
  (* .b132 *)
  r.b132 <- next_r.b132;
  let r_expected = { r_expected with b132 = next_r.b132 } in
  mark_test_run 926;
  let test = eq r r_expected in
  if not test then failwithf "test 926 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a132; b132 } = r in
  let expected_a132 = #100l in
  mark_test_run 927;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a132 a132 in
  if not test then failwithf "test 927 failed";
  let expected_b132 = #101n in
  mark_test_run 928;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b132 b132 in
  if not test then failwithf "test 928 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a132; b132 } = r in
  let expected_a132 = #100l in
  mark_test_run 929;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a132 a132 in
  if not test then failwithf "test 929 failed";
  let expected_b132 = #101n in
  mark_test_run 930;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b132 b132 in
  if not test then failwithf "test 930 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t133 = { int32#; unit_u }   *)
  (*********************************)
  let r = { a133 = #0l; b133 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a133 *)
  let actual = r.a133 in
  let expected = #0l in
  mark_test_run 931;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 931 failed";
  (* Paths of depth 1 *)
  (* .b133 *)
  let actual = r.b133 in
  let expected = (unbox_unit ()) in
  mark_test_run 932;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 932 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a133 = a1331; b133 = b1331 } { a133 = a1332; b133 = b1332 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1331 a1332 && (fun _ _ -> true) b1331 b1332) in
  let next_r = { a133 = #100l; b133 = (unbox_unit ()) } in
  let r_expected = { a133 = #0l; b133 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a133 *)
  r.a133 <- next_r.a133;
  let r_expected = { r_expected with a133 = next_r.a133 } in
  mark_test_run 933;
  let test = eq r r_expected in
  if not test then failwithf "test 933 failed";
  Gc.compact ();
  (* .b133 *)
  r.b133 <- next_r.b133;
  let r_expected = { r_expected with b133 = next_r.b133 } in
  mark_test_run 934;
  let test = eq r r_expected in
  if not test then failwithf "test 934 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a133; b133 } = r in
  let expected_a133 = #100l in
  mark_test_run 935;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a133 a133 in
  if not test then failwithf "test 935 failed";
  let expected_b133 = (unbox_unit ()) in
  mark_test_run 936;
  let test = (fun _ _ -> true) expected_b133 b133 in
  if not test then failwithf "test 936 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a133; b133 } = r in
  let expected_a133 = #100l in
  mark_test_run 937;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a133 a133 in
  if not test then failwithf "test 937 failed";
  let expected_b133 = (unbox_unit ()) in
  mark_test_run 938;
  let test = (fun _ _ -> true) expected_b133 b133 in
  if not test then failwithf "test 938 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t134 = { int32#; float }   *)
  (********************************)
  let r = { a134 = #0l; b134 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a134 *)
  let actual = r.a134 in
  let expected = #0l in
  mark_test_run 939;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 939 failed";
  (* Paths of depth 1 *)
  (* .b134 *)
  let actual = r.b134 in
  let expected = 1. in
  mark_test_run 940;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 940 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a134 = a1341; b134 = b1341 } { a134 = a1342; b134 = b1342 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1341 a1342 && (fun a b -> Float.equal (globalize a) (globalize b)) b1341 b1342) in
  let next_r = { a134 = #100l; b134 = 101. } in
  let r_expected = { a134 = #0l; b134 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a134 *)
  r.a134 <- next_r.a134;
  let r_expected = { r_expected with a134 = next_r.a134 } in
  mark_test_run 941;
  let test = eq r r_expected in
  if not test then failwithf "test 941 failed";
  Gc.compact ();
  (* .b134 *)
  r.b134 <- next_r.b134;
  let r_expected = { r_expected with b134 = next_r.b134 } in
  mark_test_run 942;
  let test = eq r r_expected in
  if not test then failwithf "test 942 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a134; b134 } = r in
  let expected_a134 = #100l in
  mark_test_run 943;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a134 a134 in
  if not test then failwithf "test 943 failed";
  let expected_b134 = 101. in
  mark_test_run 944;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b134 b134 in
  if not test then failwithf "test 944 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a134; b134 } = r in
  let expected_a134 = #100l in
  mark_test_run 945;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a134 a134 in
  if not test then failwithf "test 945 failed";
  let expected_b134 = 101. in
  mark_test_run 946;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b134 b134 in
  if not test then failwithf "test 946 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t135 = { int32#; (| unit_u) }   *)
  (*************************************)
  let r = { a135 = #0l; b135 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a135 *)
  let actual = r.a135 in
  let expected = #0l in
  mark_test_run 947;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 947 failed";
  (* Paths of depth 1 *)
  (* .b135 *)
  let actual = r.b135 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 948;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 948 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a135 = a1351; b135 = b1351 } { a135 = a1352; b135 = b1352 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1351 a1352 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b1351 b1352) in
  let next_r = { a135 = #100l; b135 = C19_0((unbox_unit ())) } in
  let r_expected = { a135 = #0l; b135 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a135 *)
  r.a135 <- next_r.a135;
  let r_expected = { r_expected with a135 = next_r.a135 } in
  mark_test_run 949;
  let test = eq r r_expected in
  if not test then failwithf "test 949 failed";
  Gc.compact ();
  (* .b135 *)
  r.b135 <- next_r.b135;
  let r_expected = { r_expected with b135 = next_r.b135 } in
  mark_test_run 950;
  let test = eq r r_expected in
  if not test then failwithf "test 950 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a135; b135 } = r in
  let expected_a135 = #100l in
  mark_test_run 951;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a135 a135 in
  if not test then failwithf "test 951 failed";
  let expected_b135 = C19_0((unbox_unit ())) in
  mark_test_run 952;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b135 b135 in
  if not test then failwithf "test 952 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a135; b135 } = r in
  let expected_a135 = #100l in
  mark_test_run 953;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a135 a135 in
  if not test then failwithf "test 953 failed";
  let expected_b135 = C19_0((unbox_unit ())) in
  mark_test_run 954;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b135 b135 in
  if not test then failwithf "test 954 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t136 = { int32#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (***************************************************************************)
  let r = { a136 = #0l; b136 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a136 *)
  let actual = r.a136 in
  let expected = #0l in
  mark_test_run 955;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 955 failed";
  (* Paths of depth 1 *)
  (* .b136 *)
  let actual = r.b136 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 956;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 956 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a136 = a1361; b136 = b1361 } { a136 = a1362; b136 = b1362 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1361 a1362 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b1361 b1362) in
  let next_r = { a136 = #100l; b136 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a136 = #0l; b136 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a136 *)
  r.a136 <- next_r.a136;
  let r_expected = { r_expected with a136 = next_r.a136 } in
  mark_test_run 957;
  let test = eq r r_expected in
  if not test then failwithf "test 957 failed";
  Gc.compact ();
  (* .b136 *)
  r.b136 <- next_r.b136;
  let r_expected = { r_expected with b136 = next_r.b136 } in
  mark_test_run 958;
  let test = eq r r_expected in
  if not test then failwithf "test 958 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a136; b136 } = r in
  let expected_a136 = #100l in
  mark_test_run 959;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a136 a136 in
  if not test then failwithf "test 959 failed";
  let expected_b136 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 960;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b136 b136 in
  if not test then failwithf "test 960 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a136; b136 } = r in
  let expected_a136 = #100l in
  mark_test_run 961;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a136 a136 in
  if not test then failwithf "test 961 failed";
  let expected_b136 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 962;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b136 b136 in
  if not test then failwithf "test 962 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t137 = { int32#; #(unit_u, int) }   *)
  (*****************************************)
  let r = { a137 = #0l; b137 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a137 *)
  let actual = r.a137 in
  let expected = #0l in
  mark_test_run 963;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 963 failed";
  (* Paths of depth 1 *)
  (* .b137 *)
  let actual = r.b137 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 964;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 964 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a137 = a1371; b137 = b1371 } { a137 = a1372; b137 = b1372 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1371 a1372 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b1371 b1372) in
  let next_r = { a137 = #100l; b137 = #((unbox_unit ()), 101) } in
  let r_expected = { a137 = #0l; b137 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a137 *)
  r.a137 <- next_r.a137;
  let r_expected = { r_expected with a137 = next_r.a137 } in
  mark_test_run 965;
  let test = eq r r_expected in
  if not test then failwithf "test 965 failed";
  Gc.compact ();
  (* .b137 *)
  r.b137 <- next_r.b137;
  let r_expected = { r_expected with b137 = next_r.b137 } in
  mark_test_run 966;
  let test = eq r r_expected in
  if not test then failwithf "test 966 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a137; b137 } = r in
  let expected_a137 = #100l in
  mark_test_run 967;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a137 a137 in
  if not test then failwithf "test 967 failed";
  let expected_b137 = #((unbox_unit ()), 101) in
  mark_test_run 968;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b137 b137 in
  if not test then failwithf "test 968 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a137; b137 } = r in
  let expected_a137 = #100l in
  mark_test_run 969;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a137 a137 in
  if not test then failwithf "test 969 failed";
  let expected_b137 = #((unbox_unit ()), 101) in
  mark_test_run 970;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b137 b137 in
  if not test then failwithf "test 970 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t138 = { int32#; #(unit_u, int64#) }   *)
  (********************************************)
  let r = { a138 = #0l; b138 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a138 *)
  let actual = r.a138 in
  let expected = #0l in
  mark_test_run 971;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 971 failed";
  (* Paths of depth 1 *)
  (* .b138 *)
  let actual = r.b138 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 972;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 972 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a138 = a1381; b138 = b1381 } { a138 = a1382; b138 = b1382 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1381 a1382 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b1381 b1382) in
  let next_r = { a138 = #100l; b138 = #((unbox_unit ()), #101L) } in
  let r_expected = { a138 = #0l; b138 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a138 *)
  r.a138 <- next_r.a138;
  let r_expected = { r_expected with a138 = next_r.a138 } in
  mark_test_run 973;
  let test = eq r r_expected in
  if not test then failwithf "test 973 failed";
  Gc.compact ();
  (* .b138 *)
  r.b138 <- next_r.b138;
  let r_expected = { r_expected with b138 = next_r.b138 } in
  mark_test_run 974;
  let test = eq r r_expected in
  if not test then failwithf "test 974 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a138; b138 } = r in
  let expected_a138 = #100l in
  mark_test_run 975;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a138 a138 in
  if not test then failwithf "test 975 failed";
  let expected_b138 = #((unbox_unit ()), #101L) in
  mark_test_run 976;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b138 b138 in
  if not test then failwithf "test 976 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a138; b138 } = r in
  let expected_a138 = #100l in
  mark_test_run 977;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a138 a138 in
  if not test then failwithf "test 977 failed";
  let expected_b138 = #((unbox_unit ()), #101L) in
  mark_test_run 978;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b138 b138 in
  if not test then failwithf "test 978 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t139 = { int32#; #(unit_u, unit_u) }   *)
  (********************************************)
  let r = { a139 = #0l; b139 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a139 *)
  let actual = r.a139 in
  let expected = #0l in
  mark_test_run 979;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 979 failed";
  (* Paths of depth 1 *)
  (* .b139 *)
  let actual = r.b139 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 980;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 980 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a139 = a1391; b139 = b1391 } { a139 = a1392; b139 = b1392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1391 a1392 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b1391 b1392) in
  let next_r = { a139 = #100l; b139 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a139 = #0l; b139 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a139 *)
  r.a139 <- next_r.a139;
  let r_expected = { r_expected with a139 = next_r.a139 } in
  mark_test_run 981;
  let test = eq r r_expected in
  if not test then failwithf "test 981 failed";
  Gc.compact ();
  (* .b139 *)
  r.b139 <- next_r.b139;
  let r_expected = { r_expected with b139 = next_r.b139 } in
  mark_test_run 982;
  let test = eq r r_expected in
  if not test then failwithf "test 982 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a139; b139 } = r in
  let expected_a139 = #100l in
  mark_test_run 983;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a139 a139 in
  if not test then failwithf "test 983 failed";
  let expected_b139 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 984;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b139 b139 in
  if not test then failwithf "test 984 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a139; b139 } = r in
  let expected_a139 = #100l in
  mark_test_run 985;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a139 a139 in
  if not test then failwithf "test 985 failed";
  let expected_b139 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 986;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b139 b139 in
  if not test then failwithf "test 986 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t140 = { int32#; #(unit_u, string) }   *)
  (********************************************)
  let r = { a140 = #0l; b140 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a140 *)
  let actual = r.a140 in
  let expected = #0l in
  mark_test_run 987;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 987 failed";
  (* Paths of depth 1 *)
  (* .b140 *)
  let actual = r.b140 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 988;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 988 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a140 = a1401; b140 = b1401 } { a140 = a1402; b140 = b1402 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1401 a1402 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b1401 b1402) in
  let next_r = { a140 = #100l; b140 = #((unbox_unit ()), "101") } in
  let r_expected = { a140 = #0l; b140 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a140 *)
  r.a140 <- next_r.a140;
  let r_expected = { r_expected with a140 = next_r.a140 } in
  mark_test_run 989;
  let test = eq r r_expected in
  if not test then failwithf "test 989 failed";
  Gc.compact ();
  (* .b140 *)
  r.b140 <- next_r.b140;
  let r_expected = { r_expected with b140 = next_r.b140 } in
  mark_test_run 990;
  let test = eq r r_expected in
  if not test then failwithf "test 990 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a140; b140 } = r in
  let expected_a140 = #100l in
  mark_test_run 991;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a140 a140 in
  if not test then failwithf "test 991 failed";
  let expected_b140 = #((unbox_unit ()), "101") in
  mark_test_run 992;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b140 b140 in
  if not test then failwithf "test 992 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a140; b140 } = r in
  let expected_a140 = #100l in
  mark_test_run 993;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a140 a140 in
  if not test then failwithf "test 993 failed";
  let expected_b140 = #((unbox_unit ()), "101") in
  mark_test_run 994;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b140 b140 in
  if not test then failwithf "test 994 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t141 = { int32#; #{ int } }   *)
  (***********************************)
  let r = { a141 = #0l; b141 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a141 *)
  let actual = r.a141 in
  let expected = #0l in
  mark_test_run 995;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 995 failed";
  (* Paths of depth 1 *)
  (* .b141 *)
  let actual = r.b141 in
  let expected = #{ a27 = 1 } in
  mark_test_run 996;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 996 failed";
  (* Paths of depth 2 *)
  (* .b141.#a27 *)
  let actual = r.b141.#a27 in
  let expected = 1 in
  mark_test_run 997;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 997 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a141 = a1411; b141 = b1411 } { a141 = a1412; b141 = b1412 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1411 a1412 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b1411 b1412) in
  let next_r = { a141 = #100l; b141 = #{ a27 = 101 } } in
  let r_expected = { a141 = #0l; b141 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a141 *)
  r.a141 <- next_r.a141;
  let r_expected = { r_expected with a141 = next_r.a141 } in
  mark_test_run 998;
  let test = eq r r_expected in
  if not test then failwithf "test 998 failed";
  Gc.compact ();
  (* .b141 *)
  r.b141 <- next_r.b141;
  let r_expected = { r_expected with b141 = next_r.b141 } in
  mark_test_run 999;
  let test = eq r r_expected in
  if not test then failwithf "test 999 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a141; b141 = #{ a27 } } = r in
  let expected_a141 = #100l in
  mark_test_run 1000;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a141 a141 in
  if not test then failwithf "test 1000 failed";
  let expected_a27 = 101 in
  mark_test_run 1001;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1001 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a141; b141 } = r in
  let expected_a141 = #100l in
  mark_test_run 1002;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a141 a141 in
  if not test then failwithf "test 1002 failed";
  let expected_b141 = #{ a27 = 101 } in
  mark_test_run 1003;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_b141 b141 in
  if not test then failwithf "test 1003 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t142 = { int32#; #{ int; int } }   *)
  (****************************************)
  let r = { a142 = #0l; b142 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a142 *)
  let actual = r.a142 in
  let expected = #0l in
  mark_test_run 1004;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1004 failed";
  (* Paths of depth 1 *)
  (* .b142 *)
  let actual = r.b142 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 1005;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 1005 failed";
  (* Paths of depth 2 *)
  (* .b142.#a29 *)
  let actual = r.b142.#a29 in
  let expected = 1 in
  mark_test_run 1006;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1006 failed";
  (* .b142.#b29 *)
  let actual = r.b142.#b29 in
  let expected = 2 in
  mark_test_run 1007;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1007 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a142 = a1421; b142 = b1421 } { a142 = a1422; b142 = b1422 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1421 a1422 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b1421 b1422) in
  let next_r = { a142 = #100l; b142 = #{ a29 = 101; b29 = 102 } } in
  let r_expected = { a142 = #0l; b142 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a142 *)
  r.a142 <- next_r.a142;
  let r_expected = { r_expected with a142 = next_r.a142 } in
  mark_test_run 1008;
  let test = eq r r_expected in
  if not test then failwithf "test 1008 failed";
  Gc.compact ();
  (* .b142 *)
  r.b142 <- next_r.b142;
  let r_expected = { r_expected with b142 = next_r.b142 } in
  mark_test_run 1009;
  let test = eq r r_expected in
  if not test then failwithf "test 1009 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a142; b142 = #{ a29; b29 } } = r in
  let expected_a142 = #100l in
  mark_test_run 1010;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a142 a142 in
  if not test then failwithf "test 1010 failed";
  let expected_a29 = 101 in
  mark_test_run 1011;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 1011 failed";
  let expected_b29 = 102 in
  mark_test_run 1012;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 1012 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a142; b142 } = r in
  let expected_a142 = #100l in
  mark_test_run 1013;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a142 a142 in
  if not test then failwithf "test 1013 failed";
  let expected_b142 = #{ a29 = 101; b29 = 102 } in
  mark_test_run 1014;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_b142 b142 in
  if not test then failwithf "test 1014 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t143 = { int32#; #{ int; int32# } }   *)
  (*******************************************)
  let r = { a143 = #0l; b143 = #{ a31 = 1; b31 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a143 *)
  let actual = r.a143 in
  let expected = #0l in
  mark_test_run 1015;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1015 failed";
  (* Paths of depth 1 *)
  (* .b143 *)
  let actual = r.b143 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 1016;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 1016 failed";
  (* Paths of depth 2 *)
  (* .b143.#a31 *)
  let actual = r.b143.#a31 in
  let expected = 1 in
  mark_test_run 1017;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1017 failed";
  (* .b143.#b31 *)
  let actual = r.b143.#b31 in
  let expected = #2l in
  mark_test_run 1018;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1018 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a143 = a1431; b143 = b1431 } { a143 = a1432; b143 = b1432 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1431 a1432 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b1431 b1432) in
  let next_r = { a143 = #100l; b143 = #{ a31 = 101; b31 = #102l } } in
  let r_expected = { a143 = #0l; b143 = #{ a31 = 1; b31 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a143 *)
  r.a143 <- next_r.a143;
  let r_expected = { r_expected with a143 = next_r.a143 } in
  mark_test_run 1019;
  let test = eq r r_expected in
  if not test then failwithf "test 1019 failed";
  Gc.compact ();
  (* .b143 *)
  r.b143 <- next_r.b143;
  let r_expected = { r_expected with b143 = next_r.b143 } in
  mark_test_run 1020;
  let test = eq r r_expected in
  if not test then failwithf "test 1020 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a143; b143 = #{ a31; b31 } } = r in
  let expected_a143 = #100l in
  mark_test_run 1021;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a143 a143 in
  if not test then failwithf "test 1021 failed";
  let expected_a31 = 101 in
  mark_test_run 1022;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 1022 failed";
  let expected_b31 = #102l in
  mark_test_run 1023;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 1023 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a143; b143 } = r in
  let expected_a143 = #100l in
  mark_test_run 1024;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a143 a143 in
  if not test then failwithf "test 1024 failed";
  let expected_b143 = #{ a31 = 101; b31 = #102l } in
  mark_test_run 1025;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) expected_b143 b143 in
  if not test then failwithf "test 1025 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t144 = { int32#; #{ int; #{ int } } }   *)
  (*********************************************)
  let r = { a144 = #0l; b144 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a144 *)
  let actual = r.a144 in
  let expected = #0l in
  mark_test_run 1026;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1026 failed";
  (* Paths of depth 1 *)
  (* .b144 *)
  let actual = r.b144 in
  let expected = #{ a37 = 1; b37 = #{ a27 = 2 } } in
  mark_test_run 1027;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) actual expected in
  if not test then failwithf "test 1027 failed";
  (* Paths of depth 2 *)
  (* .b144.#a37 *)
  let actual = r.b144.#a37 in
  let expected = 1 in
  mark_test_run 1028;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1028 failed";
  (* .b144.#b37 *)
  let actual = r.b144.#b37 in
  let expected = #{ a27 = 2 } in
  mark_test_run 1029;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 1029 failed";
  (* Paths of depth 3 *)
  (* .b144.#b37.#a27 *)
  let actual = r.b144.#b37.#a27 in
  let expected = 2 in
  mark_test_run 1030;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1030 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a144 = a1441; b144 = b1441 } { a144 = a1442; b144 = b1442 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1441 a1442 && (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) b1441 b1442) in
  let next_r = { a144 = #100l; b144 = #{ a37 = 101; b37 = #{ a27 = 102 } } } in
  let r_expected = { a144 = #0l; b144 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a144 *)
  r.a144 <- next_r.a144;
  let r_expected = { r_expected with a144 = next_r.a144 } in
  mark_test_run 1031;
  let test = eq r r_expected in
  if not test then failwithf "test 1031 failed";
  Gc.compact ();
  (* .b144 *)
  r.b144 <- next_r.b144;
  let r_expected = { r_expected with b144 = next_r.b144 } in
  mark_test_run 1032;
  let test = eq r r_expected in
  if not test then failwithf "test 1032 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a144; b144 = #{ a37; b37 = #{ a27 } } } = r in
  let expected_a144 = #100l in
  mark_test_run 1033;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a144 a144 in
  if not test then failwithf "test 1033 failed";
  let expected_a37 = 101 in
  mark_test_run 1034;
  let test = (fun a b -> Int.equal a b) expected_a37 a37 in
  if not test then failwithf "test 1034 failed";
  let expected_a27 = 102 in
  mark_test_run 1035;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1035 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a144; b144 } = r in
  let expected_a144 = #100l in
  mark_test_run 1036;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a144 a144 in
  if not test then failwithf "test 1036 failed";
  let expected_b144 = #{ a37 = 101; b37 = #{ a27 = 102 } } in
  mark_test_run 1037;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) expected_b144 b144 in
  if not test then failwithf "test 1037 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t145 = { int32#; #{ int; #{ int32# } } }   *)
  (************************************************)
  let r = { a145 = #0l; b145 = #{ a40 = 1; b40 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a145 *)
  let actual = r.a145 in
  let expected = #0l in
  mark_test_run 1038;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1038 failed";
  (* Paths of depth 1 *)
  (* .b145 *)
  let actual = r.b145 in
  let expected = #{ a40 = 1; b40 = #{ a39 = #2l } } in
  mark_test_run 1039;
  let test = (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) actual expected in
  if not test then failwithf "test 1039 failed";
  (* Paths of depth 2 *)
  (* .b145.#a40 *)
  let actual = r.b145.#a40 in
  let expected = 1 in
  mark_test_run 1040;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1040 failed";
  (* .b145.#b40 *)
  let actual = r.b145.#b40 in
  let expected = #{ a39 = #2l } in
  mark_test_run 1041;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 1041 failed";
  (* Paths of depth 3 *)
  (* .b145.#b40.#a39 *)
  let actual = r.b145.#b40.#a39 in
  let expected = #2l in
  mark_test_run 1042;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1042 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a145 = a1451; b145 = b1451 } { a145 = a1452; b145 = b1452 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1451 a1452 && (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) b1451 b1452) in
  let next_r = { a145 = #100l; b145 = #{ a40 = 101; b40 = #{ a39 = #102l } } } in
  let r_expected = { a145 = #0l; b145 = #{ a40 = 1; b40 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a145 *)
  r.a145 <- next_r.a145;
  let r_expected = { r_expected with a145 = next_r.a145 } in
  mark_test_run 1043;
  let test = eq r r_expected in
  if not test then failwithf "test 1043 failed";
  Gc.compact ();
  (* .b145 *)
  r.b145 <- next_r.b145;
  let r_expected = { r_expected with b145 = next_r.b145 } in
  mark_test_run 1044;
  let test = eq r r_expected in
  if not test then failwithf "test 1044 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a145; b145 = #{ a40; b40 = #{ a39 } } } = r in
  let expected_a145 = #100l in
  mark_test_run 1045;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a145 a145 in
  if not test then failwithf "test 1045 failed";
  let expected_a40 = 101 in
  mark_test_run 1046;
  let test = (fun a b -> Int.equal a b) expected_a40 a40 in
  if not test then failwithf "test 1046 failed";
  let expected_a39 = #102l in
  mark_test_run 1047;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 1047 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a145; b145 } = r in
  let expected_a145 = #100l in
  mark_test_run 1048;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a145 a145 in
  if not test then failwithf "test 1048 failed";
  let expected_b145 = #{ a40 = 101; b40 = #{ a39 = #102l } } in
  mark_test_run 1049;
  let test = (fun #{ a40 = a401; b40 = b401 } #{ a40 = a402; b40 = b402 } -> (fun a b -> Int.equal a b) a401 a402 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b401 b402) expected_b145 b145 in
  if not test then failwithf "test 1049 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t146 = { int32#; #{ int32# } }   *)
  (**************************************)
  let r = { a146 = #0l; b146 = #{ a39 = #1l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a146 *)
  let actual = r.a146 in
  let expected = #0l in
  mark_test_run 1050;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1050 failed";
  (* Paths of depth 1 *)
  (* .b146 *)
  let actual = r.b146 in
  let expected = #{ a39 = #1l } in
  mark_test_run 1051;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 1051 failed";
  (* Paths of depth 2 *)
  (* .b146.#a39 *)
  let actual = r.b146.#a39 in
  let expected = #1l in
  mark_test_run 1052;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1052 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a146 = a1461; b146 = b1461 } { a146 = a1462; b146 = b1462 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1461 a1462 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b1461 b1462) in
  let next_r = { a146 = #100l; b146 = #{ a39 = #101l } } in
  let r_expected = { a146 = #0l; b146 = #{ a39 = #1l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a146 *)
  r.a146 <- next_r.a146;
  let r_expected = { r_expected with a146 = next_r.a146 } in
  mark_test_run 1053;
  let test = eq r r_expected in
  if not test then failwithf "test 1053 failed";
  Gc.compact ();
  (* .b146 *)
  r.b146 <- next_r.b146;
  let r_expected = { r_expected with b146 = next_r.b146 } in
  mark_test_run 1054;
  let test = eq r r_expected in
  if not test then failwithf "test 1054 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a146; b146 = #{ a39 } } = r in
  let expected_a146 = #100l in
  mark_test_run 1055;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a146 a146 in
  if not test then failwithf "test 1055 failed";
  let expected_a39 = #101l in
  mark_test_run 1056;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 1056 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a146; b146 } = r in
  let expected_a146 = #100l in
  mark_test_run 1057;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a146 a146 in
  if not test then failwithf "test 1057 failed";
  let expected_b146 = #{ a39 = #101l } in
  mark_test_run 1058;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) expected_b146 b146 in
  if not test then failwithf "test 1058 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t147 = { int32#; #{ int32#; int } }   *)
  (*******************************************)
  let r = { a147 = #0l; b147 = #{ a49 = #1l; b49 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a147 *)
  let actual = r.a147 in
  let expected = #0l in
  mark_test_run 1059;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1059 failed";
  (* Paths of depth 1 *)
  (* .b147 *)
  let actual = r.b147 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 1060;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 1060 failed";
  (* Paths of depth 2 *)
  (* .b147.#a49 *)
  let actual = r.b147.#a49 in
  let expected = #1l in
  mark_test_run 1061;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1061 failed";
  (* .b147.#b49 *)
  let actual = r.b147.#b49 in
  let expected = 2 in
  mark_test_run 1062;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1062 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a147 = a1471; b147 = b1471 } { a147 = a1472; b147 = b1472 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1471 a1472 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b1471 b1472) in
  let next_r = { a147 = #100l; b147 = #{ a49 = #101l; b49 = 102 } } in
  let r_expected = { a147 = #0l; b147 = #{ a49 = #1l; b49 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a147 *)
  r.a147 <- next_r.a147;
  let r_expected = { r_expected with a147 = next_r.a147 } in
  mark_test_run 1063;
  let test = eq r r_expected in
  if not test then failwithf "test 1063 failed";
  Gc.compact ();
  (* .b147 *)
  r.b147 <- next_r.b147;
  let r_expected = { r_expected with b147 = next_r.b147 } in
  mark_test_run 1064;
  let test = eq r r_expected in
  if not test then failwithf "test 1064 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a147; b147 = #{ a49; b49 } } = r in
  let expected_a147 = #100l in
  mark_test_run 1065;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a147 a147 in
  if not test then failwithf "test 1065 failed";
  let expected_a49 = #101l in
  mark_test_run 1066;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 1066 failed";
  let expected_b49 = 102 in
  mark_test_run 1067;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 1067 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a147; b147 } = r in
  let expected_a147 = #100l in
  mark_test_run 1068;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a147 a147 in
  if not test then failwithf "test 1068 failed";
  let expected_b147 = #{ a49 = #101l; b49 = 102 } in
  mark_test_run 1069;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) expected_b147 b147 in
  if not test then failwithf "test 1069 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t148 = { int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let r = { a148 = #0l; b148 = #{ a51 = #1l; b51 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a148 *)
  let actual = r.a148 in
  let expected = #0l in
  mark_test_run 1070;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1070 failed";
  (* Paths of depth 1 *)
  (* .b148 *)
  let actual = r.b148 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 1071;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 1071 failed";
  (* Paths of depth 2 *)
  (* .b148.#a51 *)
  let actual = r.b148.#a51 in
  let expected = #1l in
  mark_test_run 1072;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1072 failed";
  (* .b148.#b51 *)
  let actual = r.b148.#b51 in
  let expected = #2l in
  mark_test_run 1073;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1073 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a148 = a1481; b148 = b1481 } { a148 = a1482; b148 = b1482 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1481 a1482 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b1481 b1482) in
  let next_r = { a148 = #100l; b148 = #{ a51 = #101l; b51 = #102l } } in
  let r_expected = { a148 = #0l; b148 = #{ a51 = #1l; b51 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a148 *)
  r.a148 <- next_r.a148;
  let r_expected = { r_expected with a148 = next_r.a148 } in
  mark_test_run 1074;
  let test = eq r r_expected in
  if not test then failwithf "test 1074 failed";
  Gc.compact ();
  (* .b148 *)
  r.b148 <- next_r.b148;
  let r_expected = { r_expected with b148 = next_r.b148 } in
  mark_test_run 1075;
  let test = eq r r_expected in
  if not test then failwithf "test 1075 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a148; b148 = #{ a51; b51 } } = r in
  let expected_a148 = #100l in
  mark_test_run 1076;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a148 a148 in
  if not test then failwithf "test 1076 failed";
  let expected_a51 = #101l in
  mark_test_run 1077;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 1077 failed";
  let expected_b51 = #102l in
  mark_test_run 1078;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 1078 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a148; b148 } = r in
  let expected_a148 = #100l in
  mark_test_run 1079;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a148 a148 in
  if not test then failwithf "test 1079 failed";
  let expected_b148 = #{ a51 = #101l; b51 = #102l } in
  mark_test_run 1080;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) expected_b148 b148 in
  if not test then failwithf "test 1080 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t149 = { int32#; #{ int32#; #{ int } } }   *)
  (************************************************)
  let r = { a149 = #0l; b149 = #{ a53 = #1l; b53 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a149 *)
  let actual = r.a149 in
  let expected = #0l in
  mark_test_run 1081;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1081 failed";
  (* Paths of depth 1 *)
  (* .b149 *)
  let actual = r.b149 in
  let expected = #{ a53 = #1l; b53 = #{ a27 = 2 } } in
  mark_test_run 1082;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) actual expected in
  if not test then failwithf "test 1082 failed";
  (* Paths of depth 2 *)
  (* .b149.#a53 *)
  let actual = r.b149.#a53 in
  let expected = #1l in
  mark_test_run 1083;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1083 failed";
  (* .b149.#b53 *)
  let actual = r.b149.#b53 in
  let expected = #{ a27 = 2 } in
  mark_test_run 1084;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 1084 failed";
  (* Paths of depth 3 *)
  (* .b149.#b53.#a27 *)
  let actual = r.b149.#b53.#a27 in
  let expected = 2 in
  mark_test_run 1085;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1085 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a149 = a1491; b149 = b1491 } { a149 = a1492; b149 = b1492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1491 a1492 && (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) b1491 b1492) in
  let next_r = { a149 = #100l; b149 = #{ a53 = #101l; b53 = #{ a27 = 102 } } } in
  let r_expected = { a149 = #0l; b149 = #{ a53 = #1l; b53 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a149 *)
  r.a149 <- next_r.a149;
  let r_expected = { r_expected with a149 = next_r.a149 } in
  mark_test_run 1086;
  let test = eq r r_expected in
  if not test then failwithf "test 1086 failed";
  Gc.compact ();
  (* .b149 *)
  r.b149 <- next_r.b149;
  let r_expected = { r_expected with b149 = next_r.b149 } in
  mark_test_run 1087;
  let test = eq r r_expected in
  if not test then failwithf "test 1087 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a149; b149 = #{ a53; b53 = #{ a27 } } } = r in
  let expected_a149 = #100l in
  mark_test_run 1088;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a149 a149 in
  if not test then failwithf "test 1088 failed";
  let expected_a53 = #101l in
  mark_test_run 1089;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a53 a53 in
  if not test then failwithf "test 1089 failed";
  let expected_a27 = 102 in
  mark_test_run 1090;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1090 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a149; b149 } = r in
  let expected_a149 = #100l in
  mark_test_run 1091;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a149 a149 in
  if not test then failwithf "test 1091 failed";
  let expected_b149 = #{ a53 = #101l; b53 = #{ a27 = 102 } } in
  mark_test_run 1092;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b531 b532) expected_b149 b149 in
  if not test then failwithf "test 1092 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t150 = { int32#; #{ int32#; #{ int32# } } }   *)
  (***************************************************)
  let r = { a150 = #0l; b150 = #{ a55 = #1l; b55 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a150 *)
  let actual = r.a150 in
  let expected = #0l in
  mark_test_run 1093;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1093 failed";
  (* Paths of depth 1 *)
  (* .b150 *)
  let actual = r.b150 in
  let expected = #{ a55 = #1l; b55 = #{ a39 = #2l } } in
  mark_test_run 1094;
  let test = (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) actual expected in
  if not test then failwithf "test 1094 failed";
  (* Paths of depth 2 *)
  (* .b150.#a55 *)
  let actual = r.b150.#a55 in
  let expected = #1l in
  mark_test_run 1095;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1095 failed";
  (* .b150.#b55 *)
  let actual = r.b150.#b55 in
  let expected = #{ a39 = #2l } in
  mark_test_run 1096;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 1096 failed";
  (* Paths of depth 3 *)
  (* .b150.#b55.#a39 *)
  let actual = r.b150.#b55.#a39 in
  let expected = #2l in
  mark_test_run 1097;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1097 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a150 = a1501; b150 = b1501 } { a150 = a1502; b150 = b1502 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1501 a1502 && (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) b1501 b1502) in
  let next_r = { a150 = #100l; b150 = #{ a55 = #101l; b55 = #{ a39 = #102l } } } in
  let r_expected = { a150 = #0l; b150 = #{ a55 = #1l; b55 = #{ a39 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a150 *)
  r.a150 <- next_r.a150;
  let r_expected = { r_expected with a150 = next_r.a150 } in
  mark_test_run 1098;
  let test = eq r r_expected in
  if not test then failwithf "test 1098 failed";
  Gc.compact ();
  (* .b150 *)
  r.b150 <- next_r.b150;
  let r_expected = { r_expected with b150 = next_r.b150 } in
  mark_test_run 1099;
  let test = eq r r_expected in
  if not test then failwithf "test 1099 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a150; b150 = #{ a55; b55 = #{ a39 } } } = r in
  let expected_a150 = #100l in
  mark_test_run 1100;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a150 a150 in
  if not test then failwithf "test 1100 failed";
  let expected_a55 = #101l in
  mark_test_run 1101;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a55 a55 in
  if not test then failwithf "test 1101 failed";
  let expected_a39 = #102l in
  mark_test_run 1102;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 1102 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a150; b150 } = r in
  let expected_a150 = #100l in
  mark_test_run 1103;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a150 a150 in
  if not test then failwithf "test 1103 failed";
  let expected_b150 = #{ a55 = #101l; b55 = #{ a39 = #102l } } in
  mark_test_run 1104;
  let test = (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a551 a552 && (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) b551 b552) expected_b150 b150 in
  if not test then failwithf "test 1104 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t151 = { int32#; #{ #{ int; int } } }   *)
  (*********************************************)
  let r = { a151 = #0l; b151 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a151 *)
  let actual = r.a151 in
  let expected = #0l in
  mark_test_run 1105;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1105 failed";
  (* Paths of depth 1 *)
  (* .b151 *)
  let actual = r.b151 in
  let expected = #{ a75 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 1106;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) actual expected in
  if not test then failwithf "test 1106 failed";
  (* Paths of depth 2 *)
  (* .b151.#a75 *)
  let actual = r.b151.#a75 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 1107;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 1107 failed";
  (* Paths of depth 3 *)
  (* .b151.#a75.#a29 *)
  let actual = r.b151.#a75.#a29 in
  let expected = 1 in
  mark_test_run 1108;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1108 failed";
  (* .b151.#a75.#b29 *)
  let actual = r.b151.#a75.#b29 in
  let expected = 2 in
  mark_test_run 1109;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1109 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a151 = a1511; b151 = b1511 } { a151 = a1512; b151 = b1512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1511 a1512 && (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) b1511 b1512) in
  let next_r = { a151 = #100l; b151 = #{ a75 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a151 = #0l; b151 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a151 *)
  r.a151 <- next_r.a151;
  let r_expected = { r_expected with a151 = next_r.a151 } in
  mark_test_run 1110;
  let test = eq r r_expected in
  if not test then failwithf "test 1110 failed";
  Gc.compact ();
  (* .b151 *)
  r.b151 <- next_r.b151;
  let r_expected = { r_expected with b151 = next_r.b151 } in
  mark_test_run 1111;
  let test = eq r r_expected in
  if not test then failwithf "test 1111 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a151; b151 = #{ a75 = #{ a29; b29 } } } = r in
  let expected_a151 = #100l in
  mark_test_run 1112;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a151 a151 in
  if not test then failwithf "test 1112 failed";
  let expected_a29 = 101 in
  mark_test_run 1113;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 1113 failed";
  let expected_b29 = 102 in
  mark_test_run 1114;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 1114 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a151; b151 } = r in
  let expected_a151 = #100l in
  mark_test_run 1115;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a151 a151 in
  if not test then failwithf "test 1115 failed";
  let expected_b151 = #{ a75 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 1116;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) expected_b151 b151 in
  if not test then failwithf "test 1116 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t152 = { int32#; #{ #{ int; int32# } } }   *)
  (************************************************)
  let r = { a152 = #0l; b152 = #{ a77 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a152 *)
  let actual = r.a152 in
  let expected = #0l in
  mark_test_run 1117;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1117 failed";
  (* Paths of depth 1 *)
  (* .b152 *)
  let actual = r.b152 in
  let expected = #{ a77 = #{ a31 = 1; b31 = #2l } } in
  mark_test_run 1118;
  let test = (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) actual expected in
  if not test then failwithf "test 1118 failed";
  (* Paths of depth 2 *)
  (* .b152.#a77 *)
  let actual = r.b152.#a77 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 1119;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 1119 failed";
  (* Paths of depth 3 *)
  (* .b152.#a77.#a31 *)
  let actual = r.b152.#a77.#a31 in
  let expected = 1 in
  mark_test_run 1120;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1120 failed";
  (* .b152.#a77.#b31 *)
  let actual = r.b152.#a77.#b31 in
  let expected = #2l in
  mark_test_run 1121;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1121 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a152 = a1521; b152 = b1521 } { a152 = a1522; b152 = b1522 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1521 a1522 && (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) b1521 b1522) in
  let next_r = { a152 = #100l; b152 = #{ a77 = #{ a31 = 101; b31 = #102l } } } in
  let r_expected = { a152 = #0l; b152 = #{ a77 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a152 *)
  r.a152 <- next_r.a152;
  let r_expected = { r_expected with a152 = next_r.a152 } in
  mark_test_run 1122;
  let test = eq r r_expected in
  if not test then failwithf "test 1122 failed";
  Gc.compact ();
  (* .b152 *)
  r.b152 <- next_r.b152;
  let r_expected = { r_expected with b152 = next_r.b152 } in
  mark_test_run 1123;
  let test = eq r r_expected in
  if not test then failwithf "test 1123 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a152; b152 = #{ a77 = #{ a31; b31 } } } = r in
  let expected_a152 = #100l in
  mark_test_run 1124;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a152 a152 in
  if not test then failwithf "test 1124 failed";
  let expected_a31 = 101 in
  mark_test_run 1125;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 1125 failed";
  let expected_b31 = #102l in
  mark_test_run 1126;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 1126 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a152; b152 } = r in
  let expected_a152 = #100l in
  mark_test_run 1127;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a152 a152 in
  if not test then failwithf "test 1127 failed";
  let expected_b152 = #{ a77 = #{ a31 = 101; b31 = #102l } } in
  mark_test_run 1128;
  let test = (fun #{ a77 = a771 } #{ a77 = a772 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a771 a772) expected_b152 b152 in
  if not test then failwithf "test 1128 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t153 = { int32#; #{ #{ int32#; int } } }   *)
  (************************************************)
  let r = { a153 = #0l; b153 = #{ a83 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a153 *)
  let actual = r.a153 in
  let expected = #0l in
  mark_test_run 1129;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1129 failed";
  (* Paths of depth 1 *)
  (* .b153 *)
  let actual = r.b153 in
  let expected = #{ a83 = #{ a49 = #1l; b49 = 2 } } in
  mark_test_run 1130;
  let test = (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) actual expected in
  if not test then failwithf "test 1130 failed";
  (* Paths of depth 2 *)
  (* .b153.#a83 *)
  let actual = r.b153.#a83 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 1131;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 1131 failed";
  (* Paths of depth 3 *)
  (* .b153.#a83.#a49 *)
  let actual = r.b153.#a83.#a49 in
  let expected = #1l in
  mark_test_run 1132;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1132 failed";
  (* .b153.#a83.#b49 *)
  let actual = r.b153.#a83.#b49 in
  let expected = 2 in
  mark_test_run 1133;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1133 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a153 = a1531; b153 = b1531 } { a153 = a1532; b153 = b1532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1531 a1532 && (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) b1531 b1532) in
  let next_r = { a153 = #100l; b153 = #{ a83 = #{ a49 = #101l; b49 = 102 } } } in
  let r_expected = { a153 = #0l; b153 = #{ a83 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a153 *)
  r.a153 <- next_r.a153;
  let r_expected = { r_expected with a153 = next_r.a153 } in
  mark_test_run 1134;
  let test = eq r r_expected in
  if not test then failwithf "test 1134 failed";
  Gc.compact ();
  (* .b153 *)
  r.b153 <- next_r.b153;
  let r_expected = { r_expected with b153 = next_r.b153 } in
  mark_test_run 1135;
  let test = eq r r_expected in
  if not test then failwithf "test 1135 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a153; b153 = #{ a83 = #{ a49; b49 } } } = r in
  let expected_a153 = #100l in
  mark_test_run 1136;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a153 a153 in
  if not test then failwithf "test 1136 failed";
  let expected_a49 = #101l in
  mark_test_run 1137;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 1137 failed";
  let expected_b49 = 102 in
  mark_test_run 1138;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 1138 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a153; b153 } = r in
  let expected_a153 = #100l in
  mark_test_run 1139;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a153 a153 in
  if not test then failwithf "test 1139 failed";
  let expected_b153 = #{ a83 = #{ a49 = #101l; b49 = 102 } } in
  mark_test_run 1140;
  let test = (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a831 a832) expected_b153 b153 in
  if not test then failwithf "test 1140 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t154 = { int32#; #{ #{ int32#; int32# } } }   *)
  (***************************************************)
  let r = { a154 = #0l; b154 = #{ a85 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a154 *)
  let actual = r.a154 in
  let expected = #0l in
  mark_test_run 1141;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1141 failed";
  (* Paths of depth 1 *)
  (* .b154 *)
  let actual = r.b154 in
  let expected = #{ a85 = #{ a51 = #1l; b51 = #2l } } in
  mark_test_run 1142;
  let test = (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) actual expected in
  if not test then failwithf "test 1142 failed";
  (* Paths of depth 2 *)
  (* .b154.#a85 *)
  let actual = r.b154.#a85 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 1143;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 1143 failed";
  (* Paths of depth 3 *)
  (* .b154.#a85.#a51 *)
  let actual = r.b154.#a85.#a51 in
  let expected = #1l in
  mark_test_run 1144;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1144 failed";
  (* .b154.#a85.#b51 *)
  let actual = r.b154.#a85.#b51 in
  let expected = #2l in
  mark_test_run 1145;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1145 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a154 = a1541; b154 = b1541 } { a154 = a1542; b154 = b1542 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1541 a1542 && (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) b1541 b1542) in
  let next_r = { a154 = #100l; b154 = #{ a85 = #{ a51 = #101l; b51 = #102l } } } in
  let r_expected = { a154 = #0l; b154 = #{ a85 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a154 *)
  r.a154 <- next_r.a154;
  let r_expected = { r_expected with a154 = next_r.a154 } in
  mark_test_run 1146;
  let test = eq r r_expected in
  if not test then failwithf "test 1146 failed";
  Gc.compact ();
  (* .b154 *)
  r.b154 <- next_r.b154;
  let r_expected = { r_expected with b154 = next_r.b154 } in
  mark_test_run 1147;
  let test = eq r r_expected in
  if not test then failwithf "test 1147 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a154; b154 = #{ a85 = #{ a51; b51 } } } = r in
  let expected_a154 = #100l in
  mark_test_run 1148;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a154 a154 in
  if not test then failwithf "test 1148 failed";
  let expected_a51 = #101l in
  mark_test_run 1149;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 1149 failed";
  let expected_b51 = #102l in
  mark_test_run 1150;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 1150 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a154; b154 } = r in
  let expected_a154 = #100l in
  mark_test_run 1151;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a154 a154 in
  if not test then failwithf "test 1151 failed";
  let expected_b154 = #{ a85 = #{ a51 = #101l; b51 = #102l } } in
  mark_test_run 1152;
  let test = (fun #{ a85 = a851 } #{ a85 = a852 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a851 a852) expected_b154 b154 in
  if not test then failwithf "test 1152 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t155 = { nativeint# }   *)
  (*****************************)
  let r = { a155 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a155 *)
  let actual = r.a155 in
  let expected = #0n in
  mark_test_run 1153;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1153 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a155 = a1551 } { a155 = a1552 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1551 a1552) in
  let next_r = { a155 = #100n } in
  let r_expected = { a155 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a155 *)
  r.a155 <- next_r.a155;
  let r_expected = { r_expected with a155 = next_r.a155 } in
  mark_test_run 1154;
  let test = eq r r_expected in
  if not test then failwithf "test 1154 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a155 } = r in
  let expected_a155 = #100n in
  mark_test_run 1155;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a155 a155 in
  if not test then failwithf "test 1155 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a155 } = r in
  let expected_a155 = #100n in
  mark_test_run 1156;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a155 a155 in
  if not test then failwithf "test 1156 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t156 = { nativeint#; int }   *)
  (**********************************)
  let r = { a156 = #0n; b156 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a156 *)
  let actual = r.a156 in
  let expected = #0n in
  mark_test_run 1157;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1157 failed";
  (* Paths of depth 1 *)
  (* .b156 *)
  let actual = r.b156 in
  let expected = 1 in
  mark_test_run 1158;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1158 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a156 = a1561; b156 = b1561 } { a156 = a1562; b156 = b1562 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1561 a1562 && (fun a b -> Int.equal a b) b1561 b1562) in
  let next_r = { a156 = #100n; b156 = 101 } in
  let r_expected = { a156 = #0n; b156 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a156 *)
  r.a156 <- next_r.a156;
  let r_expected = { r_expected with a156 = next_r.a156 } in
  mark_test_run 1159;
  let test = eq r r_expected in
  if not test then failwithf "test 1159 failed";
  Gc.compact ();
  (* .b156 *)
  r.b156 <- next_r.b156;
  let r_expected = { r_expected with b156 = next_r.b156 } in
  mark_test_run 1160;
  let test = eq r r_expected in
  if not test then failwithf "test 1160 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a156; b156 } = r in
  let expected_a156 = #100n in
  mark_test_run 1161;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a156 a156 in
  if not test then failwithf "test 1161 failed";
  let expected_b156 = 101 in
  mark_test_run 1162;
  let test = (fun a b -> Int.equal a b) expected_b156 b156 in
  if not test then failwithf "test 1162 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a156; b156 } = r in
  let expected_a156 = #100n in
  mark_test_run 1163;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a156 a156 in
  if not test then failwithf "test 1163 failed";
  let expected_b156 = 101 in
  mark_test_run 1164;
  let test = (fun a b -> Int.equal a b) expected_b156 b156 in
  if not test then failwithf "test 1164 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t157 = { nativeint#; int64 }   *)
  (************************************)
  let r = { a157 = #0n; b157 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a157 *)
  let actual = r.a157 in
  let expected = #0n in
  mark_test_run 1165;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1165 failed";
  (* Paths of depth 1 *)
  (* .b157 *)
  let actual = r.b157 in
  let expected = 1L in
  mark_test_run 1166;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1166 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a157 = a1571; b157 = b1571 } { a157 = a1572; b157 = b1572 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1571 a1572 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1571 b1572) in
  let next_r = { a157 = #100n; b157 = 101L } in
  let r_expected = { a157 = #0n; b157 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a157 *)
  r.a157 <- next_r.a157;
  let r_expected = { r_expected with a157 = next_r.a157 } in
  mark_test_run 1167;
  let test = eq r r_expected in
  if not test then failwithf "test 1167 failed";
  Gc.compact ();
  (* .b157 *)
  r.b157 <- next_r.b157;
  let r_expected = { r_expected with b157 = next_r.b157 } in
  mark_test_run 1168;
  let test = eq r r_expected in
  if not test then failwithf "test 1168 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a157; b157 } = r in
  let expected_a157 = #100n in
  mark_test_run 1169;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a157 a157 in
  if not test then failwithf "test 1169 failed";
  let expected_b157 = 101L in
  mark_test_run 1170;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b157 b157 in
  if not test then failwithf "test 1170 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a157; b157 } = r in
  let expected_a157 = #100n in
  mark_test_run 1171;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a157 a157 in
  if not test then failwithf "test 1171 failed";
  let expected_b157 = 101L in
  mark_test_run 1172;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b157 b157 in
  if not test then failwithf "test 1172 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t158 = { nativeint#; int64# }   *)
  (*************************************)
  let r = { a158 = #0n; b158 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a158 *)
  let actual = r.a158 in
  let expected = #0n in
  mark_test_run 1173;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1173 failed";
  (* Paths of depth 1 *)
  (* .b158 *)
  let actual = r.b158 in
  let expected = #1L in
  mark_test_run 1174;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 1174 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a158 = a1581; b158 = b1581 } { a158 = a1582; b158 = b1582 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1581 a1582 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1581 b1582) in
  let next_r = { a158 = #100n; b158 = #101L } in
  let r_expected = { a158 = #0n; b158 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a158 *)
  r.a158 <- next_r.a158;
  let r_expected = { r_expected with a158 = next_r.a158 } in
  mark_test_run 1175;
  let test = eq r r_expected in
  if not test then failwithf "test 1175 failed";
  Gc.compact ();
  (* .b158 *)
  r.b158 <- next_r.b158;
  let r_expected = { r_expected with b158 = next_r.b158 } in
  mark_test_run 1176;
  let test = eq r r_expected in
  if not test then failwithf "test 1176 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a158; b158 } = r in
  let expected_a158 = #100n in
  mark_test_run 1177;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a158 a158 in
  if not test then failwithf "test 1177 failed";
  let expected_b158 = #101L in
  mark_test_run 1178;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b158 b158 in
  if not test then failwithf "test 1178 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a158; b158 } = r in
  let expected_a158 = #100n in
  mark_test_run 1179;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a158 a158 in
  if not test then failwithf "test 1179 failed";
  let expected_b158 = #101L in
  mark_test_run 1180;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b158 b158 in
  if not test then failwithf "test 1180 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t159 = { nativeint#; int32# }   *)
  (*************************************)
  let r = { a159 = #0n; b159 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a159 *)
  let actual = r.a159 in
  let expected = #0n in
  mark_test_run 1181;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1181 failed";
  (* Paths of depth 1 *)
  (* .b159 *)
  let actual = r.b159 in
  let expected = #1l in
  mark_test_run 1182;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1182 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a159 = a1591; b159 = b1591 } { a159 = a1592; b159 = b1592 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1591 a1592 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1591 b1592) in
  let next_r = { a159 = #100n; b159 = #101l } in
  let r_expected = { a159 = #0n; b159 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a159 *)
  r.a159 <- next_r.a159;
  let r_expected = { r_expected with a159 = next_r.a159 } in
  mark_test_run 1183;
  let test = eq r r_expected in
  if not test then failwithf "test 1183 failed";
  Gc.compact ();
  (* .b159 *)
  r.b159 <- next_r.b159;
  let r_expected = { r_expected with b159 = next_r.b159 } in
  mark_test_run 1184;
  let test = eq r r_expected in
  if not test then failwithf "test 1184 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a159; b159 } = r in
  let expected_a159 = #100n in
  mark_test_run 1185;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a159 a159 in
  if not test then failwithf "test 1185 failed";
  let expected_b159 = #101l in
  mark_test_run 1186;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b159 b159 in
  if not test then failwithf "test 1186 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a159; b159 } = r in
  let expected_a159 = #100n in
  mark_test_run 1187;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a159 a159 in
  if not test then failwithf "test 1187 failed";
  let expected_b159 = #101l in
  mark_test_run 1188;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b159 b159 in
  if not test then failwithf "test 1188 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t160 = { nativeint#; nativeint# }   *)
  (*****************************************)
  let r = { a160 = #0n; b160 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a160 *)
  let actual = r.a160 in
  let expected = #0n in
  mark_test_run 1189;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1189 failed";
  (* Paths of depth 1 *)
  (* .b160 *)
  let actual = r.b160 in
  let expected = #1n in
  mark_test_run 1190;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1190 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a160 = a1601; b160 = b1601 } { a160 = a1602; b160 = b1602 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1601 a1602 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1601 b1602) in
  let next_r = { a160 = #100n; b160 = #101n } in
  let r_expected = { a160 = #0n; b160 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a160 *)
  r.a160 <- next_r.a160;
  let r_expected = { r_expected with a160 = next_r.a160 } in
  mark_test_run 1191;
  let test = eq r r_expected in
  if not test then failwithf "test 1191 failed";
  Gc.compact ();
  (* .b160 *)
  r.b160 <- next_r.b160;
  let r_expected = { r_expected with b160 = next_r.b160 } in
  mark_test_run 1192;
  let test = eq r r_expected in
  if not test then failwithf "test 1192 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a160; b160 } = r in
  let expected_a160 = #100n in
  mark_test_run 1193;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a160 a160 in
  if not test then failwithf "test 1193 failed";
  let expected_b160 = #101n in
  mark_test_run 1194;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b160 b160 in
  if not test then failwithf "test 1194 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a160; b160 } = r in
  let expected_a160 = #100n in
  mark_test_run 1195;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a160 a160 in
  if not test then failwithf "test 1195 failed";
  let expected_b160 = #101n in
  mark_test_run 1196;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b160 b160 in
  if not test then failwithf "test 1196 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t161 = { nativeint#; unit_u }   *)
  (*************************************)
  let r = { a161 = #0n; b161 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a161 *)
  let actual = r.a161 in
  let expected = #0n in
  mark_test_run 1197;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1197 failed";
  (* Paths of depth 1 *)
  (* .b161 *)
  let actual = r.b161 in
  let expected = (unbox_unit ()) in
  mark_test_run 1198;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1198 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a161 = a1611; b161 = b1611 } { a161 = a1612; b161 = b1612 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1611 a1612 && (fun _ _ -> true) b1611 b1612) in
  let next_r = { a161 = #100n; b161 = (unbox_unit ()) } in
  let r_expected = { a161 = #0n; b161 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a161 *)
  r.a161 <- next_r.a161;
  let r_expected = { r_expected with a161 = next_r.a161 } in
  mark_test_run 1199;
  let test = eq r r_expected in
  if not test then failwithf "test 1199 failed";
  Gc.compact ();
  (* .b161 *)
  r.b161 <- next_r.b161;
  let r_expected = { r_expected with b161 = next_r.b161 } in
  mark_test_run 1200;
  let test = eq r r_expected in
  if not test then failwithf "test 1200 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a161; b161 } = r in
  let expected_a161 = #100n in
  mark_test_run 1201;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a161 a161 in
  if not test then failwithf "test 1201 failed";
  let expected_b161 = (unbox_unit ()) in
  mark_test_run 1202;
  let test = (fun _ _ -> true) expected_b161 b161 in
  if not test then failwithf "test 1202 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a161; b161 } = r in
  let expected_a161 = #100n in
  mark_test_run 1203;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a161 a161 in
  if not test then failwithf "test 1203 failed";
  let expected_b161 = (unbox_unit ()) in
  mark_test_run 1204;
  let test = (fun _ _ -> true) expected_b161 b161 in
  if not test then failwithf "test 1204 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t162 = { nativeint#; float }   *)
  (************************************)
  let r = { a162 = #0n; b162 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a162 *)
  let actual = r.a162 in
  let expected = #0n in
  mark_test_run 1205;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1205 failed";
  (* Paths of depth 1 *)
  (* .b162 *)
  let actual = r.b162 in
  let expected = 1. in
  mark_test_run 1206;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1206 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a162 = a1621; b162 = b1621 } { a162 = a1622; b162 = b1622 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1621 a1622 && (fun a b -> Float.equal (globalize a) (globalize b)) b1621 b1622) in
  let next_r = { a162 = #100n; b162 = 101. } in
  let r_expected = { a162 = #0n; b162 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a162 *)
  r.a162 <- next_r.a162;
  let r_expected = { r_expected with a162 = next_r.a162 } in
  mark_test_run 1207;
  let test = eq r r_expected in
  if not test then failwithf "test 1207 failed";
  Gc.compact ();
  (* .b162 *)
  r.b162 <- next_r.b162;
  let r_expected = { r_expected with b162 = next_r.b162 } in
  mark_test_run 1208;
  let test = eq r r_expected in
  if not test then failwithf "test 1208 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a162; b162 } = r in
  let expected_a162 = #100n in
  mark_test_run 1209;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a162 a162 in
  if not test then failwithf "test 1209 failed";
  let expected_b162 = 101. in
  mark_test_run 1210;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b162 b162 in
  if not test then failwithf "test 1210 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a162; b162 } = r in
  let expected_a162 = #100n in
  mark_test_run 1211;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a162 a162 in
  if not test then failwithf "test 1211 failed";
  let expected_b162 = 101. in
  mark_test_run 1212;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b162 b162 in
  if not test then failwithf "test 1212 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t163 = { nativeint#; (| unit_u) }   *)
  (*****************************************)
  let r = { a163 = #0n; b163 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a163 *)
  let actual = r.a163 in
  let expected = #0n in
  mark_test_run 1213;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1213 failed";
  (* Paths of depth 1 *)
  (* .b163 *)
  let actual = r.b163 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 1214;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 1214 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a163 = a1631; b163 = b1631 } { a163 = a1632; b163 = b1632 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1631 a1632 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b1631 b1632) in
  let next_r = { a163 = #100n; b163 = C19_0((unbox_unit ())) } in
  let r_expected = { a163 = #0n; b163 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a163 *)
  r.a163 <- next_r.a163;
  let r_expected = { r_expected with a163 = next_r.a163 } in
  mark_test_run 1215;
  let test = eq r r_expected in
  if not test then failwithf "test 1215 failed";
  Gc.compact ();
  (* .b163 *)
  r.b163 <- next_r.b163;
  let r_expected = { r_expected with b163 = next_r.b163 } in
  mark_test_run 1216;
  let test = eq r r_expected in
  if not test then failwithf "test 1216 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a163; b163 } = r in
  let expected_a163 = #100n in
  mark_test_run 1217;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a163 a163 in
  if not test then failwithf "test 1217 failed";
  let expected_b163 = C19_0((unbox_unit ())) in
  mark_test_run 1218;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b163 b163 in
  if not test then failwithf "test 1218 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a163; b163 } = r in
  let expected_a163 = #100n in
  mark_test_run 1219;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a163 a163 in
  if not test then failwithf "test 1219 failed";
  let expected_b163 = C19_0((unbox_unit ())) in
  mark_test_run 1220;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b163 b163 in
  if not test then failwithf "test 1220 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************************************)
  (*   t164 = { nativeint#; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (*******************************************************************************)
  let r = { a164 = #0n; b164 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a164 *)
  let actual = r.a164 in
  let expected = #0n in
  mark_test_run 1221;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1221 failed";
  (* Paths of depth 1 *)
  (* .b164 *)
  let actual = r.b164 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1222;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 1222 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a164 = a1641; b164 = b1641 } { a164 = a1642; b164 = b1642 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1641 a1642 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b1641 b1642) in
  let next_r = { a164 = #100n; b164 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a164 = #0n; b164 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a164 *)
  r.a164 <- next_r.a164;
  let r_expected = { r_expected with a164 = next_r.a164 } in
  mark_test_run 1223;
  let test = eq r r_expected in
  if not test then failwithf "test 1223 failed";
  Gc.compact ();
  (* .b164 *)
  r.b164 <- next_r.b164;
  let r_expected = { r_expected with b164 = next_r.b164 } in
  mark_test_run 1224;
  let test = eq r r_expected in
  if not test then failwithf "test 1224 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a164; b164 } = r in
  let expected_a164 = #100n in
  mark_test_run 1225;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a164 a164 in
  if not test then failwithf "test 1225 failed";
  let expected_b164 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 1226;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b164 b164 in
  if not test then failwithf "test 1226 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a164; b164 } = r in
  let expected_a164 = #100n in
  mark_test_run 1227;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a164 a164 in
  if not test then failwithf "test 1227 failed";
  let expected_b164 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 1228;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b164 b164 in
  if not test then failwithf "test 1228 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t165 = { nativeint#; #(unit_u, int) }   *)
  (*********************************************)
  let r = { a165 = #0n; b165 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a165 *)
  let actual = r.a165 in
  let expected = #0n in
  mark_test_run 1229;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1229 failed";
  (* Paths of depth 1 *)
  (* .b165 *)
  let actual = r.b165 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 1230;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 1230 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a165 = a1651; b165 = b1651 } { a165 = a1652; b165 = b1652 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1651 a1652 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b1651 b1652) in
  let next_r = { a165 = #100n; b165 = #((unbox_unit ()), 101) } in
  let r_expected = { a165 = #0n; b165 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a165 *)
  r.a165 <- next_r.a165;
  let r_expected = { r_expected with a165 = next_r.a165 } in
  mark_test_run 1231;
  let test = eq r r_expected in
  if not test then failwithf "test 1231 failed";
  Gc.compact ();
  (* .b165 *)
  r.b165 <- next_r.b165;
  let r_expected = { r_expected with b165 = next_r.b165 } in
  mark_test_run 1232;
  let test = eq r r_expected in
  if not test then failwithf "test 1232 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a165; b165 } = r in
  let expected_a165 = #100n in
  mark_test_run 1233;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a165 a165 in
  if not test then failwithf "test 1233 failed";
  let expected_b165 = #((unbox_unit ()), 101) in
  mark_test_run 1234;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b165 b165 in
  if not test then failwithf "test 1234 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a165; b165 } = r in
  let expected_a165 = #100n in
  mark_test_run 1235;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a165 a165 in
  if not test then failwithf "test 1235 failed";
  let expected_b165 = #((unbox_unit ()), 101) in
  mark_test_run 1236;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b165 b165 in
  if not test then failwithf "test 1236 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t166 = { nativeint#; #(unit_u, int64#) }   *)
  (************************************************)
  let r = { a166 = #0n; b166 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a166 *)
  let actual = r.a166 in
  let expected = #0n in
  mark_test_run 1237;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1237 failed";
  (* Paths of depth 1 *)
  (* .b166 *)
  let actual = r.b166 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 1238;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 1238 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a166 = a1661; b166 = b1661 } { a166 = a1662; b166 = b1662 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1661 a1662 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b1661 b1662) in
  let next_r = { a166 = #100n; b166 = #((unbox_unit ()), #101L) } in
  let r_expected = { a166 = #0n; b166 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a166 *)
  r.a166 <- next_r.a166;
  let r_expected = { r_expected with a166 = next_r.a166 } in
  mark_test_run 1239;
  let test = eq r r_expected in
  if not test then failwithf "test 1239 failed";
  Gc.compact ();
  (* .b166 *)
  r.b166 <- next_r.b166;
  let r_expected = { r_expected with b166 = next_r.b166 } in
  mark_test_run 1240;
  let test = eq r r_expected in
  if not test then failwithf "test 1240 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a166; b166 } = r in
  let expected_a166 = #100n in
  mark_test_run 1241;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a166 a166 in
  if not test then failwithf "test 1241 failed";
  let expected_b166 = #((unbox_unit ()), #101L) in
  mark_test_run 1242;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b166 b166 in
  if not test then failwithf "test 1242 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a166; b166 } = r in
  let expected_a166 = #100n in
  mark_test_run 1243;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a166 a166 in
  if not test then failwithf "test 1243 failed";
  let expected_b166 = #((unbox_unit ()), #101L) in
  mark_test_run 1244;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b166 b166 in
  if not test then failwithf "test 1244 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t167 = { nativeint#; #(unit_u, unit_u) }   *)
  (************************************************)
  let r = { a167 = #0n; b167 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a167 *)
  let actual = r.a167 in
  let expected = #0n in
  mark_test_run 1245;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1245 failed";
  (* Paths of depth 1 *)
  (* .b167 *)
  let actual = r.b167 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1246;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 1246 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a167 = a1671; b167 = b1671 } { a167 = a1672; b167 = b1672 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1671 a1672 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b1671 b1672) in
  let next_r = { a167 = #100n; b167 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a167 = #0n; b167 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a167 *)
  r.a167 <- next_r.a167;
  let r_expected = { r_expected with a167 = next_r.a167 } in
  mark_test_run 1247;
  let test = eq r r_expected in
  if not test then failwithf "test 1247 failed";
  Gc.compact ();
  (* .b167 *)
  r.b167 <- next_r.b167;
  let r_expected = { r_expected with b167 = next_r.b167 } in
  mark_test_run 1248;
  let test = eq r r_expected in
  if not test then failwithf "test 1248 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a167; b167 } = r in
  let expected_a167 = #100n in
  mark_test_run 1249;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a167 a167 in
  if not test then failwithf "test 1249 failed";
  let expected_b167 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1250;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b167 b167 in
  if not test then failwithf "test 1250 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a167; b167 } = r in
  let expected_a167 = #100n in
  mark_test_run 1251;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a167 a167 in
  if not test then failwithf "test 1251 failed";
  let expected_b167 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1252;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b167 b167 in
  if not test then failwithf "test 1252 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t168 = { nativeint#; #(unit_u, string) }   *)
  (************************************************)
  let r = { a168 = #0n; b168 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a168 *)
  let actual = r.a168 in
  let expected = #0n in
  mark_test_run 1253;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1253 failed";
  (* Paths of depth 1 *)
  (* .b168 *)
  let actual = r.b168 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 1254;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 1254 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a168 = a1681; b168 = b1681 } { a168 = a1682; b168 = b1682 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1681 a1682 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b1681 b1682) in
  let next_r = { a168 = #100n; b168 = #((unbox_unit ()), "101") } in
  let r_expected = { a168 = #0n; b168 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a168 *)
  r.a168 <- next_r.a168;
  let r_expected = { r_expected with a168 = next_r.a168 } in
  mark_test_run 1255;
  let test = eq r r_expected in
  if not test then failwithf "test 1255 failed";
  Gc.compact ();
  (* .b168 *)
  r.b168 <- next_r.b168;
  let r_expected = { r_expected with b168 = next_r.b168 } in
  mark_test_run 1256;
  let test = eq r r_expected in
  if not test then failwithf "test 1256 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a168; b168 } = r in
  let expected_a168 = #100n in
  mark_test_run 1257;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a168 a168 in
  if not test then failwithf "test 1257 failed";
  let expected_b168 = #((unbox_unit ()), "101") in
  mark_test_run 1258;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b168 b168 in
  if not test then failwithf "test 1258 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a168; b168 } = r in
  let expected_a168 = #100n in
  mark_test_run 1259;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a168 a168 in
  if not test then failwithf "test 1259 failed";
  let expected_b168 = #((unbox_unit ()), "101") in
  mark_test_run 1260;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b168 b168 in
  if not test then failwithf "test 1260 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t169 = { unit_u; int }   *)
  (******************************)
  let r = { a169 = (unbox_unit ()); b169 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a169 *)
  let actual = r.a169 in
  let expected = (unbox_unit ()) in
  mark_test_run 1261;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1261 failed";
  (* Paths of depth 1 *)
  (* .b169 *)
  let actual = r.b169 in
  let expected = 0 in
  mark_test_run 1262;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1262 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a169 = a1691; b169 = b1691 } { a169 = a1692; b169 = b1692 } -> (fun _ _ -> true) a1691 a1692 && (fun a b -> Int.equal a b) b1691 b1692) in
  let next_r = { a169 = (unbox_unit ()); b169 = 100 } in
  let r_expected = { a169 = (unbox_unit ()); b169 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a169 *)
  r.a169 <- next_r.a169;
  let r_expected = { r_expected with a169 = next_r.a169 } in
  mark_test_run 1263;
  let test = eq r r_expected in
  if not test then failwithf "test 1263 failed";
  Gc.compact ();
  (* .b169 *)
  r.b169 <- next_r.b169;
  let r_expected = { r_expected with b169 = next_r.b169 } in
  mark_test_run 1264;
  let test = eq r r_expected in
  if not test then failwithf "test 1264 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a169; b169 } = r in
  let expected_a169 = (unbox_unit ()) in
  mark_test_run 1265;
  let test = (fun _ _ -> true) expected_a169 a169 in
  if not test then failwithf "test 1265 failed";
  let expected_b169 = 100 in
  mark_test_run 1266;
  let test = (fun a b -> Int.equal a b) expected_b169 b169 in
  if not test then failwithf "test 1266 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a169; b169 } = r in
  let expected_a169 = (unbox_unit ()) in
  mark_test_run 1267;
  let test = (fun _ _ -> true) expected_a169 a169 in
  if not test then failwithf "test 1267 failed";
  let expected_b169 = 100 in
  mark_test_run 1268;
  let test = (fun a b -> Int.equal a b) expected_b169 b169 in
  if not test then failwithf "test 1268 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t170 = { unit_u; int64 }   *)
  (********************************)
  let r = { a170 = (unbox_unit ()); b170 = 0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a170 *)
  let actual = r.a170 in
  let expected = (unbox_unit ()) in
  mark_test_run 1269;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1269 failed";
  (* Paths of depth 1 *)
  (* .b170 *)
  let actual = r.b170 in
  let expected = 0L in
  mark_test_run 1270;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1270 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a170 = a1701; b170 = b1701 } { a170 = a1702; b170 = b1702 } -> (fun _ _ -> true) a1701 a1702 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1701 b1702) in
  let next_r = { a170 = (unbox_unit ()); b170 = 100L } in
  let r_expected = { a170 = (unbox_unit ()); b170 = 0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a170 *)
  r.a170 <- next_r.a170;
  let r_expected = { r_expected with a170 = next_r.a170 } in
  mark_test_run 1271;
  let test = eq r r_expected in
  if not test then failwithf "test 1271 failed";
  Gc.compact ();
  (* .b170 *)
  r.b170 <- next_r.b170;
  let r_expected = { r_expected with b170 = next_r.b170 } in
  mark_test_run 1272;
  let test = eq r r_expected in
  if not test then failwithf "test 1272 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a170; b170 } = r in
  let expected_a170 = (unbox_unit ()) in
  mark_test_run 1273;
  let test = (fun _ _ -> true) expected_a170 a170 in
  if not test then failwithf "test 1273 failed";
  let expected_b170 = 100L in
  mark_test_run 1274;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b170 b170 in
  if not test then failwithf "test 1274 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a170; b170 } = r in
  let expected_a170 = (unbox_unit ()) in
  mark_test_run 1275;
  let test = (fun _ _ -> true) expected_a170 a170 in
  if not test then failwithf "test 1275 failed";
  let expected_b170 = 100L in
  mark_test_run 1276;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b170 b170 in
  if not test then failwithf "test 1276 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t171 = { unit_u; int64# }   *)
  (*********************************)
  let r = { a171 = (unbox_unit ()); b171 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a171 *)
  let actual = r.a171 in
  let expected = (unbox_unit ()) in
  mark_test_run 1277;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1277 failed";
  (* Paths of depth 1 *)
  (* .b171 *)
  let actual = r.b171 in
  let expected = #0L in
  mark_test_run 1278;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 1278 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a171 = a1711; b171 = b1711 } { a171 = a1712; b171 = b1712 } -> (fun _ _ -> true) a1711 a1712 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1711 b1712) in
  let next_r = { a171 = (unbox_unit ()); b171 = #100L } in
  let r_expected = { a171 = (unbox_unit ()); b171 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a171 *)
  r.a171 <- next_r.a171;
  let r_expected = { r_expected with a171 = next_r.a171 } in
  mark_test_run 1279;
  let test = eq r r_expected in
  if not test then failwithf "test 1279 failed";
  Gc.compact ();
  (* .b171 *)
  r.b171 <- next_r.b171;
  let r_expected = { r_expected with b171 = next_r.b171 } in
  mark_test_run 1280;
  let test = eq r r_expected in
  if not test then failwithf "test 1280 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a171; b171 } = r in
  let expected_a171 = (unbox_unit ()) in
  mark_test_run 1281;
  let test = (fun _ _ -> true) expected_a171 a171 in
  if not test then failwithf "test 1281 failed";
  let expected_b171 = #100L in
  mark_test_run 1282;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b171 b171 in
  if not test then failwithf "test 1282 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a171; b171 } = r in
  let expected_a171 = (unbox_unit ()) in
  mark_test_run 1283;
  let test = (fun _ _ -> true) expected_a171 a171 in
  if not test then failwithf "test 1283 failed";
  let expected_b171 = #100L in
  mark_test_run 1284;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b171 b171 in
  if not test then failwithf "test 1284 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t172 = { unit_u; int32# }   *)
  (*********************************)
  let r = { a172 = (unbox_unit ()); b172 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a172 *)
  let actual = r.a172 in
  let expected = (unbox_unit ()) in
  mark_test_run 1285;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1285 failed";
  (* Paths of depth 1 *)
  (* .b172 *)
  let actual = r.b172 in
  let expected = #0l in
  mark_test_run 1286;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1286 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a172 = a1721; b172 = b1721 } { a172 = a1722; b172 = b1722 } -> (fun _ _ -> true) a1721 a1722 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1721 b1722) in
  let next_r = { a172 = (unbox_unit ()); b172 = #100l } in
  let r_expected = { a172 = (unbox_unit ()); b172 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a172 *)
  r.a172 <- next_r.a172;
  let r_expected = { r_expected with a172 = next_r.a172 } in
  mark_test_run 1287;
  let test = eq r r_expected in
  if not test then failwithf "test 1287 failed";
  Gc.compact ();
  (* .b172 *)
  r.b172 <- next_r.b172;
  let r_expected = { r_expected with b172 = next_r.b172 } in
  mark_test_run 1288;
  let test = eq r r_expected in
  if not test then failwithf "test 1288 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a172; b172 } = r in
  let expected_a172 = (unbox_unit ()) in
  mark_test_run 1289;
  let test = (fun _ _ -> true) expected_a172 a172 in
  if not test then failwithf "test 1289 failed";
  let expected_b172 = #100l in
  mark_test_run 1290;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b172 b172 in
  if not test then failwithf "test 1290 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a172; b172 } = r in
  let expected_a172 = (unbox_unit ()) in
  mark_test_run 1291;
  let test = (fun _ _ -> true) expected_a172 a172 in
  if not test then failwithf "test 1291 failed";
  let expected_b172 = #100l in
  mark_test_run 1292;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b172 b172 in
  if not test then failwithf "test 1292 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t173 = { unit_u; nativeint# }   *)
  (*************************************)
  let r = { a173 = (unbox_unit ()); b173 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a173 *)
  let actual = r.a173 in
  let expected = (unbox_unit ()) in
  mark_test_run 1293;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1293 failed";
  (* Paths of depth 1 *)
  (* .b173 *)
  let actual = r.b173 in
  let expected = #0n in
  mark_test_run 1294;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1294 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a173 = a1731; b173 = b1731 } { a173 = a1732; b173 = b1732 } -> (fun _ _ -> true) a1731 a1732 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1731 b1732) in
  let next_r = { a173 = (unbox_unit ()); b173 = #100n } in
  let r_expected = { a173 = (unbox_unit ()); b173 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a173 *)
  r.a173 <- next_r.a173;
  let r_expected = { r_expected with a173 = next_r.a173 } in
  mark_test_run 1295;
  let test = eq r r_expected in
  if not test then failwithf "test 1295 failed";
  Gc.compact ();
  (* .b173 *)
  r.b173 <- next_r.b173;
  let r_expected = { r_expected with b173 = next_r.b173 } in
  mark_test_run 1296;
  let test = eq r r_expected in
  if not test then failwithf "test 1296 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a173; b173 } = r in
  let expected_a173 = (unbox_unit ()) in
  mark_test_run 1297;
  let test = (fun _ _ -> true) expected_a173 a173 in
  if not test then failwithf "test 1297 failed";
  let expected_b173 = #100n in
  mark_test_run 1298;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b173 b173 in
  if not test then failwithf "test 1298 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a173; b173 } = r in
  let expected_a173 = (unbox_unit ()) in
  mark_test_run 1299;
  let test = (fun _ _ -> true) expected_a173 a173 in
  if not test then failwithf "test 1299 failed";
  let expected_b173 = #100n in
  mark_test_run 1300;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b173 b173 in
  if not test then failwithf "test 1300 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t174 = { unit_u; unit_u; string }   *)
  (*****************************************)
  let r = { a174 = (unbox_unit ()); b174 = (unbox_unit ()); c174 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a174 *)
  let actual = r.a174 in
  let expected = (unbox_unit ()) in
  mark_test_run 1301;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1301 failed";
  (* Paths of depth 1 *)
  (* .b174 *)
  let actual = r.b174 in
  let expected = (unbox_unit ()) in
  mark_test_run 1302;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1302 failed";
  (* Paths of depth 1 *)
  (* .c174 *)
  let actual = r.c174 in
  let expected = "0" in
  mark_test_run 1303;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1303 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a174 = a1741; b174 = b1741; c174 = c1741 } { a174 = a1742; b174 = b1742; c174 = c1742 } -> (fun _ _ -> true) a1741 a1742 && (fun _ _ -> true) b1741 b1742 && (fun a b -> String.equal (globalize a) (globalize b)) c1741 c1742) in
  let next_r = { a174 = (unbox_unit ()); b174 = (unbox_unit ()); c174 = "100" } in
  let r_expected = { a174 = (unbox_unit ()); b174 = (unbox_unit ()); c174 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a174 *)
  r.a174 <- next_r.a174;
  let r_expected = { r_expected with a174 = next_r.a174 } in
  mark_test_run 1304;
  let test = eq r r_expected in
  if not test then failwithf "test 1304 failed";
  Gc.compact ();
  (* .b174 *)
  r.b174 <- next_r.b174;
  let r_expected = { r_expected with b174 = next_r.b174 } in
  mark_test_run 1305;
  let test = eq r r_expected in
  if not test then failwithf "test 1305 failed";
  Gc.compact ();
  (* .c174 *)
  r.c174 <- next_r.c174;
  let r_expected = { r_expected with c174 = next_r.c174 } in
  mark_test_run 1306;
  let test = eq r r_expected in
  if not test then failwithf "test 1306 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a174; b174; c174 } = r in
  let expected_a174 = (unbox_unit ()) in
  mark_test_run 1307;
  let test = (fun _ _ -> true) expected_a174 a174 in
  if not test then failwithf "test 1307 failed";
  let expected_b174 = (unbox_unit ()) in
  mark_test_run 1308;
  let test = (fun _ _ -> true) expected_b174 b174 in
  if not test then failwithf "test 1308 failed";
  let expected_c174 = "100" in
  mark_test_run 1309;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c174 c174 in
  if not test then failwithf "test 1309 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a174; b174; c174 } = r in
  let expected_a174 = (unbox_unit ()) in
  mark_test_run 1310;
  let test = (fun _ _ -> true) expected_a174 a174 in
  if not test then failwithf "test 1310 failed";
  let expected_b174 = (unbox_unit ()) in
  mark_test_run 1311;
  let test = (fun _ _ -> true) expected_b174 b174 in
  if not test then failwithf "test 1311 failed";
  let expected_c174 = "100" in
  mark_test_run 1312;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c174 c174 in
  if not test then failwithf "test 1312 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t175 = { unit_u; float }   *)
  (********************************)
  let r = { a175 = (unbox_unit ()); b175 = 0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a175 *)
  let actual = r.a175 in
  let expected = (unbox_unit ()) in
  mark_test_run 1313;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1313 failed";
  (* Paths of depth 1 *)
  (* .b175 *)
  let actual = r.b175 in
  let expected = 0. in
  mark_test_run 1314;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1314 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a175 = a1751; b175 = b1751 } { a175 = a1752; b175 = b1752 } -> (fun _ _ -> true) a1751 a1752 && (fun a b -> Float.equal (globalize a) (globalize b)) b1751 b1752) in
  let next_r = { a175 = (unbox_unit ()); b175 = 100. } in
  let r_expected = { a175 = (unbox_unit ()); b175 = 0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a175 *)
  r.a175 <- next_r.a175;
  let r_expected = { r_expected with a175 = next_r.a175 } in
  mark_test_run 1315;
  let test = eq r r_expected in
  if not test then failwithf "test 1315 failed";
  Gc.compact ();
  (* .b175 *)
  r.b175 <- next_r.b175;
  let r_expected = { r_expected with b175 = next_r.b175 } in
  mark_test_run 1316;
  let test = eq r r_expected in
  if not test then failwithf "test 1316 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a175; b175 } = r in
  let expected_a175 = (unbox_unit ()) in
  mark_test_run 1317;
  let test = (fun _ _ -> true) expected_a175 a175 in
  if not test then failwithf "test 1317 failed";
  let expected_b175 = 100. in
  mark_test_run 1318;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b175 b175 in
  if not test then failwithf "test 1318 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a175; b175 } = r in
  let expected_a175 = (unbox_unit ()) in
  mark_test_run 1319;
  let test = (fun _ _ -> true) expected_a175 a175 in
  if not test then failwithf "test 1319 failed";
  let expected_b175 = 100. in
  mark_test_run 1320;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b175 b175 in
  if not test then failwithf "test 1320 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t176 = { unit_u; string }   *)
  (*********************************)
  let r = { a176 = (unbox_unit ()); b176 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a176 *)
  let actual = r.a176 in
  let expected = (unbox_unit ()) in
  mark_test_run 1321;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1321 failed";
  (* Paths of depth 1 *)
  (* .b176 *)
  let actual = r.b176 in
  let expected = "0" in
  mark_test_run 1322;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1322 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a176 = a1761; b176 = b1761 } { a176 = a1762; b176 = b1762 } -> (fun _ _ -> true) a1761 a1762 && (fun a b -> String.equal (globalize a) (globalize b)) b1761 b1762) in
  let next_r = { a176 = (unbox_unit ()); b176 = "100" } in
  let r_expected = { a176 = (unbox_unit ()); b176 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a176 *)
  r.a176 <- next_r.a176;
  let r_expected = { r_expected with a176 = next_r.a176 } in
  mark_test_run 1323;
  let test = eq r r_expected in
  if not test then failwithf "test 1323 failed";
  Gc.compact ();
  (* .b176 *)
  r.b176 <- next_r.b176;
  let r_expected = { r_expected with b176 = next_r.b176 } in
  mark_test_run 1324;
  let test = eq r r_expected in
  if not test then failwithf "test 1324 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a176; b176 } = r in
  let expected_a176 = (unbox_unit ()) in
  mark_test_run 1325;
  let test = (fun _ _ -> true) expected_a176 a176 in
  if not test then failwithf "test 1325 failed";
  let expected_b176 = "100" in
  mark_test_run 1326;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b176 b176 in
  if not test then failwithf "test 1326 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a176; b176 } = r in
  let expected_a176 = (unbox_unit ()) in
  mark_test_run 1327;
  let test = (fun _ _ -> true) expected_a176 a176 in
  if not test then failwithf "test 1327 failed";
  let expected_b176 = "100" in
  mark_test_run 1328;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b176 b176 in
  if not test then failwithf "test 1328 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t177 = { unit_u; string; unit_u }   *)
  (*****************************************)
  let r = { a177 = (unbox_unit ()); b177 = "0"; c177 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a177 *)
  let actual = r.a177 in
  let expected = (unbox_unit ()) in
  mark_test_run 1329;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1329 failed";
  (* Paths of depth 1 *)
  (* .b177 *)
  let actual = r.b177 in
  let expected = "0" in
  mark_test_run 1330;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1330 failed";
  (* Paths of depth 1 *)
  (* .c177 *)
  let actual = r.c177 in
  let expected = (unbox_unit ()) in
  mark_test_run 1331;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1331 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a177 = a1771; b177 = b1771; c177 = c1771 } { a177 = a1772; b177 = b1772; c177 = c1772 } -> (fun _ _ -> true) a1771 a1772 && (fun a b -> String.equal (globalize a) (globalize b)) b1771 b1772 && (fun _ _ -> true) c1771 c1772) in
  let next_r = { a177 = (unbox_unit ()); b177 = "100"; c177 = (unbox_unit ()) } in
  let r_expected = { a177 = (unbox_unit ()); b177 = "0"; c177 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a177 *)
  r.a177 <- next_r.a177;
  let r_expected = { r_expected with a177 = next_r.a177 } in
  mark_test_run 1332;
  let test = eq r r_expected in
  if not test then failwithf "test 1332 failed";
  Gc.compact ();
  (* .b177 *)
  r.b177 <- next_r.b177;
  let r_expected = { r_expected with b177 = next_r.b177 } in
  mark_test_run 1333;
  let test = eq r r_expected in
  if not test then failwithf "test 1333 failed";
  Gc.compact ();
  (* .c177 *)
  r.c177 <- next_r.c177;
  let r_expected = { r_expected with c177 = next_r.c177 } in
  mark_test_run 1334;
  let test = eq r r_expected in
  if not test then failwithf "test 1334 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a177; b177; c177 } = r in
  let expected_a177 = (unbox_unit ()) in
  mark_test_run 1335;
  let test = (fun _ _ -> true) expected_a177 a177 in
  if not test then failwithf "test 1335 failed";
  let expected_b177 = "100" in
  mark_test_run 1336;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b177 b177 in
  if not test then failwithf "test 1336 failed";
  let expected_c177 = (unbox_unit ()) in
  mark_test_run 1337;
  let test = (fun _ _ -> true) expected_c177 c177 in
  if not test then failwithf "test 1337 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a177; b177; c177 } = r in
  let expected_a177 = (unbox_unit ()) in
  mark_test_run 1338;
  let test = (fun _ _ -> true) expected_a177 a177 in
  if not test then failwithf "test 1338 failed";
  let expected_b177 = "100" in
  mark_test_run 1339;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b177 b177 in
  if not test then failwithf "test 1339 failed";
  let expected_c177 = (unbox_unit ()) in
  mark_test_run 1340;
  let test = (fun _ _ -> true) expected_c177 c177 in
  if not test then failwithf "test 1340 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t178 = { unit_u; string; string }   *)
  (*****************************************)
  let r = { a178 = (unbox_unit ()); b178 = "0"; c178 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a178 *)
  let actual = r.a178 in
  let expected = (unbox_unit ()) in
  mark_test_run 1341;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1341 failed";
  (* Paths of depth 1 *)
  (* .b178 *)
  let actual = r.b178 in
  let expected = "0" in
  mark_test_run 1342;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1342 failed";
  (* Paths of depth 1 *)
  (* .c178 *)
  let actual = r.c178 in
  let expected = "1" in
  mark_test_run 1343;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1343 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a178 = a1781; b178 = b1781; c178 = c1781 } { a178 = a1782; b178 = b1782; c178 = c1782 } -> (fun _ _ -> true) a1781 a1782 && (fun a b -> String.equal (globalize a) (globalize b)) b1781 b1782 && (fun a b -> String.equal (globalize a) (globalize b)) c1781 c1782) in
  let next_r = { a178 = (unbox_unit ()); b178 = "100"; c178 = "101" } in
  let r_expected = { a178 = (unbox_unit ()); b178 = "0"; c178 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a178 *)
  r.a178 <- next_r.a178;
  let r_expected = { r_expected with a178 = next_r.a178 } in
  mark_test_run 1344;
  let test = eq r r_expected in
  if not test then failwithf "test 1344 failed";
  Gc.compact ();
  (* .b178 *)
  r.b178 <- next_r.b178;
  let r_expected = { r_expected with b178 = next_r.b178 } in
  mark_test_run 1345;
  let test = eq r r_expected in
  if not test then failwithf "test 1345 failed";
  Gc.compact ();
  (* .c178 *)
  r.c178 <- next_r.c178;
  let r_expected = { r_expected with c178 = next_r.c178 } in
  mark_test_run 1346;
  let test = eq r r_expected in
  if not test then failwithf "test 1346 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a178; b178; c178 } = r in
  let expected_a178 = (unbox_unit ()) in
  mark_test_run 1347;
  let test = (fun _ _ -> true) expected_a178 a178 in
  if not test then failwithf "test 1347 failed";
  let expected_b178 = "100" in
  mark_test_run 1348;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b178 b178 in
  if not test then failwithf "test 1348 failed";
  let expected_c178 = "101" in
  mark_test_run 1349;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c178 c178 in
  if not test then failwithf "test 1349 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a178; b178; c178 } = r in
  let expected_a178 = (unbox_unit ()) in
  mark_test_run 1350;
  let test = (fun _ _ -> true) expected_a178 a178 in
  if not test then failwithf "test 1350 failed";
  let expected_b178 = "100" in
  mark_test_run 1351;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b178 b178 in
  if not test then failwithf "test 1351 failed";
  let expected_c178 = "101" in
  mark_test_run 1352;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c178 c178 in
  if not test then failwithf "test 1352 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t179 = { unit_u; (| unit_u) }   *)
  (*************************************)
  let r = { a179 = (unbox_unit ()); b179 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a179 *)
  let actual = r.a179 in
  let expected = (unbox_unit ()) in
  mark_test_run 1353;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1353 failed";
  (* Paths of depth 1 *)
  (* .b179 *)
  let actual = r.b179 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 1354;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 1354 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a179 = a1791; b179 = b1791 } { a179 = a1792; b179 = b1792 } -> (fun _ _ -> true) a1791 a1792 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b1791 b1792) in
  let next_r = { a179 = (unbox_unit ()); b179 = C19_0((unbox_unit ())) } in
  let r_expected = { a179 = (unbox_unit ()); b179 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a179 *)
  r.a179 <- next_r.a179;
  let r_expected = { r_expected with a179 = next_r.a179 } in
  mark_test_run 1355;
  let test = eq r r_expected in
  if not test then failwithf "test 1355 failed";
  Gc.compact ();
  (* .b179 *)
  r.b179 <- next_r.b179;
  let r_expected = { r_expected with b179 = next_r.b179 } in
  mark_test_run 1356;
  let test = eq r r_expected in
  if not test then failwithf "test 1356 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a179; b179 } = r in
  let expected_a179 = (unbox_unit ()) in
  mark_test_run 1357;
  let test = (fun _ _ -> true) expected_a179 a179 in
  if not test then failwithf "test 1357 failed";
  let expected_b179 = C19_0((unbox_unit ())) in
  mark_test_run 1358;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b179 b179 in
  if not test then failwithf "test 1358 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a179; b179 } = r in
  let expected_a179 = (unbox_unit ()) in
  mark_test_run 1359;
  let test = (fun _ _ -> true) expected_a179 a179 in
  if not test then failwithf "test 1359 failed";
  let expected_b179 = C19_0((unbox_unit ())) in
  mark_test_run 1360;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b179 b179 in
  if not test then failwithf "test 1360 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t180 = { unit_u; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (***************************************************************************)
  let r = { a180 = (unbox_unit ()); b180 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a180 *)
  let actual = r.a180 in
  let expected = (unbox_unit ()) in
  mark_test_run 1361;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1361 failed";
  (* Paths of depth 1 *)
  (* .b180 *)
  let actual = r.b180 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 1362;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 1362 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a180 = a1801; b180 = b1801 } { a180 = a1802; b180 = b1802 } -> (fun _ _ -> true) a1801 a1802 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b1801 b1802) in
  let next_r = { a180 = (unbox_unit ()); b180 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a180 = (unbox_unit ()); b180 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a180 *)
  r.a180 <- next_r.a180;
  let r_expected = { r_expected with a180 = next_r.a180 } in
  mark_test_run 1363;
  let test = eq r r_expected in
  if not test then failwithf "test 1363 failed";
  Gc.compact ();
  (* .b180 *)
  r.b180 <- next_r.b180;
  let r_expected = { r_expected with b180 = next_r.b180 } in
  mark_test_run 1364;
  let test = eq r r_expected in
  if not test then failwithf "test 1364 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a180; b180 } = r in
  let expected_a180 = (unbox_unit ()) in
  mark_test_run 1365;
  let test = (fun _ _ -> true) expected_a180 a180 in
  if not test then failwithf "test 1365 failed";
  let expected_b180 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1366;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b180 b180 in
  if not test then failwithf "test 1366 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a180; b180 } = r in
  let expected_a180 = (unbox_unit ()) in
  mark_test_run 1367;
  let test = (fun _ _ -> true) expected_a180 a180 in
  if not test then failwithf "test 1367 failed";
  let expected_b180 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1368;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b180 b180 in
  if not test then failwithf "test 1368 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t181 = { unit_u; #(unit_u, int) }   *)
  (*****************************************)
  let r = { a181 = (unbox_unit ()); b181 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a181 *)
  let actual = r.a181 in
  let expected = (unbox_unit ()) in
  mark_test_run 1369;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1369 failed";
  (* Paths of depth 1 *)
  (* .b181 *)
  let actual = r.b181 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 1370;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 1370 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a181 = a1811; b181 = b1811 } { a181 = a1812; b181 = b1812 } -> (fun _ _ -> true) a1811 a1812 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b1811 b1812) in
  let next_r = { a181 = (unbox_unit ()); b181 = #((unbox_unit ()), 100) } in
  let r_expected = { a181 = (unbox_unit ()); b181 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a181 *)
  r.a181 <- next_r.a181;
  let r_expected = { r_expected with a181 = next_r.a181 } in
  mark_test_run 1371;
  let test = eq r r_expected in
  if not test then failwithf "test 1371 failed";
  Gc.compact ();
  (* .b181 *)
  r.b181 <- next_r.b181;
  let r_expected = { r_expected with b181 = next_r.b181 } in
  mark_test_run 1372;
  let test = eq r r_expected in
  if not test then failwithf "test 1372 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a181; b181 } = r in
  let expected_a181 = (unbox_unit ()) in
  mark_test_run 1373;
  let test = (fun _ _ -> true) expected_a181 a181 in
  if not test then failwithf "test 1373 failed";
  let expected_b181 = #((unbox_unit ()), 100) in
  mark_test_run 1374;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b181 b181 in
  if not test then failwithf "test 1374 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a181; b181 } = r in
  let expected_a181 = (unbox_unit ()) in
  mark_test_run 1375;
  let test = (fun _ _ -> true) expected_a181 a181 in
  if not test then failwithf "test 1375 failed";
  let expected_b181 = #((unbox_unit ()), 100) in
  mark_test_run 1376;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b181 b181 in
  if not test then failwithf "test 1376 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t182 = { unit_u; #(unit_u, int64#) }   *)
  (********************************************)
  let r = { a182 = (unbox_unit ()); b182 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a182 *)
  let actual = r.a182 in
  let expected = (unbox_unit ()) in
  mark_test_run 1377;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1377 failed";
  (* Paths of depth 1 *)
  (* .b182 *)
  let actual = r.b182 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 1378;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 1378 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a182 = a1821; b182 = b1821 } { a182 = a1822; b182 = b1822 } -> (fun _ _ -> true) a1821 a1822 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b1821 b1822) in
  let next_r = { a182 = (unbox_unit ()); b182 = #((unbox_unit ()), #100L) } in
  let r_expected = { a182 = (unbox_unit ()); b182 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a182 *)
  r.a182 <- next_r.a182;
  let r_expected = { r_expected with a182 = next_r.a182 } in
  mark_test_run 1379;
  let test = eq r r_expected in
  if not test then failwithf "test 1379 failed";
  Gc.compact ();
  (* .b182 *)
  r.b182 <- next_r.b182;
  let r_expected = { r_expected with b182 = next_r.b182 } in
  mark_test_run 1380;
  let test = eq r r_expected in
  if not test then failwithf "test 1380 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a182; b182 } = r in
  let expected_a182 = (unbox_unit ()) in
  mark_test_run 1381;
  let test = (fun _ _ -> true) expected_a182 a182 in
  if not test then failwithf "test 1381 failed";
  let expected_b182 = #((unbox_unit ()), #100L) in
  mark_test_run 1382;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b182 b182 in
  if not test then failwithf "test 1382 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a182; b182 } = r in
  let expected_a182 = (unbox_unit ()) in
  mark_test_run 1383;
  let test = (fun _ _ -> true) expected_a182 a182 in
  if not test then failwithf "test 1383 failed";
  let expected_b182 = #((unbox_unit ()), #100L) in
  mark_test_run 1384;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b182 b182 in
  if not test then failwithf "test 1384 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t183 = { unit_u; #(unit_u, string) }   *)
  (********************************************)
  let r = { a183 = (unbox_unit ()); b183 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a183 *)
  let actual = r.a183 in
  let expected = (unbox_unit ()) in
  mark_test_run 1385;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1385 failed";
  (* Paths of depth 1 *)
  (* .b183 *)
  let actual = r.b183 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 1386;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 1386 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a183 = a1831; b183 = b1831 } { a183 = a1832; b183 = b1832 } -> (fun _ _ -> true) a1831 a1832 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b1831 b1832) in
  let next_r = { a183 = (unbox_unit ()); b183 = #((unbox_unit ()), "100") } in
  let r_expected = { a183 = (unbox_unit ()); b183 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a183 *)
  r.a183 <- next_r.a183;
  let r_expected = { r_expected with a183 = next_r.a183 } in
  mark_test_run 1387;
  let test = eq r r_expected in
  if not test then failwithf "test 1387 failed";
  Gc.compact ();
  (* .b183 *)
  r.b183 <- next_r.b183;
  let r_expected = { r_expected with b183 = next_r.b183 } in
  mark_test_run 1388;
  let test = eq r r_expected in
  if not test then failwithf "test 1388 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a183; b183 } = r in
  let expected_a183 = (unbox_unit ()) in
  mark_test_run 1389;
  let test = (fun _ _ -> true) expected_a183 a183 in
  if not test then failwithf "test 1389 failed";
  let expected_b183 = #((unbox_unit ()), "100") in
  mark_test_run 1390;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b183 b183 in
  if not test then failwithf "test 1390 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a183; b183 } = r in
  let expected_a183 = (unbox_unit ()) in
  mark_test_run 1391;
  let test = (fun _ _ -> true) expected_a183 a183 in
  if not test then failwithf "test 1391 failed";
  let expected_b183 = #((unbox_unit ()), "100") in
  mark_test_run 1392;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b183 b183 in
  if not test then failwithf "test 1392 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t185 = { unit_u; #{ unit_u; string } }   *)
  (**********************************************)
  let r = { a185 = (unbox_unit ()); b185 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a185 *)
  let actual = r.a185 in
  let expected = (unbox_unit ()) in
  mark_test_run 1393;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1393 failed";
  (* Paths of depth 1 *)
  (* .b185 *)
  let actual = r.b185 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 1394;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 1394 failed";
  (* Paths of depth 2 *)
  (* .b185.#a184 *)
  let actual = r.b185.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 1395;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1395 failed";
  (* .b185.#b184 *)
  let actual = r.b185.#b184 in
  let expected = "0" in
  mark_test_run 1396;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1396 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a185 = a1851; b185 = b1851 } { a185 = a1852; b185 = b1852 } -> (fun _ _ -> true) a1851 a1852 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b1851 b1852) in
  let next_r = { a185 = (unbox_unit ()); b185 = #{ a184 = (unbox_unit ()); b184 = "100" } } in
  let r_expected = { a185 = (unbox_unit ()); b185 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a185 *)
  r.a185 <- next_r.a185;
  let r_expected = { r_expected with a185 = next_r.a185 } in
  mark_test_run 1397;
  let test = eq r r_expected in
  if not test then failwithf "test 1397 failed";
  Gc.compact ();
  (* .b185 *)
  r.b185 <- next_r.b185;
  let r_expected = { r_expected with b185 = next_r.b185 } in
  mark_test_run 1398;
  let test = eq r r_expected in
  if not test then failwithf "test 1398 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a185; b185 = #{ a184; b184 } } = r in
  let expected_a185 = (unbox_unit ()) in
  mark_test_run 1399;
  let test = (fun _ _ -> true) expected_a185 a185 in
  if not test then failwithf "test 1399 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 1400;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 1400 failed";
  let expected_b184 = "100" in
  mark_test_run 1401;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 1401 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a185; b185 } = r in
  let expected_a185 = (unbox_unit ()) in
  mark_test_run 1402;
  let test = (fun _ _ -> true) expected_a185 a185 in
  if not test then failwithf "test 1402 failed";
  let expected_b185 = #{ a184 = (unbox_unit ()); b184 = "100" } in
  mark_test_run 1403;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) expected_b185 b185 in
  if not test then failwithf "test 1403 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t188 = { unit_u; #{ unit_u; #{ string } } }   *)
  (***************************************************)
  let r = { a188 = (unbox_unit ()); b188 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "0" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a188 *)
  let actual = r.a188 in
  let expected = (unbox_unit ()) in
  mark_test_run 1404;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1404 failed";
  (* Paths of depth 1 *)
  (* .b188 *)
  let actual = r.b188 in
  let expected = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "0" } } in
  mark_test_run 1405;
  let test = (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) actual expected in
  if not test then failwithf "test 1405 failed";
  (* Paths of depth 2 *)
  (* .b188.#a187 *)
  let actual = r.b188.#a187 in
  let expected = (unbox_unit ()) in
  mark_test_run 1406;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1406 failed";
  (* .b188.#b187 *)
  let actual = r.b188.#b187 in
  let expected = #{ a186 = "0" } in
  mark_test_run 1407;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 1407 failed";
  (* Paths of depth 3 *)
  (* .b188.#b187.#a186 *)
  let actual = r.b188.#b187.#a186 in
  let expected = "0" in
  mark_test_run 1408;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1408 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a188 = a1881; b188 = b1881 } { a188 = a1882; b188 = b1882 } -> (fun _ _ -> true) a1881 a1882 && (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) b1881 b1882) in
  let next_r = { a188 = (unbox_unit ()); b188 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "100" } } } in
  let r_expected = { a188 = (unbox_unit ()); b188 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "0" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a188 *)
  r.a188 <- next_r.a188;
  let r_expected = { r_expected with a188 = next_r.a188 } in
  mark_test_run 1409;
  let test = eq r r_expected in
  if not test then failwithf "test 1409 failed";
  Gc.compact ();
  (* .b188 *)
  r.b188 <- next_r.b188;
  let r_expected = { r_expected with b188 = next_r.b188 } in
  mark_test_run 1410;
  let test = eq r r_expected in
  if not test then failwithf "test 1410 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a188; b188 = #{ a187; b187 = #{ a186 } } } = r in
  let expected_a188 = (unbox_unit ()) in
  mark_test_run 1411;
  let test = (fun _ _ -> true) expected_a188 a188 in
  if not test then failwithf "test 1411 failed";
  let expected_a187 = (unbox_unit ()) in
  mark_test_run 1412;
  let test = (fun _ _ -> true) expected_a187 a187 in
  if not test then failwithf "test 1412 failed";
  let expected_a186 = "100" in
  mark_test_run 1413;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 1413 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a188; b188 } = r in
  let expected_a188 = (unbox_unit ()) in
  mark_test_run 1414;
  let test = (fun _ _ -> true) expected_a188 a188 in
  if not test then failwithf "test 1414 failed";
  let expected_b188 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "100" } } in
  mark_test_run 1415;
  let test = (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) expected_b188 b188 in
  if not test then failwithf "test 1415 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t189 = { unit_u; #{ string } }   *)
  (**************************************)
  let r = { a189 = (unbox_unit ()); b189 = #{ a186 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a189 *)
  let actual = r.a189 in
  let expected = (unbox_unit ()) in
  mark_test_run 1416;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1416 failed";
  (* Paths of depth 1 *)
  (* .b189 *)
  let actual = r.b189 in
  let expected = #{ a186 = "0" } in
  mark_test_run 1417;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 1417 failed";
  (* Paths of depth 2 *)
  (* .b189.#a186 *)
  let actual = r.b189.#a186 in
  let expected = "0" in
  mark_test_run 1418;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1418 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a189 = a1891; b189 = b1891 } { a189 = a1892; b189 = b1892 } -> (fun _ _ -> true) a1891 a1892 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1891 b1892) in
  let next_r = { a189 = (unbox_unit ()); b189 = #{ a186 = "100" } } in
  let r_expected = { a189 = (unbox_unit ()); b189 = #{ a186 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a189 *)
  r.a189 <- next_r.a189;
  let r_expected = { r_expected with a189 = next_r.a189 } in
  mark_test_run 1419;
  let test = eq r r_expected in
  if not test then failwithf "test 1419 failed";
  Gc.compact ();
  (* .b189 *)
  r.b189 <- next_r.b189;
  let r_expected = { r_expected with b189 = next_r.b189 } in
  mark_test_run 1420;
  let test = eq r r_expected in
  if not test then failwithf "test 1420 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a189; b189 = #{ a186 } } = r in
  let expected_a189 = (unbox_unit ()) in
  mark_test_run 1421;
  let test = (fun _ _ -> true) expected_a189 a189 in
  if not test then failwithf "test 1421 failed";
  let expected_a186 = "100" in
  mark_test_run 1422;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 1422 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a189; b189 } = r in
  let expected_a189 = (unbox_unit ()) in
  mark_test_run 1423;
  let test = (fun _ _ -> true) expected_a189 a189 in
  if not test then failwithf "test 1423 failed";
  let expected_b189 = #{ a186 = "100" } in
  mark_test_run 1424;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) expected_b189 b189 in
  if not test then failwithf "test 1424 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t191 = { unit_u; #{ string; unit_u } }   *)
  (**********************************************)
  let r = { a191 = (unbox_unit ()); b191 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a191 *)
  let actual = r.a191 in
  let expected = (unbox_unit ()) in
  mark_test_run 1425;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1425 failed";
  (* Paths of depth 1 *)
  (* .b191 *)
  let actual = r.b191 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 1426;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 1426 failed";
  (* Paths of depth 2 *)
  (* .b191.#a190 *)
  let actual = r.b191.#a190 in
  let expected = "0" in
  mark_test_run 1427;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1427 failed";
  (* .b191.#b190 *)
  let actual = r.b191.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 1428;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1428 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a191 = a1911; b191 = b1911 } { a191 = a1912; b191 = b1912 } -> (fun _ _ -> true) a1911 a1912 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b1911 b1912) in
  let next_r = { a191 = (unbox_unit ()); b191 = #{ a190 = "100"; b190 = (unbox_unit ()) } } in
  let r_expected = { a191 = (unbox_unit ()); b191 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a191 *)
  r.a191 <- next_r.a191;
  let r_expected = { r_expected with a191 = next_r.a191 } in
  mark_test_run 1429;
  let test = eq r r_expected in
  if not test then failwithf "test 1429 failed";
  Gc.compact ();
  (* .b191 *)
  r.b191 <- next_r.b191;
  let r_expected = { r_expected with b191 = next_r.b191 } in
  mark_test_run 1430;
  let test = eq r r_expected in
  if not test then failwithf "test 1430 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a191; b191 = #{ a190; b190 } } = r in
  let expected_a191 = (unbox_unit ()) in
  mark_test_run 1431;
  let test = (fun _ _ -> true) expected_a191 a191 in
  if not test then failwithf "test 1431 failed";
  let expected_a190 = "100" in
  mark_test_run 1432;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 1432 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 1433;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 1433 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a191; b191 } = r in
  let expected_a191 = (unbox_unit ()) in
  mark_test_run 1434;
  let test = (fun _ _ -> true) expected_a191 a191 in
  if not test then failwithf "test 1434 failed";
  let expected_b191 = #{ a190 = "100"; b190 = (unbox_unit ()) } in
  mark_test_run 1435;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) expected_b191 b191 in
  if not test then failwithf "test 1435 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t193 = { unit_u; #{ string; string } }   *)
  (**********************************************)
  let r = { a193 = (unbox_unit ()); b193 = #{ a192 = "0"; b192 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a193 *)
  let actual = r.a193 in
  let expected = (unbox_unit ()) in
  mark_test_run 1436;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1436 failed";
  (* Paths of depth 1 *)
  (* .b193 *)
  let actual = r.b193 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 1437;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 1437 failed";
  (* Paths of depth 2 *)
  (* .b193.#a192 *)
  let actual = r.b193.#a192 in
  let expected = "0" in
  mark_test_run 1438;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1438 failed";
  (* .b193.#b192 *)
  let actual = r.b193.#b192 in
  let expected = "1" in
  mark_test_run 1439;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1439 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a193 = a1931; b193 = b1931 } { a193 = a1932; b193 = b1932 } -> (fun _ _ -> true) a1931 a1932 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b1931 b1932) in
  let next_r = { a193 = (unbox_unit ()); b193 = #{ a192 = "100"; b192 = "101" } } in
  let r_expected = { a193 = (unbox_unit ()); b193 = #{ a192 = "0"; b192 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a193 *)
  r.a193 <- next_r.a193;
  let r_expected = { r_expected with a193 = next_r.a193 } in
  mark_test_run 1440;
  let test = eq r r_expected in
  if not test then failwithf "test 1440 failed";
  Gc.compact ();
  (* .b193 *)
  r.b193 <- next_r.b193;
  let r_expected = { r_expected with b193 = next_r.b193 } in
  mark_test_run 1441;
  let test = eq r r_expected in
  if not test then failwithf "test 1441 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a193; b193 = #{ a192; b192 } } = r in
  let expected_a193 = (unbox_unit ()) in
  mark_test_run 1442;
  let test = (fun _ _ -> true) expected_a193 a193 in
  if not test then failwithf "test 1442 failed";
  let expected_a192 = "100" in
  mark_test_run 1443;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 1443 failed";
  let expected_b192 = "101" in
  mark_test_run 1444;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 1444 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a193; b193 } = r in
  let expected_a193 = (unbox_unit ()) in
  mark_test_run 1445;
  let test = (fun _ _ -> true) expected_a193 a193 in
  if not test then failwithf "test 1445 failed";
  let expected_b193 = #{ a192 = "100"; b192 = "101" } in
  mark_test_run 1446;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) expected_b193 b193 in
  if not test then failwithf "test 1446 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t196 = { unit_u; #{ string; #{ unit_u } } }   *)
  (***************************************************)
  let r = { a196 = (unbox_unit ()); b196 = #{ a195 = "0"; b195 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a196 *)
  let actual = r.a196 in
  let expected = (unbox_unit ()) in
  mark_test_run 1447;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1447 failed";
  (* Paths of depth 1 *)
  (* .b196 *)
  let actual = r.b196 in
  let expected = #{ a195 = "0"; b195 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 1448;
  let test = (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) actual expected in
  if not test then failwithf "test 1448 failed";
  (* Paths of depth 2 *)
  (* .b196.#a195 *)
  let actual = r.b196.#a195 in
  let expected = "0" in
  mark_test_run 1449;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1449 failed";
  (* .b196.#b195 *)
  let actual = r.b196.#b195 in
  let expected = #{ a194 = (unbox_unit ()) } in
  mark_test_run 1450;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) actual expected in
  if not test then failwithf "test 1450 failed";
  (* Paths of depth 3 *)
  (* .b196.#b195.#a194 *)
  let actual = r.b196.#b195.#a194 in
  let expected = (unbox_unit ()) in
  mark_test_run 1451;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1451 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a196 = a1961; b196 = b1961 } { a196 = a1962; b196 = b1962 } -> (fun _ _ -> true) a1961 a1962 && (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) b1961 b1962) in
  let next_r = { a196 = (unbox_unit ()); b196 = #{ a195 = "100"; b195 = #{ a194 = (unbox_unit ()) } } } in
  let r_expected = { a196 = (unbox_unit ()); b196 = #{ a195 = "0"; b195 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a196 *)
  r.a196 <- next_r.a196;
  let r_expected = { r_expected with a196 = next_r.a196 } in
  mark_test_run 1452;
  let test = eq r r_expected in
  if not test then failwithf "test 1452 failed";
  Gc.compact ();
  (* .b196 *)
  r.b196 <- next_r.b196;
  let r_expected = { r_expected with b196 = next_r.b196 } in
  mark_test_run 1453;
  let test = eq r r_expected in
  if not test then failwithf "test 1453 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a196; b196 = #{ a195; b195 = #{ a194 } } } = r in
  let expected_a196 = (unbox_unit ()) in
  mark_test_run 1454;
  let test = (fun _ _ -> true) expected_a196 a196 in
  if not test then failwithf "test 1454 failed";
  let expected_a195 = "100" in
  mark_test_run 1455;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a195 a195 in
  if not test then failwithf "test 1455 failed";
  let expected_a194 = (unbox_unit ()) in
  mark_test_run 1456;
  let test = (fun _ _ -> true) expected_a194 a194 in
  if not test then failwithf "test 1456 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a196; b196 } = r in
  let expected_a196 = (unbox_unit ()) in
  mark_test_run 1457;
  let test = (fun _ _ -> true) expected_a196 a196 in
  if not test then failwithf "test 1457 failed";
  let expected_b196 = #{ a195 = "100"; b195 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 1458;
  let test = (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) expected_b196 b196 in
  if not test then failwithf "test 1458 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t198 = { unit_u; #{ string; #{ string } } }   *)
  (***************************************************)
  let r = { a198 = (unbox_unit ()); b198 = #{ a197 = "0"; b197 = #{ a186 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a198 *)
  let actual = r.a198 in
  let expected = (unbox_unit ()) in
  mark_test_run 1459;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1459 failed";
  (* Paths of depth 1 *)
  (* .b198 *)
  let actual = r.b198 in
  let expected = #{ a197 = "0"; b197 = #{ a186 = "1" } } in
  mark_test_run 1460;
  let test = (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) actual expected in
  if not test then failwithf "test 1460 failed";
  (* Paths of depth 2 *)
  (* .b198.#a197 *)
  let actual = r.b198.#a197 in
  let expected = "0" in
  mark_test_run 1461;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1461 failed";
  (* .b198.#b197 *)
  let actual = r.b198.#b197 in
  let expected = #{ a186 = "1" } in
  mark_test_run 1462;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 1462 failed";
  (* Paths of depth 3 *)
  (* .b198.#b197.#a186 *)
  let actual = r.b198.#b197.#a186 in
  let expected = "1" in
  mark_test_run 1463;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1463 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a198 = a1981; b198 = b1981 } { a198 = a1982; b198 = b1982 } -> (fun _ _ -> true) a1981 a1982 && (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) b1981 b1982) in
  let next_r = { a198 = (unbox_unit ()); b198 = #{ a197 = "100"; b197 = #{ a186 = "101" } } } in
  let r_expected = { a198 = (unbox_unit ()); b198 = #{ a197 = "0"; b197 = #{ a186 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a198 *)
  r.a198 <- next_r.a198;
  let r_expected = { r_expected with a198 = next_r.a198 } in
  mark_test_run 1464;
  let test = eq r r_expected in
  if not test then failwithf "test 1464 failed";
  Gc.compact ();
  (* .b198 *)
  r.b198 <- next_r.b198;
  let r_expected = { r_expected with b198 = next_r.b198 } in
  mark_test_run 1465;
  let test = eq r r_expected in
  if not test then failwithf "test 1465 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a198; b198 = #{ a197; b197 = #{ a186 } } } = r in
  let expected_a198 = (unbox_unit ()) in
  mark_test_run 1466;
  let test = (fun _ _ -> true) expected_a198 a198 in
  if not test then failwithf "test 1466 failed";
  let expected_a197 = "100" in
  mark_test_run 1467;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a197 a197 in
  if not test then failwithf "test 1467 failed";
  let expected_a186 = "101" in
  mark_test_run 1468;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 1468 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a198; b198 } = r in
  let expected_a198 = (unbox_unit ()) in
  mark_test_run 1469;
  let test = (fun _ _ -> true) expected_a198 a198 in
  if not test then failwithf "test 1469 failed";
  let expected_b198 = #{ a197 = "100"; b197 = #{ a186 = "101" } } in
  mark_test_run 1470;
  let test = (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) expected_b198 b198 in
  if not test then failwithf "test 1470 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t200 = { unit_u; #{ #{ unit_u; string } } }   *)
  (***************************************************)
  let r = { a200 = (unbox_unit ()); b200 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "0" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a200 *)
  let actual = r.a200 in
  let expected = (unbox_unit ()) in
  mark_test_run 1471;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1471 failed";
  (* Paths of depth 1 *)
  (* .b200 *)
  let actual = r.b200 in
  let expected = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  mark_test_run 1472;
  let test = (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) actual expected in
  if not test then failwithf "test 1472 failed";
  (* Paths of depth 2 *)
  (* .b200.#a199 *)
  let actual = r.b200.#a199 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 1473;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 1473 failed";
  (* Paths of depth 3 *)
  (* .b200.#a199.#a184 *)
  let actual = r.b200.#a199.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 1474;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1474 failed";
  (* .b200.#a199.#b184 *)
  let actual = r.b200.#a199.#b184 in
  let expected = "0" in
  mark_test_run 1475;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1475 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a200 = a2001; b200 = b2001 } { a200 = a2002; b200 = b2002 } -> (fun _ _ -> true) a2001 a2002 && (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) b2001 b2002) in
  let next_r = { a200 = (unbox_unit ()); b200 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "100" } } } in
  let r_expected = { a200 = (unbox_unit ()); b200 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "0" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a200 *)
  r.a200 <- next_r.a200;
  let r_expected = { r_expected with a200 = next_r.a200 } in
  mark_test_run 1476;
  let test = eq r r_expected in
  if not test then failwithf "test 1476 failed";
  Gc.compact ();
  (* .b200 *)
  r.b200 <- next_r.b200;
  let r_expected = { r_expected with b200 = next_r.b200 } in
  mark_test_run 1477;
  let test = eq r r_expected in
  if not test then failwithf "test 1477 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a200; b200 = #{ a199 = #{ a184; b184 } } } = r in
  let expected_a200 = (unbox_unit ()) in
  mark_test_run 1478;
  let test = (fun _ _ -> true) expected_a200 a200 in
  if not test then failwithf "test 1478 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 1479;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 1479 failed";
  let expected_b184 = "100" in
  mark_test_run 1480;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 1480 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a200; b200 } = r in
  let expected_a200 = (unbox_unit ()) in
  mark_test_run 1481;
  let test = (fun _ _ -> true) expected_a200 a200 in
  if not test then failwithf "test 1481 failed";
  let expected_b200 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "100" } } in
  mark_test_run 1482;
  let test = (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) expected_b200 b200 in
  if not test then failwithf "test 1482 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t202 = { unit_u; #{ #{ string; unit_u } } }   *)
  (***************************************************)
  let r = { a202 = (unbox_unit ()); b202 = #{ a201 = #{ a190 = "0"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a202 *)
  let actual = r.a202 in
  let expected = (unbox_unit ()) in
  mark_test_run 1483;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1483 failed";
  (* Paths of depth 1 *)
  (* .b202 *)
  let actual = r.b202 in
  let expected = #{ a201 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  mark_test_run 1484;
  let test = (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) actual expected in
  if not test then failwithf "test 1484 failed";
  (* Paths of depth 2 *)
  (* .b202.#a201 *)
  let actual = r.b202.#a201 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 1485;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 1485 failed";
  (* Paths of depth 3 *)
  (* .b202.#a201.#a190 *)
  let actual = r.b202.#a201.#a190 in
  let expected = "0" in
  mark_test_run 1486;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1486 failed";
  (* .b202.#a201.#b190 *)
  let actual = r.b202.#a201.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 1487;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1487 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a202 = a2021; b202 = b2021 } { a202 = a2022; b202 = b2022 } -> (fun _ _ -> true) a2021 a2022 && (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) b2021 b2022) in
  let next_r = { a202 = (unbox_unit ()); b202 = #{ a201 = #{ a190 = "100"; b190 = (unbox_unit ()) } } } in
  let r_expected = { a202 = (unbox_unit ()); b202 = #{ a201 = #{ a190 = "0"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a202 *)
  r.a202 <- next_r.a202;
  let r_expected = { r_expected with a202 = next_r.a202 } in
  mark_test_run 1488;
  let test = eq r r_expected in
  if not test then failwithf "test 1488 failed";
  Gc.compact ();
  (* .b202 *)
  r.b202 <- next_r.b202;
  let r_expected = { r_expected with b202 = next_r.b202 } in
  mark_test_run 1489;
  let test = eq r r_expected in
  if not test then failwithf "test 1489 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a202; b202 = #{ a201 = #{ a190; b190 } } } = r in
  let expected_a202 = (unbox_unit ()) in
  mark_test_run 1490;
  let test = (fun _ _ -> true) expected_a202 a202 in
  if not test then failwithf "test 1490 failed";
  let expected_a190 = "100" in
  mark_test_run 1491;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 1491 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 1492;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 1492 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a202; b202 } = r in
  let expected_a202 = (unbox_unit ()) in
  mark_test_run 1493;
  let test = (fun _ _ -> true) expected_a202 a202 in
  if not test then failwithf "test 1493 failed";
  let expected_b202 = #{ a201 = #{ a190 = "100"; b190 = (unbox_unit ()) } } in
  mark_test_run 1494;
  let test = (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) expected_b202 b202 in
  if not test then failwithf "test 1494 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t204 = { unit_u; #{ #{ string; string } } }   *)
  (***************************************************)
  let r = { a204 = (unbox_unit ()); b204 = #{ a203 = #{ a192 = "0"; b192 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a204 *)
  let actual = r.a204 in
  let expected = (unbox_unit ()) in
  mark_test_run 1495;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1495 failed";
  (* Paths of depth 1 *)
  (* .b204 *)
  let actual = r.b204 in
  let expected = #{ a203 = #{ a192 = "0"; b192 = "1" } } in
  mark_test_run 1496;
  let test = (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) actual expected in
  if not test then failwithf "test 1496 failed";
  (* Paths of depth 2 *)
  (* .b204.#a203 *)
  let actual = r.b204.#a203 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 1497;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 1497 failed";
  (* Paths of depth 3 *)
  (* .b204.#a203.#a192 *)
  let actual = r.b204.#a203.#a192 in
  let expected = "0" in
  mark_test_run 1498;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1498 failed";
  (* .b204.#a203.#b192 *)
  let actual = r.b204.#a203.#b192 in
  let expected = "1" in
  mark_test_run 1499;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1499 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a204 = a2041; b204 = b2041 } { a204 = a2042; b204 = b2042 } -> (fun _ _ -> true) a2041 a2042 && (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) b2041 b2042) in
  let next_r = { a204 = (unbox_unit ()); b204 = #{ a203 = #{ a192 = "100"; b192 = "101" } } } in
  let r_expected = { a204 = (unbox_unit ()); b204 = #{ a203 = #{ a192 = "0"; b192 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a204 *)
  r.a204 <- next_r.a204;
  let r_expected = { r_expected with a204 = next_r.a204 } in
  mark_test_run 1500;
  let test = eq r r_expected in
  if not test then failwithf "test 1500 failed";
  Gc.compact ();
  (* .b204 *)
  r.b204 <- next_r.b204;
  let r_expected = { r_expected with b204 = next_r.b204 } in
  mark_test_run 1501;
  let test = eq r r_expected in
  if not test then failwithf "test 1501 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a204; b204 = #{ a203 = #{ a192; b192 } } } = r in
  let expected_a204 = (unbox_unit ()) in
  mark_test_run 1502;
  let test = (fun _ _ -> true) expected_a204 a204 in
  if not test then failwithf "test 1502 failed";
  let expected_a192 = "100" in
  mark_test_run 1503;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 1503 failed";
  let expected_b192 = "101" in
  mark_test_run 1504;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 1504 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a204; b204 } = r in
  let expected_a204 = (unbox_unit ()) in
  mark_test_run 1505;
  let test = (fun _ _ -> true) expected_a204 a204 in
  if not test then failwithf "test 1505 failed";
  let expected_b204 = #{ a203 = #{ a192 = "100"; b192 = "101" } } in
  mark_test_run 1506;
  let test = (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) expected_b204 b204 in
  if not test then failwithf "test 1506 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************)
  (*   t205 = { float }   *)
  (************************)
  let r = { a205 = 0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a205 *)
  let actual = r.a205 in
  let expected = 0. in
  mark_test_run 1507;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1507 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a205 = a2051 } { a205 = a2052 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2051 a2052) in
  let next_r = { a205 = 100. } in
  let r_expected = { a205 = 0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a205 *)
  r.a205 <- next_r.a205;
  let r_expected = { r_expected with a205 = next_r.a205 } in
  mark_test_run 1508;
  let test = eq r r_expected in
  if not test then failwithf "test 1508 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a205 } = r in
  let expected_a205 = 100. in
  mark_test_run 1509;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a205 a205 in
  if not test then failwithf "test 1509 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a205 } = r in
  let expected_a205 = 100. in
  mark_test_run 1510;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a205 a205 in
  if not test then failwithf "test 1510 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t206 = { float; int }   *)
  (*****************************)
  let r = { a206 = 0.; b206 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a206 *)
  let actual = r.a206 in
  let expected = 0. in
  mark_test_run 1511;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1511 failed";
  (* Paths of depth 1 *)
  (* .b206 *)
  let actual = r.b206 in
  let expected = 1 in
  mark_test_run 1512;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1512 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a206 = a2061; b206 = b2061 } { a206 = a2062; b206 = b2062 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2061 a2062 && (fun a b -> Int.equal a b) b2061 b2062) in
  let next_r = { a206 = 100.; b206 = 101 } in
  let r_expected = { a206 = 0.; b206 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a206 *)
  r.a206 <- next_r.a206;
  let r_expected = { r_expected with a206 = next_r.a206 } in
  mark_test_run 1513;
  let test = eq r r_expected in
  if not test then failwithf "test 1513 failed";
  Gc.compact ();
  (* .b206 *)
  r.b206 <- next_r.b206;
  let r_expected = { r_expected with b206 = next_r.b206 } in
  mark_test_run 1514;
  let test = eq r r_expected in
  if not test then failwithf "test 1514 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a206; b206 } = r in
  let expected_a206 = 100. in
  mark_test_run 1515;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a206 a206 in
  if not test then failwithf "test 1515 failed";
  let expected_b206 = 101 in
  mark_test_run 1516;
  let test = (fun a b -> Int.equal a b) expected_b206 b206 in
  if not test then failwithf "test 1516 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a206; b206 } = r in
  let expected_a206 = 100. in
  mark_test_run 1517;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a206 a206 in
  if not test then failwithf "test 1517 failed";
  let expected_b206 = 101 in
  mark_test_run 1518;
  let test = (fun a b -> Int.equal a b) expected_b206 b206 in
  if not test then failwithf "test 1518 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t207 = { float; int; int }   *)
  (**********************************)
  let r = { a207 = 0.; b207 = 1; c207 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a207 *)
  let actual = r.a207 in
  let expected = 0. in
  mark_test_run 1519;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1519 failed";
  (* Paths of depth 1 *)
  (* .b207 *)
  let actual = r.b207 in
  let expected = 1 in
  mark_test_run 1520;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1520 failed";
  (* Paths of depth 1 *)
  (* .c207 *)
  let actual = r.c207 in
  let expected = 2 in
  mark_test_run 1521;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1521 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a207 = a2071; b207 = b2071; c207 = c2071 } { a207 = a2072; b207 = b2072; c207 = c2072 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2071 a2072 && (fun a b -> Int.equal a b) b2071 b2072 && (fun a b -> Int.equal a b) c2071 c2072) in
  let next_r = { a207 = 100.; b207 = 101; c207 = 102 } in
  let r_expected = { a207 = 0.; b207 = 1; c207 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a207 *)
  r.a207 <- next_r.a207;
  let r_expected = { r_expected with a207 = next_r.a207 } in
  mark_test_run 1522;
  let test = eq r r_expected in
  if not test then failwithf "test 1522 failed";
  Gc.compact ();
  (* .b207 *)
  r.b207 <- next_r.b207;
  let r_expected = { r_expected with b207 = next_r.b207 } in
  mark_test_run 1523;
  let test = eq r r_expected in
  if not test then failwithf "test 1523 failed";
  Gc.compact ();
  (* .c207 *)
  r.c207 <- next_r.c207;
  let r_expected = { r_expected with c207 = next_r.c207 } in
  mark_test_run 1524;
  let test = eq r r_expected in
  if not test then failwithf "test 1524 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a207; b207; c207 } = r in
  let expected_a207 = 100. in
  mark_test_run 1525;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a207 a207 in
  if not test then failwithf "test 1525 failed";
  let expected_b207 = 101 in
  mark_test_run 1526;
  let test = (fun a b -> Int.equal a b) expected_b207 b207 in
  if not test then failwithf "test 1526 failed";
  let expected_c207 = 102 in
  mark_test_run 1527;
  let test = (fun a b -> Int.equal a b) expected_c207 c207 in
  if not test then failwithf "test 1527 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a207; b207; c207 } = r in
  let expected_a207 = 100. in
  mark_test_run 1528;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a207 a207 in
  if not test then failwithf "test 1528 failed";
  let expected_b207 = 101 in
  mark_test_run 1529;
  let test = (fun a b -> Int.equal a b) expected_b207 b207 in
  if not test then failwithf "test 1529 failed";
  let expected_c207 = 102 in
  mark_test_run 1530;
  let test = (fun a b -> Int.equal a b) expected_c207 c207 in
  if not test then failwithf "test 1530 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t208 = { float; int; float }   *)
  (************************************)
  let r = { a208 = 0.; b208 = 1; c208 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a208 *)
  let actual = r.a208 in
  let expected = 0. in
  mark_test_run 1531;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1531 failed";
  (* Paths of depth 1 *)
  (* .b208 *)
  let actual = r.b208 in
  let expected = 1 in
  mark_test_run 1532;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1532 failed";
  (* Paths of depth 1 *)
  (* .c208 *)
  let actual = r.c208 in
  let expected = 2. in
  mark_test_run 1533;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1533 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a208 = a2081; b208 = b2081; c208 = c2081 } { a208 = a2082; b208 = b2082; c208 = c2082 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2081 a2082 && (fun a b -> Int.equal a b) b2081 b2082 && (fun a b -> Float.equal (globalize a) (globalize b)) c2081 c2082) in
  let next_r = { a208 = 100.; b208 = 101; c208 = 102. } in
  let r_expected = { a208 = 0.; b208 = 1; c208 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a208 *)
  r.a208 <- next_r.a208;
  let r_expected = { r_expected with a208 = next_r.a208 } in
  mark_test_run 1534;
  let test = eq r r_expected in
  if not test then failwithf "test 1534 failed";
  Gc.compact ();
  (* .b208 *)
  r.b208 <- next_r.b208;
  let r_expected = { r_expected with b208 = next_r.b208 } in
  mark_test_run 1535;
  let test = eq r r_expected in
  if not test then failwithf "test 1535 failed";
  Gc.compact ();
  (* .c208 *)
  r.c208 <- next_r.c208;
  let r_expected = { r_expected with c208 = next_r.c208 } in
  mark_test_run 1536;
  let test = eq r r_expected in
  if not test then failwithf "test 1536 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a208; b208; c208 } = r in
  let expected_a208 = 100. in
  mark_test_run 1537;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a208 a208 in
  if not test then failwithf "test 1537 failed";
  let expected_b208 = 101 in
  mark_test_run 1538;
  let test = (fun a b -> Int.equal a b) expected_b208 b208 in
  if not test then failwithf "test 1538 failed";
  let expected_c208 = 102. in
  mark_test_run 1539;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c208 c208 in
  if not test then failwithf "test 1539 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a208; b208; c208 } = r in
  let expected_a208 = 100. in
  mark_test_run 1540;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a208 a208 in
  if not test then failwithf "test 1540 failed";
  let expected_b208 = 101 in
  mark_test_run 1541;
  let test = (fun a b -> Int.equal a b) expected_b208 b208 in
  if not test then failwithf "test 1541 failed";
  let expected_c208 = 102. in
  mark_test_run 1542;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c208 c208 in
  if not test then failwithf "test 1542 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t209 = { float; int64 }   *)
  (*******************************)
  let r = { a209 = 0.; b209 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a209 *)
  let actual = r.a209 in
  let expected = 0. in
  mark_test_run 1543;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1543 failed";
  (* Paths of depth 1 *)
  (* .b209 *)
  let actual = r.b209 in
  let expected = 1L in
  mark_test_run 1544;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1544 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a209 = a2091; b209 = b2091 } { a209 = a2092; b209 = b2092 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2091 a2092 && (fun a b -> Int64.equal (globalize a) (globalize b)) b2091 b2092) in
  let next_r = { a209 = 100.; b209 = 101L } in
  let r_expected = { a209 = 0.; b209 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a209 *)
  r.a209 <- next_r.a209;
  let r_expected = { r_expected with a209 = next_r.a209 } in
  mark_test_run 1545;
  let test = eq r r_expected in
  if not test then failwithf "test 1545 failed";
  Gc.compact ();
  (* .b209 *)
  r.b209 <- next_r.b209;
  let r_expected = { r_expected with b209 = next_r.b209 } in
  mark_test_run 1546;
  let test = eq r r_expected in
  if not test then failwithf "test 1546 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a209; b209 } = r in
  let expected_a209 = 100. in
  mark_test_run 1547;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a209 a209 in
  if not test then failwithf "test 1547 failed";
  let expected_b209 = 101L in
  mark_test_run 1548;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b209 b209 in
  if not test then failwithf "test 1548 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a209; b209 } = r in
  let expected_a209 = 100. in
  mark_test_run 1549;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a209 a209 in
  if not test then failwithf "test 1549 failed";
  let expected_b209 = 101L in
  mark_test_run 1550;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b209 b209 in
  if not test then failwithf "test 1550 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t210 = { float; int64# }   *)
  (********************************)
  let r = { a210 = 0.; b210 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a210 *)
  let actual = r.a210 in
  let expected = 0. in
  mark_test_run 1551;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1551 failed";
  (* Paths of depth 1 *)
  (* .b210 *)
  let actual = r.b210 in
  let expected = #1L in
  mark_test_run 1552;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 1552 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a210 = a2101; b210 = b2101 } { a210 = a2102; b210 = b2102 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2101 a2102 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2101 b2102) in
  let next_r = { a210 = 100.; b210 = #101L } in
  let r_expected = { a210 = 0.; b210 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a210 *)
  r.a210 <- next_r.a210;
  let r_expected = { r_expected with a210 = next_r.a210 } in
  mark_test_run 1553;
  let test = eq r r_expected in
  if not test then failwithf "test 1553 failed";
  Gc.compact ();
  (* .b210 *)
  r.b210 <- next_r.b210;
  let r_expected = { r_expected with b210 = next_r.b210 } in
  mark_test_run 1554;
  let test = eq r r_expected in
  if not test then failwithf "test 1554 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a210; b210 } = r in
  let expected_a210 = 100. in
  mark_test_run 1555;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a210 a210 in
  if not test then failwithf "test 1555 failed";
  let expected_b210 = #101L in
  mark_test_run 1556;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b210 b210 in
  if not test then failwithf "test 1556 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a210; b210 } = r in
  let expected_a210 = 100. in
  mark_test_run 1557;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a210 a210 in
  if not test then failwithf "test 1557 failed";
  let expected_b210 = #101L in
  mark_test_run 1558;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b210 b210 in
  if not test then failwithf "test 1558 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t211 = { float; int32# }   *)
  (********************************)
  let r = { a211 = 0.; b211 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a211 *)
  let actual = r.a211 in
  let expected = 0. in
  mark_test_run 1559;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1559 failed";
  (* Paths of depth 1 *)
  (* .b211 *)
  let actual = r.b211 in
  let expected = #1l in
  mark_test_run 1560;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 1560 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a211 = a2111; b211 = b2111 } { a211 = a2112; b211 = b2112 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2111 a2112 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b2111 b2112) in
  let next_r = { a211 = 100.; b211 = #101l } in
  let r_expected = { a211 = 0.; b211 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a211 *)
  r.a211 <- next_r.a211;
  let r_expected = { r_expected with a211 = next_r.a211 } in
  mark_test_run 1561;
  let test = eq r r_expected in
  if not test then failwithf "test 1561 failed";
  Gc.compact ();
  (* .b211 *)
  r.b211 <- next_r.b211;
  let r_expected = { r_expected with b211 = next_r.b211 } in
  mark_test_run 1562;
  let test = eq r r_expected in
  if not test then failwithf "test 1562 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a211; b211 } = r in
  let expected_a211 = 100. in
  mark_test_run 1563;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a211 a211 in
  if not test then failwithf "test 1563 failed";
  let expected_b211 = #101l in
  mark_test_run 1564;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b211 b211 in
  if not test then failwithf "test 1564 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a211; b211 } = r in
  let expected_a211 = 100. in
  mark_test_run 1565;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a211 a211 in
  if not test then failwithf "test 1565 failed";
  let expected_b211 = #101l in
  mark_test_run 1566;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b211 b211 in
  if not test then failwithf "test 1566 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t212 = { float; nativeint# }   *)
  (************************************)
  let r = { a212 = 0.; b212 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a212 *)
  let actual = r.a212 in
  let expected = 0. in
  mark_test_run 1567;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1567 failed";
  (* Paths of depth 1 *)
  (* .b212 *)
  let actual = r.b212 in
  let expected = #1n in
  mark_test_run 1568;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 1568 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a212 = a2121; b212 = b2121 } { a212 = a2122; b212 = b2122 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2121 a2122 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b2121 b2122) in
  let next_r = { a212 = 100.; b212 = #101n } in
  let r_expected = { a212 = 0.; b212 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a212 *)
  r.a212 <- next_r.a212;
  let r_expected = { r_expected with a212 = next_r.a212 } in
  mark_test_run 1569;
  let test = eq r r_expected in
  if not test then failwithf "test 1569 failed";
  Gc.compact ();
  (* .b212 *)
  r.b212 <- next_r.b212;
  let r_expected = { r_expected with b212 = next_r.b212 } in
  mark_test_run 1570;
  let test = eq r r_expected in
  if not test then failwithf "test 1570 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a212; b212 } = r in
  let expected_a212 = 100. in
  mark_test_run 1571;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a212 a212 in
  if not test then failwithf "test 1571 failed";
  let expected_b212 = #101n in
  mark_test_run 1572;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b212 b212 in
  if not test then failwithf "test 1572 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a212; b212 } = r in
  let expected_a212 = 100. in
  mark_test_run 1573;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a212 a212 in
  if not test then failwithf "test 1573 failed";
  let expected_b212 = #101n in
  mark_test_run 1574;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b212 b212 in
  if not test then failwithf "test 1574 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t213 = { float; unit_u }   *)
  (********************************)
  let r = { a213 = 0.; b213 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a213 *)
  let actual = r.a213 in
  let expected = 0. in
  mark_test_run 1575;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1575 failed";
  (* Paths of depth 1 *)
  (* .b213 *)
  let actual = r.b213 in
  let expected = (unbox_unit ()) in
  mark_test_run 1576;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 1576 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a213 = a2131; b213 = b2131 } { a213 = a2132; b213 = b2132 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2131 a2132 && (fun _ _ -> true) b2131 b2132) in
  let next_r = { a213 = 100.; b213 = (unbox_unit ()) } in
  let r_expected = { a213 = 0.; b213 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a213 *)
  r.a213 <- next_r.a213;
  let r_expected = { r_expected with a213 = next_r.a213 } in
  mark_test_run 1577;
  let test = eq r r_expected in
  if not test then failwithf "test 1577 failed";
  Gc.compact ();
  (* .b213 *)
  r.b213 <- next_r.b213;
  let r_expected = { r_expected with b213 = next_r.b213 } in
  mark_test_run 1578;
  let test = eq r r_expected in
  if not test then failwithf "test 1578 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a213; b213 } = r in
  let expected_a213 = 100. in
  mark_test_run 1579;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a213 a213 in
  if not test then failwithf "test 1579 failed";
  let expected_b213 = (unbox_unit ()) in
  mark_test_run 1580;
  let test = (fun _ _ -> true) expected_b213 b213 in
  if not test then failwithf "test 1580 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a213; b213 } = r in
  let expected_a213 = 100. in
  mark_test_run 1581;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a213 a213 in
  if not test then failwithf "test 1581 failed";
  let expected_b213 = (unbox_unit ()) in
  mark_test_run 1582;
  let test = (fun _ _ -> true) expected_b213 b213 in
  if not test then failwithf "test 1582 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t214 = { float; float }   *)
  (*******************************)
  let r = { a214 = 0.; b214 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a214 *)
  let actual = r.a214 in
  let expected = 0. in
  mark_test_run 1583;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1583 failed";
  (* Paths of depth 1 *)
  (* .b214 *)
  let actual = r.b214 in
  let expected = 1. in
  mark_test_run 1584;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1584 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a214 = a2141; b214 = b2141 } { a214 = a2142; b214 = b2142 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2141 a2142 && (fun a b -> Float.equal (globalize a) (globalize b)) b2141 b2142) in
  let next_r = { a214 = 100.; b214 = 101. } in
  let r_expected = { a214 = 0.; b214 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a214 *)
  r.a214 <- next_r.a214;
  let r_expected = { r_expected with a214 = next_r.a214 } in
  mark_test_run 1585;
  let test = eq r r_expected in
  if not test then failwithf "test 1585 failed";
  Gc.compact ();
  (* .b214 *)
  r.b214 <- next_r.b214;
  let r_expected = { r_expected with b214 = next_r.b214 } in
  mark_test_run 1586;
  let test = eq r r_expected in
  if not test then failwithf "test 1586 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a214; b214 } = r in
  let expected_a214 = 100. in
  mark_test_run 1587;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a214 a214 in
  if not test then failwithf "test 1587 failed";
  let expected_b214 = 101. in
  mark_test_run 1588;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b214 b214 in
  if not test then failwithf "test 1588 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a214; b214 } = r in
  let expected_a214 = 100. in
  mark_test_run 1589;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a214 a214 in
  if not test then failwithf "test 1589 failed";
  let expected_b214 = 101. in
  mark_test_run 1590;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b214 b214 in
  if not test then failwithf "test 1590 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t215 = { float; float; int }   *)
  (************************************)
  let r = { a215 = 0.; b215 = 1.; c215 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a215 *)
  let actual = r.a215 in
  let expected = 0. in
  mark_test_run 1591;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1591 failed";
  (* Paths of depth 1 *)
  (* .b215 *)
  let actual = r.b215 in
  let expected = 1. in
  mark_test_run 1592;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1592 failed";
  (* Paths of depth 1 *)
  (* .c215 *)
  let actual = r.c215 in
  let expected = 2 in
  mark_test_run 1593;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1593 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a215 = a2151; b215 = b2151; c215 = c2151 } { a215 = a2152; b215 = b2152; c215 = c2152 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2151 a2152 && (fun a b -> Float.equal (globalize a) (globalize b)) b2151 b2152 && (fun a b -> Int.equal a b) c2151 c2152) in
  let next_r = { a215 = 100.; b215 = 101.; c215 = 102 } in
  let r_expected = { a215 = 0.; b215 = 1.; c215 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a215 *)
  r.a215 <- next_r.a215;
  let r_expected = { r_expected with a215 = next_r.a215 } in
  mark_test_run 1594;
  let test = eq r r_expected in
  if not test then failwithf "test 1594 failed";
  Gc.compact ();
  (* .b215 *)
  r.b215 <- next_r.b215;
  let r_expected = { r_expected with b215 = next_r.b215 } in
  mark_test_run 1595;
  let test = eq r r_expected in
  if not test then failwithf "test 1595 failed";
  Gc.compact ();
  (* .c215 *)
  r.c215 <- next_r.c215;
  let r_expected = { r_expected with c215 = next_r.c215 } in
  mark_test_run 1596;
  let test = eq r r_expected in
  if not test then failwithf "test 1596 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a215; b215; c215 } = r in
  let expected_a215 = 100. in
  mark_test_run 1597;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a215 a215 in
  if not test then failwithf "test 1597 failed";
  let expected_b215 = 101. in
  mark_test_run 1598;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b215 b215 in
  if not test then failwithf "test 1598 failed";
  let expected_c215 = 102 in
  mark_test_run 1599;
  let test = (fun a b -> Int.equal a b) expected_c215 c215 in
  if not test then failwithf "test 1599 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a215; b215; c215 } = r in
  let expected_a215 = 100. in
  mark_test_run 1600;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a215 a215 in
  if not test then failwithf "test 1600 failed";
  let expected_b215 = 101. in
  mark_test_run 1601;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b215 b215 in
  if not test then failwithf "test 1601 failed";
  let expected_c215 = 102 in
  mark_test_run 1602;
  let test = (fun a b -> Int.equal a b) expected_c215 c215 in
  if not test then failwithf "test 1602 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t216 = { float; float; float }   *)
  (**************************************)
  let r = { a216 = 0.; b216 = 1.; c216 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a216 *)
  let actual = r.a216 in
  let expected = 0. in
  mark_test_run 1603;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1603 failed";
  (* Paths of depth 1 *)
  (* .b216 *)
  let actual = r.b216 in
  let expected = 1. in
  mark_test_run 1604;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1604 failed";
  (* Paths of depth 1 *)
  (* .c216 *)
  let actual = r.c216 in
  let expected = 2. in
  mark_test_run 1605;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1605 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a216 = a2161; b216 = b2161; c216 = c2161 } { a216 = a2162; b216 = b2162; c216 = c2162 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2161 a2162 && (fun a b -> Float.equal (globalize a) (globalize b)) b2161 b2162 && (fun a b -> Float.equal (globalize a) (globalize b)) c2161 c2162) in
  let next_r = { a216 = 100.; b216 = 101.; c216 = 102. } in
  let r_expected = { a216 = 0.; b216 = 1.; c216 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a216 *)
  r.a216 <- next_r.a216;
  let r_expected = { r_expected with a216 = next_r.a216 } in
  mark_test_run 1606;
  let test = eq r r_expected in
  if not test then failwithf "test 1606 failed";
  Gc.compact ();
  (* .b216 *)
  r.b216 <- next_r.b216;
  let r_expected = { r_expected with b216 = next_r.b216 } in
  mark_test_run 1607;
  let test = eq r r_expected in
  if not test then failwithf "test 1607 failed";
  Gc.compact ();
  (* .c216 *)
  r.c216 <- next_r.c216;
  let r_expected = { r_expected with c216 = next_r.c216 } in
  mark_test_run 1608;
  let test = eq r r_expected in
  if not test then failwithf "test 1608 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a216; b216; c216 } = r in
  let expected_a216 = 100. in
  mark_test_run 1609;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a216 a216 in
  if not test then failwithf "test 1609 failed";
  let expected_b216 = 101. in
  mark_test_run 1610;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b216 b216 in
  if not test then failwithf "test 1610 failed";
  let expected_c216 = 102. in
  mark_test_run 1611;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c216 c216 in
  if not test then failwithf "test 1611 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a216; b216; c216 } = r in
  let expected_a216 = 100. in
  mark_test_run 1612;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a216 a216 in
  if not test then failwithf "test 1612 failed";
  let expected_b216 = 101. in
  mark_test_run 1613;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b216 b216 in
  if not test then failwithf "test 1613 failed";
  let expected_c216 = 102. in
  mark_test_run 1614;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c216 c216 in
  if not test then failwithf "test 1614 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t217 = { float; float; float# }   *)
  (***************************************)
  let r = { a217 = 0.; b217 = 1.; c217 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a217 *)
  let actual = r.a217 in
  let expected = 0. in
  mark_test_run 1615;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1615 failed";
  (* Paths of depth 1 *)
  (* .b217 *)
  let actual = r.b217 in
  let expected = 1. in
  mark_test_run 1616;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1616 failed";
  (* Paths of depth 1 *)
  (* .c217 *)
  let actual = r.c217 in
  let expected = #2. in
  mark_test_run 1617;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1617 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a217 = a2171; b217 = b2171; c217 = c2171 } { a217 = a2172; b217 = b2172; c217 = c2172 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2171 a2172 && (fun a b -> Float.equal (globalize a) (globalize b)) b2171 b2172 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) c2171 c2172) in
  let next_r = { a217 = 100.; b217 = 101.; c217 = #102. } in
  let r_expected = { a217 = 0.; b217 = 1.; c217 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a217 *)
  r.a217 <- next_r.a217;
  let r_expected = { r_expected with a217 = next_r.a217 } in
  mark_test_run 1618;
  let test = eq r r_expected in
  if not test then failwithf "test 1618 failed";
  Gc.compact ();
  (* .b217 *)
  r.b217 <- next_r.b217;
  let r_expected = { r_expected with b217 = next_r.b217 } in
  mark_test_run 1619;
  let test = eq r r_expected in
  if not test then failwithf "test 1619 failed";
  Gc.compact ();
  (* .c217 *)
  r.c217 <- next_r.c217;
  let r_expected = { r_expected with c217 = next_r.c217 } in
  mark_test_run 1620;
  let test = eq r r_expected in
  if not test then failwithf "test 1620 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a217; b217; c217 } = r in
  let expected_a217 = 100. in
  mark_test_run 1621;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a217 a217 in
  if not test then failwithf "test 1621 failed";
  let expected_b217 = 101. in
  mark_test_run 1622;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b217 b217 in
  if not test then failwithf "test 1622 failed";
  let expected_c217 = #102. in
  mark_test_run 1623;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c217 c217 in
  if not test then failwithf "test 1623 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a217; b217; c217 } = r in
  let expected_a217 = 100. in
  mark_test_run 1624;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a217 a217 in
  if not test then failwithf "test 1624 failed";
  let expected_b217 = 101. in
  mark_test_run 1625;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b217 b217 in
  if not test then failwithf "test 1625 failed";
  let expected_c217 = #102. in
  mark_test_run 1626;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c217 c217 in
  if not test then failwithf "test 1626 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t218 = { float; float# }   *)
  (********************************)
  let r = { a218 = 0.; b218 = #1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a218 *)
  let actual = r.a218 in
  let expected = 0. in
  mark_test_run 1627;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1627 failed";
  (* Paths of depth 1 *)
  (* .b218 *)
  let actual = r.b218 in
  let expected = #1. in
  mark_test_run 1628;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1628 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a218 = a2181; b218 = b2181 } { a218 = a2182; b218 = b2182 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2181 a2182 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2181 b2182) in
  let next_r = { a218 = 100.; b218 = #101. } in
  let r_expected = { a218 = 0.; b218 = #1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a218 *)
  r.a218 <- next_r.a218;
  let r_expected = { r_expected with a218 = next_r.a218 } in
  mark_test_run 1629;
  let test = eq r r_expected in
  if not test then failwithf "test 1629 failed";
  Gc.compact ();
  (* .b218 *)
  r.b218 <- next_r.b218;
  let r_expected = { r_expected with b218 = next_r.b218 } in
  mark_test_run 1630;
  let test = eq r r_expected in
  if not test then failwithf "test 1630 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a218; b218 } = r in
  let expected_a218 = 100. in
  mark_test_run 1631;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a218 a218 in
  if not test then failwithf "test 1631 failed";
  let expected_b218 = #101. in
  mark_test_run 1632;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b218 b218 in
  if not test then failwithf "test 1632 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a218; b218 } = r in
  let expected_a218 = 100. in
  mark_test_run 1633;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a218 a218 in
  if not test then failwithf "test 1633 failed";
  let expected_b218 = #101. in
  mark_test_run 1634;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b218 b218 in
  if not test then failwithf "test 1634 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t219 = { float; float#; float }   *)
  (***************************************)
  let r = { a219 = 0.; b219 = #1.; c219 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a219 *)
  let actual = r.a219 in
  let expected = 0. in
  mark_test_run 1635;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1635 failed";
  (* Paths of depth 1 *)
  (* .b219 *)
  let actual = r.b219 in
  let expected = #1. in
  mark_test_run 1636;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1636 failed";
  (* Paths of depth 1 *)
  (* .c219 *)
  let actual = r.c219 in
  let expected = 2. in
  mark_test_run 1637;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1637 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a219 = a2191; b219 = b2191; c219 = c2191 } { a219 = a2192; b219 = b2192; c219 = c2192 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2191 a2192 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2191 b2192 && (fun a b -> Float.equal (globalize a) (globalize b)) c2191 c2192) in
  let next_r = { a219 = 100.; b219 = #101.; c219 = 102. } in
  let r_expected = { a219 = 0.; b219 = #1.; c219 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a219 *)
  r.a219 <- next_r.a219;
  let r_expected = { r_expected with a219 = next_r.a219 } in
  mark_test_run 1638;
  let test = eq r r_expected in
  if not test then failwithf "test 1638 failed";
  Gc.compact ();
  (* .b219 *)
  r.b219 <- next_r.b219;
  let r_expected = { r_expected with b219 = next_r.b219 } in
  mark_test_run 1639;
  let test = eq r r_expected in
  if not test then failwithf "test 1639 failed";
  Gc.compact ();
  (* .c219 *)
  r.c219 <- next_r.c219;
  let r_expected = { r_expected with c219 = next_r.c219 } in
  mark_test_run 1640;
  let test = eq r r_expected in
  if not test then failwithf "test 1640 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a219; b219; c219 } = r in
  let expected_a219 = 100. in
  mark_test_run 1641;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a219 a219 in
  if not test then failwithf "test 1641 failed";
  let expected_b219 = #101. in
  mark_test_run 1642;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b219 b219 in
  if not test then failwithf "test 1642 failed";
  let expected_c219 = 102. in
  mark_test_run 1643;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c219 c219 in
  if not test then failwithf "test 1643 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a219; b219; c219 } = r in
  let expected_a219 = 100. in
  mark_test_run 1644;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a219 a219 in
  if not test then failwithf "test 1644 failed";
  let expected_b219 = #101. in
  mark_test_run 1645;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b219 b219 in
  if not test then failwithf "test 1645 failed";
  let expected_c219 = 102. in
  mark_test_run 1646;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c219 c219 in
  if not test then failwithf "test 1646 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t220 = { float; float#; float# }   *)
  (****************************************)
  let r = { a220 = 0.; b220 = #1.; c220 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a220 *)
  let actual = r.a220 in
  let expected = 0. in
  mark_test_run 1647;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1647 failed";
  (* Paths of depth 1 *)
  (* .b220 *)
  let actual = r.b220 in
  let expected = #1. in
  mark_test_run 1648;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1648 failed";
  (* Paths of depth 1 *)
  (* .c220 *)
  let actual = r.c220 in
  let expected = #2. in
  mark_test_run 1649;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1649 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a220 = a2201; b220 = b2201; c220 = c2201 } { a220 = a2202; b220 = b2202; c220 = c2202 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2201 a2202 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2201 b2202 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) c2201 c2202) in
  let next_r = { a220 = 100.; b220 = #101.; c220 = #102. } in
  let r_expected = { a220 = 0.; b220 = #1.; c220 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a220 *)
  r.a220 <- next_r.a220;
  let r_expected = { r_expected with a220 = next_r.a220 } in
  mark_test_run 1650;
  let test = eq r r_expected in
  if not test then failwithf "test 1650 failed";
  Gc.compact ();
  (* .b220 *)
  r.b220 <- next_r.b220;
  let r_expected = { r_expected with b220 = next_r.b220 } in
  mark_test_run 1651;
  let test = eq r r_expected in
  if not test then failwithf "test 1651 failed";
  Gc.compact ();
  (* .c220 *)
  r.c220 <- next_r.c220;
  let r_expected = { r_expected with c220 = next_r.c220 } in
  mark_test_run 1652;
  let test = eq r r_expected in
  if not test then failwithf "test 1652 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a220; b220; c220 } = r in
  let expected_a220 = 100. in
  mark_test_run 1653;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a220 a220 in
  if not test then failwithf "test 1653 failed";
  let expected_b220 = #101. in
  mark_test_run 1654;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b220 b220 in
  if not test then failwithf "test 1654 failed";
  let expected_c220 = #102. in
  mark_test_run 1655;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c220 c220 in
  if not test then failwithf "test 1655 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a220; b220; c220 } = r in
  let expected_a220 = 100. in
  mark_test_run 1656;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a220 a220 in
  if not test then failwithf "test 1656 failed";
  let expected_b220 = #101. in
  mark_test_run 1657;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b220 b220 in
  if not test then failwithf "test 1657 failed";
  let expected_c220 = #102. in
  mark_test_run 1658;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c220 c220 in
  if not test then failwithf "test 1658 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t221 = { float; (| unit_u) }   *)
  (************************************)
  let r = { a221 = 0.; b221 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a221 *)
  let actual = r.a221 in
  let expected = 0. in
  mark_test_run 1659;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1659 failed";
  (* Paths of depth 1 *)
  (* .b221 *)
  let actual = r.b221 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 1660;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 1660 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a221 = a2211; b221 = b2211 } { a221 = a2212; b221 = b2212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2211 a2212 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b2211 b2212) in
  let next_r = { a221 = 100.; b221 = C19_0((unbox_unit ())) } in
  let r_expected = { a221 = 0.; b221 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a221 *)
  r.a221 <- next_r.a221;
  let r_expected = { r_expected with a221 = next_r.a221 } in
  mark_test_run 1661;
  let test = eq r r_expected in
  if not test then failwithf "test 1661 failed";
  Gc.compact ();
  (* .b221 *)
  r.b221 <- next_r.b221;
  let r_expected = { r_expected with b221 = next_r.b221 } in
  mark_test_run 1662;
  let test = eq r r_expected in
  if not test then failwithf "test 1662 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a221; b221 } = r in
  let expected_a221 = 100. in
  mark_test_run 1663;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a221 a221 in
  if not test then failwithf "test 1663 failed";
  let expected_b221 = C19_0((unbox_unit ())) in
  mark_test_run 1664;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b221 b221 in
  if not test then failwithf "test 1664 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a221; b221 } = r in
  let expected_a221 = 100. in
  mark_test_run 1665;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a221 a221 in
  if not test then failwithf "test 1665 failed";
  let expected_b221 = C19_0((unbox_unit ())) in
  mark_test_run 1666;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b221 b221 in
  if not test then failwithf "test 1666 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************)
  (*   t222 = { float; (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (**************************************************************************)
  let r = { a222 = 0.; b222 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a222 *)
  let actual = r.a222 in
  let expected = 0. in
  mark_test_run 1667;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1667 failed";
  (* Paths of depth 1 *)
  (* .b222 *)
  let actual = r.b222 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1668;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 1668 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a222 = a2221; b222 = b2221 } { a222 = a2222; b222 = b2222 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2221 a2222 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b2221 b2222) in
  let next_r = { a222 = 100.; b222 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a222 = 0.; b222 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a222 *)
  r.a222 <- next_r.a222;
  let r_expected = { r_expected with a222 = next_r.a222 } in
  mark_test_run 1669;
  let test = eq r r_expected in
  if not test then failwithf "test 1669 failed";
  Gc.compact ();
  (* .b222 *)
  r.b222 <- next_r.b222;
  let r_expected = { r_expected with b222 = next_r.b222 } in
  mark_test_run 1670;
  let test = eq r r_expected in
  if not test then failwithf "test 1670 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a222; b222 } = r in
  let expected_a222 = 100. in
  mark_test_run 1671;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a222 a222 in
  if not test then failwithf "test 1671 failed";
  let expected_b222 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 1672;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b222 b222 in
  if not test then failwithf "test 1672 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a222; b222 } = r in
  let expected_a222 = 100. in
  mark_test_run 1673;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a222 a222 in
  if not test then failwithf "test 1673 failed";
  let expected_b222 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 1674;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b222 b222 in
  if not test then failwithf "test 1674 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t223 = { float; #(unit_u, int) }   *)
  (****************************************)
  let r = { a223 = 0.; b223 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a223 *)
  let actual = r.a223 in
  let expected = 0. in
  mark_test_run 1675;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1675 failed";
  (* Paths of depth 1 *)
  (* .b223 *)
  let actual = r.b223 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 1676;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 1676 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a223 = a2231; b223 = b2231 } { a223 = a2232; b223 = b2232 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2231 a2232 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b2231 b2232) in
  let next_r = { a223 = 100.; b223 = #((unbox_unit ()), 101) } in
  let r_expected = { a223 = 0.; b223 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a223 *)
  r.a223 <- next_r.a223;
  let r_expected = { r_expected with a223 = next_r.a223 } in
  mark_test_run 1677;
  let test = eq r r_expected in
  if not test then failwithf "test 1677 failed";
  Gc.compact ();
  (* .b223 *)
  r.b223 <- next_r.b223;
  let r_expected = { r_expected with b223 = next_r.b223 } in
  mark_test_run 1678;
  let test = eq r r_expected in
  if not test then failwithf "test 1678 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a223; b223 } = r in
  let expected_a223 = 100. in
  mark_test_run 1679;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a223 a223 in
  if not test then failwithf "test 1679 failed";
  let expected_b223 = #((unbox_unit ()), 101) in
  mark_test_run 1680;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b223 b223 in
  if not test then failwithf "test 1680 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a223; b223 } = r in
  let expected_a223 = 100. in
  mark_test_run 1681;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a223 a223 in
  if not test then failwithf "test 1681 failed";
  let expected_b223 = #((unbox_unit ()), 101) in
  mark_test_run 1682;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b223 b223 in
  if not test then failwithf "test 1682 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t224 = { float; #(unit_u, int64#) }   *)
  (*******************************************)
  let r = { a224 = 0.; b224 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a224 *)
  let actual = r.a224 in
  let expected = 0. in
  mark_test_run 1683;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1683 failed";
  (* Paths of depth 1 *)
  (* .b224 *)
  let actual = r.b224 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 1684;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 1684 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a224 = a2241; b224 = b2241 } { a224 = a2242; b224 = b2242 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2241 a2242 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b2241 b2242) in
  let next_r = { a224 = 100.; b224 = #((unbox_unit ()), #101L) } in
  let r_expected = { a224 = 0.; b224 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a224 *)
  r.a224 <- next_r.a224;
  let r_expected = { r_expected with a224 = next_r.a224 } in
  mark_test_run 1685;
  let test = eq r r_expected in
  if not test then failwithf "test 1685 failed";
  Gc.compact ();
  (* .b224 *)
  r.b224 <- next_r.b224;
  let r_expected = { r_expected with b224 = next_r.b224 } in
  mark_test_run 1686;
  let test = eq r r_expected in
  if not test then failwithf "test 1686 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a224; b224 } = r in
  let expected_a224 = 100. in
  mark_test_run 1687;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a224 a224 in
  if not test then failwithf "test 1687 failed";
  let expected_b224 = #((unbox_unit ()), #101L) in
  mark_test_run 1688;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b224 b224 in
  if not test then failwithf "test 1688 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a224; b224 } = r in
  let expected_a224 = 100. in
  mark_test_run 1689;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a224 a224 in
  if not test then failwithf "test 1689 failed";
  let expected_b224 = #((unbox_unit ()), #101L) in
  mark_test_run 1690;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b224 b224 in
  if not test then failwithf "test 1690 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t225 = { float; #(unit_u, unit_u) }   *)
  (*******************************************)
  let r = { a225 = 0.; b225 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a225 *)
  let actual = r.a225 in
  let expected = 0. in
  mark_test_run 1691;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1691 failed";
  (* Paths of depth 1 *)
  (* .b225 *)
  let actual = r.b225 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1692;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 1692 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a225 = a2251; b225 = b2251 } { a225 = a2252; b225 = b2252 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2251 a2252 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b2251 b2252) in
  let next_r = { a225 = 100.; b225 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a225 = 0.; b225 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a225 *)
  r.a225 <- next_r.a225;
  let r_expected = { r_expected with a225 = next_r.a225 } in
  mark_test_run 1693;
  let test = eq r r_expected in
  if not test then failwithf "test 1693 failed";
  Gc.compact ();
  (* .b225 *)
  r.b225 <- next_r.b225;
  let r_expected = { r_expected with b225 = next_r.b225 } in
  mark_test_run 1694;
  let test = eq r r_expected in
  if not test then failwithf "test 1694 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a225; b225 } = r in
  let expected_a225 = 100. in
  mark_test_run 1695;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a225 a225 in
  if not test then failwithf "test 1695 failed";
  let expected_b225 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1696;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b225 b225 in
  if not test then failwithf "test 1696 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a225; b225 } = r in
  let expected_a225 = 100. in
  mark_test_run 1697;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a225 a225 in
  if not test then failwithf "test 1697 failed";
  let expected_b225 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 1698;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b225 b225 in
  if not test then failwithf "test 1698 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t226 = { float; #(unit_u, string) }   *)
  (*******************************************)
  let r = { a226 = 0.; b226 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a226 *)
  let actual = r.a226 in
  let expected = 0. in
  mark_test_run 1699;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1699 failed";
  (* Paths of depth 1 *)
  (* .b226 *)
  let actual = r.b226 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 1700;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 1700 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a226 = a2261; b226 = b2261 } { a226 = a2262; b226 = b2262 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2261 a2262 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b2261 b2262) in
  let next_r = { a226 = 100.; b226 = #((unbox_unit ()), "101") } in
  let r_expected = { a226 = 0.; b226 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a226 *)
  r.a226 <- next_r.a226;
  let r_expected = { r_expected with a226 = next_r.a226 } in
  mark_test_run 1701;
  let test = eq r r_expected in
  if not test then failwithf "test 1701 failed";
  Gc.compact ();
  (* .b226 *)
  r.b226 <- next_r.b226;
  let r_expected = { r_expected with b226 = next_r.b226 } in
  mark_test_run 1702;
  let test = eq r r_expected in
  if not test then failwithf "test 1702 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a226; b226 } = r in
  let expected_a226 = 100. in
  mark_test_run 1703;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a226 a226 in
  if not test then failwithf "test 1703 failed";
  let expected_b226 = #((unbox_unit ()), "101") in
  mark_test_run 1704;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b226 b226 in
  if not test then failwithf "test 1704 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a226; b226 } = r in
  let expected_a226 = 100. in
  mark_test_run 1705;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a226 a226 in
  if not test then failwithf "test 1705 failed";
  let expected_b226 = #((unbox_unit ()), "101") in
  mark_test_run 1706;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b226 b226 in
  if not test then failwithf "test 1706 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t227 = { float; #{ int } }   *)
  (**********************************)
  let r = { a227 = 0.; b227 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a227 *)
  let actual = r.a227 in
  let expected = 0. in
  mark_test_run 1707;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1707 failed";
  (* Paths of depth 1 *)
  (* .b227 *)
  let actual = r.b227 in
  let expected = #{ a27 = 1 } in
  mark_test_run 1708;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 1708 failed";
  (* Paths of depth 2 *)
  (* .b227.#a27 *)
  let actual = r.b227.#a27 in
  let expected = 1 in
  mark_test_run 1709;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1709 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a227 = a2271; b227 = b2271 } { a227 = a2272; b227 = b2272 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2271 a2272 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b2271 b2272) in
  let next_r = { a227 = 100.; b227 = #{ a27 = 101 } } in
  let r_expected = { a227 = 0.; b227 = #{ a27 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a227 *)
  r.a227 <- next_r.a227;
  let r_expected = { r_expected with a227 = next_r.a227 } in
  mark_test_run 1710;
  let test = eq r r_expected in
  if not test then failwithf "test 1710 failed";
  Gc.compact ();
  (* .b227 *)
  r.b227 <- next_r.b227;
  let r_expected = { r_expected with b227 = next_r.b227 } in
  mark_test_run 1711;
  let test = eq r r_expected in
  if not test then failwithf "test 1711 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a227; b227 = #{ a27 } } = r in
  let expected_a227 = 100. in
  mark_test_run 1712;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a227 a227 in
  if not test then failwithf "test 1712 failed";
  let expected_a27 = 101 in
  mark_test_run 1713;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1713 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a227; b227 } = r in
  let expected_a227 = 100. in
  mark_test_run 1714;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a227 a227 in
  if not test then failwithf "test 1714 failed";
  let expected_b227 = #{ a27 = 101 } in
  mark_test_run 1715;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_b227 b227 in
  if not test then failwithf "test 1715 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t228 = { float; #{ int; int } }   *)
  (***************************************)
  let r = { a228 = 0.; b228 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a228 *)
  let actual = r.a228 in
  let expected = 0. in
  mark_test_run 1716;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1716 failed";
  (* Paths of depth 1 *)
  (* .b228 *)
  let actual = r.b228 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 1717;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 1717 failed";
  (* Paths of depth 2 *)
  (* .b228.#a29 *)
  let actual = r.b228.#a29 in
  let expected = 1 in
  mark_test_run 1718;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1718 failed";
  (* .b228.#b29 *)
  let actual = r.b228.#b29 in
  let expected = 2 in
  mark_test_run 1719;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1719 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a228 = a2281; b228 = b2281 } { a228 = a2282; b228 = b2282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2281 a2282 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b2281 b2282) in
  let next_r = { a228 = 100.; b228 = #{ a29 = 101; b29 = 102 } } in
  let r_expected = { a228 = 0.; b228 = #{ a29 = 1; b29 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a228 *)
  r.a228 <- next_r.a228;
  let r_expected = { r_expected with a228 = next_r.a228 } in
  mark_test_run 1720;
  let test = eq r r_expected in
  if not test then failwithf "test 1720 failed";
  Gc.compact ();
  (* .b228 *)
  r.b228 <- next_r.b228;
  let r_expected = { r_expected with b228 = next_r.b228 } in
  mark_test_run 1721;
  let test = eq r r_expected in
  if not test then failwithf "test 1721 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a228; b228 = #{ a29; b29 } } = r in
  let expected_a228 = 100. in
  mark_test_run 1722;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a228 a228 in
  if not test then failwithf "test 1722 failed";
  let expected_a29 = 101 in
  mark_test_run 1723;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 1723 failed";
  let expected_b29 = 102 in
  mark_test_run 1724;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 1724 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a228; b228 } = r in
  let expected_a228 = 100. in
  mark_test_run 1725;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a228 a228 in
  if not test then failwithf "test 1725 failed";
  let expected_b228 = #{ a29 = 101; b29 = 102 } in
  mark_test_run 1726;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_b228 b228 in
  if not test then failwithf "test 1726 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t229 = { float; #{ int; float } }   *)
  (*****************************************)
  let r = { a229 = 0.; b229 = #{ a33 = 1; b33 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a229 *)
  let actual = r.a229 in
  let expected = 0. in
  mark_test_run 1727;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1727 failed";
  (* Paths of depth 1 *)
  (* .b229 *)
  let actual = r.b229 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 1728;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 1728 failed";
  (* Paths of depth 2 *)
  (* .b229.#a33 *)
  let actual = r.b229.#a33 in
  let expected = 1 in
  mark_test_run 1729;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1729 failed";
  (* .b229.#b33 *)
  let actual = r.b229.#b33 in
  let expected = 2. in
  mark_test_run 1730;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1730 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a229 = a2291; b229 = b2291 } { a229 = a2292; b229 = b2292 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2291 a2292 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b2291 b2292) in
  let next_r = { a229 = 100.; b229 = #{ a33 = 101; b33 = 102. } } in
  let r_expected = { a229 = 0.; b229 = #{ a33 = 1; b33 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a229 *)
  r.a229 <- next_r.a229;
  let r_expected = { r_expected with a229 = next_r.a229 } in
  mark_test_run 1731;
  let test = eq r r_expected in
  if not test then failwithf "test 1731 failed";
  Gc.compact ();
  (* .b229 *)
  r.b229 <- next_r.b229;
  let r_expected = { r_expected with b229 = next_r.b229 } in
  mark_test_run 1732;
  let test = eq r r_expected in
  if not test then failwithf "test 1732 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a229; b229 = #{ a33; b33 } } = r in
  let expected_a229 = 100. in
  mark_test_run 1733;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a229 a229 in
  if not test then failwithf "test 1733 failed";
  let expected_a33 = 101 in
  mark_test_run 1734;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 1734 failed";
  let expected_b33 = 102. in
  mark_test_run 1735;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 1735 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a229; b229 } = r in
  let expected_a229 = 100. in
  mark_test_run 1736;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a229 a229 in
  if not test then failwithf "test 1736 failed";
  let expected_b229 = #{ a33 = 101; b33 = 102. } in
  mark_test_run 1737;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) expected_b229 b229 in
  if not test then failwithf "test 1737 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t230 = { float; #{ int; #{ int } } }   *)
  (********************************************)
  let r = { a230 = 0.; b230 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a230 *)
  let actual = r.a230 in
  let expected = 0. in
  mark_test_run 1738;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1738 failed";
  (* Paths of depth 1 *)
  (* .b230 *)
  let actual = r.b230 in
  let expected = #{ a37 = 1; b37 = #{ a27 = 2 } } in
  mark_test_run 1739;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) actual expected in
  if not test then failwithf "test 1739 failed";
  (* Paths of depth 2 *)
  (* .b230.#a37 *)
  let actual = r.b230.#a37 in
  let expected = 1 in
  mark_test_run 1740;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1740 failed";
  (* .b230.#b37 *)
  let actual = r.b230.#b37 in
  let expected = #{ a27 = 2 } in
  mark_test_run 1741;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 1741 failed";
  (* Paths of depth 3 *)
  (* .b230.#b37.#a27 *)
  let actual = r.b230.#b37.#a27 in
  let expected = 2 in
  mark_test_run 1742;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1742 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a230 = a2301; b230 = b2301 } { a230 = a2302; b230 = b2302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2301 a2302 && (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) b2301 b2302) in
  let next_r = { a230 = 100.; b230 = #{ a37 = 101; b37 = #{ a27 = 102 } } } in
  let r_expected = { a230 = 0.; b230 = #{ a37 = 1; b37 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a230 *)
  r.a230 <- next_r.a230;
  let r_expected = { r_expected with a230 = next_r.a230 } in
  mark_test_run 1743;
  let test = eq r r_expected in
  if not test then failwithf "test 1743 failed";
  Gc.compact ();
  (* .b230 *)
  r.b230 <- next_r.b230;
  let r_expected = { r_expected with b230 = next_r.b230 } in
  mark_test_run 1744;
  let test = eq r r_expected in
  if not test then failwithf "test 1744 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a230; b230 = #{ a37; b37 = #{ a27 } } } = r in
  let expected_a230 = 100. in
  mark_test_run 1745;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a230 a230 in
  if not test then failwithf "test 1745 failed";
  let expected_a37 = 101 in
  mark_test_run 1746;
  let test = (fun a b -> Int.equal a b) expected_a37 a37 in
  if not test then failwithf "test 1746 failed";
  let expected_a27 = 102 in
  mark_test_run 1747;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1747 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a230; b230 } = r in
  let expected_a230 = 100. in
  mark_test_run 1748;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a230 a230 in
  if not test then failwithf "test 1748 failed";
  let expected_b230 = #{ a37 = 101; b37 = #{ a27 = 102 } } in
  mark_test_run 1749;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) expected_b230 b230 in
  if not test then failwithf "test 1749 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t231 = { float; #{ int; #{ float } } }   *)
  (**********************************************)
  let r = { a231 = 0.; b231 = #{ a43 = 1; b43 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a231 *)
  let actual = r.a231 in
  let expected = 0. in
  mark_test_run 1750;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1750 failed";
  (* Paths of depth 1 *)
  (* .b231 *)
  let actual = r.b231 in
  let expected = #{ a43 = 1; b43 = #{ a42 = 2. } } in
  mark_test_run 1751;
  let test = (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) actual expected in
  if not test then failwithf "test 1751 failed";
  (* Paths of depth 2 *)
  (* .b231.#a43 *)
  let actual = r.b231.#a43 in
  let expected = 1 in
  mark_test_run 1752;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1752 failed";
  (* .b231.#b43 *)
  let actual = r.b231.#b43 in
  let expected = #{ a42 = 2. } in
  mark_test_run 1753;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 1753 failed";
  (* Paths of depth 3 *)
  (* .b231.#b43.#a42 *)
  let actual = r.b231.#b43.#a42 in
  let expected = 2. in
  mark_test_run 1754;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1754 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a231 = a2311; b231 = b2311 } { a231 = a2312; b231 = b2312 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2311 a2312 && (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) b2311 b2312) in
  let next_r = { a231 = 100.; b231 = #{ a43 = 101; b43 = #{ a42 = 102. } } } in
  let r_expected = { a231 = 0.; b231 = #{ a43 = 1; b43 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a231 *)
  r.a231 <- next_r.a231;
  let r_expected = { r_expected with a231 = next_r.a231 } in
  mark_test_run 1755;
  let test = eq r r_expected in
  if not test then failwithf "test 1755 failed";
  Gc.compact ();
  (* .b231 *)
  r.b231 <- next_r.b231;
  let r_expected = { r_expected with b231 = next_r.b231 } in
  mark_test_run 1756;
  let test = eq r r_expected in
  if not test then failwithf "test 1756 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a231; b231 = #{ a43; b43 = #{ a42 } } } = r in
  let expected_a231 = 100. in
  mark_test_run 1757;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a231 a231 in
  if not test then failwithf "test 1757 failed";
  let expected_a43 = 101 in
  mark_test_run 1758;
  let test = (fun a b -> Int.equal a b) expected_a43 a43 in
  if not test then failwithf "test 1758 failed";
  let expected_a42 = 102. in
  mark_test_run 1759;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 1759 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a231; b231 } = r in
  let expected_a231 = 100. in
  mark_test_run 1760;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a231 a231 in
  if not test then failwithf "test 1760 failed";
  let expected_b231 = #{ a43 = 101; b43 = #{ a42 = 102. } } in
  mark_test_run 1761;
  let test = (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b431 b432) expected_b231 b231 in
  if not test then failwithf "test 1761 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t232 = { float; #{ float } }   *)
  (************************************)
  let r = { a232 = 0.; b232 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a232 *)
  let actual = r.a232 in
  let expected = 0. in
  mark_test_run 1762;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1762 failed";
  (* Paths of depth 1 *)
  (* .b232 *)
  let actual = r.b232 in
  let expected = #{ a42 = 1. } in
  mark_test_run 1763;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 1763 failed";
  (* Paths of depth 2 *)
  (* .b232.#a42 *)
  let actual = r.b232.#a42 in
  let expected = 1. in
  mark_test_run 1764;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1764 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a232 = a2321; b232 = b2321 } { a232 = a2322; b232 = b2322 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2321 a2322 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2321 b2322) in
  let next_r = { a232 = 100.; b232 = #{ a42 = 101. } } in
  let r_expected = { a232 = 0.; b232 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a232 *)
  r.a232 <- next_r.a232;
  let r_expected = { r_expected with a232 = next_r.a232 } in
  mark_test_run 1765;
  let test = eq r r_expected in
  if not test then failwithf "test 1765 failed";
  Gc.compact ();
  (* .b232 *)
  r.b232 <- next_r.b232;
  let r_expected = { r_expected with b232 = next_r.b232 } in
  mark_test_run 1766;
  let test = eq r r_expected in
  if not test then failwithf "test 1766 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a232; b232 = #{ a42 } } = r in
  let expected_a232 = 100. in
  mark_test_run 1767;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a232 a232 in
  if not test then failwithf "test 1767 failed";
  let expected_a42 = 101. in
  mark_test_run 1768;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 1768 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a232; b232 } = r in
  let expected_a232 = 100. in
  mark_test_run 1769;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a232 a232 in
  if not test then failwithf "test 1769 failed";
  let expected_b232 = #{ a42 = 101. } in
  mark_test_run 1770;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_b232 b232 in
  if not test then failwithf "test 1770 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t233 = { float; #{ float; int } }   *)
  (*****************************************)
  let r = { a233 = 0.; b233 = #{ a58 = 1.; b58 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a233 *)
  let actual = r.a233 in
  let expected = 0. in
  mark_test_run 1771;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1771 failed";
  (* Paths of depth 1 *)
  (* .b233 *)
  let actual = r.b233 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 1772;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 1772 failed";
  (* Paths of depth 2 *)
  (* .b233.#a58 *)
  let actual = r.b233.#a58 in
  let expected = 1. in
  mark_test_run 1773;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1773 failed";
  (* .b233.#b58 *)
  let actual = r.b233.#b58 in
  let expected = 2 in
  mark_test_run 1774;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1774 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a233 = a2331; b233 = b2331 } { a233 = a2332; b233 = b2332 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2331 a2332 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b2331 b2332) in
  let next_r = { a233 = 100.; b233 = #{ a58 = 101.; b58 = 102 } } in
  let r_expected = { a233 = 0.; b233 = #{ a58 = 1.; b58 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a233 *)
  r.a233 <- next_r.a233;
  let r_expected = { r_expected with a233 = next_r.a233 } in
  mark_test_run 1775;
  let test = eq r r_expected in
  if not test then failwithf "test 1775 failed";
  Gc.compact ();
  (* .b233 *)
  r.b233 <- next_r.b233;
  let r_expected = { r_expected with b233 = next_r.b233 } in
  mark_test_run 1776;
  let test = eq r r_expected in
  if not test then failwithf "test 1776 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a233; b233 = #{ a58; b58 } } = r in
  let expected_a233 = 100. in
  mark_test_run 1777;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a233 a233 in
  if not test then failwithf "test 1777 failed";
  let expected_a58 = 101. in
  mark_test_run 1778;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 1778 failed";
  let expected_b58 = 102 in
  mark_test_run 1779;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 1779 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a233; b233 } = r in
  let expected_a233 = 100. in
  mark_test_run 1780;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a233 a233 in
  if not test then failwithf "test 1780 failed";
  let expected_b233 = #{ a58 = 101.; b58 = 102 } in
  mark_test_run 1781;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) expected_b233 b233 in
  if not test then failwithf "test 1781 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t234 = { float; #{ float; float } }   *)
  (*******************************************)
  let r = { a234 = 0.; b234 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a234 *)
  let actual = r.a234 in
  let expected = 0. in
  mark_test_run 1782;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1782 failed";
  (* Paths of depth 1 *)
  (* .b234 *)
  let actual = r.b234 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 1783;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 1783 failed";
  (* Paths of depth 2 *)
  (* .b234.#a60 *)
  let actual = r.b234.#a60 in
  let expected = 1. in
  mark_test_run 1784;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1784 failed";
  (* .b234.#b60 *)
  let actual = r.b234.#b60 in
  let expected = 2. in
  mark_test_run 1785;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1785 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a234 = a2341; b234 = b2341 } { a234 = a2342; b234 = b2342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2341 a2342 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b2341 b2342) in
  let next_r = { a234 = 100.; b234 = #{ a60 = 101.; b60 = 102. } } in
  let r_expected = { a234 = 0.; b234 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a234 *)
  r.a234 <- next_r.a234;
  let r_expected = { r_expected with a234 = next_r.a234 } in
  mark_test_run 1786;
  let test = eq r r_expected in
  if not test then failwithf "test 1786 failed";
  Gc.compact ();
  (* .b234 *)
  r.b234 <- next_r.b234;
  let r_expected = { r_expected with b234 = next_r.b234 } in
  mark_test_run 1787;
  let test = eq r r_expected in
  if not test then failwithf "test 1787 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a234; b234 = #{ a60; b60 } } = r in
  let expected_a234 = 100. in
  mark_test_run 1788;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a234 a234 in
  if not test then failwithf "test 1788 failed";
  let expected_a60 = 101. in
  mark_test_run 1789;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 1789 failed";
  let expected_b60 = 102. in
  mark_test_run 1790;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 1790 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a234; b234 } = r in
  let expected_a234 = 100. in
  mark_test_run 1791;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a234 a234 in
  if not test then failwithf "test 1791 failed";
  let expected_b234 = #{ a60 = 101.; b60 = 102. } in
  mark_test_run 1792;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_b234 b234 in
  if not test then failwithf "test 1792 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t236 = { float; #{ float; float# } }   *)
  (********************************************)
  let r = { a236 = 0.; b236 = #{ a235 = 1.; b235 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a236 *)
  let actual = r.a236 in
  let expected = 0. in
  mark_test_run 1793;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1793 failed";
  (* Paths of depth 1 *)
  (* .b236 *)
  let actual = r.b236 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 1794;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 1794 failed";
  (* Paths of depth 2 *)
  (* .b236.#a235 *)
  let actual = r.b236.#a235 in
  let expected = 1. in
  mark_test_run 1795;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1795 failed";
  (* .b236.#b235 *)
  let actual = r.b236.#b235 in
  let expected = #2. in
  mark_test_run 1796;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1796 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a236 = a2361; b236 = b2361 } { a236 = a2362; b236 = b2362 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2361 a2362 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b2361 b2362) in
  let next_r = { a236 = 100.; b236 = #{ a235 = 101.; b235 = #102. } } in
  let r_expected = { a236 = 0.; b236 = #{ a235 = 1.; b235 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a236 *)
  r.a236 <- next_r.a236;
  let r_expected = { r_expected with a236 = next_r.a236 } in
  mark_test_run 1797;
  let test = eq r r_expected in
  if not test then failwithf "test 1797 failed";
  Gc.compact ();
  (* .b236 *)
  r.b236 <- next_r.b236;
  let r_expected = { r_expected with b236 = next_r.b236 } in
  mark_test_run 1798;
  let test = eq r r_expected in
  if not test then failwithf "test 1798 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a236; b236 = #{ a235; b235 } } = r in
  let expected_a236 = 100. in
  mark_test_run 1799;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a236 a236 in
  if not test then failwithf "test 1799 failed";
  let expected_a235 = 101. in
  mark_test_run 1800;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 1800 failed";
  let expected_b235 = #102. in
  mark_test_run 1801;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 1801 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a236; b236 } = r in
  let expected_a236 = 100. in
  mark_test_run 1802;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a236 a236 in
  if not test then failwithf "test 1802 failed";
  let expected_b236 = #{ a235 = 101.; b235 = #102. } in
  mark_test_run 1803;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) expected_b236 b236 in
  if not test then failwithf "test 1803 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t237 = { float; #{ float; #{ int } } }   *)
  (**********************************************)
  let r = { a237 = 0.; b237 = #{ a62 = 1.; b62 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a237 *)
  let actual = r.a237 in
  let expected = 0. in
  mark_test_run 1804;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1804 failed";
  (* Paths of depth 1 *)
  (* .b237 *)
  let actual = r.b237 in
  let expected = #{ a62 = 1.; b62 = #{ a27 = 2 } } in
  mark_test_run 1805;
  let test = (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) actual expected in
  if not test then failwithf "test 1805 failed";
  (* Paths of depth 2 *)
  (* .b237.#a62 *)
  let actual = r.b237.#a62 in
  let expected = 1. in
  mark_test_run 1806;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1806 failed";
  (* .b237.#b62 *)
  let actual = r.b237.#b62 in
  let expected = #{ a27 = 2 } in
  mark_test_run 1807;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 1807 failed";
  (* Paths of depth 3 *)
  (* .b237.#b62.#a27 *)
  let actual = r.b237.#b62.#a27 in
  let expected = 2 in
  mark_test_run 1808;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1808 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a237 = a2371; b237 = b2371 } { a237 = a2372; b237 = b2372 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2371 a2372 && (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) b2371 b2372) in
  let next_r = { a237 = 100.; b237 = #{ a62 = 101.; b62 = #{ a27 = 102 } } } in
  let r_expected = { a237 = 0.; b237 = #{ a62 = 1.; b62 = #{ a27 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a237 *)
  r.a237 <- next_r.a237;
  let r_expected = { r_expected with a237 = next_r.a237 } in
  mark_test_run 1809;
  let test = eq r r_expected in
  if not test then failwithf "test 1809 failed";
  Gc.compact ();
  (* .b237 *)
  r.b237 <- next_r.b237;
  let r_expected = { r_expected with b237 = next_r.b237 } in
  mark_test_run 1810;
  let test = eq r r_expected in
  if not test then failwithf "test 1810 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a237; b237 = #{ a62; b62 = #{ a27 } } } = r in
  let expected_a237 = 100. in
  mark_test_run 1811;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a237 a237 in
  if not test then failwithf "test 1811 failed";
  let expected_a62 = 101. in
  mark_test_run 1812;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a62 a62 in
  if not test then failwithf "test 1812 failed";
  let expected_a27 = 102 in
  mark_test_run 1813;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 1813 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a237; b237 } = r in
  let expected_a237 = 100. in
  mark_test_run 1814;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a237 a237 in
  if not test then failwithf "test 1814 failed";
  let expected_b237 = #{ a62 = 101.; b62 = #{ a27 = 102 } } in
  mark_test_run 1815;
  let test = (fun #{ a62 = a621; b62 = b621 } #{ a62 = a622; b62 = b622 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a621 a622 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b621 b622) expected_b237 b237 in
  if not test then failwithf "test 1815 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t238 = { float; #{ float; #{ float } } }   *)
  (************************************************)
  let r = { a238 = 0.; b238 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a238 *)
  let actual = r.a238 in
  let expected = 0. in
  mark_test_run 1816;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1816 failed";
  (* Paths of depth 1 *)
  (* .b238 *)
  let actual = r.b238 in
  let expected = #{ a64 = 1.; b64 = #{ a42 = 2. } } in
  mark_test_run 1817;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) actual expected in
  if not test then failwithf "test 1817 failed";
  (* Paths of depth 2 *)
  (* .b238.#a64 *)
  let actual = r.b238.#a64 in
  let expected = 1. in
  mark_test_run 1818;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1818 failed";
  (* .b238.#b64 *)
  let actual = r.b238.#b64 in
  let expected = #{ a42 = 2. } in
  mark_test_run 1819;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 1819 failed";
  (* Paths of depth 3 *)
  (* .b238.#b64.#a42 *)
  let actual = r.b238.#b64.#a42 in
  let expected = 2. in
  mark_test_run 1820;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1820 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a238 = a2381; b238 = b2381 } { a238 = a2382; b238 = b2382 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2381 a2382 && (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) b2381 b2382) in
  let next_r = { a238 = 100.; b238 = #{ a64 = 101.; b64 = #{ a42 = 102. } } } in
  let r_expected = { a238 = 0.; b238 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a238 *)
  r.a238 <- next_r.a238;
  let r_expected = { r_expected with a238 = next_r.a238 } in
  mark_test_run 1821;
  let test = eq r r_expected in
  if not test then failwithf "test 1821 failed";
  Gc.compact ();
  (* .b238 *)
  r.b238 <- next_r.b238;
  let r_expected = { r_expected with b238 = next_r.b238 } in
  mark_test_run 1822;
  let test = eq r r_expected in
  if not test then failwithf "test 1822 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a238; b238 = #{ a64; b64 = #{ a42 } } } = r in
  let expected_a238 = 100. in
  mark_test_run 1823;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a238 a238 in
  if not test then failwithf "test 1823 failed";
  let expected_a64 = 101. in
  mark_test_run 1824;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a64 a64 in
  if not test then failwithf "test 1824 failed";
  let expected_a42 = 102. in
  mark_test_run 1825;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 1825 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a238; b238 } = r in
  let expected_a238 = 100. in
  mark_test_run 1826;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a238 a238 in
  if not test then failwithf "test 1826 failed";
  let expected_b238 = #{ a64 = 101.; b64 = #{ a42 = 102. } } in
  mark_test_run 1827;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) expected_b238 b238 in
  if not test then failwithf "test 1827 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t241 = { float; #{ float; #{ float# } } }   *)
  (*************************************************)
  let r = { a241 = 0.; b241 = #{ a240 = 1.; b240 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a241 *)
  let actual = r.a241 in
  let expected = 0. in
  mark_test_run 1828;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1828 failed";
  (* Paths of depth 1 *)
  (* .b241 *)
  let actual = r.b241 in
  let expected = #{ a240 = 1.; b240 = #{ a239 = #2. } } in
  mark_test_run 1829;
  let test = (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) actual expected in
  if not test then failwithf "test 1829 failed";
  (* Paths of depth 2 *)
  (* .b241.#a240 *)
  let actual = r.b241.#a240 in
  let expected = 1. in
  mark_test_run 1830;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1830 failed";
  (* .b241.#b240 *)
  let actual = r.b241.#b240 in
  let expected = #{ a239 = #2. } in
  mark_test_run 1831;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 1831 failed";
  (* Paths of depth 3 *)
  (* .b241.#b240.#a239 *)
  let actual = r.b241.#b240.#a239 in
  let expected = #2. in
  mark_test_run 1832;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1832 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a241 = a2411; b241 = b2411 } { a241 = a2412; b241 = b2412 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2411 a2412 && (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) b2411 b2412) in
  let next_r = { a241 = 100.; b241 = #{ a240 = 101.; b240 = #{ a239 = #102. } } } in
  let r_expected = { a241 = 0.; b241 = #{ a240 = 1.; b240 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a241 *)
  r.a241 <- next_r.a241;
  let r_expected = { r_expected with a241 = next_r.a241 } in
  mark_test_run 1833;
  let test = eq r r_expected in
  if not test then failwithf "test 1833 failed";
  Gc.compact ();
  (* .b241 *)
  r.b241 <- next_r.b241;
  let r_expected = { r_expected with b241 = next_r.b241 } in
  mark_test_run 1834;
  let test = eq r r_expected in
  if not test then failwithf "test 1834 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a241; b241 = #{ a240; b240 = #{ a239 } } } = r in
  let expected_a241 = 100. in
  mark_test_run 1835;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a241 a241 in
  if not test then failwithf "test 1835 failed";
  let expected_a240 = 101. in
  mark_test_run 1836;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a240 a240 in
  if not test then failwithf "test 1836 failed";
  let expected_a239 = #102. in
  mark_test_run 1837;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 1837 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a241; b241 } = r in
  let expected_a241 = 100. in
  mark_test_run 1838;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a241 a241 in
  if not test then failwithf "test 1838 failed";
  let expected_b241 = #{ a240 = 101.; b240 = #{ a239 = #102. } } in
  mark_test_run 1839;
  let test = (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) expected_b241 b241 in
  if not test then failwithf "test 1839 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t242 = { float; #{ float# } }   *)
  (*************************************)
  let r = { a242 = 0.; b242 = #{ a239 = #1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a242 *)
  let actual = r.a242 in
  let expected = 0. in
  mark_test_run 1840;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1840 failed";
  (* Paths of depth 1 *)
  (* .b242 *)
  let actual = r.b242 in
  let expected = #{ a239 = #1. } in
  mark_test_run 1841;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 1841 failed";
  (* Paths of depth 2 *)
  (* .b242.#a239 *)
  let actual = r.b242.#a239 in
  let expected = #1. in
  mark_test_run 1842;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1842 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a242 = a2421; b242 = b2421 } { a242 = a2422; b242 = b2422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2421 a2422 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2421 b2422) in
  let next_r = { a242 = 100.; b242 = #{ a239 = #101. } } in
  let r_expected = { a242 = 0.; b242 = #{ a239 = #1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a242 *)
  r.a242 <- next_r.a242;
  let r_expected = { r_expected with a242 = next_r.a242 } in
  mark_test_run 1843;
  let test = eq r r_expected in
  if not test then failwithf "test 1843 failed";
  Gc.compact ();
  (* .b242 *)
  r.b242 <- next_r.b242;
  let r_expected = { r_expected with b242 = next_r.b242 } in
  mark_test_run 1844;
  let test = eq r r_expected in
  if not test then failwithf "test 1844 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a242; b242 = #{ a239 } } = r in
  let expected_a242 = 100. in
  mark_test_run 1845;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a242 a242 in
  if not test then failwithf "test 1845 failed";
  let expected_a239 = #101. in
  mark_test_run 1846;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 1846 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a242; b242 } = r in
  let expected_a242 = 100. in
  mark_test_run 1847;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a242 a242 in
  if not test then failwithf "test 1847 failed";
  let expected_b242 = #{ a239 = #101. } in
  mark_test_run 1848;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) expected_b242 b242 in
  if not test then failwithf "test 1848 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t244 = { float; #{ float#; float } }   *)
  (********************************************)
  let r = { a244 = 0.; b244 = #{ a243 = #1.; b243 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a244 *)
  let actual = r.a244 in
  let expected = 0. in
  mark_test_run 1849;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1849 failed";
  (* Paths of depth 1 *)
  (* .b244 *)
  let actual = r.b244 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 1850;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 1850 failed";
  (* Paths of depth 2 *)
  (* .b244.#a243 *)
  let actual = r.b244.#a243 in
  let expected = #1. in
  mark_test_run 1851;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1851 failed";
  (* .b244.#b243 *)
  let actual = r.b244.#b243 in
  let expected = 2. in
  mark_test_run 1852;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1852 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a244 = a2441; b244 = b2441 } { a244 = a2442; b244 = b2442 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2441 a2442 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b2441 b2442) in
  let next_r = { a244 = 100.; b244 = #{ a243 = #101.; b243 = 102. } } in
  let r_expected = { a244 = 0.; b244 = #{ a243 = #1.; b243 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a244 *)
  r.a244 <- next_r.a244;
  let r_expected = { r_expected with a244 = next_r.a244 } in
  mark_test_run 1853;
  let test = eq r r_expected in
  if not test then failwithf "test 1853 failed";
  Gc.compact ();
  (* .b244 *)
  r.b244 <- next_r.b244;
  let r_expected = { r_expected with b244 = next_r.b244 } in
  mark_test_run 1854;
  let test = eq r r_expected in
  if not test then failwithf "test 1854 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a244; b244 = #{ a243; b243 } } = r in
  let expected_a244 = 100. in
  mark_test_run 1855;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a244 a244 in
  if not test then failwithf "test 1855 failed";
  let expected_a243 = #101. in
  mark_test_run 1856;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 1856 failed";
  let expected_b243 = 102. in
  mark_test_run 1857;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 1857 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a244; b244 } = r in
  let expected_a244 = 100. in
  mark_test_run 1858;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a244 a244 in
  if not test then failwithf "test 1858 failed";
  let expected_b244 = #{ a243 = #101.; b243 = 102. } in
  mark_test_run 1859;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) expected_b244 b244 in
  if not test then failwithf "test 1859 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t246 = { float; #{ float#; float# } }   *)
  (*********************************************)
  let r = { a246 = 0.; b246 = #{ a245 = #1.; b245 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a246 *)
  let actual = r.a246 in
  let expected = 0. in
  mark_test_run 1860;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1860 failed";
  (* Paths of depth 1 *)
  (* .b246 *)
  let actual = r.b246 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 1861;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 1861 failed";
  (* Paths of depth 2 *)
  (* .b246.#a245 *)
  let actual = r.b246.#a245 in
  let expected = #1. in
  mark_test_run 1862;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1862 failed";
  (* .b246.#b245 *)
  let actual = r.b246.#b245 in
  let expected = #2. in
  mark_test_run 1863;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1863 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a246 = a2461; b246 = b2461 } { a246 = a2462; b246 = b2462 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2461 a2462 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b2461 b2462) in
  let next_r = { a246 = 100.; b246 = #{ a245 = #101.; b245 = #102. } } in
  let r_expected = { a246 = 0.; b246 = #{ a245 = #1.; b245 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a246 *)
  r.a246 <- next_r.a246;
  let r_expected = { r_expected with a246 = next_r.a246 } in
  mark_test_run 1864;
  let test = eq r r_expected in
  if not test then failwithf "test 1864 failed";
  Gc.compact ();
  (* .b246 *)
  r.b246 <- next_r.b246;
  let r_expected = { r_expected with b246 = next_r.b246 } in
  mark_test_run 1865;
  let test = eq r r_expected in
  if not test then failwithf "test 1865 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a246; b246 = #{ a245; b245 } } = r in
  let expected_a246 = 100. in
  mark_test_run 1866;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a246 a246 in
  if not test then failwithf "test 1866 failed";
  let expected_a245 = #101. in
  mark_test_run 1867;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 1867 failed";
  let expected_b245 = #102. in
  mark_test_run 1868;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 1868 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a246; b246 } = r in
  let expected_a246 = 100. in
  mark_test_run 1869;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a246 a246 in
  if not test then failwithf "test 1869 failed";
  let expected_b246 = #{ a245 = #101.; b245 = #102. } in
  mark_test_run 1870;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) expected_b246 b246 in
  if not test then failwithf "test 1870 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t248 = { float; #{ float#; #{ float } } }   *)
  (*************************************************)
  let r = { a248 = 0.; b248 = #{ a247 = #1.; b247 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a248 *)
  let actual = r.a248 in
  let expected = 0. in
  mark_test_run 1871;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1871 failed";
  (* Paths of depth 1 *)
  (* .b248 *)
  let actual = r.b248 in
  let expected = #{ a247 = #1.; b247 = #{ a42 = 2. } } in
  mark_test_run 1872;
  let test = (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) actual expected in
  if not test then failwithf "test 1872 failed";
  (* Paths of depth 2 *)
  (* .b248.#a247 *)
  let actual = r.b248.#a247 in
  let expected = #1. in
  mark_test_run 1873;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1873 failed";
  (* .b248.#b247 *)
  let actual = r.b248.#b247 in
  let expected = #{ a42 = 2. } in
  mark_test_run 1874;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 1874 failed";
  (* Paths of depth 3 *)
  (* .b248.#b247.#a42 *)
  let actual = r.b248.#b247.#a42 in
  let expected = 2. in
  mark_test_run 1875;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1875 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a248 = a2481; b248 = b2481 } { a248 = a2482; b248 = b2482 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2481 a2482 && (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) b2481 b2482) in
  let next_r = { a248 = 100.; b248 = #{ a247 = #101.; b247 = #{ a42 = 102. } } } in
  let r_expected = { a248 = 0.; b248 = #{ a247 = #1.; b247 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a248 *)
  r.a248 <- next_r.a248;
  let r_expected = { r_expected with a248 = next_r.a248 } in
  mark_test_run 1876;
  let test = eq r r_expected in
  if not test then failwithf "test 1876 failed";
  Gc.compact ();
  (* .b248 *)
  r.b248 <- next_r.b248;
  let r_expected = { r_expected with b248 = next_r.b248 } in
  mark_test_run 1877;
  let test = eq r r_expected in
  if not test then failwithf "test 1877 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a248; b248 = #{ a247; b247 = #{ a42 } } } = r in
  let expected_a248 = 100. in
  mark_test_run 1878;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a248 a248 in
  if not test then failwithf "test 1878 failed";
  let expected_a247 = #101. in
  mark_test_run 1879;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a247 a247 in
  if not test then failwithf "test 1879 failed";
  let expected_a42 = 102. in
  mark_test_run 1880;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 1880 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a248; b248 } = r in
  let expected_a248 = 100. in
  mark_test_run 1881;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a248 a248 in
  if not test then failwithf "test 1881 failed";
  let expected_b248 = #{ a247 = #101.; b247 = #{ a42 = 102. } } in
  mark_test_run 1882;
  let test = (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) expected_b248 b248 in
  if not test then failwithf "test 1882 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t250 = { float; #{ float#; #{ float# } } }   *)
  (**************************************************)
  let r = { a250 = 0.; b250 = #{ a249 = #1.; b249 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a250 *)
  let actual = r.a250 in
  let expected = 0. in
  mark_test_run 1883;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1883 failed";
  (* Paths of depth 1 *)
  (* .b250 *)
  let actual = r.b250 in
  let expected = #{ a249 = #1.; b249 = #{ a239 = #2. } } in
  mark_test_run 1884;
  let test = (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) actual expected in
  if not test then failwithf "test 1884 failed";
  (* Paths of depth 2 *)
  (* .b250.#a249 *)
  let actual = r.b250.#a249 in
  let expected = #1. in
  mark_test_run 1885;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1885 failed";
  (* .b250.#b249 *)
  let actual = r.b250.#b249 in
  let expected = #{ a239 = #2. } in
  mark_test_run 1886;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 1886 failed";
  (* Paths of depth 3 *)
  (* .b250.#b249.#a239 *)
  let actual = r.b250.#b249.#a239 in
  let expected = #2. in
  mark_test_run 1887;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1887 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a250 = a2501; b250 = b2501 } { a250 = a2502; b250 = b2502 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2501 a2502 && (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) b2501 b2502) in
  let next_r = { a250 = 100.; b250 = #{ a249 = #101.; b249 = #{ a239 = #102. } } } in
  let r_expected = { a250 = 0.; b250 = #{ a249 = #1.; b249 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a250 *)
  r.a250 <- next_r.a250;
  let r_expected = { r_expected with a250 = next_r.a250 } in
  mark_test_run 1888;
  let test = eq r r_expected in
  if not test then failwithf "test 1888 failed";
  Gc.compact ();
  (* .b250 *)
  r.b250 <- next_r.b250;
  let r_expected = { r_expected with b250 = next_r.b250 } in
  mark_test_run 1889;
  let test = eq r r_expected in
  if not test then failwithf "test 1889 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a250; b250 = #{ a249; b249 = #{ a239 } } } = r in
  let expected_a250 = 100. in
  mark_test_run 1890;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a250 a250 in
  if not test then failwithf "test 1890 failed";
  let expected_a249 = #101. in
  mark_test_run 1891;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a249 a249 in
  if not test then failwithf "test 1891 failed";
  let expected_a239 = #102. in
  mark_test_run 1892;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 1892 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a250; b250 } = r in
  let expected_a250 = 100. in
  mark_test_run 1893;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a250 a250 in
  if not test then failwithf "test 1893 failed";
  let expected_b250 = #{ a249 = #101.; b249 = #{ a239 = #102. } } in
  mark_test_run 1894;
  let test = (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) expected_b250 b250 in
  if not test then failwithf "test 1894 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t251 = { float; #{ #{ int; int } } }   *)
  (********************************************)
  let r = { a251 = 0.; b251 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a251 *)
  let actual = r.a251 in
  let expected = 0. in
  mark_test_run 1895;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1895 failed";
  (* Paths of depth 1 *)
  (* .b251 *)
  let actual = r.b251 in
  let expected = #{ a75 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 1896;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) actual expected in
  if not test then failwithf "test 1896 failed";
  (* Paths of depth 2 *)
  (* .b251.#a75 *)
  let actual = r.b251.#a75 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 1897;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 1897 failed";
  (* Paths of depth 3 *)
  (* .b251.#a75.#a29 *)
  let actual = r.b251.#a75.#a29 in
  let expected = 1 in
  mark_test_run 1898;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1898 failed";
  (* .b251.#a75.#b29 *)
  let actual = r.b251.#a75.#b29 in
  let expected = 2 in
  mark_test_run 1899;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1899 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a251 = a2511; b251 = b2511 } { a251 = a2512; b251 = b2512 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2511 a2512 && (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) b2511 b2512) in
  let next_r = { a251 = 100.; b251 = #{ a75 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a251 = 0.; b251 = #{ a75 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a251 *)
  r.a251 <- next_r.a251;
  let r_expected = { r_expected with a251 = next_r.a251 } in
  mark_test_run 1900;
  let test = eq r r_expected in
  if not test then failwithf "test 1900 failed";
  Gc.compact ();
  (* .b251 *)
  r.b251 <- next_r.b251;
  let r_expected = { r_expected with b251 = next_r.b251 } in
  mark_test_run 1901;
  let test = eq r r_expected in
  if not test then failwithf "test 1901 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a251; b251 = #{ a75 = #{ a29; b29 } } } = r in
  let expected_a251 = 100. in
  mark_test_run 1902;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a251 a251 in
  if not test then failwithf "test 1902 failed";
  let expected_a29 = 101 in
  mark_test_run 1903;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 1903 failed";
  let expected_b29 = 102 in
  mark_test_run 1904;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 1904 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a251; b251 } = r in
  let expected_a251 = 100. in
  mark_test_run 1905;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a251 a251 in
  if not test then failwithf "test 1905 failed";
  let expected_b251 = #{ a75 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 1906;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) expected_b251 b251 in
  if not test then failwithf "test 1906 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t252 = { float; #{ #{ int; float } } }   *)
  (**********************************************)
  let r = { a252 = 0.; b252 = #{ a79 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a252 *)
  let actual = r.a252 in
  let expected = 0. in
  mark_test_run 1907;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1907 failed";
  (* Paths of depth 1 *)
  (* .b252 *)
  let actual = r.b252 in
  let expected = #{ a79 = #{ a33 = 1; b33 = 2. } } in
  mark_test_run 1908;
  let test = (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) actual expected in
  if not test then failwithf "test 1908 failed";
  (* Paths of depth 2 *)
  (* .b252.#a79 *)
  let actual = r.b252.#a79 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 1909;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 1909 failed";
  (* Paths of depth 3 *)
  (* .b252.#a79.#a33 *)
  let actual = r.b252.#a79.#a33 in
  let expected = 1 in
  mark_test_run 1910;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1910 failed";
  (* .b252.#a79.#b33 *)
  let actual = r.b252.#a79.#b33 in
  let expected = 2. in
  mark_test_run 1911;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1911 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a252 = a2521; b252 = b2521 } { a252 = a2522; b252 = b2522 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2521 a2522 && (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) b2521 b2522) in
  let next_r = { a252 = 100.; b252 = #{ a79 = #{ a33 = 101; b33 = 102. } } } in
  let r_expected = { a252 = 0.; b252 = #{ a79 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a252 *)
  r.a252 <- next_r.a252;
  let r_expected = { r_expected with a252 = next_r.a252 } in
  mark_test_run 1912;
  let test = eq r r_expected in
  if not test then failwithf "test 1912 failed";
  Gc.compact ();
  (* .b252 *)
  r.b252 <- next_r.b252;
  let r_expected = { r_expected with b252 = next_r.b252 } in
  mark_test_run 1913;
  let test = eq r r_expected in
  if not test then failwithf "test 1913 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a252; b252 = #{ a79 = #{ a33; b33 } } } = r in
  let expected_a252 = 100. in
  mark_test_run 1914;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a252 a252 in
  if not test then failwithf "test 1914 failed";
  let expected_a33 = 101 in
  mark_test_run 1915;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 1915 failed";
  let expected_b33 = 102. in
  mark_test_run 1916;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 1916 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a252; b252 } = r in
  let expected_a252 = 100. in
  mark_test_run 1917;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a252 a252 in
  if not test then failwithf "test 1917 failed";
  let expected_b252 = #{ a79 = #{ a33 = 101; b33 = 102. } } in
  mark_test_run 1918;
  let test = (fun #{ a79 = a791 } #{ a79 = a792 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a791 a792) expected_b252 b252 in
  if not test then failwithf "test 1918 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t253 = { float; #{ #{ float; int } } }   *)
  (**********************************************)
  let r = { a253 = 0.; b253 = #{ a87 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a253 *)
  let actual = r.a253 in
  let expected = 0. in
  mark_test_run 1919;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1919 failed";
  (* Paths of depth 1 *)
  (* .b253 *)
  let actual = r.b253 in
  let expected = #{ a87 = #{ a58 = 1.; b58 = 2 } } in
  mark_test_run 1920;
  let test = (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) actual expected in
  if not test then failwithf "test 1920 failed";
  (* Paths of depth 2 *)
  (* .b253.#a87 *)
  let actual = r.b253.#a87 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 1921;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 1921 failed";
  (* Paths of depth 3 *)
  (* .b253.#a87.#a58 *)
  let actual = r.b253.#a87.#a58 in
  let expected = 1. in
  mark_test_run 1922;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1922 failed";
  (* .b253.#a87.#b58 *)
  let actual = r.b253.#a87.#b58 in
  let expected = 2 in
  mark_test_run 1923;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1923 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a253 = a2531; b253 = b2531 } { a253 = a2532; b253 = b2532 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2531 a2532 && (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) b2531 b2532) in
  let next_r = { a253 = 100.; b253 = #{ a87 = #{ a58 = 101.; b58 = 102 } } } in
  let r_expected = { a253 = 0.; b253 = #{ a87 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a253 *)
  r.a253 <- next_r.a253;
  let r_expected = { r_expected with a253 = next_r.a253 } in
  mark_test_run 1924;
  let test = eq r r_expected in
  if not test then failwithf "test 1924 failed";
  Gc.compact ();
  (* .b253 *)
  r.b253 <- next_r.b253;
  let r_expected = { r_expected with b253 = next_r.b253 } in
  mark_test_run 1925;
  let test = eq r r_expected in
  if not test then failwithf "test 1925 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a253; b253 = #{ a87 = #{ a58; b58 } } } = r in
  let expected_a253 = 100. in
  mark_test_run 1926;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a253 a253 in
  if not test then failwithf "test 1926 failed";
  let expected_a58 = 101. in
  mark_test_run 1927;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 1927 failed";
  let expected_b58 = 102 in
  mark_test_run 1928;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 1928 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a253; b253 } = r in
  let expected_a253 = 100. in
  mark_test_run 1929;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a253 a253 in
  if not test then failwithf "test 1929 failed";
  let expected_b253 = #{ a87 = #{ a58 = 101.; b58 = 102 } } in
  mark_test_run 1930;
  let test = (fun #{ a87 = a871 } #{ a87 = a872 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a871 a872) expected_b253 b253 in
  if not test then failwithf "test 1930 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t254 = { float; #{ #{ float; float } } }   *)
  (************************************************)
  let r = { a254 = 0.; b254 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a254 *)
  let actual = r.a254 in
  let expected = 0. in
  mark_test_run 1931;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1931 failed";
  (* Paths of depth 1 *)
  (* .b254 *)
  let actual = r.b254 in
  let expected = #{ a89 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 1932;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) actual expected in
  if not test then failwithf "test 1932 failed";
  (* Paths of depth 2 *)
  (* .b254.#a89 *)
  let actual = r.b254.#a89 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 1933;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 1933 failed";
  (* Paths of depth 3 *)
  (* .b254.#a89.#a60 *)
  let actual = r.b254.#a89.#a60 in
  let expected = 1. in
  mark_test_run 1934;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1934 failed";
  (* .b254.#a89.#b60 *)
  let actual = r.b254.#a89.#b60 in
  let expected = 2. in
  mark_test_run 1935;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1935 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a254 = a2541; b254 = b2541 } { a254 = a2542; b254 = b2542 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2541 a2542 && (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) b2541 b2542) in
  let next_r = { a254 = 100.; b254 = #{ a89 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a254 = 0.; b254 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a254 *)
  r.a254 <- next_r.a254;
  let r_expected = { r_expected with a254 = next_r.a254 } in
  mark_test_run 1936;
  let test = eq r r_expected in
  if not test then failwithf "test 1936 failed";
  Gc.compact ();
  (* .b254 *)
  r.b254 <- next_r.b254;
  let r_expected = { r_expected with b254 = next_r.b254 } in
  mark_test_run 1937;
  let test = eq r r_expected in
  if not test then failwithf "test 1937 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a254; b254 = #{ a89 = #{ a60; b60 } } } = r in
  let expected_a254 = 100. in
  mark_test_run 1938;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a254 a254 in
  if not test then failwithf "test 1938 failed";
  let expected_a60 = 101. in
  mark_test_run 1939;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 1939 failed";
  let expected_b60 = 102. in
  mark_test_run 1940;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 1940 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a254; b254 } = r in
  let expected_a254 = 100. in
  mark_test_run 1941;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a254 a254 in
  if not test then failwithf "test 1941 failed";
  let expected_b254 = #{ a89 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 1942;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) expected_b254 b254 in
  if not test then failwithf "test 1942 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t256 = { float; #{ #{ float; float# } } }   *)
  (*************************************************)
  let r = { a256 = 0.; b256 = #{ a255 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a256 *)
  let actual = r.a256 in
  let expected = 0. in
  mark_test_run 1943;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1943 failed";
  (* Paths of depth 1 *)
  (* .b256 *)
  let actual = r.b256 in
  let expected = #{ a255 = #{ a235 = 1.; b235 = #2. } } in
  mark_test_run 1944;
  let test = (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) actual expected in
  if not test then failwithf "test 1944 failed";
  (* Paths of depth 2 *)
  (* .b256.#a255 *)
  let actual = r.b256.#a255 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 1945;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 1945 failed";
  (* Paths of depth 3 *)
  (* .b256.#a255.#a235 *)
  let actual = r.b256.#a255.#a235 in
  let expected = 1. in
  mark_test_run 1946;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1946 failed";
  (* .b256.#a255.#b235 *)
  let actual = r.b256.#a255.#b235 in
  let expected = #2. in
  mark_test_run 1947;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1947 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a256 = a2561; b256 = b2561 } { a256 = a2562; b256 = b2562 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2561 a2562 && (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) b2561 b2562) in
  let next_r = { a256 = 100.; b256 = #{ a255 = #{ a235 = 101.; b235 = #102. } } } in
  let r_expected = { a256 = 0.; b256 = #{ a255 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a256 *)
  r.a256 <- next_r.a256;
  let r_expected = { r_expected with a256 = next_r.a256 } in
  mark_test_run 1948;
  let test = eq r r_expected in
  if not test then failwithf "test 1948 failed";
  Gc.compact ();
  (* .b256 *)
  r.b256 <- next_r.b256;
  let r_expected = { r_expected with b256 = next_r.b256 } in
  mark_test_run 1949;
  let test = eq r r_expected in
  if not test then failwithf "test 1949 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a256; b256 = #{ a255 = #{ a235; b235 } } } = r in
  let expected_a256 = 100. in
  mark_test_run 1950;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a256 a256 in
  if not test then failwithf "test 1950 failed";
  let expected_a235 = 101. in
  mark_test_run 1951;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 1951 failed";
  let expected_b235 = #102. in
  mark_test_run 1952;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 1952 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a256; b256 } = r in
  let expected_a256 = 100. in
  mark_test_run 1953;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a256 a256 in
  if not test then failwithf "test 1953 failed";
  let expected_b256 = #{ a255 = #{ a235 = 101.; b235 = #102. } } in
  mark_test_run 1954;
  let test = (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) expected_b256 b256 in
  if not test then failwithf "test 1954 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t258 = { float; #{ #{ float#; float } } }   *)
  (*************************************************)
  let r = { a258 = 0.; b258 = #{ a257 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a258 *)
  let actual = r.a258 in
  let expected = 0. in
  mark_test_run 1955;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1955 failed";
  (* Paths of depth 1 *)
  (* .b258 *)
  let actual = r.b258 in
  let expected = #{ a257 = #{ a243 = #1.; b243 = 2. } } in
  mark_test_run 1956;
  let test = (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) actual expected in
  if not test then failwithf "test 1956 failed";
  (* Paths of depth 2 *)
  (* .b258.#a257 *)
  let actual = r.b258.#a257 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 1957;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 1957 failed";
  (* Paths of depth 3 *)
  (* .b258.#a257.#a243 *)
  let actual = r.b258.#a257.#a243 in
  let expected = #1. in
  mark_test_run 1958;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1958 failed";
  (* .b258.#a257.#b243 *)
  let actual = r.b258.#a257.#b243 in
  let expected = 2. in
  mark_test_run 1959;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1959 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a258 = a2581; b258 = b2581 } { a258 = a2582; b258 = b2582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2581 a2582 && (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) b2581 b2582) in
  let next_r = { a258 = 100.; b258 = #{ a257 = #{ a243 = #101.; b243 = 102. } } } in
  let r_expected = { a258 = 0.; b258 = #{ a257 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a258 *)
  r.a258 <- next_r.a258;
  let r_expected = { r_expected with a258 = next_r.a258 } in
  mark_test_run 1960;
  let test = eq r r_expected in
  if not test then failwithf "test 1960 failed";
  Gc.compact ();
  (* .b258 *)
  r.b258 <- next_r.b258;
  let r_expected = { r_expected with b258 = next_r.b258 } in
  mark_test_run 1961;
  let test = eq r r_expected in
  if not test then failwithf "test 1961 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a258; b258 = #{ a257 = #{ a243; b243 } } } = r in
  let expected_a258 = 100. in
  mark_test_run 1962;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a258 a258 in
  if not test then failwithf "test 1962 failed";
  let expected_a243 = #101. in
  mark_test_run 1963;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 1963 failed";
  let expected_b243 = 102. in
  mark_test_run 1964;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 1964 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a258; b258 } = r in
  let expected_a258 = 100. in
  mark_test_run 1965;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a258 a258 in
  if not test then failwithf "test 1965 failed";
  let expected_b258 = #{ a257 = #{ a243 = #101.; b243 = 102. } } in
  mark_test_run 1966;
  let test = (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) expected_b258 b258 in
  if not test then failwithf "test 1966 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t260 = { float; #{ #{ float#; float# } } }   *)
  (**************************************************)
  let r = { a260 = 0.; b260 = #{ a259 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a260 *)
  let actual = r.a260 in
  let expected = 0. in
  mark_test_run 1967;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1967 failed";
  (* Paths of depth 1 *)
  (* .b260 *)
  let actual = r.b260 in
  let expected = #{ a259 = #{ a245 = #1.; b245 = #2. } } in
  mark_test_run 1968;
  let test = (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) actual expected in
  if not test then failwithf "test 1968 failed";
  (* Paths of depth 2 *)
  (* .b260.#a259 *)
  let actual = r.b260.#a259 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 1969;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 1969 failed";
  (* Paths of depth 3 *)
  (* .b260.#a259.#a245 *)
  let actual = r.b260.#a259.#a245 in
  let expected = #1. in
  mark_test_run 1970;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1970 failed";
  (* .b260.#a259.#b245 *)
  let actual = r.b260.#a259.#b245 in
  let expected = #2. in
  mark_test_run 1971;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1971 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a260 = a2601; b260 = b2601 } { a260 = a2602; b260 = b2602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2601 a2602 && (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) b2601 b2602) in
  let next_r = { a260 = 100.; b260 = #{ a259 = #{ a245 = #101.; b245 = #102. } } } in
  let r_expected = { a260 = 0.; b260 = #{ a259 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a260 *)
  r.a260 <- next_r.a260;
  let r_expected = { r_expected with a260 = next_r.a260 } in
  mark_test_run 1972;
  let test = eq r r_expected in
  if not test then failwithf "test 1972 failed";
  Gc.compact ();
  (* .b260 *)
  r.b260 <- next_r.b260;
  let r_expected = { r_expected with b260 = next_r.b260 } in
  mark_test_run 1973;
  let test = eq r r_expected in
  if not test then failwithf "test 1973 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a260; b260 = #{ a259 = #{ a245; b245 } } } = r in
  let expected_a260 = 100. in
  mark_test_run 1974;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a260 a260 in
  if not test then failwithf "test 1974 failed";
  let expected_a245 = #101. in
  mark_test_run 1975;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 1975 failed";
  let expected_b245 = #102. in
  mark_test_run 1976;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 1976 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a260; b260 } = r in
  let expected_a260 = 100. in
  mark_test_run 1977;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a260 a260 in
  if not test then failwithf "test 1977 failed";
  let expected_b260 = #{ a259 = #{ a245 = #101.; b245 = #102. } } in
  mark_test_run 1978;
  let test = (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) expected_b260 b260 in
  if not test then failwithf "test 1978 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t261 = { float# }   *)
  (*************************)
  let r = { a261 = #0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a261 *)
  let actual = r.a261 in
  let expected = #0. in
  mark_test_run 1979;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1979 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a261 = a2611 } { a261 = a2612 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2611 a2612) in
  let next_r = { a261 = #100. } in
  let r_expected = { a261 = #0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a261 *)
  r.a261 <- next_r.a261;
  let r_expected = { r_expected with a261 = next_r.a261 } in
  mark_test_run 1980;
  let test = eq r r_expected in
  if not test then failwithf "test 1980 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a261 } = r in
  let expected_a261 = #100. in
  mark_test_run 1981;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a261 a261 in
  if not test then failwithf "test 1981 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a261 } = r in
  let expected_a261 = #100. in
  mark_test_run 1982;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a261 a261 in
  if not test then failwithf "test 1982 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t262 = { float#; float }   *)
  (********************************)
  let r = { a262 = #0.; b262 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a262 *)
  let actual = r.a262 in
  let expected = #0. in
  mark_test_run 1983;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1983 failed";
  (* Paths of depth 1 *)
  (* .b262 *)
  let actual = r.b262 in
  let expected = 1. in
  mark_test_run 1984;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1984 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a262 = a2621; b262 = b2621 } { a262 = a2622; b262 = b2622 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2621 a2622 && (fun a b -> Float.equal (globalize a) (globalize b)) b2621 b2622) in
  let next_r = { a262 = #100.; b262 = 101. } in
  let r_expected = { a262 = #0.; b262 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a262 *)
  r.a262 <- next_r.a262;
  let r_expected = { r_expected with a262 = next_r.a262 } in
  mark_test_run 1985;
  let test = eq r r_expected in
  if not test then failwithf "test 1985 failed";
  Gc.compact ();
  (* .b262 *)
  r.b262 <- next_r.b262;
  let r_expected = { r_expected with b262 = next_r.b262 } in
  mark_test_run 1986;
  let test = eq r r_expected in
  if not test then failwithf "test 1986 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a262; b262 } = r in
  let expected_a262 = #100. in
  mark_test_run 1987;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a262 a262 in
  if not test then failwithf "test 1987 failed";
  let expected_b262 = 101. in
  mark_test_run 1988;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b262 b262 in
  if not test then failwithf "test 1988 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a262; b262 } = r in
  let expected_a262 = #100. in
  mark_test_run 1989;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a262 a262 in
  if not test then failwithf "test 1989 failed";
  let expected_b262 = 101. in
  mark_test_run 1990;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b262 b262 in
  if not test then failwithf "test 1990 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t263 = { float#; float; float }   *)
  (***************************************)
  let r = { a263 = #0.; b263 = 1.; c263 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a263 *)
  let actual = r.a263 in
  let expected = #0. in
  mark_test_run 1991;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 1991 failed";
  (* Paths of depth 1 *)
  (* .b263 *)
  let actual = r.b263 in
  let expected = 1. in
  mark_test_run 1992;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1992 failed";
  (* Paths of depth 1 *)
  (* .c263 *)
  let actual = r.c263 in
  let expected = 2. in
  mark_test_run 1993;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 1993 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a263 = a2631; b263 = b2631; c263 = c2631 } { a263 = a2632; b263 = b2632; c263 = c2632 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2631 a2632 && (fun a b -> Float.equal (globalize a) (globalize b)) b2631 b2632 && (fun a b -> Float.equal (globalize a) (globalize b)) c2631 c2632) in
  let next_r = { a263 = #100.; b263 = 101.; c263 = 102. } in
  let r_expected = { a263 = #0.; b263 = 1.; c263 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a263 *)
  r.a263 <- next_r.a263;
  let r_expected = { r_expected with a263 = next_r.a263 } in
  mark_test_run 1994;
  let test = eq r r_expected in
  if not test then failwithf "test 1994 failed";
  Gc.compact ();
  (* .b263 *)
  r.b263 <- next_r.b263;
  let r_expected = { r_expected with b263 = next_r.b263 } in
  mark_test_run 1995;
  let test = eq r r_expected in
  if not test then failwithf "test 1995 failed";
  Gc.compact ();
  (* .c263 *)
  r.c263 <- next_r.c263;
  let r_expected = { r_expected with c263 = next_r.c263 } in
  mark_test_run 1996;
  let test = eq r r_expected in
  if not test then failwithf "test 1996 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a263; b263; c263 } = r in
  let expected_a263 = #100. in
  mark_test_run 1997;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a263 a263 in
  if not test then failwithf "test 1997 failed";
  let expected_b263 = 101. in
  mark_test_run 1998;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b263 b263 in
  if not test then failwithf "test 1998 failed";
  let expected_c263 = 102. in
  mark_test_run 1999;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c263 c263 in
  if not test then failwithf "test 1999 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a263; b263; c263 } = r in
  let expected_a263 = #100. in
  mark_test_run 2000;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a263 a263 in
  if not test then failwithf "test 2000 failed";
  let expected_b263 = 101. in
  mark_test_run 2001;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b263 b263 in
  if not test then failwithf "test 2001 failed";
  let expected_c263 = 102. in
  mark_test_run 2002;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c263 c263 in
  if not test then failwithf "test 2002 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t264 = { float#; float; float# }   *)
  (****************************************)
  let r = { a264 = #0.; b264 = 1.; c264 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a264 *)
  let actual = r.a264 in
  let expected = #0. in
  mark_test_run 2003;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2003 failed";
  (* Paths of depth 1 *)
  (* .b264 *)
  let actual = r.b264 in
  let expected = 1. in
  mark_test_run 2004;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2004 failed";
  (* Paths of depth 1 *)
  (* .c264 *)
  let actual = r.c264 in
  let expected = #2. in
  mark_test_run 2005;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2005 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a264 = a2641; b264 = b2641; c264 = c2641 } { a264 = a2642; b264 = b2642; c264 = c2642 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2641 a2642 && (fun a b -> Float.equal (globalize a) (globalize b)) b2641 b2642 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) c2641 c2642) in
  let next_r = { a264 = #100.; b264 = 101.; c264 = #102. } in
  let r_expected = { a264 = #0.; b264 = 1.; c264 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a264 *)
  r.a264 <- next_r.a264;
  let r_expected = { r_expected with a264 = next_r.a264 } in
  mark_test_run 2006;
  let test = eq r r_expected in
  if not test then failwithf "test 2006 failed";
  Gc.compact ();
  (* .b264 *)
  r.b264 <- next_r.b264;
  let r_expected = { r_expected with b264 = next_r.b264 } in
  mark_test_run 2007;
  let test = eq r r_expected in
  if not test then failwithf "test 2007 failed";
  Gc.compact ();
  (* .c264 *)
  r.c264 <- next_r.c264;
  let r_expected = { r_expected with c264 = next_r.c264 } in
  mark_test_run 2008;
  let test = eq r r_expected in
  if not test then failwithf "test 2008 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a264; b264; c264 } = r in
  let expected_a264 = #100. in
  mark_test_run 2009;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a264 a264 in
  if not test then failwithf "test 2009 failed";
  let expected_b264 = 101. in
  mark_test_run 2010;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b264 b264 in
  if not test then failwithf "test 2010 failed";
  let expected_c264 = #102. in
  mark_test_run 2011;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c264 c264 in
  if not test then failwithf "test 2011 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a264; b264; c264 } = r in
  let expected_a264 = #100. in
  mark_test_run 2012;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a264 a264 in
  if not test then failwithf "test 2012 failed";
  let expected_b264 = 101. in
  mark_test_run 2013;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b264 b264 in
  if not test then failwithf "test 2013 failed";
  let expected_c264 = #102. in
  mark_test_run 2014;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c264 c264 in
  if not test then failwithf "test 2014 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t265 = { float#; float# }   *)
  (*********************************)
  let r = { a265 = #0.; b265 = #1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a265 *)
  let actual = r.a265 in
  let expected = #0. in
  mark_test_run 2015;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2015 failed";
  (* Paths of depth 1 *)
  (* .b265 *)
  let actual = r.b265 in
  let expected = #1. in
  mark_test_run 2016;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2016 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a265 = a2651; b265 = b2651 } { a265 = a2652; b265 = b2652 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2651 a2652 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2651 b2652) in
  let next_r = { a265 = #100.; b265 = #101. } in
  let r_expected = { a265 = #0.; b265 = #1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a265 *)
  r.a265 <- next_r.a265;
  let r_expected = { r_expected with a265 = next_r.a265 } in
  mark_test_run 2017;
  let test = eq r r_expected in
  if not test then failwithf "test 2017 failed";
  Gc.compact ();
  (* .b265 *)
  r.b265 <- next_r.b265;
  let r_expected = { r_expected with b265 = next_r.b265 } in
  mark_test_run 2018;
  let test = eq r r_expected in
  if not test then failwithf "test 2018 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a265; b265 } = r in
  let expected_a265 = #100. in
  mark_test_run 2019;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a265 a265 in
  if not test then failwithf "test 2019 failed";
  let expected_b265 = #101. in
  mark_test_run 2020;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b265 b265 in
  if not test then failwithf "test 2020 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a265; b265 } = r in
  let expected_a265 = #100. in
  mark_test_run 2021;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a265 a265 in
  if not test then failwithf "test 2021 failed";
  let expected_b265 = #101. in
  mark_test_run 2022;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b265 b265 in
  if not test then failwithf "test 2022 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t266 = { float#; float#; float }   *)
  (****************************************)
  let r = { a266 = #0.; b266 = #1.; c266 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a266 *)
  let actual = r.a266 in
  let expected = #0. in
  mark_test_run 2023;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2023 failed";
  (* Paths of depth 1 *)
  (* .b266 *)
  let actual = r.b266 in
  let expected = #1. in
  mark_test_run 2024;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2024 failed";
  (* Paths of depth 1 *)
  (* .c266 *)
  let actual = r.c266 in
  let expected = 2. in
  mark_test_run 2025;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2025 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a266 = a2661; b266 = b2661; c266 = c2661 } { a266 = a2662; b266 = b2662; c266 = c2662 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2661 a2662 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2661 b2662 && (fun a b -> Float.equal (globalize a) (globalize b)) c2661 c2662) in
  let next_r = { a266 = #100.; b266 = #101.; c266 = 102. } in
  let r_expected = { a266 = #0.; b266 = #1.; c266 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a266 *)
  r.a266 <- next_r.a266;
  let r_expected = { r_expected with a266 = next_r.a266 } in
  mark_test_run 2026;
  let test = eq r r_expected in
  if not test then failwithf "test 2026 failed";
  Gc.compact ();
  (* .b266 *)
  r.b266 <- next_r.b266;
  let r_expected = { r_expected with b266 = next_r.b266 } in
  mark_test_run 2027;
  let test = eq r r_expected in
  if not test then failwithf "test 2027 failed";
  Gc.compact ();
  (* .c266 *)
  r.c266 <- next_r.c266;
  let r_expected = { r_expected with c266 = next_r.c266 } in
  mark_test_run 2028;
  let test = eq r r_expected in
  if not test then failwithf "test 2028 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a266; b266; c266 } = r in
  let expected_a266 = #100. in
  mark_test_run 2029;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a266 a266 in
  if not test then failwithf "test 2029 failed";
  let expected_b266 = #101. in
  mark_test_run 2030;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b266 b266 in
  if not test then failwithf "test 2030 failed";
  let expected_c266 = 102. in
  mark_test_run 2031;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c266 c266 in
  if not test then failwithf "test 2031 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a266; b266; c266 } = r in
  let expected_a266 = #100. in
  mark_test_run 2032;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a266 a266 in
  if not test then failwithf "test 2032 failed";
  let expected_b266 = #101. in
  mark_test_run 2033;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b266 b266 in
  if not test then failwithf "test 2033 failed";
  let expected_c266 = 102. in
  mark_test_run 2034;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_c266 c266 in
  if not test then failwithf "test 2034 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t267 = { float#; float#; float# }   *)
  (*****************************************)
  let r = { a267 = #0.; b267 = #1.; c267 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a267 *)
  let actual = r.a267 in
  let expected = #0. in
  mark_test_run 2035;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2035 failed";
  (* Paths of depth 1 *)
  (* .b267 *)
  let actual = r.b267 in
  let expected = #1. in
  mark_test_run 2036;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2036 failed";
  (* Paths of depth 1 *)
  (* .c267 *)
  let actual = r.c267 in
  let expected = #2. in
  mark_test_run 2037;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2037 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a267 = a2671; b267 = b2671; c267 = c2671 } { a267 = a2672; b267 = b2672; c267 = c2672 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2671 a2672 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2671 b2672 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) c2671 c2672) in
  let next_r = { a267 = #100.; b267 = #101.; c267 = #102. } in
  let r_expected = { a267 = #0.; b267 = #1.; c267 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a267 *)
  r.a267 <- next_r.a267;
  let r_expected = { r_expected with a267 = next_r.a267 } in
  mark_test_run 2038;
  let test = eq r r_expected in
  if not test then failwithf "test 2038 failed";
  Gc.compact ();
  (* .b267 *)
  r.b267 <- next_r.b267;
  let r_expected = { r_expected with b267 = next_r.b267 } in
  mark_test_run 2039;
  let test = eq r r_expected in
  if not test then failwithf "test 2039 failed";
  Gc.compact ();
  (* .c267 *)
  r.c267 <- next_r.c267;
  let r_expected = { r_expected with c267 = next_r.c267 } in
  mark_test_run 2040;
  let test = eq r r_expected in
  if not test then failwithf "test 2040 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a267; b267; c267 } = r in
  let expected_a267 = #100. in
  mark_test_run 2041;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a267 a267 in
  if not test then failwithf "test 2041 failed";
  let expected_b267 = #101. in
  mark_test_run 2042;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b267 b267 in
  if not test then failwithf "test 2042 failed";
  let expected_c267 = #102. in
  mark_test_run 2043;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c267 c267 in
  if not test then failwithf "test 2043 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a267; b267; c267 } = r in
  let expected_a267 = #100. in
  mark_test_run 2044;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a267 a267 in
  if not test then failwithf "test 2044 failed";
  let expected_b267 = #101. in
  mark_test_run 2045;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b267 b267 in
  if not test then failwithf "test 2045 failed";
  let expected_c267 = #102. in
  mark_test_run 2046;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_c267 c267 in
  if not test then failwithf "test 2046 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t268 = { float#; #{ float } }   *)
  (*************************************)
  let r = { a268 = #0.; b268 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a268 *)
  let actual = r.a268 in
  let expected = #0. in
  mark_test_run 2047;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2047 failed";
  (* Paths of depth 1 *)
  (* .b268 *)
  let actual = r.b268 in
  let expected = #{ a42 = 1. } in
  mark_test_run 2048;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 2048 failed";
  (* Paths of depth 2 *)
  (* .b268.#a42 *)
  let actual = r.b268.#a42 in
  let expected = 1. in
  mark_test_run 2049;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2049 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a268 = a2681; b268 = b2681 } { a268 = a2682; b268 = b2682 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2681 a2682 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2681 b2682) in
  let next_r = { a268 = #100.; b268 = #{ a42 = 101. } } in
  let r_expected = { a268 = #0.; b268 = #{ a42 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a268 *)
  r.a268 <- next_r.a268;
  let r_expected = { r_expected with a268 = next_r.a268 } in
  mark_test_run 2050;
  let test = eq r r_expected in
  if not test then failwithf "test 2050 failed";
  Gc.compact ();
  (* .b268 *)
  r.b268 <- next_r.b268;
  let r_expected = { r_expected with b268 = next_r.b268 } in
  mark_test_run 2051;
  let test = eq r r_expected in
  if not test then failwithf "test 2051 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a268; b268 = #{ a42 } } = r in
  let expected_a268 = #100. in
  mark_test_run 2052;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a268 a268 in
  if not test then failwithf "test 2052 failed";
  let expected_a42 = 101. in
  mark_test_run 2053;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 2053 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a268; b268 } = r in
  let expected_a268 = #100. in
  mark_test_run 2054;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a268 a268 in
  if not test then failwithf "test 2054 failed";
  let expected_b268 = #{ a42 = 101. } in
  mark_test_run 2055;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_b268 b268 in
  if not test then failwithf "test 2055 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t269 = { float#; #{ float; float } }   *)
  (********************************************)
  let r = { a269 = #0.; b269 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a269 *)
  let actual = r.a269 in
  let expected = #0. in
  mark_test_run 2056;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2056 failed";
  (* Paths of depth 1 *)
  (* .b269 *)
  let actual = r.b269 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 2057;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 2057 failed";
  (* Paths of depth 2 *)
  (* .b269.#a60 *)
  let actual = r.b269.#a60 in
  let expected = 1. in
  mark_test_run 2058;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2058 failed";
  (* .b269.#b60 *)
  let actual = r.b269.#b60 in
  let expected = 2. in
  mark_test_run 2059;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2059 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a269 = a2691; b269 = b2691 } { a269 = a2692; b269 = b2692 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2691 a2692 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b2691 b2692) in
  let next_r = { a269 = #100.; b269 = #{ a60 = 101.; b60 = 102. } } in
  let r_expected = { a269 = #0.; b269 = #{ a60 = 1.; b60 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a269 *)
  r.a269 <- next_r.a269;
  let r_expected = { r_expected with a269 = next_r.a269 } in
  mark_test_run 2060;
  let test = eq r r_expected in
  if not test then failwithf "test 2060 failed";
  Gc.compact ();
  (* .b269 *)
  r.b269 <- next_r.b269;
  let r_expected = { r_expected with b269 = next_r.b269 } in
  mark_test_run 2061;
  let test = eq r r_expected in
  if not test then failwithf "test 2061 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a269; b269 = #{ a60; b60 } } = r in
  let expected_a269 = #100. in
  mark_test_run 2062;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a269 a269 in
  if not test then failwithf "test 2062 failed";
  let expected_a60 = 101. in
  mark_test_run 2063;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 2063 failed";
  let expected_b60 = 102. in
  mark_test_run 2064;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 2064 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a269; b269 } = r in
  let expected_a269 = #100. in
  mark_test_run 2065;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a269 a269 in
  if not test then failwithf "test 2065 failed";
  let expected_b269 = #{ a60 = 101.; b60 = 102. } in
  mark_test_run 2066;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_b269 b269 in
  if not test then failwithf "test 2066 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t270 = { float#; #{ float; float# } }   *)
  (*********************************************)
  let r = { a270 = #0.; b270 = #{ a235 = 1.; b235 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a270 *)
  let actual = r.a270 in
  let expected = #0. in
  mark_test_run 2067;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2067 failed";
  (* Paths of depth 1 *)
  (* .b270 *)
  let actual = r.b270 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 2068;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 2068 failed";
  (* Paths of depth 2 *)
  (* .b270.#a235 *)
  let actual = r.b270.#a235 in
  let expected = 1. in
  mark_test_run 2069;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2069 failed";
  (* .b270.#b235 *)
  let actual = r.b270.#b235 in
  let expected = #2. in
  mark_test_run 2070;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2070 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a270 = a2701; b270 = b2701 } { a270 = a2702; b270 = b2702 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2701 a2702 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b2701 b2702) in
  let next_r = { a270 = #100.; b270 = #{ a235 = 101.; b235 = #102. } } in
  let r_expected = { a270 = #0.; b270 = #{ a235 = 1.; b235 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a270 *)
  r.a270 <- next_r.a270;
  let r_expected = { r_expected with a270 = next_r.a270 } in
  mark_test_run 2071;
  let test = eq r r_expected in
  if not test then failwithf "test 2071 failed";
  Gc.compact ();
  (* .b270 *)
  r.b270 <- next_r.b270;
  let r_expected = { r_expected with b270 = next_r.b270 } in
  mark_test_run 2072;
  let test = eq r r_expected in
  if not test then failwithf "test 2072 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a270; b270 = #{ a235; b235 } } = r in
  let expected_a270 = #100. in
  mark_test_run 2073;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a270 a270 in
  if not test then failwithf "test 2073 failed";
  let expected_a235 = 101. in
  mark_test_run 2074;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 2074 failed";
  let expected_b235 = #102. in
  mark_test_run 2075;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 2075 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a270; b270 } = r in
  let expected_a270 = #100. in
  mark_test_run 2076;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a270 a270 in
  if not test then failwithf "test 2076 failed";
  let expected_b270 = #{ a235 = 101.; b235 = #102. } in
  mark_test_run 2077;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) expected_b270 b270 in
  if not test then failwithf "test 2077 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t271 = { float#; #{ float; #{ float } } }   *)
  (*************************************************)
  let r = { a271 = #0.; b271 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a271 *)
  let actual = r.a271 in
  let expected = #0. in
  mark_test_run 2078;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2078 failed";
  (* Paths of depth 1 *)
  (* .b271 *)
  let actual = r.b271 in
  let expected = #{ a64 = 1.; b64 = #{ a42 = 2. } } in
  mark_test_run 2079;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) actual expected in
  if not test then failwithf "test 2079 failed";
  (* Paths of depth 2 *)
  (* .b271.#a64 *)
  let actual = r.b271.#a64 in
  let expected = 1. in
  mark_test_run 2080;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2080 failed";
  (* .b271.#b64 *)
  let actual = r.b271.#b64 in
  let expected = #{ a42 = 2. } in
  mark_test_run 2081;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 2081 failed";
  (* Paths of depth 3 *)
  (* .b271.#b64.#a42 *)
  let actual = r.b271.#b64.#a42 in
  let expected = 2. in
  mark_test_run 2082;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2082 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a271 = a2711; b271 = b2711 } { a271 = a2712; b271 = b2712 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2711 a2712 && (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) b2711 b2712) in
  let next_r = { a271 = #100.; b271 = #{ a64 = 101.; b64 = #{ a42 = 102. } } } in
  let r_expected = { a271 = #0.; b271 = #{ a64 = 1.; b64 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a271 *)
  r.a271 <- next_r.a271;
  let r_expected = { r_expected with a271 = next_r.a271 } in
  mark_test_run 2083;
  let test = eq r r_expected in
  if not test then failwithf "test 2083 failed";
  Gc.compact ();
  (* .b271 *)
  r.b271 <- next_r.b271;
  let r_expected = { r_expected with b271 = next_r.b271 } in
  mark_test_run 2084;
  let test = eq r r_expected in
  if not test then failwithf "test 2084 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a271; b271 = #{ a64; b64 = #{ a42 } } } = r in
  let expected_a271 = #100. in
  mark_test_run 2085;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a271 a271 in
  if not test then failwithf "test 2085 failed";
  let expected_a64 = 101. in
  mark_test_run 2086;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a64 a64 in
  if not test then failwithf "test 2086 failed";
  let expected_a42 = 102. in
  mark_test_run 2087;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 2087 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a271; b271 } = r in
  let expected_a271 = #100. in
  mark_test_run 2088;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a271 a271 in
  if not test then failwithf "test 2088 failed";
  let expected_b271 = #{ a64 = 101.; b64 = #{ a42 = 102. } } in
  mark_test_run 2089;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a641 a642 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b641 b642) expected_b271 b271 in
  if not test then failwithf "test 2089 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t272 = { float#; #{ float; #{ float# } } }   *)
  (**************************************************)
  let r = { a272 = #0.; b272 = #{ a240 = 1.; b240 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a272 *)
  let actual = r.a272 in
  let expected = #0. in
  mark_test_run 2090;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2090 failed";
  (* Paths of depth 1 *)
  (* .b272 *)
  let actual = r.b272 in
  let expected = #{ a240 = 1.; b240 = #{ a239 = #2. } } in
  mark_test_run 2091;
  let test = (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) actual expected in
  if not test then failwithf "test 2091 failed";
  (* Paths of depth 2 *)
  (* .b272.#a240 *)
  let actual = r.b272.#a240 in
  let expected = 1. in
  mark_test_run 2092;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2092 failed";
  (* .b272.#b240 *)
  let actual = r.b272.#b240 in
  let expected = #{ a239 = #2. } in
  mark_test_run 2093;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 2093 failed";
  (* Paths of depth 3 *)
  (* .b272.#b240.#a239 *)
  let actual = r.b272.#b240.#a239 in
  let expected = #2. in
  mark_test_run 2094;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2094 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a272 = a2721; b272 = b2721 } { a272 = a2722; b272 = b2722 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2721 a2722 && (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) b2721 b2722) in
  let next_r = { a272 = #100.; b272 = #{ a240 = 101.; b240 = #{ a239 = #102. } } } in
  let r_expected = { a272 = #0.; b272 = #{ a240 = 1.; b240 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a272 *)
  r.a272 <- next_r.a272;
  let r_expected = { r_expected with a272 = next_r.a272 } in
  mark_test_run 2095;
  let test = eq r r_expected in
  if not test then failwithf "test 2095 failed";
  Gc.compact ();
  (* .b272 *)
  r.b272 <- next_r.b272;
  let r_expected = { r_expected with b272 = next_r.b272 } in
  mark_test_run 2096;
  let test = eq r r_expected in
  if not test then failwithf "test 2096 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a272; b272 = #{ a240; b240 = #{ a239 } } } = r in
  let expected_a272 = #100. in
  mark_test_run 2097;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a272 a272 in
  if not test then failwithf "test 2097 failed";
  let expected_a240 = 101. in
  mark_test_run 2098;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a240 a240 in
  if not test then failwithf "test 2098 failed";
  let expected_a239 = #102. in
  mark_test_run 2099;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 2099 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a272; b272 } = r in
  let expected_a272 = #100. in
  mark_test_run 2100;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a272 a272 in
  if not test then failwithf "test 2100 failed";
  let expected_b272 = #{ a240 = 101.; b240 = #{ a239 = #102. } } in
  mark_test_run 2101;
  let test = (fun #{ a240 = a2401; b240 = b2401 } #{ a240 = a2402; b240 = b2402 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2401 a2402 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2401 b2402) expected_b272 b272 in
  if not test then failwithf "test 2101 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t273 = { float#; #{ float# } }   *)
  (**************************************)
  let r = { a273 = #0.; b273 = #{ a239 = #1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a273 *)
  let actual = r.a273 in
  let expected = #0. in
  mark_test_run 2102;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2102 failed";
  (* Paths of depth 1 *)
  (* .b273 *)
  let actual = r.b273 in
  let expected = #{ a239 = #1. } in
  mark_test_run 2103;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 2103 failed";
  (* Paths of depth 2 *)
  (* .b273.#a239 *)
  let actual = r.b273.#a239 in
  let expected = #1. in
  mark_test_run 2104;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2104 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a273 = a2731; b273 = b2731 } { a273 = a2732; b273 = b2732 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2731 a2732 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2731 b2732) in
  let next_r = { a273 = #100.; b273 = #{ a239 = #101. } } in
  let r_expected = { a273 = #0.; b273 = #{ a239 = #1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a273 *)
  r.a273 <- next_r.a273;
  let r_expected = { r_expected with a273 = next_r.a273 } in
  mark_test_run 2105;
  let test = eq r r_expected in
  if not test then failwithf "test 2105 failed";
  Gc.compact ();
  (* .b273 *)
  r.b273 <- next_r.b273;
  let r_expected = { r_expected with b273 = next_r.b273 } in
  mark_test_run 2106;
  let test = eq r r_expected in
  if not test then failwithf "test 2106 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a273; b273 = #{ a239 } } = r in
  let expected_a273 = #100. in
  mark_test_run 2107;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a273 a273 in
  if not test then failwithf "test 2107 failed";
  let expected_a239 = #101. in
  mark_test_run 2108;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 2108 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a273; b273 } = r in
  let expected_a273 = #100. in
  mark_test_run 2109;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a273 a273 in
  if not test then failwithf "test 2109 failed";
  let expected_b273 = #{ a239 = #101. } in
  mark_test_run 2110;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) expected_b273 b273 in
  if not test then failwithf "test 2110 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t274 = { float#; #{ float#; float } }   *)
  (*********************************************)
  let r = { a274 = #0.; b274 = #{ a243 = #1.; b243 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a274 *)
  let actual = r.a274 in
  let expected = #0. in
  mark_test_run 2111;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2111 failed";
  (* Paths of depth 1 *)
  (* .b274 *)
  let actual = r.b274 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 2112;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 2112 failed";
  (* Paths of depth 2 *)
  (* .b274.#a243 *)
  let actual = r.b274.#a243 in
  let expected = #1. in
  mark_test_run 2113;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2113 failed";
  (* .b274.#b243 *)
  let actual = r.b274.#b243 in
  let expected = 2. in
  mark_test_run 2114;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2114 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a274 = a2741; b274 = b2741 } { a274 = a2742; b274 = b2742 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2741 a2742 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b2741 b2742) in
  let next_r = { a274 = #100.; b274 = #{ a243 = #101.; b243 = 102. } } in
  let r_expected = { a274 = #0.; b274 = #{ a243 = #1.; b243 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a274 *)
  r.a274 <- next_r.a274;
  let r_expected = { r_expected with a274 = next_r.a274 } in
  mark_test_run 2115;
  let test = eq r r_expected in
  if not test then failwithf "test 2115 failed";
  Gc.compact ();
  (* .b274 *)
  r.b274 <- next_r.b274;
  let r_expected = { r_expected with b274 = next_r.b274 } in
  mark_test_run 2116;
  let test = eq r r_expected in
  if not test then failwithf "test 2116 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a274; b274 = #{ a243; b243 } } = r in
  let expected_a274 = #100. in
  mark_test_run 2117;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a274 a274 in
  if not test then failwithf "test 2117 failed";
  let expected_a243 = #101. in
  mark_test_run 2118;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 2118 failed";
  let expected_b243 = 102. in
  mark_test_run 2119;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 2119 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a274; b274 } = r in
  let expected_a274 = #100. in
  mark_test_run 2120;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a274 a274 in
  if not test then failwithf "test 2120 failed";
  let expected_b274 = #{ a243 = #101.; b243 = 102. } in
  mark_test_run 2121;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) expected_b274 b274 in
  if not test then failwithf "test 2121 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t275 = { float#; #{ float#; float# } }   *)
  (**********************************************)
  let r = { a275 = #0.; b275 = #{ a245 = #1.; b245 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a275 *)
  let actual = r.a275 in
  let expected = #0. in
  mark_test_run 2122;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2122 failed";
  (* Paths of depth 1 *)
  (* .b275 *)
  let actual = r.b275 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 2123;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 2123 failed";
  (* Paths of depth 2 *)
  (* .b275.#a245 *)
  let actual = r.b275.#a245 in
  let expected = #1. in
  mark_test_run 2124;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2124 failed";
  (* .b275.#b245 *)
  let actual = r.b275.#b245 in
  let expected = #2. in
  mark_test_run 2125;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2125 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a275 = a2751; b275 = b2751 } { a275 = a2752; b275 = b2752 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2751 a2752 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b2751 b2752) in
  let next_r = { a275 = #100.; b275 = #{ a245 = #101.; b245 = #102. } } in
  let r_expected = { a275 = #0.; b275 = #{ a245 = #1.; b245 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a275 *)
  r.a275 <- next_r.a275;
  let r_expected = { r_expected with a275 = next_r.a275 } in
  mark_test_run 2126;
  let test = eq r r_expected in
  if not test then failwithf "test 2126 failed";
  Gc.compact ();
  (* .b275 *)
  r.b275 <- next_r.b275;
  let r_expected = { r_expected with b275 = next_r.b275 } in
  mark_test_run 2127;
  let test = eq r r_expected in
  if not test then failwithf "test 2127 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a275; b275 = #{ a245; b245 } } = r in
  let expected_a275 = #100. in
  mark_test_run 2128;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a275 a275 in
  if not test then failwithf "test 2128 failed";
  let expected_a245 = #101. in
  mark_test_run 2129;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 2129 failed";
  let expected_b245 = #102. in
  mark_test_run 2130;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 2130 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a275; b275 } = r in
  let expected_a275 = #100. in
  mark_test_run 2131;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a275 a275 in
  if not test then failwithf "test 2131 failed";
  let expected_b275 = #{ a245 = #101.; b245 = #102. } in
  mark_test_run 2132;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) expected_b275 b275 in
  if not test then failwithf "test 2132 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t276 = { float#; #{ float#; #{ float } } }   *)
  (**************************************************)
  let r = { a276 = #0.; b276 = #{ a247 = #1.; b247 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a276 *)
  let actual = r.a276 in
  let expected = #0. in
  mark_test_run 2133;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2133 failed";
  (* Paths of depth 1 *)
  (* .b276 *)
  let actual = r.b276 in
  let expected = #{ a247 = #1.; b247 = #{ a42 = 2. } } in
  mark_test_run 2134;
  let test = (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) actual expected in
  if not test then failwithf "test 2134 failed";
  (* Paths of depth 2 *)
  (* .b276.#a247 *)
  let actual = r.b276.#a247 in
  let expected = #1. in
  mark_test_run 2135;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2135 failed";
  (* .b276.#b247 *)
  let actual = r.b276.#b247 in
  let expected = #{ a42 = 2. } in
  mark_test_run 2136;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 2136 failed";
  (* Paths of depth 3 *)
  (* .b276.#b247.#a42 *)
  let actual = r.b276.#b247.#a42 in
  let expected = 2. in
  mark_test_run 2137;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2137 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a276 = a2761; b276 = b2761 } { a276 = a2762; b276 = b2762 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2761 a2762 && (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) b2761 b2762) in
  let next_r = { a276 = #100.; b276 = #{ a247 = #101.; b247 = #{ a42 = 102. } } } in
  let r_expected = { a276 = #0.; b276 = #{ a247 = #1.; b247 = #{ a42 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a276 *)
  r.a276 <- next_r.a276;
  let r_expected = { r_expected with a276 = next_r.a276 } in
  mark_test_run 2138;
  let test = eq r r_expected in
  if not test then failwithf "test 2138 failed";
  Gc.compact ();
  (* .b276 *)
  r.b276 <- next_r.b276;
  let r_expected = { r_expected with b276 = next_r.b276 } in
  mark_test_run 2139;
  let test = eq r r_expected in
  if not test then failwithf "test 2139 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a276; b276 = #{ a247; b247 = #{ a42 } } } = r in
  let expected_a276 = #100. in
  mark_test_run 2140;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a276 a276 in
  if not test then failwithf "test 2140 failed";
  let expected_a247 = #101. in
  mark_test_run 2141;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a247 a247 in
  if not test then failwithf "test 2141 failed";
  let expected_a42 = 102. in
  mark_test_run 2142;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 2142 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a276; b276 } = r in
  let expected_a276 = #100. in
  mark_test_run 2143;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a276 a276 in
  if not test then failwithf "test 2143 failed";
  let expected_b276 = #{ a247 = #101.; b247 = #{ a42 = 102. } } in
  mark_test_run 2144;
  let test = (fun #{ a247 = a2471; b247 = b2471 } #{ a247 = a2472; b247 = b2472 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2471 a2472 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) b2471 b2472) expected_b276 b276 in
  if not test then failwithf "test 2144 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t277 = { float#; #{ float#; #{ float# } } }   *)
  (***************************************************)
  let r = { a277 = #0.; b277 = #{ a249 = #1.; b249 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a277 *)
  let actual = r.a277 in
  let expected = #0. in
  mark_test_run 2145;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2145 failed";
  (* Paths of depth 1 *)
  (* .b277 *)
  let actual = r.b277 in
  let expected = #{ a249 = #1.; b249 = #{ a239 = #2. } } in
  mark_test_run 2146;
  let test = (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) actual expected in
  if not test then failwithf "test 2146 failed";
  (* Paths of depth 2 *)
  (* .b277.#a249 *)
  let actual = r.b277.#a249 in
  let expected = #1. in
  mark_test_run 2147;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2147 failed";
  (* .b277.#b249 *)
  let actual = r.b277.#b249 in
  let expected = #{ a239 = #2. } in
  mark_test_run 2148;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 2148 failed";
  (* Paths of depth 3 *)
  (* .b277.#b249.#a239 *)
  let actual = r.b277.#b249.#a239 in
  let expected = #2. in
  mark_test_run 2149;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2149 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a277 = a2771; b277 = b2771 } { a277 = a2772; b277 = b2772 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2771 a2772 && (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) b2771 b2772) in
  let next_r = { a277 = #100.; b277 = #{ a249 = #101.; b249 = #{ a239 = #102. } } } in
  let r_expected = { a277 = #0.; b277 = #{ a249 = #1.; b249 = #{ a239 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a277 *)
  r.a277 <- next_r.a277;
  let r_expected = { r_expected with a277 = next_r.a277 } in
  mark_test_run 2150;
  let test = eq r r_expected in
  if not test then failwithf "test 2150 failed";
  Gc.compact ();
  (* .b277 *)
  r.b277 <- next_r.b277;
  let r_expected = { r_expected with b277 = next_r.b277 } in
  mark_test_run 2151;
  let test = eq r r_expected in
  if not test then failwithf "test 2151 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a277; b277 = #{ a249; b249 = #{ a239 } } } = r in
  let expected_a277 = #100. in
  mark_test_run 2152;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a277 a277 in
  if not test then failwithf "test 2152 failed";
  let expected_a249 = #101. in
  mark_test_run 2153;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a249 a249 in
  if not test then failwithf "test 2153 failed";
  let expected_a239 = #102. in
  mark_test_run 2154;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 2154 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a277; b277 } = r in
  let expected_a277 = #100. in
  mark_test_run 2155;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a277 a277 in
  if not test then failwithf "test 2155 failed";
  let expected_b277 = #{ a249 = #101.; b249 = #{ a239 = #102. } } in
  mark_test_run 2156;
  let test = (fun #{ a249 = a2491; b249 = b2491 } #{ a249 = a2492; b249 = b2492 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2491 a2492 && (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) b2491 b2492) expected_b277 b277 in
  if not test then failwithf "test 2156 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t278 = { float#; #{ #{ float; float } } }   *)
  (*************************************************)
  let r = { a278 = #0.; b278 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a278 *)
  let actual = r.a278 in
  let expected = #0. in
  mark_test_run 2157;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2157 failed";
  (* Paths of depth 1 *)
  (* .b278 *)
  let actual = r.b278 in
  let expected = #{ a89 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 2158;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) actual expected in
  if not test then failwithf "test 2158 failed";
  (* Paths of depth 2 *)
  (* .b278.#a89 *)
  let actual = r.b278.#a89 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 2159;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 2159 failed";
  (* Paths of depth 3 *)
  (* .b278.#a89.#a60 *)
  let actual = r.b278.#a89.#a60 in
  let expected = 1. in
  mark_test_run 2160;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2160 failed";
  (* .b278.#a89.#b60 *)
  let actual = r.b278.#a89.#b60 in
  let expected = 2. in
  mark_test_run 2161;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2161 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a278 = a2781; b278 = b2781 } { a278 = a2782; b278 = b2782 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2781 a2782 && (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) b2781 b2782) in
  let next_r = { a278 = #100.; b278 = #{ a89 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a278 = #0.; b278 = #{ a89 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a278 *)
  r.a278 <- next_r.a278;
  let r_expected = { r_expected with a278 = next_r.a278 } in
  mark_test_run 2162;
  let test = eq r r_expected in
  if not test then failwithf "test 2162 failed";
  Gc.compact ();
  (* .b278 *)
  r.b278 <- next_r.b278;
  let r_expected = { r_expected with b278 = next_r.b278 } in
  mark_test_run 2163;
  let test = eq r r_expected in
  if not test then failwithf "test 2163 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a278; b278 = #{ a89 = #{ a60; b60 } } } = r in
  let expected_a278 = #100. in
  mark_test_run 2164;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a278 a278 in
  if not test then failwithf "test 2164 failed";
  let expected_a60 = 101. in
  mark_test_run 2165;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 2165 failed";
  let expected_b60 = 102. in
  mark_test_run 2166;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 2166 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a278; b278 } = r in
  let expected_a278 = #100. in
  mark_test_run 2167;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a278 a278 in
  if not test then failwithf "test 2167 failed";
  let expected_b278 = #{ a89 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 2168;
  let test = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a891 a892) expected_b278 b278 in
  if not test then failwithf "test 2168 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t279 = { float#; #{ #{ float; float# } } }   *)
  (**************************************************)
  let r = { a279 = #0.; b279 = #{ a255 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a279 *)
  let actual = r.a279 in
  let expected = #0. in
  mark_test_run 2169;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2169 failed";
  (* Paths of depth 1 *)
  (* .b279 *)
  let actual = r.b279 in
  let expected = #{ a255 = #{ a235 = 1.; b235 = #2. } } in
  mark_test_run 2170;
  let test = (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) actual expected in
  if not test then failwithf "test 2170 failed";
  (* Paths of depth 2 *)
  (* .b279.#a255 *)
  let actual = r.b279.#a255 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 2171;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 2171 failed";
  (* Paths of depth 3 *)
  (* .b279.#a255.#a235 *)
  let actual = r.b279.#a255.#a235 in
  let expected = 1. in
  mark_test_run 2172;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2172 failed";
  (* .b279.#a255.#b235 *)
  let actual = r.b279.#a255.#b235 in
  let expected = #2. in
  mark_test_run 2173;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2173 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a279 = a2791; b279 = b2791 } { a279 = a2792; b279 = b2792 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2791 a2792 && (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) b2791 b2792) in
  let next_r = { a279 = #100.; b279 = #{ a255 = #{ a235 = 101.; b235 = #102. } } } in
  let r_expected = { a279 = #0.; b279 = #{ a255 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a279 *)
  r.a279 <- next_r.a279;
  let r_expected = { r_expected with a279 = next_r.a279 } in
  mark_test_run 2174;
  let test = eq r r_expected in
  if not test then failwithf "test 2174 failed";
  Gc.compact ();
  (* .b279 *)
  r.b279 <- next_r.b279;
  let r_expected = { r_expected with b279 = next_r.b279 } in
  mark_test_run 2175;
  let test = eq r r_expected in
  if not test then failwithf "test 2175 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a279; b279 = #{ a255 = #{ a235; b235 } } } = r in
  let expected_a279 = #100. in
  mark_test_run 2176;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a279 a279 in
  if not test then failwithf "test 2176 failed";
  let expected_a235 = 101. in
  mark_test_run 2177;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 2177 failed";
  let expected_b235 = #102. in
  mark_test_run 2178;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 2178 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a279; b279 } = r in
  let expected_a279 = #100. in
  mark_test_run 2179;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a279 a279 in
  if not test then failwithf "test 2179 failed";
  let expected_b279 = #{ a255 = #{ a235 = 101.; b235 = #102. } } in
  mark_test_run 2180;
  let test = (fun #{ a255 = a2551 } #{ a255 = a2552 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a2551 a2552) expected_b279 b279 in
  if not test then failwithf "test 2180 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t280 = { float#; #{ #{ float#; float } } }   *)
  (**************************************************)
  let r = { a280 = #0.; b280 = #{ a257 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a280 *)
  let actual = r.a280 in
  let expected = #0. in
  mark_test_run 2181;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2181 failed";
  (* Paths of depth 1 *)
  (* .b280 *)
  let actual = r.b280 in
  let expected = #{ a257 = #{ a243 = #1.; b243 = 2. } } in
  mark_test_run 2182;
  let test = (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) actual expected in
  if not test then failwithf "test 2182 failed";
  (* Paths of depth 2 *)
  (* .b280.#a257 *)
  let actual = r.b280.#a257 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 2183;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 2183 failed";
  (* Paths of depth 3 *)
  (* .b280.#a257.#a243 *)
  let actual = r.b280.#a257.#a243 in
  let expected = #1. in
  mark_test_run 2184;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2184 failed";
  (* .b280.#a257.#b243 *)
  let actual = r.b280.#a257.#b243 in
  let expected = 2. in
  mark_test_run 2185;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2185 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a280 = a2801; b280 = b2801 } { a280 = a2802; b280 = b2802 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2801 a2802 && (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) b2801 b2802) in
  let next_r = { a280 = #100.; b280 = #{ a257 = #{ a243 = #101.; b243 = 102. } } } in
  let r_expected = { a280 = #0.; b280 = #{ a257 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a280 *)
  r.a280 <- next_r.a280;
  let r_expected = { r_expected with a280 = next_r.a280 } in
  mark_test_run 2186;
  let test = eq r r_expected in
  if not test then failwithf "test 2186 failed";
  Gc.compact ();
  (* .b280 *)
  r.b280 <- next_r.b280;
  let r_expected = { r_expected with b280 = next_r.b280 } in
  mark_test_run 2187;
  let test = eq r r_expected in
  if not test then failwithf "test 2187 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a280; b280 = #{ a257 = #{ a243; b243 } } } = r in
  let expected_a280 = #100. in
  mark_test_run 2188;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a280 a280 in
  if not test then failwithf "test 2188 failed";
  let expected_a243 = #101. in
  mark_test_run 2189;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 2189 failed";
  let expected_b243 = 102. in
  mark_test_run 2190;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 2190 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a280; b280 } = r in
  let expected_a280 = #100. in
  mark_test_run 2191;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a280 a280 in
  if not test then failwithf "test 2191 failed";
  let expected_b280 = #{ a257 = #{ a243 = #101.; b243 = 102. } } in
  mark_test_run 2192;
  let test = (fun #{ a257 = a2571 } #{ a257 = a2572 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a2571 a2572) expected_b280 b280 in
  if not test then failwithf "test 2192 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t281 = { float#; #{ #{ float#; float# } } }   *)
  (***************************************************)
  let r = { a281 = #0.; b281 = #{ a259 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a281 *)
  let actual = r.a281 in
  let expected = #0. in
  mark_test_run 2193;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2193 failed";
  (* Paths of depth 1 *)
  (* .b281 *)
  let actual = r.b281 in
  let expected = #{ a259 = #{ a245 = #1.; b245 = #2. } } in
  mark_test_run 2194;
  let test = (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) actual expected in
  if not test then failwithf "test 2194 failed";
  (* Paths of depth 2 *)
  (* .b281.#a259 *)
  let actual = r.b281.#a259 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 2195;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 2195 failed";
  (* Paths of depth 3 *)
  (* .b281.#a259.#a245 *)
  let actual = r.b281.#a259.#a245 in
  let expected = #1. in
  mark_test_run 2196;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2196 failed";
  (* .b281.#a259.#b245 *)
  let actual = r.b281.#a259.#b245 in
  let expected = #2. in
  mark_test_run 2197;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2197 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a281 = a2811; b281 = b2811 } { a281 = a2812; b281 = b2812 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2811 a2812 && (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) b2811 b2812) in
  let next_r = { a281 = #100.; b281 = #{ a259 = #{ a245 = #101.; b245 = #102. } } } in
  let r_expected = { a281 = #0.; b281 = #{ a259 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a281 *)
  r.a281 <- next_r.a281;
  let r_expected = { r_expected with a281 = next_r.a281 } in
  mark_test_run 2198;
  let test = eq r r_expected in
  if not test then failwithf "test 2198 failed";
  Gc.compact ();
  (* .b281 *)
  r.b281 <- next_r.b281;
  let r_expected = { r_expected with b281 = next_r.b281 } in
  mark_test_run 2199;
  let test = eq r r_expected in
  if not test then failwithf "test 2199 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a281; b281 = #{ a259 = #{ a245; b245 } } } = r in
  let expected_a281 = #100. in
  mark_test_run 2200;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a281 a281 in
  if not test then failwithf "test 2200 failed";
  let expected_a245 = #101. in
  mark_test_run 2201;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 2201 failed";
  let expected_b245 = #102. in
  mark_test_run 2202;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 2202 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a281; b281 } = r in
  let expected_a281 = #100. in
  mark_test_run 2203;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a281 a281 in
  if not test then failwithf "test 2203 failed";
  let expected_b281 = #{ a259 = #{ a245 = #101.; b245 = #102. } } in
  mark_test_run 2204;
  let test = (fun #{ a259 = a2591 } #{ a259 = a2592 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a2591 a2592) expected_b281 b281 in
  if not test then failwithf "test 2204 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************)
  (*   t282 = { string }   *)
  (*************************)
  let r = { a282 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a282 *)
  let actual = r.a282 in
  let expected = "0" in
  mark_test_run 2205;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2205 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a282 = a2821 } { a282 = a2822 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2821 a2822) in
  let next_r = { a282 = "100" } in
  let r_expected = { a282 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a282 *)
  r.a282 <- next_r.a282;
  let r_expected = { r_expected with a282 = next_r.a282 } in
  mark_test_run 2206;
  let test = eq r r_expected in
  if not test then failwithf "test 2206 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a282 } = r in
  let expected_a282 = "100" in
  mark_test_run 2207;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a282 a282 in
  if not test then failwithf "test 2207 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a282 } = r in
  let expected_a282 = "100" in
  mark_test_run 2208;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a282 a282 in
  if not test then failwithf "test 2208 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t283 = { string; unit_u }   *)
  (*********************************)
  let r = { a283 = "0"; b283 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a283 *)
  let actual = r.a283 in
  let expected = "0" in
  mark_test_run 2209;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2209 failed";
  (* Paths of depth 1 *)
  (* .b283 *)
  let actual = r.b283 in
  let expected = (unbox_unit ()) in
  mark_test_run 2210;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2210 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a283 = a2831; b283 = b2831 } { a283 = a2832; b283 = b2832 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2831 a2832 && (fun _ _ -> true) b2831 b2832) in
  let next_r = { a283 = "100"; b283 = (unbox_unit ()) } in
  let r_expected = { a283 = "0"; b283 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a283 *)
  r.a283 <- next_r.a283;
  let r_expected = { r_expected with a283 = next_r.a283 } in
  mark_test_run 2211;
  let test = eq r r_expected in
  if not test then failwithf "test 2211 failed";
  Gc.compact ();
  (* .b283 *)
  r.b283 <- next_r.b283;
  let r_expected = { r_expected with b283 = next_r.b283 } in
  mark_test_run 2212;
  let test = eq r r_expected in
  if not test then failwithf "test 2212 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a283; b283 } = r in
  let expected_a283 = "100" in
  mark_test_run 2213;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a283 a283 in
  if not test then failwithf "test 2213 failed";
  let expected_b283 = (unbox_unit ()) in
  mark_test_run 2214;
  let test = (fun _ _ -> true) expected_b283 b283 in
  if not test then failwithf "test 2214 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a283; b283 } = r in
  let expected_a283 = "100" in
  mark_test_run 2215;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a283 a283 in
  if not test then failwithf "test 2215 failed";
  let expected_b283 = (unbox_unit ()) in
  mark_test_run 2216;
  let test = (fun _ _ -> true) expected_b283 b283 in
  if not test then failwithf "test 2216 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t284 = { string; unit_u; unit_u }   *)
  (*****************************************)
  let r = { a284 = "0"; b284 = (unbox_unit ()); c284 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a284 *)
  let actual = r.a284 in
  let expected = "0" in
  mark_test_run 2217;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2217 failed";
  (* Paths of depth 1 *)
  (* .b284 *)
  let actual = r.b284 in
  let expected = (unbox_unit ()) in
  mark_test_run 2218;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2218 failed";
  (* Paths of depth 1 *)
  (* .c284 *)
  let actual = r.c284 in
  let expected = (unbox_unit ()) in
  mark_test_run 2219;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2219 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a284 = a2841; b284 = b2841; c284 = c2841 } { a284 = a2842; b284 = b2842; c284 = c2842 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2841 a2842 && (fun _ _ -> true) b2841 b2842 && (fun _ _ -> true) c2841 c2842) in
  let next_r = { a284 = "100"; b284 = (unbox_unit ()); c284 = (unbox_unit ()) } in
  let r_expected = { a284 = "0"; b284 = (unbox_unit ()); c284 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a284 *)
  r.a284 <- next_r.a284;
  let r_expected = { r_expected with a284 = next_r.a284 } in
  mark_test_run 2220;
  let test = eq r r_expected in
  if not test then failwithf "test 2220 failed";
  Gc.compact ();
  (* .b284 *)
  r.b284 <- next_r.b284;
  let r_expected = { r_expected with b284 = next_r.b284 } in
  mark_test_run 2221;
  let test = eq r r_expected in
  if not test then failwithf "test 2221 failed";
  Gc.compact ();
  (* .c284 *)
  r.c284 <- next_r.c284;
  let r_expected = { r_expected with c284 = next_r.c284 } in
  mark_test_run 2222;
  let test = eq r r_expected in
  if not test then failwithf "test 2222 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a284; b284; c284 } = r in
  let expected_a284 = "100" in
  mark_test_run 2223;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a284 a284 in
  if not test then failwithf "test 2223 failed";
  let expected_b284 = (unbox_unit ()) in
  mark_test_run 2224;
  let test = (fun _ _ -> true) expected_b284 b284 in
  if not test then failwithf "test 2224 failed";
  let expected_c284 = (unbox_unit ()) in
  mark_test_run 2225;
  let test = (fun _ _ -> true) expected_c284 c284 in
  if not test then failwithf "test 2225 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a284; b284; c284 } = r in
  let expected_a284 = "100" in
  mark_test_run 2226;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a284 a284 in
  if not test then failwithf "test 2226 failed";
  let expected_b284 = (unbox_unit ()) in
  mark_test_run 2227;
  let test = (fun _ _ -> true) expected_b284 b284 in
  if not test then failwithf "test 2227 failed";
  let expected_c284 = (unbox_unit ()) in
  mark_test_run 2228;
  let test = (fun _ _ -> true) expected_c284 c284 in
  if not test then failwithf "test 2228 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t285 = { string; unit_u; string }   *)
  (*****************************************)
  let r = { a285 = "0"; b285 = (unbox_unit ()); c285 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a285 *)
  let actual = r.a285 in
  let expected = "0" in
  mark_test_run 2229;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2229 failed";
  (* Paths of depth 1 *)
  (* .b285 *)
  let actual = r.b285 in
  let expected = (unbox_unit ()) in
  mark_test_run 2230;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2230 failed";
  (* Paths of depth 1 *)
  (* .c285 *)
  let actual = r.c285 in
  let expected = "1" in
  mark_test_run 2231;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2231 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a285 = a2851; b285 = b2851; c285 = c2851 } { a285 = a2852; b285 = b2852; c285 = c2852 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2851 a2852 && (fun _ _ -> true) b2851 b2852 && (fun a b -> String.equal (globalize a) (globalize b)) c2851 c2852) in
  let next_r = { a285 = "100"; b285 = (unbox_unit ()); c285 = "101" } in
  let r_expected = { a285 = "0"; b285 = (unbox_unit ()); c285 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a285 *)
  r.a285 <- next_r.a285;
  let r_expected = { r_expected with a285 = next_r.a285 } in
  mark_test_run 2232;
  let test = eq r r_expected in
  if not test then failwithf "test 2232 failed";
  Gc.compact ();
  (* .b285 *)
  r.b285 <- next_r.b285;
  let r_expected = { r_expected with b285 = next_r.b285 } in
  mark_test_run 2233;
  let test = eq r r_expected in
  if not test then failwithf "test 2233 failed";
  Gc.compact ();
  (* .c285 *)
  r.c285 <- next_r.c285;
  let r_expected = { r_expected with c285 = next_r.c285 } in
  mark_test_run 2234;
  let test = eq r r_expected in
  if not test then failwithf "test 2234 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a285; b285; c285 } = r in
  let expected_a285 = "100" in
  mark_test_run 2235;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a285 a285 in
  if not test then failwithf "test 2235 failed";
  let expected_b285 = (unbox_unit ()) in
  mark_test_run 2236;
  let test = (fun _ _ -> true) expected_b285 b285 in
  if not test then failwithf "test 2236 failed";
  let expected_c285 = "101" in
  mark_test_run 2237;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c285 c285 in
  if not test then failwithf "test 2237 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a285; b285; c285 } = r in
  let expected_a285 = "100" in
  mark_test_run 2238;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a285 a285 in
  if not test then failwithf "test 2238 failed";
  let expected_b285 = (unbox_unit ()) in
  mark_test_run 2239;
  let test = (fun _ _ -> true) expected_b285 b285 in
  if not test then failwithf "test 2239 failed";
  let expected_c285 = "101" in
  mark_test_run 2240;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c285 c285 in
  if not test then failwithf "test 2240 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t286 = { string; string }   *)
  (*********************************)
  let r = { a286 = "0"; b286 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a286 *)
  let actual = r.a286 in
  let expected = "0" in
  mark_test_run 2241;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2241 failed";
  (* Paths of depth 1 *)
  (* .b286 *)
  let actual = r.b286 in
  let expected = "1" in
  mark_test_run 2242;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2242 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a286 = a2861; b286 = b2861 } { a286 = a2862; b286 = b2862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2861 a2862 && (fun a b -> String.equal (globalize a) (globalize b)) b2861 b2862) in
  let next_r = { a286 = "100"; b286 = "101" } in
  let r_expected = { a286 = "0"; b286 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a286 *)
  r.a286 <- next_r.a286;
  let r_expected = { r_expected with a286 = next_r.a286 } in
  mark_test_run 2243;
  let test = eq r r_expected in
  if not test then failwithf "test 2243 failed";
  Gc.compact ();
  (* .b286 *)
  r.b286 <- next_r.b286;
  let r_expected = { r_expected with b286 = next_r.b286 } in
  mark_test_run 2244;
  let test = eq r r_expected in
  if not test then failwithf "test 2244 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a286; b286 } = r in
  let expected_a286 = "100" in
  mark_test_run 2245;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a286 a286 in
  if not test then failwithf "test 2245 failed";
  let expected_b286 = "101" in
  mark_test_run 2246;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b286 b286 in
  if not test then failwithf "test 2246 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a286; b286 } = r in
  let expected_a286 = "100" in
  mark_test_run 2247;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a286 a286 in
  if not test then failwithf "test 2247 failed";
  let expected_b286 = "101" in
  mark_test_run 2248;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b286 b286 in
  if not test then failwithf "test 2248 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t287 = { string; string; unit_u }   *)
  (*****************************************)
  let r = { a287 = "0"; b287 = "1"; c287 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a287 *)
  let actual = r.a287 in
  let expected = "0" in
  mark_test_run 2249;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2249 failed";
  (* Paths of depth 1 *)
  (* .b287 *)
  let actual = r.b287 in
  let expected = "1" in
  mark_test_run 2250;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2250 failed";
  (* Paths of depth 1 *)
  (* .c287 *)
  let actual = r.c287 in
  let expected = (unbox_unit ()) in
  mark_test_run 2251;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2251 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a287 = a2871; b287 = b2871; c287 = c2871 } { a287 = a2872; b287 = b2872; c287 = c2872 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2871 a2872 && (fun a b -> String.equal (globalize a) (globalize b)) b2871 b2872 && (fun _ _ -> true) c2871 c2872) in
  let next_r = { a287 = "100"; b287 = "101"; c287 = (unbox_unit ()) } in
  let r_expected = { a287 = "0"; b287 = "1"; c287 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a287 *)
  r.a287 <- next_r.a287;
  let r_expected = { r_expected with a287 = next_r.a287 } in
  mark_test_run 2252;
  let test = eq r r_expected in
  if not test then failwithf "test 2252 failed";
  Gc.compact ();
  (* .b287 *)
  r.b287 <- next_r.b287;
  let r_expected = { r_expected with b287 = next_r.b287 } in
  mark_test_run 2253;
  let test = eq r r_expected in
  if not test then failwithf "test 2253 failed";
  Gc.compact ();
  (* .c287 *)
  r.c287 <- next_r.c287;
  let r_expected = { r_expected with c287 = next_r.c287 } in
  mark_test_run 2254;
  let test = eq r r_expected in
  if not test then failwithf "test 2254 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a287; b287; c287 } = r in
  let expected_a287 = "100" in
  mark_test_run 2255;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a287 a287 in
  if not test then failwithf "test 2255 failed";
  let expected_b287 = "101" in
  mark_test_run 2256;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b287 b287 in
  if not test then failwithf "test 2256 failed";
  let expected_c287 = (unbox_unit ()) in
  mark_test_run 2257;
  let test = (fun _ _ -> true) expected_c287 c287 in
  if not test then failwithf "test 2257 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a287; b287; c287 } = r in
  let expected_a287 = "100" in
  mark_test_run 2258;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a287 a287 in
  if not test then failwithf "test 2258 failed";
  let expected_b287 = "101" in
  mark_test_run 2259;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b287 b287 in
  if not test then failwithf "test 2259 failed";
  let expected_c287 = (unbox_unit ()) in
  mark_test_run 2260;
  let test = (fun _ _ -> true) expected_c287 c287 in
  if not test then failwithf "test 2260 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t288 = { string; string; string }   *)
  (*****************************************)
  let r = { a288 = "0"; b288 = "1"; c288 = "2" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a288 *)
  let actual = r.a288 in
  let expected = "0" in
  mark_test_run 2261;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2261 failed";
  (* Paths of depth 1 *)
  (* .b288 *)
  let actual = r.b288 in
  let expected = "1" in
  mark_test_run 2262;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2262 failed";
  (* Paths of depth 1 *)
  (* .c288 *)
  let actual = r.c288 in
  let expected = "2" in
  mark_test_run 2263;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2263 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a288 = a2881; b288 = b2881; c288 = c2881 } { a288 = a2882; b288 = b2882; c288 = c2882 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2881 a2882 && (fun a b -> String.equal (globalize a) (globalize b)) b2881 b2882 && (fun a b -> String.equal (globalize a) (globalize b)) c2881 c2882) in
  let next_r = { a288 = "100"; b288 = "101"; c288 = "102" } in
  let r_expected = { a288 = "0"; b288 = "1"; c288 = "2" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a288 *)
  r.a288 <- next_r.a288;
  let r_expected = { r_expected with a288 = next_r.a288 } in
  mark_test_run 2264;
  let test = eq r r_expected in
  if not test then failwithf "test 2264 failed";
  Gc.compact ();
  (* .b288 *)
  r.b288 <- next_r.b288;
  let r_expected = { r_expected with b288 = next_r.b288 } in
  mark_test_run 2265;
  let test = eq r r_expected in
  if not test then failwithf "test 2265 failed";
  Gc.compact ();
  (* .c288 *)
  r.c288 <- next_r.c288;
  let r_expected = { r_expected with c288 = next_r.c288 } in
  mark_test_run 2266;
  let test = eq r r_expected in
  if not test then failwithf "test 2266 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a288; b288; c288 } = r in
  let expected_a288 = "100" in
  mark_test_run 2267;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a288 a288 in
  if not test then failwithf "test 2267 failed";
  let expected_b288 = "101" in
  mark_test_run 2268;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b288 b288 in
  if not test then failwithf "test 2268 failed";
  let expected_c288 = "102" in
  mark_test_run 2269;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c288 c288 in
  if not test then failwithf "test 2269 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a288; b288; c288 } = r in
  let expected_a288 = "100" in
  mark_test_run 2270;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a288 a288 in
  if not test then failwithf "test 2270 failed";
  let expected_b288 = "101" in
  mark_test_run 2271;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b288 b288 in
  if not test then failwithf "test 2271 failed";
  let expected_c288 = "102" in
  mark_test_run 2272;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c288 c288 in
  if not test then failwithf "test 2272 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t289 = { string; #{ unit_u } }   *)
  (**************************************)
  let r = { a289 = "0"; b289 = #{ a194 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a289 *)
  let actual = r.a289 in
  let expected = "0" in
  mark_test_run 2273;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2273 failed";
  (* Paths of depth 1 *)
  (* .b289 *)
  let actual = r.b289 in
  let expected = #{ a194 = (unbox_unit ()) } in
  mark_test_run 2274;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) actual expected in
  if not test then failwithf "test 2274 failed";
  (* Paths of depth 2 *)
  (* .b289.#a194 *)
  let actual = r.b289.#a194 in
  let expected = (unbox_unit ()) in
  mark_test_run 2275;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2275 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a289 = a2891; b289 = b2891 } { a289 = a2892; b289 = b2892 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2891 a2892 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b2891 b2892) in
  let next_r = { a289 = "100"; b289 = #{ a194 = (unbox_unit ()) } } in
  let r_expected = { a289 = "0"; b289 = #{ a194 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a289 *)
  r.a289 <- next_r.a289;
  let r_expected = { r_expected with a289 = next_r.a289 } in
  mark_test_run 2276;
  let test = eq r r_expected in
  if not test then failwithf "test 2276 failed";
  Gc.compact ();
  (* .b289 *)
  r.b289 <- next_r.b289;
  let r_expected = { r_expected with b289 = next_r.b289 } in
  mark_test_run 2277;
  let test = eq r r_expected in
  if not test then failwithf "test 2277 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a289; b289 = #{ a194 } } = r in
  let expected_a289 = "100" in
  mark_test_run 2278;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a289 a289 in
  if not test then failwithf "test 2278 failed";
  let expected_a194 = (unbox_unit ()) in
  mark_test_run 2279;
  let test = (fun _ _ -> true) expected_a194 a194 in
  if not test then failwithf "test 2279 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a289; b289 } = r in
  let expected_a289 = "100" in
  mark_test_run 2280;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a289 a289 in
  if not test then failwithf "test 2280 failed";
  let expected_b289 = #{ a194 = (unbox_unit ()) } in
  mark_test_run 2281;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) expected_b289 b289 in
  if not test then failwithf "test 2281 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t291 = { string; #{ unit_u; unit_u } }   *)
  (**********************************************)
  let r = { a291 = "0"; b291 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a291 *)
  let actual = r.a291 in
  let expected = "0" in
  mark_test_run 2282;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2282 failed";
  (* Paths of depth 1 *)
  (* .b291 *)
  let actual = r.b291 in
  let expected = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 2283;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) actual expected in
  if not test then failwithf "test 2283 failed";
  (* Paths of depth 2 *)
  (* .b291.#a290 *)
  let actual = r.b291.#a290 in
  let expected = (unbox_unit ()) in
  mark_test_run 2284;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2284 failed";
  (* .b291.#b290 *)
  let actual = r.b291.#b290 in
  let expected = (unbox_unit ()) in
  mark_test_run 2285;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2285 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a291 = a2911; b291 = b2911 } { a291 = a2912; b291 = b2912 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2911 a2912 && (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) b2911 b2912) in
  let next_r = { a291 = "100"; b291 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  let r_expected = { a291 = "0"; b291 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a291 *)
  r.a291 <- next_r.a291;
  let r_expected = { r_expected with a291 = next_r.a291 } in
  mark_test_run 2286;
  let test = eq r r_expected in
  if not test then failwithf "test 2286 failed";
  Gc.compact ();
  (* .b291 *)
  r.b291 <- next_r.b291;
  let r_expected = { r_expected with b291 = next_r.b291 } in
  mark_test_run 2287;
  let test = eq r r_expected in
  if not test then failwithf "test 2287 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a291; b291 = #{ a290; b290 } } = r in
  let expected_a291 = "100" in
  mark_test_run 2288;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a291 a291 in
  if not test then failwithf "test 2288 failed";
  let expected_a290 = (unbox_unit ()) in
  mark_test_run 2289;
  let test = (fun _ _ -> true) expected_a290 a290 in
  if not test then failwithf "test 2289 failed";
  let expected_b290 = (unbox_unit ()) in
  mark_test_run 2290;
  let test = (fun _ _ -> true) expected_b290 b290 in
  if not test then failwithf "test 2290 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a291; b291 } = r in
  let expected_a291 = "100" in
  mark_test_run 2291;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a291 a291 in
  if not test then failwithf "test 2291 failed";
  let expected_b291 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 2292;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) expected_b291 b291 in
  if not test then failwithf "test 2292 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t292 = { string; #{ unit_u; string } }   *)
  (**********************************************)
  let r = { a292 = "0"; b292 = #{ a184 = (unbox_unit ()); b184 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a292 *)
  let actual = r.a292 in
  let expected = "0" in
  mark_test_run 2293;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2293 failed";
  (* Paths of depth 1 *)
  (* .b292 *)
  let actual = r.b292 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "1" } in
  mark_test_run 2294;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 2294 failed";
  (* Paths of depth 2 *)
  (* .b292.#a184 *)
  let actual = r.b292.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 2295;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2295 failed";
  (* .b292.#b184 *)
  let actual = r.b292.#b184 in
  let expected = "1" in
  mark_test_run 2296;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2296 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a292 = a2921; b292 = b2921 } { a292 = a2922; b292 = b2922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2921 a2922 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b2921 b2922) in
  let next_r = { a292 = "100"; b292 = #{ a184 = (unbox_unit ()); b184 = "101" } } in
  let r_expected = { a292 = "0"; b292 = #{ a184 = (unbox_unit ()); b184 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a292 *)
  r.a292 <- next_r.a292;
  let r_expected = { r_expected with a292 = next_r.a292 } in
  mark_test_run 2297;
  let test = eq r r_expected in
  if not test then failwithf "test 2297 failed";
  Gc.compact ();
  (* .b292 *)
  r.b292 <- next_r.b292;
  let r_expected = { r_expected with b292 = next_r.b292 } in
  mark_test_run 2298;
  let test = eq r r_expected in
  if not test then failwithf "test 2298 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a292; b292 = #{ a184; b184 } } = r in
  let expected_a292 = "100" in
  mark_test_run 2299;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a292 a292 in
  if not test then failwithf "test 2299 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 2300;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 2300 failed";
  let expected_b184 = "101" in
  mark_test_run 2301;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 2301 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a292; b292 } = r in
  let expected_a292 = "100" in
  mark_test_run 2302;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a292 a292 in
  if not test then failwithf "test 2302 failed";
  let expected_b292 = #{ a184 = (unbox_unit ()); b184 = "101" } in
  mark_test_run 2303;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) expected_b292 b292 in
  if not test then failwithf "test 2303 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t294 = { string; #{ unit_u; #{ unit_u } } }   *)
  (***************************************************)
  let r = { a294 = "0"; b294 = #{ a293 = (unbox_unit ()); b293 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a294 *)
  let actual = r.a294 in
  let expected = "0" in
  mark_test_run 2304;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2304 failed";
  (* Paths of depth 1 *)
  (* .b294 *)
  let actual = r.b294 in
  let expected = #{ a293 = (unbox_unit ()); b293 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 2305;
  let test = (fun #{ a293 = a2931; b293 = b2931 } #{ a293 = a2932; b293 = b2932 } -> (fun _ _ -> true) a2931 a2932 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b2931 b2932) actual expected in
  if not test then failwithf "test 2305 failed";
  (* Paths of depth 2 *)
  (* .b294.#a293 *)
  let actual = r.b294.#a293 in
  let expected = (unbox_unit ()) in
  mark_test_run 2306;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2306 failed";
  (* .b294.#b293 *)
  let actual = r.b294.#b293 in
  let expected = #{ a194 = (unbox_unit ()) } in
  mark_test_run 2307;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) actual expected in
  if not test then failwithf "test 2307 failed";
  (* Paths of depth 3 *)
  (* .b294.#b293.#a194 *)
  let actual = r.b294.#b293.#a194 in
  let expected = (unbox_unit ()) in
  mark_test_run 2308;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2308 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a294 = a2941; b294 = b2941 } { a294 = a2942; b294 = b2942 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2941 a2942 && (fun #{ a293 = a2931; b293 = b2931 } #{ a293 = a2932; b293 = b2932 } -> (fun _ _ -> true) a2931 a2932 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b2931 b2932) b2941 b2942) in
  let next_r = { a294 = "100"; b294 = #{ a293 = (unbox_unit ()); b293 = #{ a194 = (unbox_unit ()) } } } in
  let r_expected = { a294 = "0"; b294 = #{ a293 = (unbox_unit ()); b293 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a294 *)
  r.a294 <- next_r.a294;
  let r_expected = { r_expected with a294 = next_r.a294 } in
  mark_test_run 2309;
  let test = eq r r_expected in
  if not test then failwithf "test 2309 failed";
  Gc.compact ();
  (* .b294 *)
  r.b294 <- next_r.b294;
  let r_expected = { r_expected with b294 = next_r.b294 } in
  mark_test_run 2310;
  let test = eq r r_expected in
  if not test then failwithf "test 2310 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a294; b294 = #{ a293; b293 = #{ a194 } } } = r in
  let expected_a294 = "100" in
  mark_test_run 2311;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a294 a294 in
  if not test then failwithf "test 2311 failed";
  let expected_a293 = (unbox_unit ()) in
  mark_test_run 2312;
  let test = (fun _ _ -> true) expected_a293 a293 in
  if not test then failwithf "test 2312 failed";
  let expected_a194 = (unbox_unit ()) in
  mark_test_run 2313;
  let test = (fun _ _ -> true) expected_a194 a194 in
  if not test then failwithf "test 2313 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a294; b294 } = r in
  let expected_a294 = "100" in
  mark_test_run 2314;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a294 a294 in
  if not test then failwithf "test 2314 failed";
  let expected_b294 = #{ a293 = (unbox_unit ()); b293 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 2315;
  let test = (fun #{ a293 = a2931; b293 = b2931 } #{ a293 = a2932; b293 = b2932 } -> (fun _ _ -> true) a2931 a2932 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b2931 b2932) expected_b294 b294 in
  if not test then failwithf "test 2315 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t295 = { string; #{ unit_u; #{ string } } }   *)
  (***************************************************)
  let r = { a295 = "0"; b295 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a295 *)
  let actual = r.a295 in
  let expected = "0" in
  mark_test_run 2316;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2316 failed";
  (* Paths of depth 1 *)
  (* .b295 *)
  let actual = r.b295 in
  let expected = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "1" } } in
  mark_test_run 2317;
  let test = (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) actual expected in
  if not test then failwithf "test 2317 failed";
  (* Paths of depth 2 *)
  (* .b295.#a187 *)
  let actual = r.b295.#a187 in
  let expected = (unbox_unit ()) in
  mark_test_run 2318;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2318 failed";
  (* .b295.#b187 *)
  let actual = r.b295.#b187 in
  let expected = #{ a186 = "1" } in
  mark_test_run 2319;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 2319 failed";
  (* Paths of depth 3 *)
  (* .b295.#b187.#a186 *)
  let actual = r.b295.#b187.#a186 in
  let expected = "1" in
  mark_test_run 2320;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2320 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a295 = a2951; b295 = b2951 } { a295 = a2952; b295 = b2952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2951 a2952 && (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) b2951 b2952) in
  let next_r = { a295 = "100"; b295 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "101" } } } in
  let r_expected = { a295 = "0"; b295 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a295 *)
  r.a295 <- next_r.a295;
  let r_expected = { r_expected with a295 = next_r.a295 } in
  mark_test_run 2321;
  let test = eq r r_expected in
  if not test then failwithf "test 2321 failed";
  Gc.compact ();
  (* .b295 *)
  r.b295 <- next_r.b295;
  let r_expected = { r_expected with b295 = next_r.b295 } in
  mark_test_run 2322;
  let test = eq r r_expected in
  if not test then failwithf "test 2322 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a295; b295 = #{ a187; b187 = #{ a186 } } } = r in
  let expected_a295 = "100" in
  mark_test_run 2323;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a295 a295 in
  if not test then failwithf "test 2323 failed";
  let expected_a187 = (unbox_unit ()) in
  mark_test_run 2324;
  let test = (fun _ _ -> true) expected_a187 a187 in
  if not test then failwithf "test 2324 failed";
  let expected_a186 = "101" in
  mark_test_run 2325;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 2325 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a295; b295 } = r in
  let expected_a295 = "100" in
  mark_test_run 2326;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a295 a295 in
  if not test then failwithf "test 2326 failed";
  let expected_b295 = #{ a187 = (unbox_unit ()); b187 = #{ a186 = "101" } } in
  mark_test_run 2327;
  let test = (fun #{ a187 = a1871; b187 = b1871 } #{ a187 = a1872; b187 = b1872 } -> (fun _ _ -> true) a1871 a1872 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1871 b1872) expected_b295 b295 in
  if not test then failwithf "test 2327 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t296 = { string; #{ string } }   *)
  (**************************************)
  let r = { a296 = "0"; b296 = #{ a186 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a296 *)
  let actual = r.a296 in
  let expected = "0" in
  mark_test_run 2328;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2328 failed";
  (* Paths of depth 1 *)
  (* .b296 *)
  let actual = r.b296 in
  let expected = #{ a186 = "1" } in
  mark_test_run 2329;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 2329 failed";
  (* Paths of depth 2 *)
  (* .b296.#a186 *)
  let actual = r.b296.#a186 in
  let expected = "1" in
  mark_test_run 2330;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2330 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a296 = a2961; b296 = b2961 } { a296 = a2962; b296 = b2962 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2961 a2962 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b2961 b2962) in
  let next_r = { a296 = "100"; b296 = #{ a186 = "101" } } in
  let r_expected = { a296 = "0"; b296 = #{ a186 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a296 *)
  r.a296 <- next_r.a296;
  let r_expected = { r_expected with a296 = next_r.a296 } in
  mark_test_run 2331;
  let test = eq r r_expected in
  if not test then failwithf "test 2331 failed";
  Gc.compact ();
  (* .b296 *)
  r.b296 <- next_r.b296;
  let r_expected = { r_expected with b296 = next_r.b296 } in
  mark_test_run 2332;
  let test = eq r r_expected in
  if not test then failwithf "test 2332 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a296; b296 = #{ a186 } } = r in
  let expected_a296 = "100" in
  mark_test_run 2333;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a296 a296 in
  if not test then failwithf "test 2333 failed";
  let expected_a186 = "101" in
  mark_test_run 2334;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 2334 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a296; b296 } = r in
  let expected_a296 = "100" in
  mark_test_run 2335;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a296 a296 in
  if not test then failwithf "test 2335 failed";
  let expected_b296 = #{ a186 = "101" } in
  mark_test_run 2336;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) expected_b296 b296 in
  if not test then failwithf "test 2336 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t297 = { string; #{ string; unit_u } }   *)
  (**********************************************)
  let r = { a297 = "0"; b297 = #{ a190 = "1"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a297 *)
  let actual = r.a297 in
  let expected = "0" in
  mark_test_run 2337;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2337 failed";
  (* Paths of depth 1 *)
  (* .b297 *)
  let actual = r.b297 in
  let expected = #{ a190 = "1"; b190 = (unbox_unit ()) } in
  mark_test_run 2338;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 2338 failed";
  (* Paths of depth 2 *)
  (* .b297.#a190 *)
  let actual = r.b297.#a190 in
  let expected = "1" in
  mark_test_run 2339;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2339 failed";
  (* .b297.#b190 *)
  let actual = r.b297.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 2340;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2340 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a297 = a2971; b297 = b2971 } { a297 = a2972; b297 = b2972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2971 a2972 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b2971 b2972) in
  let next_r = { a297 = "100"; b297 = #{ a190 = "101"; b190 = (unbox_unit ()) } } in
  let r_expected = { a297 = "0"; b297 = #{ a190 = "1"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a297 *)
  r.a297 <- next_r.a297;
  let r_expected = { r_expected with a297 = next_r.a297 } in
  mark_test_run 2341;
  let test = eq r r_expected in
  if not test then failwithf "test 2341 failed";
  Gc.compact ();
  (* .b297 *)
  r.b297 <- next_r.b297;
  let r_expected = { r_expected with b297 = next_r.b297 } in
  mark_test_run 2342;
  let test = eq r r_expected in
  if not test then failwithf "test 2342 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a297; b297 = #{ a190; b190 } } = r in
  let expected_a297 = "100" in
  mark_test_run 2343;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a297 a297 in
  if not test then failwithf "test 2343 failed";
  let expected_a190 = "101" in
  mark_test_run 2344;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 2344 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 2345;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 2345 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a297; b297 } = r in
  let expected_a297 = "100" in
  mark_test_run 2346;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a297 a297 in
  if not test then failwithf "test 2346 failed";
  let expected_b297 = #{ a190 = "101"; b190 = (unbox_unit ()) } in
  mark_test_run 2347;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) expected_b297 b297 in
  if not test then failwithf "test 2347 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t298 = { string; #{ string; string } }   *)
  (**********************************************)
  let r = { a298 = "0"; b298 = #{ a192 = "1"; b192 = "2" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a298 *)
  let actual = r.a298 in
  let expected = "0" in
  mark_test_run 2348;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2348 failed";
  (* Paths of depth 1 *)
  (* .b298 *)
  let actual = r.b298 in
  let expected = #{ a192 = "1"; b192 = "2" } in
  mark_test_run 2349;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 2349 failed";
  (* Paths of depth 2 *)
  (* .b298.#a192 *)
  let actual = r.b298.#a192 in
  let expected = "1" in
  mark_test_run 2350;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2350 failed";
  (* .b298.#b192 *)
  let actual = r.b298.#b192 in
  let expected = "2" in
  mark_test_run 2351;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2351 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a298 = a2981; b298 = b2981 } { a298 = a2982; b298 = b2982 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2981 a2982 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b2981 b2982) in
  let next_r = { a298 = "100"; b298 = #{ a192 = "101"; b192 = "102" } } in
  let r_expected = { a298 = "0"; b298 = #{ a192 = "1"; b192 = "2" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a298 *)
  r.a298 <- next_r.a298;
  let r_expected = { r_expected with a298 = next_r.a298 } in
  mark_test_run 2352;
  let test = eq r r_expected in
  if not test then failwithf "test 2352 failed";
  Gc.compact ();
  (* .b298 *)
  r.b298 <- next_r.b298;
  let r_expected = { r_expected with b298 = next_r.b298 } in
  mark_test_run 2353;
  let test = eq r r_expected in
  if not test then failwithf "test 2353 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a298; b298 = #{ a192; b192 } } = r in
  let expected_a298 = "100" in
  mark_test_run 2354;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a298 a298 in
  if not test then failwithf "test 2354 failed";
  let expected_a192 = "101" in
  mark_test_run 2355;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 2355 failed";
  let expected_b192 = "102" in
  mark_test_run 2356;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 2356 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a298; b298 } = r in
  let expected_a298 = "100" in
  mark_test_run 2357;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a298 a298 in
  if not test then failwithf "test 2357 failed";
  let expected_b298 = #{ a192 = "101"; b192 = "102" } in
  mark_test_run 2358;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) expected_b298 b298 in
  if not test then failwithf "test 2358 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t299 = { string; #{ string; #{ unit_u } } }   *)
  (***************************************************)
  let r = { a299 = "0"; b299 = #{ a195 = "1"; b195 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a299 *)
  let actual = r.a299 in
  let expected = "0" in
  mark_test_run 2359;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2359 failed";
  (* Paths of depth 1 *)
  (* .b299 *)
  let actual = r.b299 in
  let expected = #{ a195 = "1"; b195 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 2360;
  let test = (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) actual expected in
  if not test then failwithf "test 2360 failed";
  (* Paths of depth 2 *)
  (* .b299.#a195 *)
  let actual = r.b299.#a195 in
  let expected = "1" in
  mark_test_run 2361;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2361 failed";
  (* .b299.#b195 *)
  let actual = r.b299.#b195 in
  let expected = #{ a194 = (unbox_unit ()) } in
  mark_test_run 2362;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) actual expected in
  if not test then failwithf "test 2362 failed";
  (* Paths of depth 3 *)
  (* .b299.#b195.#a194 *)
  let actual = r.b299.#b195.#a194 in
  let expected = (unbox_unit ()) in
  mark_test_run 2363;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2363 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a299 = a2991; b299 = b2991 } { a299 = a2992; b299 = b2992 } -> (fun a b -> String.equal (globalize a) (globalize b)) a2991 a2992 && (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) b2991 b2992) in
  let next_r = { a299 = "100"; b299 = #{ a195 = "101"; b195 = #{ a194 = (unbox_unit ()) } } } in
  let r_expected = { a299 = "0"; b299 = #{ a195 = "1"; b195 = #{ a194 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a299 *)
  r.a299 <- next_r.a299;
  let r_expected = { r_expected with a299 = next_r.a299 } in
  mark_test_run 2364;
  let test = eq r r_expected in
  if not test then failwithf "test 2364 failed";
  Gc.compact ();
  (* .b299 *)
  r.b299 <- next_r.b299;
  let r_expected = { r_expected with b299 = next_r.b299 } in
  mark_test_run 2365;
  let test = eq r r_expected in
  if not test then failwithf "test 2365 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a299; b299 = #{ a195; b195 = #{ a194 } } } = r in
  let expected_a299 = "100" in
  mark_test_run 2366;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a299 a299 in
  if not test then failwithf "test 2366 failed";
  let expected_a195 = "101" in
  mark_test_run 2367;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a195 a195 in
  if not test then failwithf "test 2367 failed";
  let expected_a194 = (unbox_unit ()) in
  mark_test_run 2368;
  let test = (fun _ _ -> true) expected_a194 a194 in
  if not test then failwithf "test 2368 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a299; b299 } = r in
  let expected_a299 = "100" in
  mark_test_run 2369;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a299 a299 in
  if not test then failwithf "test 2369 failed";
  let expected_b299 = #{ a195 = "101"; b195 = #{ a194 = (unbox_unit ()) } } in
  mark_test_run 2370;
  let test = (fun #{ a195 = a1951; b195 = b1951 } #{ a195 = a1952; b195 = b1952 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1951 a1952 && (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) b1951 b1952) expected_b299 b299 in
  if not test then failwithf "test 2370 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t300 = { string; #{ string; #{ string } } }   *)
  (***************************************************)
  let r = { a300 = "0"; b300 = #{ a197 = "1"; b197 = #{ a186 = "2" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a300 *)
  let actual = r.a300 in
  let expected = "0" in
  mark_test_run 2371;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2371 failed";
  (* Paths of depth 1 *)
  (* .b300 *)
  let actual = r.b300 in
  let expected = #{ a197 = "1"; b197 = #{ a186 = "2" } } in
  mark_test_run 2372;
  let test = (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) actual expected in
  if not test then failwithf "test 2372 failed";
  (* Paths of depth 2 *)
  (* .b300.#a197 *)
  let actual = r.b300.#a197 in
  let expected = "1" in
  mark_test_run 2373;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2373 failed";
  (* .b300.#b197 *)
  let actual = r.b300.#b197 in
  let expected = #{ a186 = "2" } in
  mark_test_run 2374;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 2374 failed";
  (* Paths of depth 3 *)
  (* .b300.#b197.#a186 *)
  let actual = r.b300.#b197.#a186 in
  let expected = "2" in
  mark_test_run 2375;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2375 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a300 = a3001; b300 = b3001 } { a300 = a3002; b300 = b3002 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3001 a3002 && (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) b3001 b3002) in
  let next_r = { a300 = "100"; b300 = #{ a197 = "101"; b197 = #{ a186 = "102" } } } in
  let r_expected = { a300 = "0"; b300 = #{ a197 = "1"; b197 = #{ a186 = "2" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a300 *)
  r.a300 <- next_r.a300;
  let r_expected = { r_expected with a300 = next_r.a300 } in
  mark_test_run 2376;
  let test = eq r r_expected in
  if not test then failwithf "test 2376 failed";
  Gc.compact ();
  (* .b300 *)
  r.b300 <- next_r.b300;
  let r_expected = { r_expected with b300 = next_r.b300 } in
  mark_test_run 2377;
  let test = eq r r_expected in
  if not test then failwithf "test 2377 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a300; b300 = #{ a197; b197 = #{ a186 } } } = r in
  let expected_a300 = "100" in
  mark_test_run 2378;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a300 a300 in
  if not test then failwithf "test 2378 failed";
  let expected_a197 = "101" in
  mark_test_run 2379;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a197 a197 in
  if not test then failwithf "test 2379 failed";
  let expected_a186 = "102" in
  mark_test_run 2380;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 2380 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a300; b300 } = r in
  let expected_a300 = "100" in
  mark_test_run 2381;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a300 a300 in
  if not test then failwithf "test 2381 failed";
  let expected_b300 = #{ a197 = "101"; b197 = #{ a186 = "102" } } in
  mark_test_run 2382;
  let test = (fun #{ a197 = a1971; b197 = b1971 } #{ a197 = a1972; b197 = b1972 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1971 a1972 && (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) b1971 b1972) expected_b300 b300 in
  if not test then failwithf "test 2382 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t302 = { string; #{ #{ unit_u; unit_u } } }   *)
  (***************************************************)
  let r = { a302 = "0"; b302 = #{ a301 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a302 *)
  let actual = r.a302 in
  let expected = "0" in
  mark_test_run 2383;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2383 failed";
  (* Paths of depth 1 *)
  (* .b302 *)
  let actual = r.b302 in
  let expected = #{ a301 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  mark_test_run 2384;
  let test = (fun #{ a301 = a3011 } #{ a301 = a3012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a3011 a3012) actual expected in
  if not test then failwithf "test 2384 failed";
  (* Paths of depth 2 *)
  (* .b302.#a301 *)
  let actual = r.b302.#a301 in
  let expected = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 2385;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) actual expected in
  if not test then failwithf "test 2385 failed";
  (* Paths of depth 3 *)
  (* .b302.#a301.#a290 *)
  let actual = r.b302.#a301.#a290 in
  let expected = (unbox_unit ()) in
  mark_test_run 2386;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2386 failed";
  (* .b302.#a301.#b290 *)
  let actual = r.b302.#a301.#b290 in
  let expected = (unbox_unit ()) in
  mark_test_run 2387;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2387 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a302 = a3021; b302 = b3021 } { a302 = a3022; b302 = b3022 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3021 a3022 && (fun #{ a301 = a3011 } #{ a301 = a3012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a3011 a3012) b3021 b3022) in
  let next_r = { a302 = "100"; b302 = #{ a301 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  let r_expected = { a302 = "0"; b302 = #{ a301 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a302 *)
  r.a302 <- next_r.a302;
  let r_expected = { r_expected with a302 = next_r.a302 } in
  mark_test_run 2388;
  let test = eq r r_expected in
  if not test then failwithf "test 2388 failed";
  Gc.compact ();
  (* .b302 *)
  r.b302 <- next_r.b302;
  let r_expected = { r_expected with b302 = next_r.b302 } in
  mark_test_run 2389;
  let test = eq r r_expected in
  if not test then failwithf "test 2389 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a302; b302 = #{ a301 = #{ a290; b290 } } } = r in
  let expected_a302 = "100" in
  mark_test_run 2390;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a302 a302 in
  if not test then failwithf "test 2390 failed";
  let expected_a290 = (unbox_unit ()) in
  mark_test_run 2391;
  let test = (fun _ _ -> true) expected_a290 a290 in
  if not test then failwithf "test 2391 failed";
  let expected_b290 = (unbox_unit ()) in
  mark_test_run 2392;
  let test = (fun _ _ -> true) expected_b290 b290 in
  if not test then failwithf "test 2392 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a302; b302 } = r in
  let expected_a302 = "100" in
  mark_test_run 2393;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a302 a302 in
  if not test then failwithf "test 2393 failed";
  let expected_b302 = #{ a301 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  mark_test_run 2394;
  let test = (fun #{ a301 = a3011 } #{ a301 = a3012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a3011 a3012) expected_b302 b302 in
  if not test then failwithf "test 2394 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t303 = { string; #{ #{ unit_u; string } } }   *)
  (***************************************************)
  let r = { a303 = "0"; b303 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a303 *)
  let actual = r.a303 in
  let expected = "0" in
  mark_test_run 2395;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2395 failed";
  (* Paths of depth 1 *)
  (* .b303 *)
  let actual = r.b303 in
  let expected = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "1" } } in
  mark_test_run 2396;
  let test = (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) actual expected in
  if not test then failwithf "test 2396 failed";
  (* Paths of depth 2 *)
  (* .b303.#a199 *)
  let actual = r.b303.#a199 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "1" } in
  mark_test_run 2397;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 2397 failed";
  (* Paths of depth 3 *)
  (* .b303.#a199.#a184 *)
  let actual = r.b303.#a199.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 2398;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2398 failed";
  (* .b303.#a199.#b184 *)
  let actual = r.b303.#a199.#b184 in
  let expected = "1" in
  mark_test_run 2399;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2399 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a303 = a3031; b303 = b3031 } { a303 = a3032; b303 = b3032 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3031 a3032 && (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) b3031 b3032) in
  let next_r = { a303 = "100"; b303 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "101" } } } in
  let r_expected = { a303 = "0"; b303 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a303 *)
  r.a303 <- next_r.a303;
  let r_expected = { r_expected with a303 = next_r.a303 } in
  mark_test_run 2400;
  let test = eq r r_expected in
  if not test then failwithf "test 2400 failed";
  Gc.compact ();
  (* .b303 *)
  r.b303 <- next_r.b303;
  let r_expected = { r_expected with b303 = next_r.b303 } in
  mark_test_run 2401;
  let test = eq r r_expected in
  if not test then failwithf "test 2401 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a303; b303 = #{ a199 = #{ a184; b184 } } } = r in
  let expected_a303 = "100" in
  mark_test_run 2402;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a303 a303 in
  if not test then failwithf "test 2402 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 2403;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 2403 failed";
  let expected_b184 = "101" in
  mark_test_run 2404;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 2404 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a303; b303 } = r in
  let expected_a303 = "100" in
  mark_test_run 2405;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a303 a303 in
  if not test then failwithf "test 2405 failed";
  let expected_b303 = #{ a199 = #{ a184 = (unbox_unit ()); b184 = "101" } } in
  mark_test_run 2406;
  let test = (fun #{ a199 = a1991 } #{ a199 = a1992 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a1991 a1992) expected_b303 b303 in
  if not test then failwithf "test 2406 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t304 = { string; #{ #{ string; unit_u } } }   *)
  (***************************************************)
  let r = { a304 = "0"; b304 = #{ a201 = #{ a190 = "1"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a304 *)
  let actual = r.a304 in
  let expected = "0" in
  mark_test_run 2407;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2407 failed";
  (* Paths of depth 1 *)
  (* .b304 *)
  let actual = r.b304 in
  let expected = #{ a201 = #{ a190 = "1"; b190 = (unbox_unit ()) } } in
  mark_test_run 2408;
  let test = (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) actual expected in
  if not test then failwithf "test 2408 failed";
  (* Paths of depth 2 *)
  (* .b304.#a201 *)
  let actual = r.b304.#a201 in
  let expected = #{ a190 = "1"; b190 = (unbox_unit ()) } in
  mark_test_run 2409;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 2409 failed";
  (* Paths of depth 3 *)
  (* .b304.#a201.#a190 *)
  let actual = r.b304.#a201.#a190 in
  let expected = "1" in
  mark_test_run 2410;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2410 failed";
  (* .b304.#a201.#b190 *)
  let actual = r.b304.#a201.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 2411;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2411 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a304 = a3041; b304 = b3041 } { a304 = a3042; b304 = b3042 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3041 a3042 && (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) b3041 b3042) in
  let next_r = { a304 = "100"; b304 = #{ a201 = #{ a190 = "101"; b190 = (unbox_unit ()) } } } in
  let r_expected = { a304 = "0"; b304 = #{ a201 = #{ a190 = "1"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a304 *)
  r.a304 <- next_r.a304;
  let r_expected = { r_expected with a304 = next_r.a304 } in
  mark_test_run 2412;
  let test = eq r r_expected in
  if not test then failwithf "test 2412 failed";
  Gc.compact ();
  (* .b304 *)
  r.b304 <- next_r.b304;
  let r_expected = { r_expected with b304 = next_r.b304 } in
  mark_test_run 2413;
  let test = eq r r_expected in
  if not test then failwithf "test 2413 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a304; b304 = #{ a201 = #{ a190; b190 } } } = r in
  let expected_a304 = "100" in
  mark_test_run 2414;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a304 a304 in
  if not test then failwithf "test 2414 failed";
  let expected_a190 = "101" in
  mark_test_run 2415;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 2415 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 2416;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 2416 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a304; b304 } = r in
  let expected_a304 = "100" in
  mark_test_run 2417;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a304 a304 in
  if not test then failwithf "test 2417 failed";
  let expected_b304 = #{ a201 = #{ a190 = "101"; b190 = (unbox_unit ()) } } in
  mark_test_run 2418;
  let test = (fun #{ a201 = a2011 } #{ a201 = a2012 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a2011 a2012) expected_b304 b304 in
  if not test then failwithf "test 2418 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t305 = { string; #{ #{ string; string } } }   *)
  (***************************************************)
  let r = { a305 = "0"; b305 = #{ a203 = #{ a192 = "1"; b192 = "2" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a305 *)
  let actual = r.a305 in
  let expected = "0" in
  mark_test_run 2419;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2419 failed";
  (* Paths of depth 1 *)
  (* .b305 *)
  let actual = r.b305 in
  let expected = #{ a203 = #{ a192 = "1"; b192 = "2" } } in
  mark_test_run 2420;
  let test = (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) actual expected in
  if not test then failwithf "test 2420 failed";
  (* Paths of depth 2 *)
  (* .b305.#a203 *)
  let actual = r.b305.#a203 in
  let expected = #{ a192 = "1"; b192 = "2" } in
  mark_test_run 2421;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 2421 failed";
  (* Paths of depth 3 *)
  (* .b305.#a203.#a192 *)
  let actual = r.b305.#a203.#a192 in
  let expected = "1" in
  mark_test_run 2422;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2422 failed";
  (* .b305.#a203.#b192 *)
  let actual = r.b305.#a203.#b192 in
  let expected = "2" in
  mark_test_run 2423;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2423 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a305 = a3051; b305 = b3051 } { a305 = a3052; b305 = b3052 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3051 a3052 && (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) b3051 b3052) in
  let next_r = { a305 = "100"; b305 = #{ a203 = #{ a192 = "101"; b192 = "102" } } } in
  let r_expected = { a305 = "0"; b305 = #{ a203 = #{ a192 = "1"; b192 = "2" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a305 *)
  r.a305 <- next_r.a305;
  let r_expected = { r_expected with a305 = next_r.a305 } in
  mark_test_run 2424;
  let test = eq r r_expected in
  if not test then failwithf "test 2424 failed";
  Gc.compact ();
  (* .b305 *)
  r.b305 <- next_r.b305;
  let r_expected = { r_expected with b305 = next_r.b305 } in
  mark_test_run 2425;
  let test = eq r r_expected in
  if not test then failwithf "test 2425 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a305; b305 = #{ a203 = #{ a192; b192 } } } = r in
  let expected_a305 = "100" in
  mark_test_run 2426;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a305 a305 in
  if not test then failwithf "test 2426 failed";
  let expected_a192 = "101" in
  mark_test_run 2427;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 2427 failed";
  let expected_b192 = "102" in
  mark_test_run 2428;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 2428 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a305; b305 } = r in
  let expected_a305 = "100" in
  mark_test_run 2429;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a305 a305 in
  if not test then failwithf "test 2429 failed";
  let expected_b305 = #{ a203 = #{ a192 = "101"; b192 = "102" } } in
  mark_test_run 2430;
  let test = (fun #{ a203 = a2031 } #{ a203 = a2032 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a2031 a2032) expected_b305 b305 in
  if not test then failwithf "test 2430 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************)
  (*   t306 = { int64x2# }   *)
  (***************************)
  let r = { a306 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a306 *)
  let actual = r.a306 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2431;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2431 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a306 = a3061 } { a306 = a3062 } -> int64x2_u_equal a3061 a3062) in
  let next_r = { a306 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } in
  let r_expected = { a306 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a306 *)
  r.a306 <- next_r.a306;
  let r_expected = { r_expected with a306 = next_r.a306 } in
  mark_test_run 2432;
  let test = eq r r_expected in
  if not test then failwithf "test 2432 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a306 } = r in
  let expected_a306 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2433;
  let test = int64x2_u_equal expected_a306 a306 in
  if not test then failwithf "test 2433 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a306 } = r in
  let expected_a306 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2434;
  let test = int64x2_u_equal expected_a306 a306 in
  if not test then failwithf "test 2434 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t307 = { int64x2#; int }   *)
  (********************************)
  let r = { a307 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b307 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a307 *)
  let actual = r.a307 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2435;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2435 failed";
  (* Paths of depth 1 *)
  (* .b307 *)
  let actual = r.b307 in
  let expected = 2 in
  mark_test_run 2436;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2436 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a307 = a3071; b307 = b3071 } { a307 = a3072; b307 = b3072 } -> int64x2_u_equal a3071 a3072 && (fun a b -> Int.equal a b) b3071 b3072) in
  let next_r = { a307 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b307 = 102 } in
  let r_expected = { a307 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b307 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a307 *)
  r.a307 <- next_r.a307;
  let r_expected = { r_expected with a307 = next_r.a307 } in
  mark_test_run 2437;
  let test = eq r r_expected in
  if not test then failwithf "test 2437 failed";
  Gc.compact ();
  (* .b307 *)
  r.b307 <- next_r.b307;
  let r_expected = { r_expected with b307 = next_r.b307 } in
  mark_test_run 2438;
  let test = eq r r_expected in
  if not test then failwithf "test 2438 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a307; b307 } = r in
  let expected_a307 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2439;
  let test = int64x2_u_equal expected_a307 a307 in
  if not test then failwithf "test 2439 failed";
  let expected_b307 = 102 in
  mark_test_run 2440;
  let test = (fun a b -> Int.equal a b) expected_b307 b307 in
  if not test then failwithf "test 2440 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a307; b307 } = r in
  let expected_a307 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2441;
  let test = int64x2_u_equal expected_a307 a307 in
  if not test then failwithf "test 2441 failed";
  let expected_b307 = 102 in
  mark_test_run 2442;
  let test = (fun a b -> Int.equal a b) expected_b307 b307 in
  if not test then failwithf "test 2442 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t308 = { int64x2#; int; int }   *)
  (*************************************)
  let r = { a308 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b308 = 2; c308 = 3 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a308 *)
  let actual = r.a308 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2443;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2443 failed";
  (* Paths of depth 1 *)
  (* .b308 *)
  let actual = r.b308 in
  let expected = 2 in
  mark_test_run 2444;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2444 failed";
  (* Paths of depth 1 *)
  (* .c308 *)
  let actual = r.c308 in
  let expected = 3 in
  mark_test_run 2445;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2445 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a308 = a3081; b308 = b3081; c308 = c3081 } { a308 = a3082; b308 = b3082; c308 = c3082 } -> int64x2_u_equal a3081 a3082 && (fun a b -> Int.equal a b) b3081 b3082 && (fun a b -> Int.equal a b) c3081 c3082) in
  let next_r = { a308 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b308 = 102; c308 = 103 } in
  let r_expected = { a308 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b308 = 2; c308 = 3 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a308 *)
  r.a308 <- next_r.a308;
  let r_expected = { r_expected with a308 = next_r.a308 } in
  mark_test_run 2446;
  let test = eq r r_expected in
  if not test then failwithf "test 2446 failed";
  Gc.compact ();
  (* .b308 *)
  r.b308 <- next_r.b308;
  let r_expected = { r_expected with b308 = next_r.b308 } in
  mark_test_run 2447;
  let test = eq r r_expected in
  if not test then failwithf "test 2447 failed";
  Gc.compact ();
  (* .c308 *)
  r.c308 <- next_r.c308;
  let r_expected = { r_expected with c308 = next_r.c308 } in
  mark_test_run 2448;
  let test = eq r r_expected in
  if not test then failwithf "test 2448 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a308; b308; c308 } = r in
  let expected_a308 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2449;
  let test = int64x2_u_equal expected_a308 a308 in
  if not test then failwithf "test 2449 failed";
  let expected_b308 = 102 in
  mark_test_run 2450;
  let test = (fun a b -> Int.equal a b) expected_b308 b308 in
  if not test then failwithf "test 2450 failed";
  let expected_c308 = 103 in
  mark_test_run 2451;
  let test = (fun a b -> Int.equal a b) expected_c308 c308 in
  if not test then failwithf "test 2451 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a308; b308; c308 } = r in
  let expected_a308 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2452;
  let test = int64x2_u_equal expected_a308 a308 in
  if not test then failwithf "test 2452 failed";
  let expected_b308 = 102 in
  mark_test_run 2453;
  let test = (fun a b -> Int.equal a b) expected_b308 b308 in
  if not test then failwithf "test 2453 failed";
  let expected_c308 = 103 in
  mark_test_run 2454;
  let test = (fun a b -> Int.equal a b) expected_c308 c308 in
  if not test then failwithf "test 2454 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t309 = { int64x2#; int; int64x2# }   *)
  (******************************************)
  let r = { a309 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b309 = 2; c309 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a309 *)
  let actual = r.a309 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2455;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2455 failed";
  (* Paths of depth 1 *)
  (* .b309 *)
  let actual = r.b309 in
  let expected = 2 in
  mark_test_run 2456;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2456 failed";
  (* Paths of depth 1 *)
  (* .c309 *)
  let actual = r.c309 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 2457;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2457 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a309 = a3091; b309 = b3091; c309 = c3091 } { a309 = a3092; b309 = b3092; c309 = c3092 } -> int64x2_u_equal a3091 a3092 && (fun a b -> Int.equal a b) b3091 b3092 && int64x2_u_equal c3091 c3092) in
  let next_r = { a309 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b309 = 102; c309 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  let r_expected = { a309 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b309 = 2; c309 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a309 *)
  r.a309 <- next_r.a309;
  let r_expected = { r_expected with a309 = next_r.a309 } in
  mark_test_run 2458;
  let test = eq r r_expected in
  if not test then failwithf "test 2458 failed";
  Gc.compact ();
  (* .b309 *)
  r.b309 <- next_r.b309;
  let r_expected = { r_expected with b309 = next_r.b309 } in
  mark_test_run 2459;
  let test = eq r r_expected in
  if not test then failwithf "test 2459 failed";
  Gc.compact ();
  (* .c309 *)
  r.c309 <- next_r.c309;
  let r_expected = { r_expected with c309 = next_r.c309 } in
  mark_test_run 2460;
  let test = eq r r_expected in
  if not test then failwithf "test 2460 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a309; b309; c309 } = r in
  let expected_a309 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2461;
  let test = int64x2_u_equal expected_a309 a309 in
  if not test then failwithf "test 2461 failed";
  let expected_b309 = 102 in
  mark_test_run 2462;
  let test = (fun a b -> Int.equal a b) expected_b309 b309 in
  if not test then failwithf "test 2462 failed";
  let expected_c309 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 2463;
  let test = int64x2_u_equal expected_c309 c309 in
  if not test then failwithf "test 2463 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a309; b309; c309 } = r in
  let expected_a309 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2464;
  let test = int64x2_u_equal expected_a309 a309 in
  if not test then failwithf "test 2464 failed";
  let expected_b309 = 102 in
  mark_test_run 2465;
  let test = (fun a b -> Int.equal a b) expected_b309 b309 in
  if not test then failwithf "test 2465 failed";
  let expected_c309 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 2466;
  let test = int64x2_u_equal expected_c309 c309 in
  if not test then failwithf "test 2466 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t310 = { int64x2#; int64x2# }   *)
  (*************************************)
  let r = { a310 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b310 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a310 *)
  let actual = r.a310 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2467;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2467 failed";
  (* Paths of depth 1 *)
  (* .b310 *)
  let actual = r.b310 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2468;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2468 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a310 = a3101; b310 = b3101 } { a310 = a3102; b310 = b3102 } -> int64x2_u_equal a3101 a3102 && int64x2_u_equal b3101 b3102) in
  let next_r = { a310 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b310 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  let r_expected = { a310 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b310 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a310 *)
  r.a310 <- next_r.a310;
  let r_expected = { r_expected with a310 = next_r.a310 } in
  mark_test_run 2469;
  let test = eq r r_expected in
  if not test then failwithf "test 2469 failed";
  Gc.compact ();
  (* .b310 *)
  r.b310 <- next_r.b310;
  let r_expected = { r_expected with b310 = next_r.b310 } in
  mark_test_run 2470;
  let test = eq r r_expected in
  if not test then failwithf "test 2470 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a310; b310 } = r in
  let expected_a310 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2471;
  let test = int64x2_u_equal expected_a310 a310 in
  if not test then failwithf "test 2471 failed";
  let expected_b310 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2472;
  let test = int64x2_u_equal expected_b310 b310 in
  if not test then failwithf "test 2472 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a310; b310 } = r in
  let expected_a310 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2473;
  let test = int64x2_u_equal expected_a310 a310 in
  if not test then failwithf "test 2473 failed";
  let expected_b310 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2474;
  let test = int64x2_u_equal expected_b310 b310 in
  if not test then failwithf "test 2474 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t311 = { int64x2#; int64x2#; int }   *)
  (******************************************)
  let r = { a311 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b311 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c311 = 4 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a311 *)
  let actual = r.a311 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2475;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2475 failed";
  (* Paths of depth 1 *)
  (* .b311 *)
  let actual = r.b311 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2476;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2476 failed";
  (* Paths of depth 1 *)
  (* .c311 *)
  let actual = r.c311 in
  let expected = 4 in
  mark_test_run 2477;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2477 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a311 = a3111; b311 = b3111; c311 = c3111 } { a311 = a3112; b311 = b3112; c311 = c3112 } -> int64x2_u_equal a3111 a3112 && int64x2_u_equal b3111 b3112 && (fun a b -> Int.equal a b) c3111 c3112) in
  let next_r = { a311 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b311 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); c311 = 104 } in
  let r_expected = { a311 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b311 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c311 = 4 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a311 *)
  r.a311 <- next_r.a311;
  let r_expected = { r_expected with a311 = next_r.a311 } in
  mark_test_run 2478;
  let test = eq r r_expected in
  if not test then failwithf "test 2478 failed";
  Gc.compact ();
  (* .b311 *)
  r.b311 <- next_r.b311;
  let r_expected = { r_expected with b311 = next_r.b311 } in
  mark_test_run 2479;
  let test = eq r r_expected in
  if not test then failwithf "test 2479 failed";
  Gc.compact ();
  (* .c311 *)
  r.c311 <- next_r.c311;
  let r_expected = { r_expected with c311 = next_r.c311 } in
  mark_test_run 2480;
  let test = eq r r_expected in
  if not test then failwithf "test 2480 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a311; b311; c311 } = r in
  let expected_a311 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2481;
  let test = int64x2_u_equal expected_a311 a311 in
  if not test then failwithf "test 2481 failed";
  let expected_b311 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2482;
  let test = int64x2_u_equal expected_b311 b311 in
  if not test then failwithf "test 2482 failed";
  let expected_c311 = 104 in
  mark_test_run 2483;
  let test = (fun a b -> Int.equal a b) expected_c311 c311 in
  if not test then failwithf "test 2483 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a311; b311; c311 } = r in
  let expected_a311 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2484;
  let test = int64x2_u_equal expected_a311 a311 in
  if not test then failwithf "test 2484 failed";
  let expected_b311 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2485;
  let test = int64x2_u_equal expected_b311 b311 in
  if not test then failwithf "test 2485 failed";
  let expected_c311 = 104 in
  mark_test_run 2486;
  let test = (fun a b -> Int.equal a b) expected_c311 c311 in
  if not test then failwithf "test 2486 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t312 = { int64x2#; int64x2#; int64x2# }   *)
  (***********************************************)
  let r = { a312 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b312 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c312 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a312 *)
  let actual = r.a312 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2487;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2487 failed";
  (* Paths of depth 1 *)
  (* .b312 *)
  let actual = r.b312 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2488;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2488 failed";
  (* Paths of depth 1 *)
  (* .c312 *)
  let actual = r.c312 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 2489;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2489 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a312 = a3121; b312 = b3121; c312 = c3121 } { a312 = a3122; b312 = b3122; c312 = c3122 } -> int64x2_u_equal a3121 a3122 && int64x2_u_equal b3121 b3122 && int64x2_u_equal c3121 c3122) in
  let next_r = { a312 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b312 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); c312 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } in
  let r_expected = { a312 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b312 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c312 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a312 *)
  r.a312 <- next_r.a312;
  let r_expected = { r_expected with a312 = next_r.a312 } in
  mark_test_run 2490;
  let test = eq r r_expected in
  if not test then failwithf "test 2490 failed";
  Gc.compact ();
  (* .b312 *)
  r.b312 <- next_r.b312;
  let r_expected = { r_expected with b312 = next_r.b312 } in
  mark_test_run 2491;
  let test = eq r r_expected in
  if not test then failwithf "test 2491 failed";
  Gc.compact ();
  (* .c312 *)
  r.c312 <- next_r.c312;
  let r_expected = { r_expected with c312 = next_r.c312 } in
  mark_test_run 2492;
  let test = eq r r_expected in
  if not test then failwithf "test 2492 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a312; b312; c312 } = r in
  let expected_a312 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2493;
  let test = int64x2_u_equal expected_a312 a312 in
  if not test then failwithf "test 2493 failed";
  let expected_b312 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2494;
  let test = int64x2_u_equal expected_b312 b312 in
  if not test then failwithf "test 2494 failed";
  let expected_c312 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 2495;
  let test = int64x2_u_equal expected_c312 c312 in
  if not test then failwithf "test 2495 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a312; b312; c312 } = r in
  let expected_a312 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2496;
  let test = int64x2_u_equal expected_a312 a312 in
  if not test then failwithf "test 2496 failed";
  let expected_b312 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2497;
  let test = int64x2_u_equal expected_b312 b312 in
  if not test then failwithf "test 2497 failed";
  let expected_c312 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 2498;
  let test = int64x2_u_equal expected_c312 c312 in
  if not test then failwithf "test 2498 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t313 = { int64x2#; #{ int } }   *)
  (*************************************)
  let r = { a313 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b313 = #{ a27 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a313 *)
  let actual = r.a313 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2499;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2499 failed";
  (* Paths of depth 1 *)
  (* .b313 *)
  let actual = r.b313 in
  let expected = #{ a27 = 2 } in
  mark_test_run 2500;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 2500 failed";
  (* Paths of depth 2 *)
  (* .b313.#a27 *)
  let actual = r.b313.#a27 in
  let expected = 2 in
  mark_test_run 2501;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2501 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a313 = a3131; b313 = b3131 } { a313 = a3132; b313 = b3132 } -> int64x2_u_equal a3131 a3132 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b3131 b3132) in
  let next_r = { a313 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b313 = #{ a27 = 102 } } in
  let r_expected = { a313 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b313 = #{ a27 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a313 *)
  r.a313 <- next_r.a313;
  let r_expected = { r_expected with a313 = next_r.a313 } in
  mark_test_run 2502;
  let test = eq r r_expected in
  if not test then failwithf "test 2502 failed";
  Gc.compact ();
  (* .b313 *)
  r.b313 <- next_r.b313;
  let r_expected = { r_expected with b313 = next_r.b313 } in
  mark_test_run 2503;
  let test = eq r r_expected in
  if not test then failwithf "test 2503 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a313; b313 = #{ a27 } } = r in
  let expected_a313 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2504;
  let test = int64x2_u_equal expected_a313 a313 in
  if not test then failwithf "test 2504 failed";
  let expected_a27 = 102 in
  mark_test_run 2505;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 2505 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a313; b313 } = r in
  let expected_a313 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2506;
  let test = int64x2_u_equal expected_a313 a313 in
  if not test then failwithf "test 2506 failed";
  let expected_b313 = #{ a27 = 102 } in
  mark_test_run 2507;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_b313 b313 in
  if not test then failwithf "test 2507 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t314 = { int64x2#; #{ int; int } }   *)
  (******************************************)
  let r = { a314 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b314 = #{ a29 = 2; b29 = 3 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a314 *)
  let actual = r.a314 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2508;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2508 failed";
  (* Paths of depth 1 *)
  (* .b314 *)
  let actual = r.b314 in
  let expected = #{ a29 = 2; b29 = 3 } in
  mark_test_run 2509;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 2509 failed";
  (* Paths of depth 2 *)
  (* .b314.#a29 *)
  let actual = r.b314.#a29 in
  let expected = 2 in
  mark_test_run 2510;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2510 failed";
  (* .b314.#b29 *)
  let actual = r.b314.#b29 in
  let expected = 3 in
  mark_test_run 2511;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2511 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a314 = a3141; b314 = b3141 } { a314 = a3142; b314 = b3142 } -> int64x2_u_equal a3141 a3142 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b3141 b3142) in
  let next_r = { a314 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b314 = #{ a29 = 102; b29 = 103 } } in
  let r_expected = { a314 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b314 = #{ a29 = 2; b29 = 3 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a314 *)
  r.a314 <- next_r.a314;
  let r_expected = { r_expected with a314 = next_r.a314 } in
  mark_test_run 2512;
  let test = eq r r_expected in
  if not test then failwithf "test 2512 failed";
  Gc.compact ();
  (* .b314 *)
  r.b314 <- next_r.b314;
  let r_expected = { r_expected with b314 = next_r.b314 } in
  mark_test_run 2513;
  let test = eq r r_expected in
  if not test then failwithf "test 2513 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a314; b314 = #{ a29; b29 } } = r in
  let expected_a314 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2514;
  let test = int64x2_u_equal expected_a314 a314 in
  if not test then failwithf "test 2514 failed";
  let expected_a29 = 102 in
  mark_test_run 2515;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 2515 failed";
  let expected_b29 = 103 in
  mark_test_run 2516;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 2516 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a314; b314 } = r in
  let expected_a314 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2517;
  let test = int64x2_u_equal expected_a314 a314 in
  if not test then failwithf "test 2517 failed";
  let expected_b314 = #{ a29 = 102; b29 = 103 } in
  mark_test_run 2518;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_b314 b314 in
  if not test then failwithf "test 2518 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t315 = { int64x2#; #{ int; int64x2# } }   *)
  (***********************************************)
  let r = { a315 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b315 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a315 *)
  let actual = r.a315 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2519;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2519 failed";
  (* Paths of depth 1 *)
  (* .b315 *)
  let actual = r.b315 in
  let expected = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 2520;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 2520 failed";
  (* Paths of depth 2 *)
  (* .b315.#a35 *)
  let actual = r.b315.#a35 in
  let expected = 2 in
  mark_test_run 2521;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2521 failed";
  (* .b315.#b35 *)
  let actual = r.b315.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 2522;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2522 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a315 = a3151; b315 = b3151 } { a315 = a3152; b315 = b3152 } -> int64x2_u_equal a3151 a3152 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b3151 b3152) in
  let next_r = { a315 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b315 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  let r_expected = { a315 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b315 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a315 *)
  r.a315 <- next_r.a315;
  let r_expected = { r_expected with a315 = next_r.a315 } in
  mark_test_run 2523;
  let test = eq r r_expected in
  if not test then failwithf "test 2523 failed";
  Gc.compact ();
  (* .b315 *)
  r.b315 <- next_r.b315;
  let r_expected = { r_expected with b315 = next_r.b315 } in
  mark_test_run 2524;
  let test = eq r r_expected in
  if not test then failwithf "test 2524 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a315; b315 = #{ a35; b35 } } = r in
  let expected_a315 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2525;
  let test = int64x2_u_equal expected_a315 a315 in
  if not test then failwithf "test 2525 failed";
  let expected_a35 = 102 in
  mark_test_run 2526;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 2526 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 2527;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 2527 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a315; b315 } = r in
  let expected_a315 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2528;
  let test = int64x2_u_equal expected_a315 a315 in
  if not test then failwithf "test 2528 failed";
  let expected_b315 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  mark_test_run 2529;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) expected_b315 b315 in
  if not test then failwithf "test 2529 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t316 = { int64x2#; #{ int; #{ int } } }   *)
  (***********************************************)
  let r = { a316 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b316 = #{ a37 = 2; b37 = #{ a27 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a316 *)
  let actual = r.a316 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2530;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2530 failed";
  (* Paths of depth 1 *)
  (* .b316 *)
  let actual = r.b316 in
  let expected = #{ a37 = 2; b37 = #{ a27 = 3 } } in
  mark_test_run 2531;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) actual expected in
  if not test then failwithf "test 2531 failed";
  (* Paths of depth 2 *)
  (* .b316.#a37 *)
  let actual = r.b316.#a37 in
  let expected = 2 in
  mark_test_run 2532;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2532 failed";
  (* .b316.#b37 *)
  let actual = r.b316.#b37 in
  let expected = #{ a27 = 3 } in
  mark_test_run 2533;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 2533 failed";
  (* Paths of depth 3 *)
  (* .b316.#b37.#a27 *)
  let actual = r.b316.#b37.#a27 in
  let expected = 3 in
  mark_test_run 2534;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2534 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a316 = a3161; b316 = b3161 } { a316 = a3162; b316 = b3162 } -> int64x2_u_equal a3161 a3162 && (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) b3161 b3162) in
  let next_r = { a316 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b316 = #{ a37 = 102; b37 = #{ a27 = 103 } } } in
  let r_expected = { a316 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b316 = #{ a37 = 2; b37 = #{ a27 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a316 *)
  r.a316 <- next_r.a316;
  let r_expected = { r_expected with a316 = next_r.a316 } in
  mark_test_run 2535;
  let test = eq r r_expected in
  if not test then failwithf "test 2535 failed";
  Gc.compact ();
  (* .b316 *)
  r.b316 <- next_r.b316;
  let r_expected = { r_expected with b316 = next_r.b316 } in
  mark_test_run 2536;
  let test = eq r r_expected in
  if not test then failwithf "test 2536 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a316; b316 = #{ a37; b37 = #{ a27 } } } = r in
  let expected_a316 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2537;
  let test = int64x2_u_equal expected_a316 a316 in
  if not test then failwithf "test 2537 failed";
  let expected_a37 = 102 in
  mark_test_run 2538;
  let test = (fun a b -> Int.equal a b) expected_a37 a37 in
  if not test then failwithf "test 2538 failed";
  let expected_a27 = 103 in
  mark_test_run 2539;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 2539 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a316; b316 } = r in
  let expected_a316 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2540;
  let test = int64x2_u_equal expected_a316 a316 in
  if not test then failwithf "test 2540 failed";
  let expected_b316 = #{ a37 = 102; b37 = #{ a27 = 103 } } in
  mark_test_run 2541;
  let test = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b371 b372) expected_b316 b316 in
  if not test then failwithf "test 2541 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t317 = { int64x2#; #{ int; #{ int64x2# } } }   *)
  (****************************************************)
  let r = { a317 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b317 = #{ a46 = 2; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a317 *)
  let actual = r.a317 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2542;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2542 failed";
  (* Paths of depth 1 *)
  (* .b317 *)
  let actual = r.b317 in
  let expected = #{ a46 = 2; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 2543;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) actual expected in
  if not test then failwithf "test 2543 failed";
  (* Paths of depth 2 *)
  (* .b317.#a46 *)
  let actual = r.b317.#a46 in
  let expected = 2 in
  mark_test_run 2544;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2544 failed";
  (* .b317.#b46 *)
  let actual = r.b317.#b46 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 2545;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 2545 failed";
  (* Paths of depth 3 *)
  (* .b317.#b46.#a45 *)
  let actual = r.b317.#b46.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 2546;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2546 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a317 = a3171; b317 = b3171 } { a317 = a3172; b317 = b3172 } -> int64x2_u_equal a3171 a3172 && (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) b3171 b3172) in
  let next_r = { a317 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b317 = #{ a46 = 102; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a317 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b317 = #{ a46 = 2; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a317 *)
  r.a317 <- next_r.a317;
  let r_expected = { r_expected with a317 = next_r.a317 } in
  mark_test_run 2547;
  let test = eq r r_expected in
  if not test then failwithf "test 2547 failed";
  Gc.compact ();
  (* .b317 *)
  r.b317 <- next_r.b317;
  let r_expected = { r_expected with b317 = next_r.b317 } in
  mark_test_run 2548;
  let test = eq r r_expected in
  if not test then failwithf "test 2548 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a317; b317 = #{ a46; b46 = #{ a45 } } } = r in
  let expected_a317 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2549;
  let test = int64x2_u_equal expected_a317 a317 in
  if not test then failwithf "test 2549 failed";
  let expected_a46 = 102 in
  mark_test_run 2550;
  let test = (fun a b -> Int.equal a b) expected_a46 a46 in
  if not test then failwithf "test 2550 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 2551;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 2551 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a317; b317 } = r in
  let expected_a317 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2552;
  let test = int64x2_u_equal expected_a317 a317 in
  if not test then failwithf "test 2552 failed";
  let expected_b317 = #{ a46 = 102; b46 = #{ a45 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 2553;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int.equal a b) a461 a462 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b461 b462) expected_b317 b317 in
  if not test then failwithf "test 2553 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t319 = { int64x2#; #{ string; float# } }   *)
  (************************************************)
  let r = { a319 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b319 = #{ a318 = "2"; b318 = #3. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a319 *)
  let actual = r.a319 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2554;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2554 failed";
  (* Paths of depth 1 *)
  (* .b319 *)
  let actual = r.b319 in
  let expected = #{ a318 = "2"; b318 = #3. } in
  mark_test_run 2555;
  let test = (fun #{ a318 = a3181; b318 = b3181 } #{ a318 = a3182; b318 = b3182 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3181 a3182 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b3181 b3182) actual expected in
  if not test then failwithf "test 2555 failed";
  (* Paths of depth 2 *)
  (* .b319.#a318 *)
  let actual = r.b319.#a318 in
  let expected = "2" in
  mark_test_run 2556;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2556 failed";
  (* .b319.#b318 *)
  let actual = r.b319.#b318 in
  let expected = #3. in
  mark_test_run 2557;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 2557 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a319 = a3191; b319 = b3191 } { a319 = a3192; b319 = b3192 } -> int64x2_u_equal a3191 a3192 && (fun #{ a318 = a3181; b318 = b3181 } #{ a318 = a3182; b318 = b3182 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3181 a3182 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b3181 b3182) b3191 b3192) in
  let next_r = { a319 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b319 = #{ a318 = "102"; b318 = #103. } } in
  let r_expected = { a319 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b319 = #{ a318 = "2"; b318 = #3. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a319 *)
  r.a319 <- next_r.a319;
  let r_expected = { r_expected with a319 = next_r.a319 } in
  mark_test_run 2558;
  let test = eq r r_expected in
  if not test then failwithf "test 2558 failed";
  Gc.compact ();
  (* .b319 *)
  r.b319 <- next_r.b319;
  let r_expected = { r_expected with b319 = next_r.b319 } in
  mark_test_run 2559;
  let test = eq r r_expected in
  if not test then failwithf "test 2559 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a319; b319 = #{ a318; b318 } } = r in
  let expected_a319 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2560;
  let test = int64x2_u_equal expected_a319 a319 in
  if not test then failwithf "test 2560 failed";
  let expected_a318 = "102" in
  mark_test_run 2561;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a318 a318 in
  if not test then failwithf "test 2561 failed";
  let expected_b318 = #103. in
  mark_test_run 2562;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b318 b318 in
  if not test then failwithf "test 2562 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a319; b319 } = r in
  let expected_a319 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2563;
  let test = int64x2_u_equal expected_a319 a319 in
  if not test then failwithf "test 2563 failed";
  let expected_b319 = #{ a318 = "102"; b318 = #103. } in
  mark_test_run 2564;
  let test = (fun #{ a318 = a3181; b318 = b3181 } #{ a318 = a3182; b318 = b3182 } -> (fun a b -> String.equal (globalize a) (globalize b)) a3181 a3182 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b3181 b3182) expected_b319 b319 in
  if not test then failwithf "test 2564 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t320 = { int64x2#; #{ int64x2# } }   *)
  (******************************************)
  let r = { a320 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b320 = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a320 *)
  let actual = r.a320 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2565;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2565 failed";
  (* Paths of depth 1 *)
  (* .b320 *)
  let actual = r.b320 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 2566;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 2566 failed";
  (* Paths of depth 2 *)
  (* .b320.#a45 *)
  let actual = r.b320.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2567;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2567 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a320 = a3201; b320 = b3201 } { a320 = a3202; b320 = b3202 } -> int64x2_u_equal a3201 a3202 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b3201 b3202) in
  let next_r = { a320 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b320 = #{ a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  let r_expected = { a320 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b320 = #{ a45 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a320 *)
  r.a320 <- next_r.a320;
  let r_expected = { r_expected with a320 = next_r.a320 } in
  mark_test_run 2568;
  let test = eq r r_expected in
  if not test then failwithf "test 2568 failed";
  Gc.compact ();
  (* .b320 *)
  r.b320 <- next_r.b320;
  let r_expected = { r_expected with b320 = next_r.b320 } in
  mark_test_run 2569;
  let test = eq r r_expected in
  if not test then failwithf "test 2569 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a320; b320 = #{ a45 } } = r in
  let expected_a320 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2570;
  let test = int64x2_u_equal expected_a320 a320 in
  if not test then failwithf "test 2570 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2571;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 2571 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a320; b320 } = r in
  let expected_a320 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2572;
  let test = int64x2_u_equal expected_a320 a320 in
  if not test then failwithf "test 2572 failed";
  let expected_b320 = #{ a45 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 2573;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) expected_b320 b320 in
  if not test then failwithf "test 2573 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t321 = { int64x2#; #{ int64x2#; int } }   *)
  (***********************************************)
  let r = { a321 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b321 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a321 *)
  let actual = r.a321 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2574;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2574 failed";
  (* Paths of depth 1 *)
  (* .b321 *)
  let actual = r.b321 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } in
  mark_test_run 2575;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 2575 failed";
  (* Paths of depth 2 *)
  (* .b321.#a67 *)
  let actual = r.b321.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2576;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2576 failed";
  (* .b321.#b67 *)
  let actual = r.b321.#b67 in
  let expected = 4 in
  mark_test_run 2577;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2577 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a321 = a3211; b321 = b3211 } { a321 = a3212; b321 = b3212 } -> int64x2_u_equal a3211 a3212 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b3211 b3212) in
  let next_r = { a321 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b321 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } } in
  let r_expected = { a321 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b321 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a321 *)
  r.a321 <- next_r.a321;
  let r_expected = { r_expected with a321 = next_r.a321 } in
  mark_test_run 2578;
  let test = eq r r_expected in
  if not test then failwithf "test 2578 failed";
  Gc.compact ();
  (* .b321 *)
  r.b321 <- next_r.b321;
  let r_expected = { r_expected with b321 = next_r.b321 } in
  mark_test_run 2579;
  let test = eq r r_expected in
  if not test then failwithf "test 2579 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a321; b321 = #{ a67; b67 } } = r in
  let expected_a321 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2580;
  let test = int64x2_u_equal expected_a321 a321 in
  if not test then failwithf "test 2580 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2581;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 2581 failed";
  let expected_b67 = 104 in
  mark_test_run 2582;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 2582 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a321; b321 } = r in
  let expected_a321 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2583;
  let test = int64x2_u_equal expected_a321 a321 in
  if not test then failwithf "test 2583 failed";
  let expected_b321 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } in
  mark_test_run 2584;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) expected_b321 b321 in
  if not test then failwithf "test 2584 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t322 = { int64x2#; #{ int64x2#; int64x2# } }   *)
  (****************************************************)
  let r = { a322 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b322 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a322 *)
  let actual = r.a322 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2585;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2585 failed";
  (* Paths of depth 1 *)
  (* .b322 *)
  let actual = r.b322 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  mark_test_run 2586;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 2586 failed";
  (* Paths of depth 2 *)
  (* .b322.#a69 *)
  let actual = r.b322.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2587;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2587 failed";
  (* .b322.#b69 *)
  let actual = r.b322.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 2588;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2588 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a322 = a3221; b322 = b3221 } { a322 = a3222; b322 = b3222 } -> int64x2_u_equal a3221 a3222 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b3221 b3222) in
  let next_r = { a322 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b322 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } in
  let r_expected = { a322 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b322 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a322 *)
  r.a322 <- next_r.a322;
  let r_expected = { r_expected with a322 = next_r.a322 } in
  mark_test_run 2589;
  let test = eq r r_expected in
  if not test then failwithf "test 2589 failed";
  Gc.compact ();
  (* .b322 *)
  r.b322 <- next_r.b322;
  let r_expected = { r_expected with b322 = next_r.b322 } in
  mark_test_run 2590;
  let test = eq r r_expected in
  if not test then failwithf "test 2590 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a322; b322 = #{ a69; b69 } } = r in
  let expected_a322 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2591;
  let test = int64x2_u_equal expected_a322 a322 in
  if not test then failwithf "test 2591 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2592;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 2592 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 2593;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 2593 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a322; b322 } = r in
  let expected_a322 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2594;
  let test = int64x2_u_equal expected_a322 a322 in
  if not test then failwithf "test 2594 failed";
  let expected_b322 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } in
  mark_test_run 2595;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) expected_b322 b322 in
  if not test then failwithf "test 2595 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t323 = { int64x2#; #{ int64x2#; #{ int } } }   *)
  (****************************************************)
  let r = { a323 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b323 = #{ a71 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b71 = #{ a27 = 4 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a323 *)
  let actual = r.a323 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2596;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2596 failed";
  (* Paths of depth 1 *)
  (* .b323 *)
  let actual = r.b323 in
  let expected = #{ a71 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b71 = #{ a27 = 4 } } in
  mark_test_run 2597;
  let test = (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) actual expected in
  if not test then failwithf "test 2597 failed";
  (* Paths of depth 2 *)
  (* .b323.#a71 *)
  let actual = r.b323.#a71 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2598;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2598 failed";
  (* .b323.#b71 *)
  let actual = r.b323.#b71 in
  let expected = #{ a27 = 4 } in
  mark_test_run 2599;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 2599 failed";
  (* Paths of depth 3 *)
  (* .b323.#b71.#a27 *)
  let actual = r.b323.#b71.#a27 in
  let expected = 4 in
  mark_test_run 2600;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2600 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a323 = a3231; b323 = b3231 } { a323 = a3232; b323 = b3232 } -> int64x2_u_equal a3231 a3232 && (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) b3231 b3232) in
  let next_r = { a323 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b323 = #{ a71 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b71 = #{ a27 = 104 } } } in
  let r_expected = { a323 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b323 = #{ a71 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b71 = #{ a27 = 4 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a323 *)
  r.a323 <- next_r.a323;
  let r_expected = { r_expected with a323 = next_r.a323 } in
  mark_test_run 2601;
  let test = eq r r_expected in
  if not test then failwithf "test 2601 failed";
  Gc.compact ();
  (* .b323 *)
  r.b323 <- next_r.b323;
  let r_expected = { r_expected with b323 = next_r.b323 } in
  mark_test_run 2602;
  let test = eq r r_expected in
  if not test then failwithf "test 2602 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a323; b323 = #{ a71; b71 = #{ a27 } } } = r in
  let expected_a323 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2603;
  let test = int64x2_u_equal expected_a323 a323 in
  if not test then failwithf "test 2603 failed";
  let expected_a71 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2604;
  let test = int64x2_u_equal expected_a71 a71 in
  if not test then failwithf "test 2604 failed";
  let expected_a27 = 104 in
  mark_test_run 2605;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 2605 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a323; b323 } = r in
  let expected_a323 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2606;
  let test = int64x2_u_equal expected_a323 a323 in
  if not test then failwithf "test 2606 failed";
  let expected_b323 = #{ a71 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b71 = #{ a27 = 104 } } in
  mark_test_run 2607;
  let test = (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> int64x2_u_equal a711 a712 && (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) b711 b712) expected_b323 b323 in
  if not test then failwithf "test 2607 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t324 = { int64x2#; #{ int64x2#; #{ int64x2# } } }   *)
  (*********************************************************)
  let r = { a324 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b324 = #{ a73 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a324 *)
  let actual = r.a324 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2608;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2608 failed";
  (* Paths of depth 1 *)
  (* .b324 *)
  let actual = r.b324 in
  let expected = #{ a73 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  mark_test_run 2609;
  let test = (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) actual expected in
  if not test then failwithf "test 2609 failed";
  (* Paths of depth 2 *)
  (* .b324.#a73 *)
  let actual = r.b324.#a73 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2610;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2610 failed";
  (* .b324.#b73 *)
  let actual = r.b324.#b73 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  mark_test_run 2611;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 2611 failed";
  (* Paths of depth 3 *)
  (* .b324.#b73.#a45 *)
  let actual = r.b324.#b73.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 2612;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2612 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a324 = a3241; b324 = b3241 } { a324 = a3242; b324 = b3242 } -> int64x2_u_equal a3241 a3242 && (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) b3241 b3242) in
  let next_r = { a324 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b324 = #{ a73 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } } in
  let r_expected = { a324 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b324 = #{ a73 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a324 *)
  r.a324 <- next_r.a324;
  let r_expected = { r_expected with a324 = next_r.a324 } in
  mark_test_run 2613;
  let test = eq r r_expected in
  if not test then failwithf "test 2613 failed";
  Gc.compact ();
  (* .b324 *)
  r.b324 <- next_r.b324;
  let r_expected = { r_expected with b324 = next_r.b324 } in
  mark_test_run 2614;
  let test = eq r r_expected in
  if not test then failwithf "test 2614 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a324; b324 = #{ a73; b73 = #{ a45 } } } = r in
  let expected_a324 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2615;
  let test = int64x2_u_equal expected_a324 a324 in
  if not test then failwithf "test 2615 failed";
  let expected_a73 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2616;
  let test = int64x2_u_equal expected_a73 a73 in
  if not test then failwithf "test 2616 failed";
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 2617;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 2617 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a324; b324 } = r in
  let expected_a324 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2618;
  let test = int64x2_u_equal expected_a324 a324 in
  if not test then failwithf "test 2618 failed";
  let expected_b324 = #{ a73 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b73 = #{ a45 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } in
  mark_test_run 2619;
  let test = (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> int64x2_u_equal a731 a732 && (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) b731 b732) expected_b324 b324 in
  if not test then failwithf "test 2619 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t325 = { int64x2#; #{ #{ int; int } } }   *)
  (***********************************************)
  let r = { a325 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b325 = #{ a75 = #{ a29 = 2; b29 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a325 *)
  let actual = r.a325 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2620;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2620 failed";
  (* Paths of depth 1 *)
  (* .b325 *)
  let actual = r.b325 in
  let expected = #{ a75 = #{ a29 = 2; b29 = 3 } } in
  mark_test_run 2621;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) actual expected in
  if not test then failwithf "test 2621 failed";
  (* Paths of depth 2 *)
  (* .b325.#a75 *)
  let actual = r.b325.#a75 in
  let expected = #{ a29 = 2; b29 = 3 } in
  mark_test_run 2622;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 2622 failed";
  (* Paths of depth 3 *)
  (* .b325.#a75.#a29 *)
  let actual = r.b325.#a75.#a29 in
  let expected = 2 in
  mark_test_run 2623;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2623 failed";
  (* .b325.#a75.#b29 *)
  let actual = r.b325.#a75.#b29 in
  let expected = 3 in
  mark_test_run 2624;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2624 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a325 = a3251; b325 = b3251 } { a325 = a3252; b325 = b3252 } -> int64x2_u_equal a3251 a3252 && (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) b3251 b3252) in
  let next_r = { a325 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b325 = #{ a75 = #{ a29 = 102; b29 = 103 } } } in
  let r_expected = { a325 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b325 = #{ a75 = #{ a29 = 2; b29 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a325 *)
  r.a325 <- next_r.a325;
  let r_expected = { r_expected with a325 = next_r.a325 } in
  mark_test_run 2625;
  let test = eq r r_expected in
  if not test then failwithf "test 2625 failed";
  Gc.compact ();
  (* .b325 *)
  r.b325 <- next_r.b325;
  let r_expected = { r_expected with b325 = next_r.b325 } in
  mark_test_run 2626;
  let test = eq r r_expected in
  if not test then failwithf "test 2626 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a325; b325 = #{ a75 = #{ a29; b29 } } } = r in
  let expected_a325 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2627;
  let test = int64x2_u_equal expected_a325 a325 in
  if not test then failwithf "test 2627 failed";
  let expected_a29 = 102 in
  mark_test_run 2628;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 2628 failed";
  let expected_b29 = 103 in
  mark_test_run 2629;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 2629 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a325; b325 } = r in
  let expected_a325 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2630;
  let test = int64x2_u_equal expected_a325 a325 in
  if not test then failwithf "test 2630 failed";
  let expected_b325 = #{ a75 = #{ a29 = 102; b29 = 103 } } in
  mark_test_run 2631;
  let test = (fun #{ a75 = a751 } #{ a75 = a752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a751 a752) expected_b325 b325 in
  if not test then failwithf "test 2631 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t326 = { int64x2#; #{ #{ int; int64x2# } } }   *)
  (****************************************************)
  let r = { a326 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b326 = #{ a81 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a326 *)
  let actual = r.a326 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2632;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2632 failed";
  (* Paths of depth 1 *)
  (* .b326 *)
  let actual = r.b326 in
  let expected = #{ a81 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 2633;
  let test = (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) actual expected in
  if not test then failwithf "test 2633 failed";
  (* Paths of depth 2 *)
  (* .b326.#a81 *)
  let actual = r.b326.#a81 in
  let expected = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 2634;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 2634 failed";
  (* Paths of depth 3 *)
  (* .b326.#a81.#a35 *)
  let actual = r.b326.#a81.#a35 in
  let expected = 2 in
  mark_test_run 2635;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2635 failed";
  (* .b326.#a81.#b35 *)
  let actual = r.b326.#a81.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 2636;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2636 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a326 = a3261; b326 = b3261 } { a326 = a3262; b326 = b3262 } -> int64x2_u_equal a3261 a3262 && (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) b3261 b3262) in
  let next_r = { a326 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b326 = #{ a81 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a326 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b326 = #{ a81 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a326 *)
  r.a326 <- next_r.a326;
  let r_expected = { r_expected with a326 = next_r.a326 } in
  mark_test_run 2637;
  let test = eq r r_expected in
  if not test then failwithf "test 2637 failed";
  Gc.compact ();
  (* .b326 *)
  r.b326 <- next_r.b326;
  let r_expected = { r_expected with b326 = next_r.b326 } in
  mark_test_run 2638;
  let test = eq r r_expected in
  if not test then failwithf "test 2638 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a326; b326 = #{ a81 = #{ a35; b35 } } } = r in
  let expected_a326 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2639;
  let test = int64x2_u_equal expected_a326 a326 in
  if not test then failwithf "test 2639 failed";
  let expected_a35 = 102 in
  mark_test_run 2640;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 2640 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 2641;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 2641 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a326; b326 } = r in
  let expected_a326 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2642;
  let test = int64x2_u_equal expected_a326 a326 in
  if not test then failwithf "test 2642 failed";
  let expected_b326 = #{ a81 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 2643;
  let test = (fun #{ a81 = a811 } #{ a81 = a812 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a811 a812) expected_b326 b326 in
  if not test then failwithf "test 2643 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t327 = { int64x2#; #{ #{ int64x2#; int } } }   *)
  (****************************************************)
  let r = { a327 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b327 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a327 *)
  let actual = r.a327 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2644;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2644 failed";
  (* Paths of depth 1 *)
  (* .b327 *)
  let actual = r.b327 in
  let expected = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } in
  mark_test_run 2645;
  let test = (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) actual expected in
  if not test then failwithf "test 2645 failed";
  (* Paths of depth 2 *)
  (* .b327.#a91 *)
  let actual = r.b327.#a91 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } in
  mark_test_run 2646;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 2646 failed";
  (* Paths of depth 3 *)
  (* .b327.#a91.#a67 *)
  let actual = r.b327.#a91.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2647;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2647 failed";
  (* .b327.#a91.#b67 *)
  let actual = r.b327.#a91.#b67 in
  let expected = 4 in
  mark_test_run 2648;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2648 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a327 = a3271; b327 = b3271 } { a327 = a3272; b327 = b3272 } -> int64x2_u_equal a3271 a3272 && (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) b3271 b3272) in
  let next_r = { a327 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b327 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } } } in
  let r_expected = { a327 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b327 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a327 *)
  r.a327 <- next_r.a327;
  let r_expected = { r_expected with a327 = next_r.a327 } in
  mark_test_run 2649;
  let test = eq r r_expected in
  if not test then failwithf "test 2649 failed";
  Gc.compact ();
  (* .b327 *)
  r.b327 <- next_r.b327;
  let r_expected = { r_expected with b327 = next_r.b327 } in
  mark_test_run 2650;
  let test = eq r r_expected in
  if not test then failwithf "test 2650 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a327; b327 = #{ a91 = #{ a67; b67 } } } = r in
  let expected_a327 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2651;
  let test = int64x2_u_equal expected_a327 a327 in
  if not test then failwithf "test 2651 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2652;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 2652 failed";
  let expected_b67 = 104 in
  mark_test_run 2653;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 2653 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a327; b327 } = r in
  let expected_a327 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2654;
  let test = int64x2_u_equal expected_a327 a327 in
  if not test then failwithf "test 2654 failed";
  let expected_b327 = #{ a91 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } } in
  mark_test_run 2655;
  let test = (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a911 a912) expected_b327 b327 in
  if not test then failwithf "test 2655 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t328 = { int64x2#; #{ #{ int64x2#; int64x2# } } }   *)
  (*********************************************************)
  let r = { a328 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b328 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a328 *)
  let actual = r.a328 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 2656;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2656 failed";
  (* Paths of depth 1 *)
  (* .b328 *)
  let actual = r.b328 in
  let expected = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  mark_test_run 2657;
  let test = (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) actual expected in
  if not test then failwithf "test 2657 failed";
  (* Paths of depth 2 *)
  (* .b328.#a93 *)
  let actual = r.b328.#a93 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  mark_test_run 2658;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 2658 failed";
  (* Paths of depth 3 *)
  (* .b328.#a93.#a69 *)
  let actual = r.b328.#a93.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 2659;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2659 failed";
  (* .b328.#a93.#b69 *)
  let actual = r.b328.#a93.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 2660;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 2660 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a328 = a3281; b328 = b3281 } { a328 = a3282; b328 = b3282 } -> int64x2_u_equal a3281 a3282 && (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) b3281 b3282) in
  let next_r = { a328 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b328 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } } in
  let r_expected = { a328 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b328 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a328 *)
  r.a328 <- next_r.a328;
  let r_expected = { r_expected with a328 = next_r.a328 } in
  mark_test_run 2661;
  let test = eq r r_expected in
  if not test then failwithf "test 2661 failed";
  Gc.compact ();
  (* .b328 *)
  r.b328 <- next_r.b328;
  let r_expected = { r_expected with b328 = next_r.b328 } in
  mark_test_run 2662;
  let test = eq r r_expected in
  if not test then failwithf "test 2662 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a328; b328 = #{ a93 = #{ a69; b69 } } } = r in
  let expected_a328 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2663;
  let test = int64x2_u_equal expected_a328 a328 in
  if not test then failwithf "test 2663 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 2664;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 2664 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 2665;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 2665 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a328; b328 } = r in
  let expected_a328 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 2666;
  let test = int64x2_u_equal expected_a328 a328 in
  if not test then failwithf "test 2666 failed";
  let expected_b328 = #{ a93 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } in
  mark_test_run 2667;
  let test = (fun #{ a93 = a931 } #{ a93 = a932 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a931 a932) expected_b328 b328 in
  if not test then failwithf "test 2667 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t329 = { (| unit_u) }   *)
  (*****************************)
  let r = { a329 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a329 *)
  let actual = r.a329 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2668;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2668 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a329 = a3291 } { a329 = a3292 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3291 a3292) in
  let next_r = { a329 = C19_0((unbox_unit ())) } in
  let r_expected = { a329 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a329 *)
  r.a329 <- next_r.a329;
  let r_expected = { r_expected with a329 = next_r.a329 } in
  mark_test_run 2669;
  let test = eq r r_expected in
  if not test then failwithf "test 2669 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a329 } = r in
  let expected_a329 = C19_0((unbox_unit ())) in
  mark_test_run 2670;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a329 a329 in
  if not test then failwithf "test 2670 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a329 } = r in
  let expected_a329 = C19_0((unbox_unit ())) in
  mark_test_run 2671;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a329 a329 in
  if not test then failwithf "test 2671 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t330 = { (| unit_u); int }   *)
  (**********************************)
  let r = { a330 = C19_0((unbox_unit ())); b330 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a330 *)
  let actual = r.a330 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2672;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2672 failed";
  (* Paths of depth 1 *)
  (* .b330 *)
  let actual = r.b330 in
  let expected = 0 in
  mark_test_run 2673;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2673 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a330 = a3301; b330 = b3301 } { a330 = a3302; b330 = b3302 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3301 a3302 && (fun a b -> Int.equal a b) b3301 b3302) in
  let next_r = { a330 = C19_0((unbox_unit ())); b330 = 100 } in
  let r_expected = { a330 = C19_0((unbox_unit ())); b330 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a330 *)
  r.a330 <- next_r.a330;
  let r_expected = { r_expected with a330 = next_r.a330 } in
  mark_test_run 2674;
  let test = eq r r_expected in
  if not test then failwithf "test 2674 failed";
  Gc.compact ();
  (* .b330 *)
  r.b330 <- next_r.b330;
  let r_expected = { r_expected with b330 = next_r.b330 } in
  mark_test_run 2675;
  let test = eq r r_expected in
  if not test then failwithf "test 2675 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a330; b330 } = r in
  let expected_a330 = C19_0((unbox_unit ())) in
  mark_test_run 2676;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a330 a330 in
  if not test then failwithf "test 2676 failed";
  let expected_b330 = 100 in
  mark_test_run 2677;
  let test = (fun a b -> Int.equal a b) expected_b330 b330 in
  if not test then failwithf "test 2677 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a330; b330 } = r in
  let expected_a330 = C19_0((unbox_unit ())) in
  mark_test_run 2678;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a330 a330 in
  if not test then failwithf "test 2678 failed";
  let expected_b330 = 100 in
  mark_test_run 2679;
  let test = (fun a b -> Int.equal a b) expected_b330 b330 in
  if not test then failwithf "test 2679 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t331 = { (| unit_u); int64 }   *)
  (************************************)
  let r = { a331 = C19_0((unbox_unit ())); b331 = 0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a331 *)
  let actual = r.a331 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2680;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2680 failed";
  (* Paths of depth 1 *)
  (* .b331 *)
  let actual = r.b331 in
  let expected = 0L in
  mark_test_run 2681;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2681 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a331 = a3311; b331 = b3311 } { a331 = a3312; b331 = b3312 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3311 a3312 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3311 b3312) in
  let next_r = { a331 = C19_0((unbox_unit ())); b331 = 100L } in
  let r_expected = { a331 = C19_0((unbox_unit ())); b331 = 0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a331 *)
  r.a331 <- next_r.a331;
  let r_expected = { r_expected with a331 = next_r.a331 } in
  mark_test_run 2682;
  let test = eq r r_expected in
  if not test then failwithf "test 2682 failed";
  Gc.compact ();
  (* .b331 *)
  r.b331 <- next_r.b331;
  let r_expected = { r_expected with b331 = next_r.b331 } in
  mark_test_run 2683;
  let test = eq r r_expected in
  if not test then failwithf "test 2683 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a331; b331 } = r in
  let expected_a331 = C19_0((unbox_unit ())) in
  mark_test_run 2684;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a331 a331 in
  if not test then failwithf "test 2684 failed";
  let expected_b331 = 100L in
  mark_test_run 2685;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b331 b331 in
  if not test then failwithf "test 2685 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a331; b331 } = r in
  let expected_a331 = C19_0((unbox_unit ())) in
  mark_test_run 2686;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a331 a331 in
  if not test then failwithf "test 2686 failed";
  let expected_b331 = 100L in
  mark_test_run 2687;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b331 b331 in
  if not test then failwithf "test 2687 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t332 = { (| unit_u); int64# }   *)
  (*************************************)
  let r = { a332 = C19_0((unbox_unit ())); b332 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a332 *)
  let actual = r.a332 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2688;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2688 failed";
  (* Paths of depth 1 *)
  (* .b332 *)
  let actual = r.b332 in
  let expected = #0L in
  mark_test_run 2689;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 2689 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a332 = a3321; b332 = b3321 } { a332 = a3322; b332 = b3322 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3321 a3322 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3321 b3322) in
  let next_r = { a332 = C19_0((unbox_unit ())); b332 = #100L } in
  let r_expected = { a332 = C19_0((unbox_unit ())); b332 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a332 *)
  r.a332 <- next_r.a332;
  let r_expected = { r_expected with a332 = next_r.a332 } in
  mark_test_run 2690;
  let test = eq r r_expected in
  if not test then failwithf "test 2690 failed";
  Gc.compact ();
  (* .b332 *)
  r.b332 <- next_r.b332;
  let r_expected = { r_expected with b332 = next_r.b332 } in
  mark_test_run 2691;
  let test = eq r r_expected in
  if not test then failwithf "test 2691 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a332; b332 } = r in
  let expected_a332 = C19_0((unbox_unit ())) in
  mark_test_run 2692;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a332 a332 in
  if not test then failwithf "test 2692 failed";
  let expected_b332 = #100L in
  mark_test_run 2693;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b332 b332 in
  if not test then failwithf "test 2693 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a332; b332 } = r in
  let expected_a332 = C19_0((unbox_unit ())) in
  mark_test_run 2694;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a332 a332 in
  if not test then failwithf "test 2694 failed";
  let expected_b332 = #100L in
  mark_test_run 2695;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b332 b332 in
  if not test then failwithf "test 2695 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t333 = { (| unit_u); int32# }   *)
  (*************************************)
  let r = { a333 = C19_0((unbox_unit ())); b333 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a333 *)
  let actual = r.a333 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2696;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2696 failed";
  (* Paths of depth 1 *)
  (* .b333 *)
  let actual = r.b333 in
  let expected = #0l in
  mark_test_run 2697;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 2697 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a333 = a3331; b333 = b3331 } { a333 = a3332; b333 = b3332 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3331 a3332 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b3331 b3332) in
  let next_r = { a333 = C19_0((unbox_unit ())); b333 = #100l } in
  let r_expected = { a333 = C19_0((unbox_unit ())); b333 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a333 *)
  r.a333 <- next_r.a333;
  let r_expected = { r_expected with a333 = next_r.a333 } in
  mark_test_run 2698;
  let test = eq r r_expected in
  if not test then failwithf "test 2698 failed";
  Gc.compact ();
  (* .b333 *)
  r.b333 <- next_r.b333;
  let r_expected = { r_expected with b333 = next_r.b333 } in
  mark_test_run 2699;
  let test = eq r r_expected in
  if not test then failwithf "test 2699 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a333; b333 } = r in
  let expected_a333 = C19_0((unbox_unit ())) in
  mark_test_run 2700;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a333 a333 in
  if not test then failwithf "test 2700 failed";
  let expected_b333 = #100l in
  mark_test_run 2701;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b333 b333 in
  if not test then failwithf "test 2701 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a333; b333 } = r in
  let expected_a333 = C19_0((unbox_unit ())) in
  mark_test_run 2702;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a333 a333 in
  if not test then failwithf "test 2702 failed";
  let expected_b333 = #100l in
  mark_test_run 2703;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b333 b333 in
  if not test then failwithf "test 2703 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t334 = { (| unit_u); nativeint# }   *)
  (*****************************************)
  let r = { a334 = C19_0((unbox_unit ())); b334 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a334 *)
  let actual = r.a334 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2704;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2704 failed";
  (* Paths of depth 1 *)
  (* .b334 *)
  let actual = r.b334 in
  let expected = #0n in
  mark_test_run 2705;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 2705 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a334 = a3341; b334 = b3341 } { a334 = a3342; b334 = b3342 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3341 a3342 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b3341 b3342) in
  let next_r = { a334 = C19_0((unbox_unit ())); b334 = #100n } in
  let r_expected = { a334 = C19_0((unbox_unit ())); b334 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a334 *)
  r.a334 <- next_r.a334;
  let r_expected = { r_expected with a334 = next_r.a334 } in
  mark_test_run 2706;
  let test = eq r r_expected in
  if not test then failwithf "test 2706 failed";
  Gc.compact ();
  (* .b334 *)
  r.b334 <- next_r.b334;
  let r_expected = { r_expected with b334 = next_r.b334 } in
  mark_test_run 2707;
  let test = eq r r_expected in
  if not test then failwithf "test 2707 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a334; b334 } = r in
  let expected_a334 = C19_0((unbox_unit ())) in
  mark_test_run 2708;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a334 a334 in
  if not test then failwithf "test 2708 failed";
  let expected_b334 = #100n in
  mark_test_run 2709;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b334 b334 in
  if not test then failwithf "test 2709 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a334; b334 } = r in
  let expected_a334 = C19_0((unbox_unit ())) in
  mark_test_run 2710;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a334 a334 in
  if not test then failwithf "test 2710 failed";
  let expected_b334 = #100n in
  mark_test_run 2711;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b334 b334 in
  if not test then failwithf "test 2711 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t335 = { (| unit_u); unit_u }   *)
  (*************************************)
  let r = { a335 = C19_0((unbox_unit ())); b335 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a335 *)
  let actual = r.a335 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2712;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2712 failed";
  (* Paths of depth 1 *)
  (* .b335 *)
  let actual = r.b335 in
  let expected = (unbox_unit ()) in
  mark_test_run 2713;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2713 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a335 = a3351; b335 = b3351 } { a335 = a3352; b335 = b3352 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3351 a3352 && (fun _ _ -> true) b3351 b3352) in
  let next_r = { a335 = C19_0((unbox_unit ())); b335 = (unbox_unit ()) } in
  let r_expected = { a335 = C19_0((unbox_unit ())); b335 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a335 *)
  r.a335 <- next_r.a335;
  let r_expected = { r_expected with a335 = next_r.a335 } in
  mark_test_run 2714;
  let test = eq r r_expected in
  if not test then failwithf "test 2714 failed";
  Gc.compact ();
  (* .b335 *)
  r.b335 <- next_r.b335;
  let r_expected = { r_expected with b335 = next_r.b335 } in
  mark_test_run 2715;
  let test = eq r r_expected in
  if not test then failwithf "test 2715 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a335; b335 } = r in
  let expected_a335 = C19_0((unbox_unit ())) in
  mark_test_run 2716;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a335 a335 in
  if not test then failwithf "test 2716 failed";
  let expected_b335 = (unbox_unit ()) in
  mark_test_run 2717;
  let test = (fun _ _ -> true) expected_b335 b335 in
  if not test then failwithf "test 2717 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a335; b335 } = r in
  let expected_a335 = C19_0((unbox_unit ())) in
  mark_test_run 2718;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a335 a335 in
  if not test then failwithf "test 2718 failed";
  let expected_b335 = (unbox_unit ()) in
  mark_test_run 2719;
  let test = (fun _ _ -> true) expected_b335 b335 in
  if not test then failwithf "test 2719 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t336 = { (| unit_u); float }   *)
  (************************************)
  let r = { a336 = C19_0((unbox_unit ())); b336 = 0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a336 *)
  let actual = r.a336 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2720;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2720 failed";
  (* Paths of depth 1 *)
  (* .b336 *)
  let actual = r.b336 in
  let expected = 0. in
  mark_test_run 2721;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2721 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a336 = a3361; b336 = b3361 } { a336 = a3362; b336 = b3362 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3361 a3362 && (fun a b -> Float.equal (globalize a) (globalize b)) b3361 b3362) in
  let next_r = { a336 = C19_0((unbox_unit ())); b336 = 100. } in
  let r_expected = { a336 = C19_0((unbox_unit ())); b336 = 0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a336 *)
  r.a336 <- next_r.a336;
  let r_expected = { r_expected with a336 = next_r.a336 } in
  mark_test_run 2722;
  let test = eq r r_expected in
  if not test then failwithf "test 2722 failed";
  Gc.compact ();
  (* .b336 *)
  r.b336 <- next_r.b336;
  let r_expected = { r_expected with b336 = next_r.b336 } in
  mark_test_run 2723;
  let test = eq r r_expected in
  if not test then failwithf "test 2723 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a336; b336 } = r in
  let expected_a336 = C19_0((unbox_unit ())) in
  mark_test_run 2724;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a336 a336 in
  if not test then failwithf "test 2724 failed";
  let expected_b336 = 100. in
  mark_test_run 2725;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b336 b336 in
  if not test then failwithf "test 2725 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a336; b336 } = r in
  let expected_a336 = C19_0((unbox_unit ())) in
  mark_test_run 2726;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a336 a336 in
  if not test then failwithf "test 2726 failed";
  let expected_b336 = 100. in
  mark_test_run 2727;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b336 b336 in
  if not test then failwithf "test 2727 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t337 = { (| unit_u); (| unit_u) }   *)
  (*****************************************)
  let r = { a337 = C19_0((unbox_unit ())); b337 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a337 *)
  let actual = r.a337 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2728;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2728 failed";
  (* Paths of depth 1 *)
  (* .b337 *)
  let actual = r.b337 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2729;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2729 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a337 = a3371; b337 = b3371 } { a337 = a3372; b337 = b3372 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3371 a3372 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b3371 b3372) in
  let next_r = { a337 = C19_0((unbox_unit ())); b337 = C19_0((unbox_unit ())) } in
  let r_expected = { a337 = C19_0((unbox_unit ())); b337 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a337 *)
  r.a337 <- next_r.a337;
  let r_expected = { r_expected with a337 = next_r.a337 } in
  mark_test_run 2730;
  let test = eq r r_expected in
  if not test then failwithf "test 2730 failed";
  Gc.compact ();
  (* .b337 *)
  r.b337 <- next_r.b337;
  let r_expected = { r_expected with b337 = next_r.b337 } in
  mark_test_run 2731;
  let test = eq r r_expected in
  if not test then failwithf "test 2731 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a337; b337 } = r in
  let expected_a337 = C19_0((unbox_unit ())) in
  mark_test_run 2732;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a337 a337 in
  if not test then failwithf "test 2732 failed";
  let expected_b337 = C19_0((unbox_unit ())) in
  mark_test_run 2733;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b337 b337 in
  if not test then failwithf "test 2733 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a337; b337 } = r in
  let expected_a337 = C19_0((unbox_unit ())) in
  mark_test_run 2734;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a337 a337 in
  if not test then failwithf "test 2734 failed";
  let expected_b337 = C19_0((unbox_unit ())) in
  mark_test_run 2735;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b337 b337 in
  if not test then failwithf "test 2735 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************************************)
  (*   t338 = { (| unit_u); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (*******************************************************************************)
  let r = { a338 = C19_0((unbox_unit ())); b338 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a338 *)
  let actual = r.a338 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2736;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2736 failed";
  (* Paths of depth 1 *)
  (* .b338 *)
  let actual = r.b338 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2737;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2737 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a338 = a3381; b338 = b3381 } { a338 = a3382; b338 = b3382 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3381 a3382 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b3381 b3382) in
  let next_r = { a338 = C19_0((unbox_unit ())); b338 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a338 = C19_0((unbox_unit ())); b338 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a338 *)
  r.a338 <- next_r.a338;
  let r_expected = { r_expected with a338 = next_r.a338 } in
  mark_test_run 2738;
  let test = eq r r_expected in
  if not test then failwithf "test 2738 failed";
  Gc.compact ();
  (* .b338 *)
  r.b338 <- next_r.b338;
  let r_expected = { r_expected with b338 = next_r.b338 } in
  mark_test_run 2739;
  let test = eq r r_expected in
  if not test then failwithf "test 2739 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a338; b338 } = r in
  let expected_a338 = C19_0((unbox_unit ())) in
  mark_test_run 2740;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a338 a338 in
  if not test then failwithf "test 2740 failed";
  let expected_b338 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2741;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b338 b338 in
  if not test then failwithf "test 2741 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a338; b338 } = r in
  let expected_a338 = C19_0((unbox_unit ())) in
  mark_test_run 2742;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a338 a338 in
  if not test then failwithf "test 2742 failed";
  let expected_b338 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2743;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b338 b338 in
  if not test then failwithf "test 2743 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t339 = { (| unit_u); #(unit_u, int) }   *)
  (*********************************************)
  let r = { a339 = C19_0((unbox_unit ())); b339 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a339 *)
  let actual = r.a339 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2744;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2744 failed";
  (* Paths of depth 1 *)
  (* .b339 *)
  let actual = r.b339 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2745;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2745 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a339 = a3391; b339 = b3391 } { a339 = a3392; b339 = b3392 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3391 a3392 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b3391 b3392) in
  let next_r = { a339 = C19_0((unbox_unit ())); b339 = #((unbox_unit ()), 100) } in
  let r_expected = { a339 = C19_0((unbox_unit ())); b339 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a339 *)
  r.a339 <- next_r.a339;
  let r_expected = { r_expected with a339 = next_r.a339 } in
  mark_test_run 2746;
  let test = eq r r_expected in
  if not test then failwithf "test 2746 failed";
  Gc.compact ();
  (* .b339 *)
  r.b339 <- next_r.b339;
  let r_expected = { r_expected with b339 = next_r.b339 } in
  mark_test_run 2747;
  let test = eq r r_expected in
  if not test then failwithf "test 2747 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a339; b339 } = r in
  let expected_a339 = C19_0((unbox_unit ())) in
  mark_test_run 2748;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a339 a339 in
  if not test then failwithf "test 2748 failed";
  let expected_b339 = #((unbox_unit ()), 100) in
  mark_test_run 2749;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b339 b339 in
  if not test then failwithf "test 2749 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a339; b339 } = r in
  let expected_a339 = C19_0((unbox_unit ())) in
  mark_test_run 2750;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a339 a339 in
  if not test then failwithf "test 2750 failed";
  let expected_b339 = #((unbox_unit ()), 100) in
  mark_test_run 2751;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b339 b339 in
  if not test then failwithf "test 2751 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t340 = { (| unit_u); #(unit_u, int64#) }   *)
  (************************************************)
  let r = { a340 = C19_0((unbox_unit ())); b340 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a340 *)
  let actual = r.a340 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2752;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2752 failed";
  (* Paths of depth 1 *)
  (* .b340 *)
  let actual = r.b340 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 2753;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 2753 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a340 = a3401; b340 = b3401 } { a340 = a3402; b340 = b3402 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3401 a3402 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b3401 b3402) in
  let next_r = { a340 = C19_0((unbox_unit ())); b340 = #((unbox_unit ()), #100L) } in
  let r_expected = { a340 = C19_0((unbox_unit ())); b340 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a340 *)
  r.a340 <- next_r.a340;
  let r_expected = { r_expected with a340 = next_r.a340 } in
  mark_test_run 2754;
  let test = eq r r_expected in
  if not test then failwithf "test 2754 failed";
  Gc.compact ();
  (* .b340 *)
  r.b340 <- next_r.b340;
  let r_expected = { r_expected with b340 = next_r.b340 } in
  mark_test_run 2755;
  let test = eq r r_expected in
  if not test then failwithf "test 2755 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a340; b340 } = r in
  let expected_a340 = C19_0((unbox_unit ())) in
  mark_test_run 2756;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a340 a340 in
  if not test then failwithf "test 2756 failed";
  let expected_b340 = #((unbox_unit ()), #100L) in
  mark_test_run 2757;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b340 b340 in
  if not test then failwithf "test 2757 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a340; b340 } = r in
  let expected_a340 = C19_0((unbox_unit ())) in
  mark_test_run 2758;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a340 a340 in
  if not test then failwithf "test 2758 failed";
  let expected_b340 = #((unbox_unit ()), #100L) in
  mark_test_run 2759;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b340 b340 in
  if not test then failwithf "test 2759 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t341 = { (| unit_u); #(unit_u, unit_u) }   *)
  (************************************************)
  let r = { a341 = C19_0((unbox_unit ())); b341 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a341 *)
  let actual = r.a341 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2760;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2760 failed";
  (* Paths of depth 1 *)
  (* .b341 *)
  let actual = r.b341 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2761;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 2761 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a341 = a3411; b341 = b3411 } { a341 = a3412; b341 = b3412 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3411 a3412 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b3411 b3412) in
  let next_r = { a341 = C19_0((unbox_unit ())); b341 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a341 = C19_0((unbox_unit ())); b341 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a341 *)
  r.a341 <- next_r.a341;
  let r_expected = { r_expected with a341 = next_r.a341 } in
  mark_test_run 2762;
  let test = eq r r_expected in
  if not test then failwithf "test 2762 failed";
  Gc.compact ();
  (* .b341 *)
  r.b341 <- next_r.b341;
  let r_expected = { r_expected with b341 = next_r.b341 } in
  mark_test_run 2763;
  let test = eq r r_expected in
  if not test then failwithf "test 2763 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a341; b341 } = r in
  let expected_a341 = C19_0((unbox_unit ())) in
  mark_test_run 2764;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a341 a341 in
  if not test then failwithf "test 2764 failed";
  let expected_b341 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2765;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b341 b341 in
  if not test then failwithf "test 2765 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a341; b341 } = r in
  let expected_a341 = C19_0((unbox_unit ())) in
  mark_test_run 2766;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a341 a341 in
  if not test then failwithf "test 2766 failed";
  let expected_b341 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2767;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b341 b341 in
  if not test then failwithf "test 2767 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t342 = { (| unit_u); #(unit_u, string) }   *)
  (************************************************)
  let r = { a342 = C19_0((unbox_unit ())); b342 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a342 *)
  let actual = r.a342 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2768;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2768 failed";
  (* Paths of depth 1 *)
  (* .b342 *)
  let actual = r.b342 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 2769;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 2769 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a342 = a3421; b342 = b3421 } { a342 = a3422; b342 = b3422 } -> (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) a3421 a3422 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b3421 b3422) in
  let next_r = { a342 = C19_0((unbox_unit ())); b342 = #((unbox_unit ()), "100") } in
  let r_expected = { a342 = C19_0((unbox_unit ())); b342 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a342 *)
  r.a342 <- next_r.a342;
  let r_expected = { r_expected with a342 = next_r.a342 } in
  mark_test_run 2770;
  let test = eq r r_expected in
  if not test then failwithf "test 2770 failed";
  Gc.compact ();
  (* .b342 *)
  r.b342 <- next_r.b342;
  let r_expected = { r_expected with b342 = next_r.b342 } in
  mark_test_run 2771;
  let test = eq r r_expected in
  if not test then failwithf "test 2771 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a342; b342 } = r in
  let expected_a342 = C19_0((unbox_unit ())) in
  mark_test_run 2772;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a342 a342 in
  if not test then failwithf "test 2772 failed";
  let expected_b342 = #((unbox_unit ()), "100") in
  mark_test_run 2773;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b342 b342 in
  if not test then failwithf "test 2773 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a342; b342 } = r in
  let expected_a342 = C19_0((unbox_unit ())) in
  mark_test_run 2774;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_a342 a342 in
  if not test then failwithf "test 2774 failed";
  let expected_b342 = #((unbox_unit ()), "100") in
  mark_test_run 2775;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b342 b342 in
  if not test then failwithf "test 2775 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************************)
  (*   t343 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (*******************************************************************)
  let r = { a343 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a343 *)
  let actual = r.a343 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2776;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2776 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a343 = a3431 } { a343 = a3432 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3431 a3432) in
  let next_r = { a343 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a343 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a343 *)
  r.a343 <- next_r.a343;
  let r_expected = { r_expected with a343 = next_r.a343 } in
  mark_test_run 2777;
  let test = eq r r_expected in
  if not test then failwithf "test 2777 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a343 } = r in
  let expected_a343 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2778;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a343 a343 in
  if not test then failwithf "test 2778 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a343 } = r in
  let expected_a343 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2779;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a343 a343 in
  if not test then failwithf "test 2779 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************************************)
  (*   t344 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int }   *)
  (************************************************************************)
  let r = { a344 = C21_0((unbox_unit ())); b344 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a344 *)
  let actual = r.a344 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2780;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2780 failed";
  (* Paths of depth 1 *)
  (* .b344 *)
  let actual = r.b344 in
  let expected = 0 in
  mark_test_run 2781;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2781 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a344 = a3441; b344 = b3441 } { a344 = a3442; b344 = b3442 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3441 a3442 && (fun a b -> Int.equal a b) b3441 b3442) in
  let next_r = { a344 = C21_1((unbox_unit ()), (unbox_unit ())); b344 = 100 } in
  let r_expected = { a344 = C21_0((unbox_unit ())); b344 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a344 *)
  r.a344 <- next_r.a344;
  let r_expected = { r_expected with a344 = next_r.a344 } in
  mark_test_run 2782;
  let test = eq r r_expected in
  if not test then failwithf "test 2782 failed";
  Gc.compact ();
  (* .b344 *)
  r.b344 <- next_r.b344;
  let r_expected = { r_expected with b344 = next_r.b344 } in
  mark_test_run 2783;
  let test = eq r r_expected in
  if not test then failwithf "test 2783 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a344; b344 } = r in
  let expected_a344 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2784;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a344 a344 in
  if not test then failwithf "test 2784 failed";
  let expected_b344 = 100 in
  mark_test_run 2785;
  let test = (fun a b -> Int.equal a b) expected_b344 b344 in
  if not test then failwithf "test 2785 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a344; b344 } = r in
  let expected_a344 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2786;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a344 a344 in
  if not test then failwithf "test 2786 failed";
  let expected_b344 = 100 in
  mark_test_run 2787;
  let test = (fun a b -> Int.equal a b) expected_b344 b344 in
  if not test then failwithf "test 2787 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************)
  (*   t345 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int64 }   *)
  (**************************************************************************)
  let r = { a345 = C21_0((unbox_unit ())); b345 = 0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a345 *)
  let actual = r.a345 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2788;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2788 failed";
  (* Paths of depth 1 *)
  (* .b345 *)
  let actual = r.b345 in
  let expected = 0L in
  mark_test_run 2789;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2789 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a345 = a3451; b345 = b3451 } { a345 = a3452; b345 = b3452 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3451 a3452 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3451 b3452) in
  let next_r = { a345 = C21_1((unbox_unit ()), (unbox_unit ())); b345 = 100L } in
  let r_expected = { a345 = C21_0((unbox_unit ())); b345 = 0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a345 *)
  r.a345 <- next_r.a345;
  let r_expected = { r_expected with a345 = next_r.a345 } in
  mark_test_run 2790;
  let test = eq r r_expected in
  if not test then failwithf "test 2790 failed";
  Gc.compact ();
  (* .b345 *)
  r.b345 <- next_r.b345;
  let r_expected = { r_expected with b345 = next_r.b345 } in
  mark_test_run 2791;
  let test = eq r r_expected in
  if not test then failwithf "test 2791 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a345; b345 } = r in
  let expected_a345 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2792;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a345 a345 in
  if not test then failwithf "test 2792 failed";
  let expected_b345 = 100L in
  mark_test_run 2793;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b345 b345 in
  if not test then failwithf "test 2793 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a345; b345 } = r in
  let expected_a345 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2794;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a345 a345 in
  if not test then failwithf "test 2794 failed";
  let expected_b345 = 100L in
  mark_test_run 2795;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b345 b345 in
  if not test then failwithf "test 2795 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t346 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int64# }   *)
  (***************************************************************************)
  let r = { a346 = C21_0((unbox_unit ())); b346 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a346 *)
  let actual = r.a346 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2796;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2796 failed";
  (* Paths of depth 1 *)
  (* .b346 *)
  let actual = r.b346 in
  let expected = #0L in
  mark_test_run 2797;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 2797 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a346 = a3461; b346 = b3461 } { a346 = a3462; b346 = b3462 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3461 a3462 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3461 b3462) in
  let next_r = { a346 = C21_1((unbox_unit ()), (unbox_unit ())); b346 = #100L } in
  let r_expected = { a346 = C21_0((unbox_unit ())); b346 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a346 *)
  r.a346 <- next_r.a346;
  let r_expected = { r_expected with a346 = next_r.a346 } in
  mark_test_run 2798;
  let test = eq r r_expected in
  if not test then failwithf "test 2798 failed";
  Gc.compact ();
  (* .b346 *)
  r.b346 <- next_r.b346;
  let r_expected = { r_expected with b346 = next_r.b346 } in
  mark_test_run 2799;
  let test = eq r r_expected in
  if not test then failwithf "test 2799 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a346; b346 } = r in
  let expected_a346 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2800;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a346 a346 in
  if not test then failwithf "test 2800 failed";
  let expected_b346 = #100L in
  mark_test_run 2801;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b346 b346 in
  if not test then failwithf "test 2801 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a346; b346 } = r in
  let expected_a346 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2802;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a346 a346 in
  if not test then failwithf "test 2802 failed";
  let expected_b346 = #100L in
  mark_test_run 2803;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b346 b346 in
  if not test then failwithf "test 2803 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t347 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); int32# }   *)
  (***************************************************************************)
  let r = { a347 = C21_0((unbox_unit ())); b347 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a347 *)
  let actual = r.a347 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2804;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2804 failed";
  (* Paths of depth 1 *)
  (* .b347 *)
  let actual = r.b347 in
  let expected = #0l in
  mark_test_run 2805;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 2805 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a347 = a3471; b347 = b3471 } { a347 = a3472; b347 = b3472 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3471 a3472 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b3471 b3472) in
  let next_r = { a347 = C21_1((unbox_unit ()), (unbox_unit ())); b347 = #100l } in
  let r_expected = { a347 = C21_0((unbox_unit ())); b347 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a347 *)
  r.a347 <- next_r.a347;
  let r_expected = { r_expected with a347 = next_r.a347 } in
  mark_test_run 2806;
  let test = eq r r_expected in
  if not test then failwithf "test 2806 failed";
  Gc.compact ();
  (* .b347 *)
  r.b347 <- next_r.b347;
  let r_expected = { r_expected with b347 = next_r.b347 } in
  mark_test_run 2807;
  let test = eq r r_expected in
  if not test then failwithf "test 2807 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a347; b347 } = r in
  let expected_a347 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2808;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a347 a347 in
  if not test then failwithf "test 2808 failed";
  let expected_b347 = #100l in
  mark_test_run 2809;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b347 b347 in
  if not test then failwithf "test 2809 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a347; b347 } = r in
  let expected_a347 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2810;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a347 a347 in
  if not test then failwithf "test 2810 failed";
  let expected_b347 = #100l in
  mark_test_run 2811;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b347 b347 in
  if not test then failwithf "test 2811 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************************************)
  (*   t348 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); nativeint# }   *)
  (*******************************************************************************)
  let r = { a348 = C21_0((unbox_unit ())); b348 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a348 *)
  let actual = r.a348 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2812;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2812 failed";
  (* Paths of depth 1 *)
  (* .b348 *)
  let actual = r.b348 in
  let expected = #0n in
  mark_test_run 2813;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 2813 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a348 = a3481; b348 = b3481 } { a348 = a3482; b348 = b3482 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3481 a3482 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b3481 b3482) in
  let next_r = { a348 = C21_1((unbox_unit ()), (unbox_unit ())); b348 = #100n } in
  let r_expected = { a348 = C21_0((unbox_unit ())); b348 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a348 *)
  r.a348 <- next_r.a348;
  let r_expected = { r_expected with a348 = next_r.a348 } in
  mark_test_run 2814;
  let test = eq r r_expected in
  if not test then failwithf "test 2814 failed";
  Gc.compact ();
  (* .b348 *)
  r.b348 <- next_r.b348;
  let r_expected = { r_expected with b348 = next_r.b348 } in
  mark_test_run 2815;
  let test = eq r r_expected in
  if not test then failwithf "test 2815 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a348; b348 } = r in
  let expected_a348 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2816;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a348 a348 in
  if not test then failwithf "test 2816 failed";
  let expected_b348 = #100n in
  mark_test_run 2817;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b348 b348 in
  if not test then failwithf "test 2817 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a348; b348 } = r in
  let expected_a348 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2818;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a348 a348 in
  if not test then failwithf "test 2818 failed";
  let expected_b348 = #100n in
  mark_test_run 2819;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b348 b348 in
  if not test then failwithf "test 2819 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************************************)
  (*   t349 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); unit_u }   *)
  (***************************************************************************)
  let r = { a349 = C21_0((unbox_unit ())); b349 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a349 *)
  let actual = r.a349 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2820;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2820 failed";
  (* Paths of depth 1 *)
  (* .b349 *)
  let actual = r.b349 in
  let expected = (unbox_unit ()) in
  mark_test_run 2821;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2821 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a349 = a3491; b349 = b3491 } { a349 = a3492; b349 = b3492 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3491 a3492 && (fun _ _ -> true) b3491 b3492) in
  let next_r = { a349 = C21_1((unbox_unit ()), (unbox_unit ())); b349 = (unbox_unit ()) } in
  let r_expected = { a349 = C21_0((unbox_unit ())); b349 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a349 *)
  r.a349 <- next_r.a349;
  let r_expected = { r_expected with a349 = next_r.a349 } in
  mark_test_run 2822;
  let test = eq r r_expected in
  if not test then failwithf "test 2822 failed";
  Gc.compact ();
  (* .b349 *)
  r.b349 <- next_r.b349;
  let r_expected = { r_expected with b349 = next_r.b349 } in
  mark_test_run 2823;
  let test = eq r r_expected in
  if not test then failwithf "test 2823 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a349; b349 } = r in
  let expected_a349 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2824;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a349 a349 in
  if not test then failwithf "test 2824 failed";
  let expected_b349 = (unbox_unit ()) in
  mark_test_run 2825;
  let test = (fun _ _ -> true) expected_b349 b349 in
  if not test then failwithf "test 2825 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a349; b349 } = r in
  let expected_a349 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2826;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a349 a349 in
  if not test then failwithf "test 2826 failed";
  let expected_b349 = (unbox_unit ()) in
  mark_test_run 2827;
  let test = (fun _ _ -> true) expected_b349 b349 in
  if not test then failwithf "test 2827 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************)
  (*   t350 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); float }   *)
  (**************************************************************************)
  let r = { a350 = C21_0((unbox_unit ())); b350 = 0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a350 *)
  let actual = r.a350 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2828;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2828 failed";
  (* Paths of depth 1 *)
  (* .b350 *)
  let actual = r.b350 in
  let expected = 0. in
  mark_test_run 2829;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2829 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a350 = a3501; b350 = b3501 } { a350 = a3502; b350 = b3502 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3501 a3502 && (fun a b -> Float.equal (globalize a) (globalize b)) b3501 b3502) in
  let next_r = { a350 = C21_1((unbox_unit ()), (unbox_unit ())); b350 = 100. } in
  let r_expected = { a350 = C21_0((unbox_unit ())); b350 = 0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a350 *)
  r.a350 <- next_r.a350;
  let r_expected = { r_expected with a350 = next_r.a350 } in
  mark_test_run 2830;
  let test = eq r r_expected in
  if not test then failwithf "test 2830 failed";
  Gc.compact ();
  (* .b350 *)
  r.b350 <- next_r.b350;
  let r_expected = { r_expected with b350 = next_r.b350 } in
  mark_test_run 2831;
  let test = eq r r_expected in
  if not test then failwithf "test 2831 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a350; b350 } = r in
  let expected_a350 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2832;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a350 a350 in
  if not test then failwithf "test 2832 failed";
  let expected_b350 = 100. in
  mark_test_run 2833;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b350 b350 in
  if not test then failwithf "test 2833 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a350; b350 } = r in
  let expected_a350 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2834;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a350 a350 in
  if not test then failwithf "test 2834 failed";
  let expected_b350 = 100. in
  mark_test_run 2835;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b350 b350 in
  if not test then failwithf "test 2835 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************************************)
  (*   t351 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); (| unit_u) }   *)
  (*******************************************************************************)
  let r = { a351 = C21_0((unbox_unit ())); b351 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a351 *)
  let actual = r.a351 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2836;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2836 failed";
  (* Paths of depth 1 *)
  (* .b351 *)
  let actual = r.b351 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2837;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2837 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a351 = a3511; b351 = b3511 } { a351 = a3512; b351 = b3512 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3511 a3512 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b3511 b3512) in
  let next_r = { a351 = C21_1((unbox_unit ()), (unbox_unit ())); b351 = C19_0((unbox_unit ())) } in
  let r_expected = { a351 = C21_0((unbox_unit ())); b351 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a351 *)
  r.a351 <- next_r.a351;
  let r_expected = { r_expected with a351 = next_r.a351 } in
  mark_test_run 2838;
  let test = eq r r_expected in
  if not test then failwithf "test 2838 failed";
  Gc.compact ();
  (* .b351 *)
  r.b351 <- next_r.b351;
  let r_expected = { r_expected with b351 = next_r.b351 } in
  mark_test_run 2839;
  let test = eq r r_expected in
  if not test then failwithf "test 2839 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a351; b351 } = r in
  let expected_a351 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2840;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a351 a351 in
  if not test then failwithf "test 2840 failed";
  let expected_b351 = C19_0((unbox_unit ())) in
  mark_test_run 2841;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b351 b351 in
  if not test then failwithf "test 2841 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a351; b351 } = r in
  let expected_a351 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2842;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a351 a351 in
  if not test then failwithf "test 2842 failed";
  let expected_b351 = C19_0((unbox_unit ())) in
  mark_test_run 2843;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b351 b351 in
  if not test then failwithf "test 2843 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************************************************************************)
  (*   t352 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (*********************************************************************************************************************)
  let r = { a352 = C21_0((unbox_unit ())); b352 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a352 *)
  let actual = r.a352 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2844;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2844 failed";
  (* Paths of depth 1 *)
  (* .b352 *)
  let actual = r.b352 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2845;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2845 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a352 = a3521; b352 = b3521 } { a352 = a3522; b352 = b3522 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3521 a3522 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b3521 b3522) in
  let next_r = { a352 = C21_1((unbox_unit ()), (unbox_unit ())); b352 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a352 = C21_0((unbox_unit ())); b352 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a352 *)
  r.a352 <- next_r.a352;
  let r_expected = { r_expected with a352 = next_r.a352 } in
  mark_test_run 2846;
  let test = eq r r_expected in
  if not test then failwithf "test 2846 failed";
  Gc.compact ();
  (* .b352 *)
  r.b352 <- next_r.b352;
  let r_expected = { r_expected with b352 = next_r.b352 } in
  mark_test_run 2847;
  let test = eq r r_expected in
  if not test then failwithf "test 2847 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a352; b352 } = r in
  let expected_a352 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2848;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a352 a352 in
  if not test then failwithf "test 2848 failed";
  let expected_b352 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2849;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b352 b352 in
  if not test then failwithf "test 2849 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a352; b352 } = r in
  let expected_a352 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2850;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a352 a352 in
  if not test then failwithf "test 2850 failed";
  let expected_b352 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2851;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b352 b352 in
  if not test then failwithf "test 2851 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************************************************)
  (*   t353 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, int) }   *)
  (***********************************************************************************)
  let r = { a353 = C21_0((unbox_unit ())); b353 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a353 *)
  let actual = r.a353 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2852;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2852 failed";
  (* Paths of depth 1 *)
  (* .b353 *)
  let actual = r.b353 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2853;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2853 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a353 = a3531; b353 = b3531 } { a353 = a3532; b353 = b3532 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3531 a3532 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b3531 b3532) in
  let next_r = { a353 = C21_1((unbox_unit ()), (unbox_unit ())); b353 = #((unbox_unit ()), 100) } in
  let r_expected = { a353 = C21_0((unbox_unit ())); b353 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a353 *)
  r.a353 <- next_r.a353;
  let r_expected = { r_expected with a353 = next_r.a353 } in
  mark_test_run 2854;
  let test = eq r r_expected in
  if not test then failwithf "test 2854 failed";
  Gc.compact ();
  (* .b353 *)
  r.b353 <- next_r.b353;
  let r_expected = { r_expected with b353 = next_r.b353 } in
  mark_test_run 2855;
  let test = eq r r_expected in
  if not test then failwithf "test 2855 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a353; b353 } = r in
  let expected_a353 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2856;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a353 a353 in
  if not test then failwithf "test 2856 failed";
  let expected_b353 = #((unbox_unit ()), 100) in
  mark_test_run 2857;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b353 b353 in
  if not test then failwithf "test 2857 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a353; b353 } = r in
  let expected_a353 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2858;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a353 a353 in
  if not test then failwithf "test 2858 failed";
  let expected_b353 = #((unbox_unit ()), 100) in
  mark_test_run 2859;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b353 b353 in
  if not test then failwithf "test 2859 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t354 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, int64#) }   *)
  (**************************************************************************************)
  let r = { a354 = C21_0((unbox_unit ())); b354 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a354 *)
  let actual = r.a354 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2860;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2860 failed";
  (* Paths of depth 1 *)
  (* .b354 *)
  let actual = r.b354 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 2861;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 2861 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a354 = a3541; b354 = b3541 } { a354 = a3542; b354 = b3542 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3541 a3542 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b3541 b3542) in
  let next_r = { a354 = C21_1((unbox_unit ()), (unbox_unit ())); b354 = #((unbox_unit ()), #100L) } in
  let r_expected = { a354 = C21_0((unbox_unit ())); b354 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a354 *)
  r.a354 <- next_r.a354;
  let r_expected = { r_expected with a354 = next_r.a354 } in
  mark_test_run 2862;
  let test = eq r r_expected in
  if not test then failwithf "test 2862 failed";
  Gc.compact ();
  (* .b354 *)
  r.b354 <- next_r.b354;
  let r_expected = { r_expected with b354 = next_r.b354 } in
  mark_test_run 2863;
  let test = eq r r_expected in
  if not test then failwithf "test 2863 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a354; b354 } = r in
  let expected_a354 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2864;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a354 a354 in
  if not test then failwithf "test 2864 failed";
  let expected_b354 = #((unbox_unit ()), #100L) in
  mark_test_run 2865;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b354 b354 in
  if not test then failwithf "test 2865 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a354; b354 } = r in
  let expected_a354 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2866;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a354 a354 in
  if not test then failwithf "test 2866 failed";
  let expected_b354 = #((unbox_unit ()), #100L) in
  mark_test_run 2867;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b354 b354 in
  if not test then failwithf "test 2867 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t355 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, unit_u) }   *)
  (**************************************************************************************)
  let r = { a355 = C21_0((unbox_unit ())); b355 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a355 *)
  let actual = r.a355 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2868;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2868 failed";
  (* Paths of depth 1 *)
  (* .b355 *)
  let actual = r.b355 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2869;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 2869 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a355 = a3551; b355 = b3551 } { a355 = a3552; b355 = b3552 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3551 a3552 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b3551 b3552) in
  let next_r = { a355 = C21_1((unbox_unit ()), (unbox_unit ())); b355 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a355 = C21_0((unbox_unit ())); b355 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a355 *)
  r.a355 <- next_r.a355;
  let r_expected = { r_expected with a355 = next_r.a355 } in
  mark_test_run 2870;
  let test = eq r r_expected in
  if not test then failwithf "test 2870 failed";
  Gc.compact ();
  (* .b355 *)
  r.b355 <- next_r.b355;
  let r_expected = { r_expected with b355 = next_r.b355 } in
  mark_test_run 2871;
  let test = eq r r_expected in
  if not test then failwithf "test 2871 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a355; b355 } = r in
  let expected_a355 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2872;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a355 a355 in
  if not test then failwithf "test 2872 failed";
  let expected_b355 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2873;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b355 b355 in
  if not test then failwithf "test 2873 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a355; b355 } = r in
  let expected_a355 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2874;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a355 a355 in
  if not test then failwithf "test 2874 failed";
  let expected_b355 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2875;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b355 b355 in
  if not test then failwithf "test 2875 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t356 = { (| unit_u | unit_u * unit_u | #(unit_u, unit_u)); #(unit_u, string) }   *)
  (**************************************************************************************)
  let r = { a356 = C21_0((unbox_unit ())); b356 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a356 *)
  let actual = r.a356 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 2876;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2876 failed";
  (* Paths of depth 1 *)
  (* .b356 *)
  let actual = r.b356 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 2877;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 2877 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a356 = a3561; b356 = b3561 } { a356 = a3562; b356 = b3562 } -> (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) a3561 a3562 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b3561 b3562) in
  let next_r = { a356 = C21_1((unbox_unit ()), (unbox_unit ())); b356 = #((unbox_unit ()), "100") } in
  let r_expected = { a356 = C21_0((unbox_unit ())); b356 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a356 *)
  r.a356 <- next_r.a356;
  let r_expected = { r_expected with a356 = next_r.a356 } in
  mark_test_run 2878;
  let test = eq r r_expected in
  if not test then failwithf "test 2878 failed";
  Gc.compact ();
  (* .b356 *)
  r.b356 <- next_r.b356;
  let r_expected = { r_expected with b356 = next_r.b356 } in
  mark_test_run 2879;
  let test = eq r r_expected in
  if not test then failwithf "test 2879 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a356; b356 } = r in
  let expected_a356 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2880;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a356 a356 in
  if not test then failwithf "test 2880 failed";
  let expected_b356 = #((unbox_unit ()), "100") in
  mark_test_run 2881;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b356 b356 in
  if not test then failwithf "test 2881 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a356; b356 } = r in
  let expected_a356 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2882;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_a356 a356 in
  if not test then failwithf "test 2882 failed";
  let expected_b356 = #((unbox_unit ()), "100") in
  mark_test_run 2883;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b356 b356 in
  if not test then failwithf "test 2883 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t357 = { #(unit_u, int) }   *)
  (*********************************)
  let r = { a357 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a357 *)
  let actual = r.a357 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2884;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2884 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a357 = a3571 } { a357 = a3572 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3571 a3572) in
  let next_r = { a357 = #((unbox_unit ()), 100) } in
  let r_expected = { a357 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a357 *)
  r.a357 <- next_r.a357;
  let r_expected = { r_expected with a357 = next_r.a357 } in
  mark_test_run 2885;
  let test = eq r r_expected in
  if not test then failwithf "test 2885 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a357 } = r in
  let expected_a357 = #((unbox_unit ()), 100) in
  mark_test_run 2886;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a357 a357 in
  if not test then failwithf "test 2886 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a357 } = r in
  let expected_a357 = #((unbox_unit ()), 100) in
  mark_test_run 2887;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a357 a357 in
  if not test then failwithf "test 2887 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t358 = { #(unit_u, int); int }   *)
  (**************************************)
  let r = { a358 = #((unbox_unit ()), 0); b358 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a358 *)
  let actual = r.a358 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2888;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2888 failed";
  (* Paths of depth 1 *)
  (* .b358 *)
  let actual = r.b358 in
  let expected = 1 in
  mark_test_run 2889;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2889 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a358 = a3581; b358 = b3581 } { a358 = a3582; b358 = b3582 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3581 a3582 && (fun a b -> Int.equal a b) b3581 b3582) in
  let next_r = { a358 = #((unbox_unit ()), 100); b358 = 101 } in
  let r_expected = { a358 = #((unbox_unit ()), 0); b358 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a358 *)
  r.a358 <- next_r.a358;
  let r_expected = { r_expected with a358 = next_r.a358 } in
  mark_test_run 2890;
  let test = eq r r_expected in
  if not test then failwithf "test 2890 failed";
  Gc.compact ();
  (* .b358 *)
  r.b358 <- next_r.b358;
  let r_expected = { r_expected with b358 = next_r.b358 } in
  mark_test_run 2891;
  let test = eq r r_expected in
  if not test then failwithf "test 2891 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a358; b358 } = r in
  let expected_a358 = #((unbox_unit ()), 100) in
  mark_test_run 2892;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a358 a358 in
  if not test then failwithf "test 2892 failed";
  let expected_b358 = 101 in
  mark_test_run 2893;
  let test = (fun a b -> Int.equal a b) expected_b358 b358 in
  if not test then failwithf "test 2893 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a358; b358 } = r in
  let expected_a358 = #((unbox_unit ()), 100) in
  mark_test_run 2894;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a358 a358 in
  if not test then failwithf "test 2894 failed";
  let expected_b358 = 101 in
  mark_test_run 2895;
  let test = (fun a b -> Int.equal a b) expected_b358 b358 in
  if not test then failwithf "test 2895 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t359 = { #(unit_u, int); int64 }   *)
  (****************************************)
  let r = { a359 = #((unbox_unit ()), 0); b359 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a359 *)
  let actual = r.a359 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2896;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2896 failed";
  (* Paths of depth 1 *)
  (* .b359 *)
  let actual = r.b359 in
  let expected = 1L in
  mark_test_run 2897;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2897 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a359 = a3591; b359 = b3591 } { a359 = a3592; b359 = b3592 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3591 a3592 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3591 b3592) in
  let next_r = { a359 = #((unbox_unit ()), 100); b359 = 101L } in
  let r_expected = { a359 = #((unbox_unit ()), 0); b359 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a359 *)
  r.a359 <- next_r.a359;
  let r_expected = { r_expected with a359 = next_r.a359 } in
  mark_test_run 2898;
  let test = eq r r_expected in
  if not test then failwithf "test 2898 failed";
  Gc.compact ();
  (* .b359 *)
  r.b359 <- next_r.b359;
  let r_expected = { r_expected with b359 = next_r.b359 } in
  mark_test_run 2899;
  let test = eq r r_expected in
  if not test then failwithf "test 2899 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a359; b359 } = r in
  let expected_a359 = #((unbox_unit ()), 100) in
  mark_test_run 2900;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a359 a359 in
  if not test then failwithf "test 2900 failed";
  let expected_b359 = 101L in
  mark_test_run 2901;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b359 b359 in
  if not test then failwithf "test 2901 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a359; b359 } = r in
  let expected_a359 = #((unbox_unit ()), 100) in
  mark_test_run 2902;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a359 a359 in
  if not test then failwithf "test 2902 failed";
  let expected_b359 = 101L in
  mark_test_run 2903;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b359 b359 in
  if not test then failwithf "test 2903 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t360 = { #(unit_u, int); int64# }   *)
  (*****************************************)
  let r = { a360 = #((unbox_unit ()), 0); b360 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a360 *)
  let actual = r.a360 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2904;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2904 failed";
  (* Paths of depth 1 *)
  (* .b360 *)
  let actual = r.b360 in
  let expected = #1L in
  mark_test_run 2905;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 2905 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a360 = a3601; b360 = b3601 } { a360 = a3602; b360 = b3602 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3601 a3602 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3601 b3602) in
  let next_r = { a360 = #((unbox_unit ()), 100); b360 = #101L } in
  let r_expected = { a360 = #((unbox_unit ()), 0); b360 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a360 *)
  r.a360 <- next_r.a360;
  let r_expected = { r_expected with a360 = next_r.a360 } in
  mark_test_run 2906;
  let test = eq r r_expected in
  if not test then failwithf "test 2906 failed";
  Gc.compact ();
  (* .b360 *)
  r.b360 <- next_r.b360;
  let r_expected = { r_expected with b360 = next_r.b360 } in
  mark_test_run 2907;
  let test = eq r r_expected in
  if not test then failwithf "test 2907 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a360; b360 } = r in
  let expected_a360 = #((unbox_unit ()), 100) in
  mark_test_run 2908;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a360 a360 in
  if not test then failwithf "test 2908 failed";
  let expected_b360 = #101L in
  mark_test_run 2909;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b360 b360 in
  if not test then failwithf "test 2909 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a360; b360 } = r in
  let expected_a360 = #((unbox_unit ()), 100) in
  mark_test_run 2910;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a360 a360 in
  if not test then failwithf "test 2910 failed";
  let expected_b360 = #101L in
  mark_test_run 2911;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b360 b360 in
  if not test then failwithf "test 2911 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t361 = { #(unit_u, int); int32# }   *)
  (*****************************************)
  let r = { a361 = #((unbox_unit ()), 0); b361 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a361 *)
  let actual = r.a361 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2912;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2912 failed";
  (* Paths of depth 1 *)
  (* .b361 *)
  let actual = r.b361 in
  let expected = #1l in
  mark_test_run 2913;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 2913 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a361 = a3611; b361 = b3611 } { a361 = a3612; b361 = b3612 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3611 a3612 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b3611 b3612) in
  let next_r = { a361 = #((unbox_unit ()), 100); b361 = #101l } in
  let r_expected = { a361 = #((unbox_unit ()), 0); b361 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a361 *)
  r.a361 <- next_r.a361;
  let r_expected = { r_expected with a361 = next_r.a361 } in
  mark_test_run 2914;
  let test = eq r r_expected in
  if not test then failwithf "test 2914 failed";
  Gc.compact ();
  (* .b361 *)
  r.b361 <- next_r.b361;
  let r_expected = { r_expected with b361 = next_r.b361 } in
  mark_test_run 2915;
  let test = eq r r_expected in
  if not test then failwithf "test 2915 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a361; b361 } = r in
  let expected_a361 = #((unbox_unit ()), 100) in
  mark_test_run 2916;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a361 a361 in
  if not test then failwithf "test 2916 failed";
  let expected_b361 = #101l in
  mark_test_run 2917;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b361 b361 in
  if not test then failwithf "test 2917 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a361; b361 } = r in
  let expected_a361 = #((unbox_unit ()), 100) in
  mark_test_run 2918;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a361 a361 in
  if not test then failwithf "test 2918 failed";
  let expected_b361 = #101l in
  mark_test_run 2919;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b361 b361 in
  if not test then failwithf "test 2919 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t362 = { #(unit_u, int); nativeint# }   *)
  (*********************************************)
  let r = { a362 = #((unbox_unit ()), 0); b362 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a362 *)
  let actual = r.a362 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2920;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2920 failed";
  (* Paths of depth 1 *)
  (* .b362 *)
  let actual = r.b362 in
  let expected = #1n in
  mark_test_run 2921;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 2921 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a362 = a3621; b362 = b3621 } { a362 = a3622; b362 = b3622 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3621 a3622 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b3621 b3622) in
  let next_r = { a362 = #((unbox_unit ()), 100); b362 = #101n } in
  let r_expected = { a362 = #((unbox_unit ()), 0); b362 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a362 *)
  r.a362 <- next_r.a362;
  let r_expected = { r_expected with a362 = next_r.a362 } in
  mark_test_run 2922;
  let test = eq r r_expected in
  if not test then failwithf "test 2922 failed";
  Gc.compact ();
  (* .b362 *)
  r.b362 <- next_r.b362;
  let r_expected = { r_expected with b362 = next_r.b362 } in
  mark_test_run 2923;
  let test = eq r r_expected in
  if not test then failwithf "test 2923 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a362; b362 } = r in
  let expected_a362 = #((unbox_unit ()), 100) in
  mark_test_run 2924;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a362 a362 in
  if not test then failwithf "test 2924 failed";
  let expected_b362 = #101n in
  mark_test_run 2925;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b362 b362 in
  if not test then failwithf "test 2925 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a362; b362 } = r in
  let expected_a362 = #((unbox_unit ()), 100) in
  mark_test_run 2926;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a362 a362 in
  if not test then failwithf "test 2926 failed";
  let expected_b362 = #101n in
  mark_test_run 2927;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b362 b362 in
  if not test then failwithf "test 2927 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t363 = { #(unit_u, int); unit_u }   *)
  (*****************************************)
  let r = { a363 = #((unbox_unit ()), 0); b363 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a363 *)
  let actual = r.a363 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2928;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2928 failed";
  (* Paths of depth 1 *)
  (* .b363 *)
  let actual = r.b363 in
  let expected = (unbox_unit ()) in
  mark_test_run 2929;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2929 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a363 = a3631; b363 = b3631 } { a363 = a3632; b363 = b3632 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3631 a3632 && (fun _ _ -> true) b3631 b3632) in
  let next_r = { a363 = #((unbox_unit ()), 100); b363 = (unbox_unit ()) } in
  let r_expected = { a363 = #((unbox_unit ()), 0); b363 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a363 *)
  r.a363 <- next_r.a363;
  let r_expected = { r_expected with a363 = next_r.a363 } in
  mark_test_run 2930;
  let test = eq r r_expected in
  if not test then failwithf "test 2930 failed";
  Gc.compact ();
  (* .b363 *)
  r.b363 <- next_r.b363;
  let r_expected = { r_expected with b363 = next_r.b363 } in
  mark_test_run 2931;
  let test = eq r r_expected in
  if not test then failwithf "test 2931 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a363; b363 } = r in
  let expected_a363 = #((unbox_unit ()), 100) in
  mark_test_run 2932;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a363 a363 in
  if not test then failwithf "test 2932 failed";
  let expected_b363 = (unbox_unit ()) in
  mark_test_run 2933;
  let test = (fun _ _ -> true) expected_b363 b363 in
  if not test then failwithf "test 2933 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a363; b363 } = r in
  let expected_a363 = #((unbox_unit ()), 100) in
  mark_test_run 2934;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a363 a363 in
  if not test then failwithf "test 2934 failed";
  let expected_b363 = (unbox_unit ()) in
  mark_test_run 2935;
  let test = (fun _ _ -> true) expected_b363 b363 in
  if not test then failwithf "test 2935 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t364 = { #(unit_u, int); float }   *)
  (****************************************)
  let r = { a364 = #((unbox_unit ()), 0); b364 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a364 *)
  let actual = r.a364 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2936;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2936 failed";
  (* Paths of depth 1 *)
  (* .b364 *)
  let actual = r.b364 in
  let expected = 1. in
  mark_test_run 2937;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 2937 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a364 = a3641; b364 = b3641 } { a364 = a3642; b364 = b3642 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3641 a3642 && (fun a b -> Float.equal (globalize a) (globalize b)) b3641 b3642) in
  let next_r = { a364 = #((unbox_unit ()), 100); b364 = 101. } in
  let r_expected = { a364 = #((unbox_unit ()), 0); b364 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a364 *)
  r.a364 <- next_r.a364;
  let r_expected = { r_expected with a364 = next_r.a364 } in
  mark_test_run 2938;
  let test = eq r r_expected in
  if not test then failwithf "test 2938 failed";
  Gc.compact ();
  (* .b364 *)
  r.b364 <- next_r.b364;
  let r_expected = { r_expected with b364 = next_r.b364 } in
  mark_test_run 2939;
  let test = eq r r_expected in
  if not test then failwithf "test 2939 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a364; b364 } = r in
  let expected_a364 = #((unbox_unit ()), 100) in
  mark_test_run 2940;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a364 a364 in
  if not test then failwithf "test 2940 failed";
  let expected_b364 = 101. in
  mark_test_run 2941;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b364 b364 in
  if not test then failwithf "test 2941 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a364; b364 } = r in
  let expected_a364 = #((unbox_unit ()), 100) in
  mark_test_run 2942;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a364 a364 in
  if not test then failwithf "test 2942 failed";
  let expected_b364 = 101. in
  mark_test_run 2943;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b364 b364 in
  if not test then failwithf "test 2943 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t365 = { #(unit_u, int); (| unit_u) }   *)
  (*********************************************)
  let r = { a365 = #((unbox_unit ()), 0); b365 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a365 *)
  let actual = r.a365 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2944;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2944 failed";
  (* Paths of depth 1 *)
  (* .b365 *)
  let actual = r.b365 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 2945;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 2945 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a365 = a3651; b365 = b3651 } { a365 = a3652; b365 = b3652 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3651 a3652 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b3651 b3652) in
  let next_r = { a365 = #((unbox_unit ()), 100); b365 = C19_0((unbox_unit ())) } in
  let r_expected = { a365 = #((unbox_unit ()), 0); b365 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a365 *)
  r.a365 <- next_r.a365;
  let r_expected = { r_expected with a365 = next_r.a365 } in
  mark_test_run 2946;
  let test = eq r r_expected in
  if not test then failwithf "test 2946 failed";
  Gc.compact ();
  (* .b365 *)
  r.b365 <- next_r.b365;
  let r_expected = { r_expected with b365 = next_r.b365 } in
  mark_test_run 2947;
  let test = eq r r_expected in
  if not test then failwithf "test 2947 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a365; b365 } = r in
  let expected_a365 = #((unbox_unit ()), 100) in
  mark_test_run 2948;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a365 a365 in
  if not test then failwithf "test 2948 failed";
  let expected_b365 = C19_0((unbox_unit ())) in
  mark_test_run 2949;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b365 b365 in
  if not test then failwithf "test 2949 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a365; b365 } = r in
  let expected_a365 = #((unbox_unit ()), 100) in
  mark_test_run 2950;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a365 a365 in
  if not test then failwithf "test 2950 failed";
  let expected_b365 = C19_0((unbox_unit ())) in
  mark_test_run 2951;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b365 b365 in
  if not test then failwithf "test 2951 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************************************************)
  (*   t366 = { #(unit_u, int); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (***********************************************************************************)
  let r = { a366 = #((unbox_unit ()), 0); b366 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a366 *)
  let actual = r.a366 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2952;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2952 failed";
  (* Paths of depth 1 *)
  (* .b366 *)
  let actual = r.b366 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2953;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 2953 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a366 = a3661; b366 = b3661 } { a366 = a3662; b366 = b3662 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3661 a3662 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b3661 b3662) in
  let next_r = { a366 = #((unbox_unit ()), 100); b366 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a366 = #((unbox_unit ()), 0); b366 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a366 *)
  r.a366 <- next_r.a366;
  let r_expected = { r_expected with a366 = next_r.a366 } in
  mark_test_run 2954;
  let test = eq r r_expected in
  if not test then failwithf "test 2954 failed";
  Gc.compact ();
  (* .b366 *)
  r.b366 <- next_r.b366;
  let r_expected = { r_expected with b366 = next_r.b366 } in
  mark_test_run 2955;
  let test = eq r r_expected in
  if not test then failwithf "test 2955 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a366; b366 } = r in
  let expected_a366 = #((unbox_unit ()), 100) in
  mark_test_run 2956;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a366 a366 in
  if not test then failwithf "test 2956 failed";
  let expected_b366 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 2957;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b366 b366 in
  if not test then failwithf "test 2957 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a366; b366 } = r in
  let expected_a366 = #((unbox_unit ()), 100) in
  mark_test_run 2958;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a366 a366 in
  if not test then failwithf "test 2958 failed";
  let expected_b366 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 2959;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b366 b366 in
  if not test then failwithf "test 2959 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t367 = { #(unit_u, int); #(unit_u, int) }   *)
  (*************************************************)
  let r = { a367 = #((unbox_unit ()), 0); b367 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a367 *)
  let actual = r.a367 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2960;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2960 failed";
  (* Paths of depth 1 *)
  (* .b367 *)
  let actual = r.b367 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 2961;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2961 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a367 = a3671; b367 = b3671 } { a367 = a3672; b367 = b3672 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3671 a3672 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b3671 b3672) in
  let next_r = { a367 = #((unbox_unit ()), 100); b367 = #((unbox_unit ()), 101) } in
  let r_expected = { a367 = #((unbox_unit ()), 0); b367 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a367 *)
  r.a367 <- next_r.a367;
  let r_expected = { r_expected with a367 = next_r.a367 } in
  mark_test_run 2962;
  let test = eq r r_expected in
  if not test then failwithf "test 2962 failed";
  Gc.compact ();
  (* .b367 *)
  r.b367 <- next_r.b367;
  let r_expected = { r_expected with b367 = next_r.b367 } in
  mark_test_run 2963;
  let test = eq r r_expected in
  if not test then failwithf "test 2963 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a367; b367 } = r in
  let expected_a367 = #((unbox_unit ()), 100) in
  mark_test_run 2964;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a367 a367 in
  if not test then failwithf "test 2964 failed";
  let expected_b367 = #((unbox_unit ()), 101) in
  mark_test_run 2965;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b367 b367 in
  if not test then failwithf "test 2965 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a367; b367 } = r in
  let expected_a367 = #((unbox_unit ()), 100) in
  mark_test_run 2966;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a367 a367 in
  if not test then failwithf "test 2966 failed";
  let expected_b367 = #((unbox_unit ()), 101) in
  mark_test_run 2967;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b367 b367 in
  if not test then failwithf "test 2967 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t368 = { #(unit_u, int); #(unit_u, int64#) }   *)
  (****************************************************)
  let r = { a368 = #((unbox_unit ()), 0); b368 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a368 *)
  let actual = r.a368 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2968;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2968 failed";
  (* Paths of depth 1 *)
  (* .b368 *)
  let actual = r.b368 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 2969;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 2969 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a368 = a3681; b368 = b3681 } { a368 = a3682; b368 = b3682 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3681 a3682 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b3681 b3682) in
  let next_r = { a368 = #((unbox_unit ()), 100); b368 = #((unbox_unit ()), #101L) } in
  let r_expected = { a368 = #((unbox_unit ()), 0); b368 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a368 *)
  r.a368 <- next_r.a368;
  let r_expected = { r_expected with a368 = next_r.a368 } in
  mark_test_run 2970;
  let test = eq r r_expected in
  if not test then failwithf "test 2970 failed";
  Gc.compact ();
  (* .b368 *)
  r.b368 <- next_r.b368;
  let r_expected = { r_expected with b368 = next_r.b368 } in
  mark_test_run 2971;
  let test = eq r r_expected in
  if not test then failwithf "test 2971 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a368; b368 } = r in
  let expected_a368 = #((unbox_unit ()), 100) in
  mark_test_run 2972;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a368 a368 in
  if not test then failwithf "test 2972 failed";
  let expected_b368 = #((unbox_unit ()), #101L) in
  mark_test_run 2973;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b368 b368 in
  if not test then failwithf "test 2973 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a368; b368 } = r in
  let expected_a368 = #((unbox_unit ()), 100) in
  mark_test_run 2974;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a368 a368 in
  if not test then failwithf "test 2974 failed";
  let expected_b368 = #((unbox_unit ()), #101L) in
  mark_test_run 2975;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b368 b368 in
  if not test then failwithf "test 2975 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t369 = { #(unit_u, int); #(unit_u, unit_u) }   *)
  (****************************************************)
  let r = { a369 = #((unbox_unit ()), 0); b369 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a369 *)
  let actual = r.a369 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2976;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2976 failed";
  (* Paths of depth 1 *)
  (* .b369 *)
  let actual = r.b369 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2977;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 2977 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a369 = a3691; b369 = b3691 } { a369 = a3692; b369 = b3692 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3691 a3692 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b3691 b3692) in
  let next_r = { a369 = #((unbox_unit ()), 100); b369 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a369 = #((unbox_unit ()), 0); b369 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a369 *)
  r.a369 <- next_r.a369;
  let r_expected = { r_expected with a369 = next_r.a369 } in
  mark_test_run 2978;
  let test = eq r r_expected in
  if not test then failwithf "test 2978 failed";
  Gc.compact ();
  (* .b369 *)
  r.b369 <- next_r.b369;
  let r_expected = { r_expected with b369 = next_r.b369 } in
  mark_test_run 2979;
  let test = eq r r_expected in
  if not test then failwithf "test 2979 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a369; b369 } = r in
  let expected_a369 = #((unbox_unit ()), 100) in
  mark_test_run 2980;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a369 a369 in
  if not test then failwithf "test 2980 failed";
  let expected_b369 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2981;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b369 b369 in
  if not test then failwithf "test 2981 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a369; b369 } = r in
  let expected_a369 = #((unbox_unit ()), 100) in
  mark_test_run 2982;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a369 a369 in
  if not test then failwithf "test 2982 failed";
  let expected_b369 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 2983;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b369 b369 in
  if not test then failwithf "test 2983 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t370 = { #(unit_u, int); #(unit_u, string) }   *)
  (****************************************************)
  let r = { a370 = #((unbox_unit ()), 0); b370 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a370 *)
  let actual = r.a370 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 2984;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 2984 failed";
  (* Paths of depth 1 *)
  (* .b370 *)
  let actual = r.b370 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 2985;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 2985 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a370 = a3701; b370 = b3701 } { a370 = a3702; b370 = b3702 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) a3701 a3702 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b3701 b3702) in
  let next_r = { a370 = #((unbox_unit ()), 100); b370 = #((unbox_unit ()), "101") } in
  let r_expected = { a370 = #((unbox_unit ()), 0); b370 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a370 *)
  r.a370 <- next_r.a370;
  let r_expected = { r_expected with a370 = next_r.a370 } in
  mark_test_run 2986;
  let test = eq r r_expected in
  if not test then failwithf "test 2986 failed";
  Gc.compact ();
  (* .b370 *)
  r.b370 <- next_r.b370;
  let r_expected = { r_expected with b370 = next_r.b370 } in
  mark_test_run 2987;
  let test = eq r r_expected in
  if not test then failwithf "test 2987 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a370; b370 } = r in
  let expected_a370 = #((unbox_unit ()), 100) in
  mark_test_run 2988;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a370 a370 in
  if not test then failwithf "test 2988 failed";
  let expected_b370 = #((unbox_unit ()), "101") in
  mark_test_run 2989;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b370 b370 in
  if not test then failwithf "test 2989 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a370; b370 } = r in
  let expected_a370 = #((unbox_unit ()), 100) in
  mark_test_run 2990;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_a370 a370 in
  if not test then failwithf "test 2990 failed";
  let expected_b370 = #((unbox_unit ()), "101") in
  mark_test_run 2991;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b370 b370 in
  if not test then failwithf "test 2991 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t371 = { #(unit_u, int64#) }   *)
  (************************************)
  let r = { a371 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a371 *)
  let actual = r.a371 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 2992;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 2992 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a371 = a3711 } { a371 = a3712 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3711 a3712) in
  let next_r = { a371 = #((unbox_unit ()), #100L) } in
  let r_expected = { a371 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a371 *)
  r.a371 <- next_r.a371;
  let r_expected = { r_expected with a371 = next_r.a371 } in
  mark_test_run 2993;
  let test = eq r r_expected in
  if not test then failwithf "test 2993 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a371 } = r in
  let expected_a371 = #((unbox_unit ()), #100L) in
  mark_test_run 2994;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a371 a371 in
  if not test then failwithf "test 2994 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a371 } = r in
  let expected_a371 = #((unbox_unit ()), #100L) in
  mark_test_run 2995;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a371 a371 in
  if not test then failwithf "test 2995 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t372 = { #(unit_u, int64#); int }   *)
  (*****************************************)
  let r = { a372 = #((unbox_unit ()), #0L); b372 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a372 *)
  let actual = r.a372 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 2996;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 2996 failed";
  (* Paths of depth 1 *)
  (* .b372 *)
  let actual = r.b372 in
  let expected = 1 in
  mark_test_run 2997;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2997 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a372 = a3721; b372 = b3721 } { a372 = a3722; b372 = b3722 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3721 a3722 && (fun a b -> Int.equal a b) b3721 b3722) in
  let next_r = { a372 = #((unbox_unit ()), #100L); b372 = 101 } in
  let r_expected = { a372 = #((unbox_unit ()), #0L); b372 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a372 *)
  r.a372 <- next_r.a372;
  let r_expected = { r_expected with a372 = next_r.a372 } in
  mark_test_run 2998;
  let test = eq r r_expected in
  if not test then failwithf "test 2998 failed";
  Gc.compact ();
  (* .b372 *)
  r.b372 <- next_r.b372;
  let r_expected = { r_expected with b372 = next_r.b372 } in
  mark_test_run 2999;
  let test = eq r r_expected in
  if not test then failwithf "test 2999 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a372; b372 } = r in
  let expected_a372 = #((unbox_unit ()), #100L) in
  mark_test_run 3000;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a372 a372 in
  if not test then failwithf "test 3000 failed";
  let expected_b372 = 101 in
  mark_test_run 3001;
  let test = (fun a b -> Int.equal a b) expected_b372 b372 in
  if not test then failwithf "test 3001 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a372; b372 } = r in
  let expected_a372 = #((unbox_unit ()), #100L) in
  mark_test_run 3002;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a372 a372 in
  if not test then failwithf "test 3002 failed";
  let expected_b372 = 101 in
  mark_test_run 3003;
  let test = (fun a b -> Int.equal a b) expected_b372 b372 in
  if not test then failwithf "test 3003 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t373 = { #(unit_u, int64#); int64 }   *)
  (*******************************************)
  let r = { a373 = #((unbox_unit ()), #0L); b373 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a373 *)
  let actual = r.a373 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3004;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3004 failed";
  (* Paths of depth 1 *)
  (* .b373 *)
  let actual = r.b373 in
  let expected = 1L in
  mark_test_run 3005;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3005 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a373 = a3731; b373 = b3731 } { a373 = a3732; b373 = b3732 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3731 a3732 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3731 b3732) in
  let next_r = { a373 = #((unbox_unit ()), #100L); b373 = 101L } in
  let r_expected = { a373 = #((unbox_unit ()), #0L); b373 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a373 *)
  r.a373 <- next_r.a373;
  let r_expected = { r_expected with a373 = next_r.a373 } in
  mark_test_run 3006;
  let test = eq r r_expected in
  if not test then failwithf "test 3006 failed";
  Gc.compact ();
  (* .b373 *)
  r.b373 <- next_r.b373;
  let r_expected = { r_expected with b373 = next_r.b373 } in
  mark_test_run 3007;
  let test = eq r r_expected in
  if not test then failwithf "test 3007 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a373; b373 } = r in
  let expected_a373 = #((unbox_unit ()), #100L) in
  mark_test_run 3008;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a373 a373 in
  if not test then failwithf "test 3008 failed";
  let expected_b373 = 101L in
  mark_test_run 3009;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b373 b373 in
  if not test then failwithf "test 3009 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a373; b373 } = r in
  let expected_a373 = #((unbox_unit ()), #100L) in
  mark_test_run 3010;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a373 a373 in
  if not test then failwithf "test 3010 failed";
  let expected_b373 = 101L in
  mark_test_run 3011;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b373 b373 in
  if not test then failwithf "test 3011 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t374 = { #(unit_u, int64#); int64# }   *)
  (********************************************)
  let r = { a374 = #((unbox_unit ()), #0L); b374 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a374 *)
  let actual = r.a374 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3012;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3012 failed";
  (* Paths of depth 1 *)
  (* .b374 *)
  let actual = r.b374 in
  let expected = #1L in
  mark_test_run 3013;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3013 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a374 = a3741; b374 = b3741 } { a374 = a3742; b374 = b3742 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3741 a3742 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3741 b3742) in
  let next_r = { a374 = #((unbox_unit ()), #100L); b374 = #101L } in
  let r_expected = { a374 = #((unbox_unit ()), #0L); b374 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a374 *)
  r.a374 <- next_r.a374;
  let r_expected = { r_expected with a374 = next_r.a374 } in
  mark_test_run 3014;
  let test = eq r r_expected in
  if not test then failwithf "test 3014 failed";
  Gc.compact ();
  (* .b374 *)
  r.b374 <- next_r.b374;
  let r_expected = { r_expected with b374 = next_r.b374 } in
  mark_test_run 3015;
  let test = eq r r_expected in
  if not test then failwithf "test 3015 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a374; b374 } = r in
  let expected_a374 = #((unbox_unit ()), #100L) in
  mark_test_run 3016;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a374 a374 in
  if not test then failwithf "test 3016 failed";
  let expected_b374 = #101L in
  mark_test_run 3017;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b374 b374 in
  if not test then failwithf "test 3017 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a374; b374 } = r in
  let expected_a374 = #((unbox_unit ()), #100L) in
  mark_test_run 3018;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a374 a374 in
  if not test then failwithf "test 3018 failed";
  let expected_b374 = #101L in
  mark_test_run 3019;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b374 b374 in
  if not test then failwithf "test 3019 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t375 = { #(unit_u, int64#); int32# }   *)
  (********************************************)
  let r = { a375 = #((unbox_unit ()), #0L); b375 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a375 *)
  let actual = r.a375 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3020;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3020 failed";
  (* Paths of depth 1 *)
  (* .b375 *)
  let actual = r.b375 in
  let expected = #1l in
  mark_test_run 3021;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3021 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a375 = a3751; b375 = b3751 } { a375 = a3752; b375 = b3752 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3751 a3752 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b3751 b3752) in
  let next_r = { a375 = #((unbox_unit ()), #100L); b375 = #101l } in
  let r_expected = { a375 = #((unbox_unit ()), #0L); b375 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a375 *)
  r.a375 <- next_r.a375;
  let r_expected = { r_expected with a375 = next_r.a375 } in
  mark_test_run 3022;
  let test = eq r r_expected in
  if not test then failwithf "test 3022 failed";
  Gc.compact ();
  (* .b375 *)
  r.b375 <- next_r.b375;
  let r_expected = { r_expected with b375 = next_r.b375 } in
  mark_test_run 3023;
  let test = eq r r_expected in
  if not test then failwithf "test 3023 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a375; b375 } = r in
  let expected_a375 = #((unbox_unit ()), #100L) in
  mark_test_run 3024;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a375 a375 in
  if not test then failwithf "test 3024 failed";
  let expected_b375 = #101l in
  mark_test_run 3025;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b375 b375 in
  if not test then failwithf "test 3025 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a375; b375 } = r in
  let expected_a375 = #((unbox_unit ()), #100L) in
  mark_test_run 3026;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a375 a375 in
  if not test then failwithf "test 3026 failed";
  let expected_b375 = #101l in
  mark_test_run 3027;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b375 b375 in
  if not test then failwithf "test 3027 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t376 = { #(unit_u, int64#); nativeint# }   *)
  (************************************************)
  let r = { a376 = #((unbox_unit ()), #0L); b376 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a376 *)
  let actual = r.a376 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3028;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3028 failed";
  (* Paths of depth 1 *)
  (* .b376 *)
  let actual = r.b376 in
  let expected = #1n in
  mark_test_run 3029;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 3029 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a376 = a3761; b376 = b3761 } { a376 = a3762; b376 = b3762 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3761 a3762 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b3761 b3762) in
  let next_r = { a376 = #((unbox_unit ()), #100L); b376 = #101n } in
  let r_expected = { a376 = #((unbox_unit ()), #0L); b376 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a376 *)
  r.a376 <- next_r.a376;
  let r_expected = { r_expected with a376 = next_r.a376 } in
  mark_test_run 3030;
  let test = eq r r_expected in
  if not test then failwithf "test 3030 failed";
  Gc.compact ();
  (* .b376 *)
  r.b376 <- next_r.b376;
  let r_expected = { r_expected with b376 = next_r.b376 } in
  mark_test_run 3031;
  let test = eq r r_expected in
  if not test then failwithf "test 3031 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a376; b376 } = r in
  let expected_a376 = #((unbox_unit ()), #100L) in
  mark_test_run 3032;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a376 a376 in
  if not test then failwithf "test 3032 failed";
  let expected_b376 = #101n in
  mark_test_run 3033;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b376 b376 in
  if not test then failwithf "test 3033 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a376; b376 } = r in
  let expected_a376 = #((unbox_unit ()), #100L) in
  mark_test_run 3034;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a376 a376 in
  if not test then failwithf "test 3034 failed";
  let expected_b376 = #101n in
  mark_test_run 3035;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b376 b376 in
  if not test then failwithf "test 3035 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t377 = { #(unit_u, int64#); unit_u }   *)
  (********************************************)
  let r = { a377 = #((unbox_unit ()), #0L); b377 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a377 *)
  let actual = r.a377 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3036;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3036 failed";
  (* Paths of depth 1 *)
  (* .b377 *)
  let actual = r.b377 in
  let expected = (unbox_unit ()) in
  mark_test_run 3037;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3037 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a377 = a3771; b377 = b3771 } { a377 = a3772; b377 = b3772 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3771 a3772 && (fun _ _ -> true) b3771 b3772) in
  let next_r = { a377 = #((unbox_unit ()), #100L); b377 = (unbox_unit ()) } in
  let r_expected = { a377 = #((unbox_unit ()), #0L); b377 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a377 *)
  r.a377 <- next_r.a377;
  let r_expected = { r_expected with a377 = next_r.a377 } in
  mark_test_run 3038;
  let test = eq r r_expected in
  if not test then failwithf "test 3038 failed";
  Gc.compact ();
  (* .b377 *)
  r.b377 <- next_r.b377;
  let r_expected = { r_expected with b377 = next_r.b377 } in
  mark_test_run 3039;
  let test = eq r r_expected in
  if not test then failwithf "test 3039 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a377; b377 } = r in
  let expected_a377 = #((unbox_unit ()), #100L) in
  mark_test_run 3040;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a377 a377 in
  if not test then failwithf "test 3040 failed";
  let expected_b377 = (unbox_unit ()) in
  mark_test_run 3041;
  let test = (fun _ _ -> true) expected_b377 b377 in
  if not test then failwithf "test 3041 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a377; b377 } = r in
  let expected_a377 = #((unbox_unit ()), #100L) in
  mark_test_run 3042;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a377 a377 in
  if not test then failwithf "test 3042 failed";
  let expected_b377 = (unbox_unit ()) in
  mark_test_run 3043;
  let test = (fun _ _ -> true) expected_b377 b377 in
  if not test then failwithf "test 3043 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t378 = { #(unit_u, int64#); float }   *)
  (*******************************************)
  let r = { a378 = #((unbox_unit ()), #0L); b378 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a378 *)
  let actual = r.a378 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3044;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3044 failed";
  (* Paths of depth 1 *)
  (* .b378 *)
  let actual = r.b378 in
  let expected = 1. in
  mark_test_run 3045;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3045 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a378 = a3781; b378 = b3781 } { a378 = a3782; b378 = b3782 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3781 a3782 && (fun a b -> Float.equal (globalize a) (globalize b)) b3781 b3782) in
  let next_r = { a378 = #((unbox_unit ()), #100L); b378 = 101. } in
  let r_expected = { a378 = #((unbox_unit ()), #0L); b378 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a378 *)
  r.a378 <- next_r.a378;
  let r_expected = { r_expected with a378 = next_r.a378 } in
  mark_test_run 3046;
  let test = eq r r_expected in
  if not test then failwithf "test 3046 failed";
  Gc.compact ();
  (* .b378 *)
  r.b378 <- next_r.b378;
  let r_expected = { r_expected with b378 = next_r.b378 } in
  mark_test_run 3047;
  let test = eq r r_expected in
  if not test then failwithf "test 3047 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a378; b378 } = r in
  let expected_a378 = #((unbox_unit ()), #100L) in
  mark_test_run 3048;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a378 a378 in
  if not test then failwithf "test 3048 failed";
  let expected_b378 = 101. in
  mark_test_run 3049;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b378 b378 in
  if not test then failwithf "test 3049 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a378; b378 } = r in
  let expected_a378 = #((unbox_unit ()), #100L) in
  mark_test_run 3050;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a378 a378 in
  if not test then failwithf "test 3050 failed";
  let expected_b378 = 101. in
  mark_test_run 3051;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b378 b378 in
  if not test then failwithf "test 3051 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t379 = { #(unit_u, int64#); (| unit_u) }   *)
  (************************************************)
  let r = { a379 = #((unbox_unit ()), #0L); b379 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a379 *)
  let actual = r.a379 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3052;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3052 failed";
  (* Paths of depth 1 *)
  (* .b379 *)
  let actual = r.b379 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 3053;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 3053 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a379 = a3791; b379 = b3791 } { a379 = a3792; b379 = b3792 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3791 a3792 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b3791 b3792) in
  let next_r = { a379 = #((unbox_unit ()), #100L); b379 = C19_0((unbox_unit ())) } in
  let r_expected = { a379 = #((unbox_unit ()), #0L); b379 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a379 *)
  r.a379 <- next_r.a379;
  let r_expected = { r_expected with a379 = next_r.a379 } in
  mark_test_run 3054;
  let test = eq r r_expected in
  if not test then failwithf "test 3054 failed";
  Gc.compact ();
  (* .b379 *)
  r.b379 <- next_r.b379;
  let r_expected = { r_expected with b379 = next_r.b379 } in
  mark_test_run 3055;
  let test = eq r r_expected in
  if not test then failwithf "test 3055 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a379; b379 } = r in
  let expected_a379 = #((unbox_unit ()), #100L) in
  mark_test_run 3056;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a379 a379 in
  if not test then failwithf "test 3056 failed";
  let expected_b379 = C19_0((unbox_unit ())) in
  mark_test_run 3057;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b379 b379 in
  if not test then failwithf "test 3057 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a379; b379 } = r in
  let expected_a379 = #((unbox_unit ()), #100L) in
  mark_test_run 3058;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a379 a379 in
  if not test then failwithf "test 3058 failed";
  let expected_b379 = C19_0((unbox_unit ())) in
  mark_test_run 3059;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b379 b379 in
  if not test then failwithf "test 3059 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t380 = { #(unit_u, int64#); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (**************************************************************************************)
  let r = { a380 = #((unbox_unit ()), #0L); b380 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a380 *)
  let actual = r.a380 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3060;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3060 failed";
  (* Paths of depth 1 *)
  (* .b380 *)
  let actual = r.b380 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3061;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 3061 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a380 = a3801; b380 = b3801 } { a380 = a3802; b380 = b3802 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3801 a3802 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b3801 b3802) in
  let next_r = { a380 = #((unbox_unit ()), #100L); b380 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a380 = #((unbox_unit ()), #0L); b380 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a380 *)
  r.a380 <- next_r.a380;
  let r_expected = { r_expected with a380 = next_r.a380 } in
  mark_test_run 3062;
  let test = eq r r_expected in
  if not test then failwithf "test 3062 failed";
  Gc.compact ();
  (* .b380 *)
  r.b380 <- next_r.b380;
  let r_expected = { r_expected with b380 = next_r.b380 } in
  mark_test_run 3063;
  let test = eq r r_expected in
  if not test then failwithf "test 3063 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a380; b380 } = r in
  let expected_a380 = #((unbox_unit ()), #100L) in
  mark_test_run 3064;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a380 a380 in
  if not test then failwithf "test 3064 failed";
  let expected_b380 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 3065;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b380 b380 in
  if not test then failwithf "test 3065 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a380; b380 } = r in
  let expected_a380 = #((unbox_unit ()), #100L) in
  mark_test_run 3066;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a380 a380 in
  if not test then failwithf "test 3066 failed";
  let expected_b380 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 3067;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b380 b380 in
  if not test then failwithf "test 3067 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t381 = { #(unit_u, int64#); #(unit_u, int) }   *)
  (****************************************************)
  let r = { a381 = #((unbox_unit ()), #0L); b381 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a381 *)
  let actual = r.a381 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3068;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3068 failed";
  (* Paths of depth 1 *)
  (* .b381 *)
  let actual = r.b381 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 3069;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 3069 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a381 = a3811; b381 = b3811 } { a381 = a3812; b381 = b3812 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3811 a3812 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b3811 b3812) in
  let next_r = { a381 = #((unbox_unit ()), #100L); b381 = #((unbox_unit ()), 101) } in
  let r_expected = { a381 = #((unbox_unit ()), #0L); b381 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a381 *)
  r.a381 <- next_r.a381;
  let r_expected = { r_expected with a381 = next_r.a381 } in
  mark_test_run 3070;
  let test = eq r r_expected in
  if not test then failwithf "test 3070 failed";
  Gc.compact ();
  (* .b381 *)
  r.b381 <- next_r.b381;
  let r_expected = { r_expected with b381 = next_r.b381 } in
  mark_test_run 3071;
  let test = eq r r_expected in
  if not test then failwithf "test 3071 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a381; b381 } = r in
  let expected_a381 = #((unbox_unit ()), #100L) in
  mark_test_run 3072;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a381 a381 in
  if not test then failwithf "test 3072 failed";
  let expected_b381 = #((unbox_unit ()), 101) in
  mark_test_run 3073;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b381 b381 in
  if not test then failwithf "test 3073 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a381; b381 } = r in
  let expected_a381 = #((unbox_unit ()), #100L) in
  mark_test_run 3074;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a381 a381 in
  if not test then failwithf "test 3074 failed";
  let expected_b381 = #((unbox_unit ()), 101) in
  mark_test_run 3075;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b381 b381 in
  if not test then failwithf "test 3075 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t382 = { #(unit_u, int64#); #(unit_u, int64#) }   *)
  (*******************************************************)
  let r = { a382 = #((unbox_unit ()), #0L); b382 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a382 *)
  let actual = r.a382 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3076;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3076 failed";
  (* Paths of depth 1 *)
  (* .b382 *)
  let actual = r.b382 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 3077;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3077 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a382 = a3821; b382 = b3821 } { a382 = a3822; b382 = b3822 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3821 a3822 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b3821 b3822) in
  let next_r = { a382 = #((unbox_unit ()), #100L); b382 = #((unbox_unit ()), #101L) } in
  let r_expected = { a382 = #((unbox_unit ()), #0L); b382 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a382 *)
  r.a382 <- next_r.a382;
  let r_expected = { r_expected with a382 = next_r.a382 } in
  mark_test_run 3078;
  let test = eq r r_expected in
  if not test then failwithf "test 3078 failed";
  Gc.compact ();
  (* .b382 *)
  r.b382 <- next_r.b382;
  let r_expected = { r_expected with b382 = next_r.b382 } in
  mark_test_run 3079;
  let test = eq r r_expected in
  if not test then failwithf "test 3079 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a382; b382 } = r in
  let expected_a382 = #((unbox_unit ()), #100L) in
  mark_test_run 3080;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a382 a382 in
  if not test then failwithf "test 3080 failed";
  let expected_b382 = #((unbox_unit ()), #101L) in
  mark_test_run 3081;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b382 b382 in
  if not test then failwithf "test 3081 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a382; b382 } = r in
  let expected_a382 = #((unbox_unit ()), #100L) in
  mark_test_run 3082;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a382 a382 in
  if not test then failwithf "test 3082 failed";
  let expected_b382 = #((unbox_unit ()), #101L) in
  mark_test_run 3083;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b382 b382 in
  if not test then failwithf "test 3083 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t383 = { #(unit_u, int64#); #(unit_u, unit_u) }   *)
  (*******************************************************)
  let r = { a383 = #((unbox_unit ()), #0L); b383 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a383 *)
  let actual = r.a383 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3084;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3084 failed";
  (* Paths of depth 1 *)
  (* .b383 *)
  let actual = r.b383 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3085;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3085 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a383 = a3831; b383 = b3831 } { a383 = a3832; b383 = b3832 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3831 a3832 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b3831 b3832) in
  let next_r = { a383 = #((unbox_unit ()), #100L); b383 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a383 = #((unbox_unit ()), #0L); b383 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a383 *)
  r.a383 <- next_r.a383;
  let r_expected = { r_expected with a383 = next_r.a383 } in
  mark_test_run 3086;
  let test = eq r r_expected in
  if not test then failwithf "test 3086 failed";
  Gc.compact ();
  (* .b383 *)
  r.b383 <- next_r.b383;
  let r_expected = { r_expected with b383 = next_r.b383 } in
  mark_test_run 3087;
  let test = eq r r_expected in
  if not test then failwithf "test 3087 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a383; b383 } = r in
  let expected_a383 = #((unbox_unit ()), #100L) in
  mark_test_run 3088;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a383 a383 in
  if not test then failwithf "test 3088 failed";
  let expected_b383 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3089;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b383 b383 in
  if not test then failwithf "test 3089 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a383; b383 } = r in
  let expected_a383 = #((unbox_unit ()), #100L) in
  mark_test_run 3090;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a383 a383 in
  if not test then failwithf "test 3090 failed";
  let expected_b383 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3091;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b383 b383 in
  if not test then failwithf "test 3091 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t384 = { #(unit_u, int64#); #(unit_u, string) }   *)
  (*******************************************************)
  let r = { a384 = #((unbox_unit ()), #0L); b384 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a384 *)
  let actual = r.a384 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3092;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3092 failed";
  (* Paths of depth 1 *)
  (* .b384 *)
  let actual = r.b384 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 3093;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3093 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a384 = a3841; b384 = b3841 } { a384 = a3842; b384 = b3842 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a3841 a3842 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b3841 b3842) in
  let next_r = { a384 = #((unbox_unit ()), #100L); b384 = #((unbox_unit ()), "101") } in
  let r_expected = { a384 = #((unbox_unit ()), #0L); b384 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a384 *)
  r.a384 <- next_r.a384;
  let r_expected = { r_expected with a384 = next_r.a384 } in
  mark_test_run 3094;
  let test = eq r r_expected in
  if not test then failwithf "test 3094 failed";
  Gc.compact ();
  (* .b384 *)
  r.b384 <- next_r.b384;
  let r_expected = { r_expected with b384 = next_r.b384 } in
  mark_test_run 3095;
  let test = eq r r_expected in
  if not test then failwithf "test 3095 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a384; b384 } = r in
  let expected_a384 = #((unbox_unit ()), #100L) in
  mark_test_run 3096;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a384 a384 in
  if not test then failwithf "test 3096 failed";
  let expected_b384 = #((unbox_unit ()), "101") in
  mark_test_run 3097;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b384 b384 in
  if not test then failwithf "test 3097 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a384; b384 } = r in
  let expected_a384 = #((unbox_unit ()), #100L) in
  mark_test_run 3098;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_a384 a384 in
  if not test then failwithf "test 3098 failed";
  let expected_b384 = #((unbox_unit ()), "101") in
  mark_test_run 3099;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b384 b384 in
  if not test then failwithf "test 3099 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t385 = { #(unit_u, unit_u); int }   *)
  (*****************************************)
  let r = { a385 = #((unbox_unit ()), (unbox_unit ())); b385 = 0 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a385 *)
  let actual = r.a385 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3100;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3100 failed";
  (* Paths of depth 1 *)
  (* .b385 *)
  let actual = r.b385 in
  let expected = 0 in
  mark_test_run 3101;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3101 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a385 = a3851; b385 = b3851 } { a385 = a3852; b385 = b3852 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3851 a3852 && (fun a b -> Int.equal a b) b3851 b3852) in
  let next_r = { a385 = #((unbox_unit ()), (unbox_unit ())); b385 = 100 } in
  let r_expected = { a385 = #((unbox_unit ()), (unbox_unit ())); b385 = 0 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a385 *)
  r.a385 <- next_r.a385;
  let r_expected = { r_expected with a385 = next_r.a385 } in
  mark_test_run 3102;
  let test = eq r r_expected in
  if not test then failwithf "test 3102 failed";
  Gc.compact ();
  (* .b385 *)
  r.b385 <- next_r.b385;
  let r_expected = { r_expected with b385 = next_r.b385 } in
  mark_test_run 3103;
  let test = eq r r_expected in
  if not test then failwithf "test 3103 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a385; b385 } = r in
  let expected_a385 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3104;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a385 a385 in
  if not test then failwithf "test 3104 failed";
  let expected_b385 = 100 in
  mark_test_run 3105;
  let test = (fun a b -> Int.equal a b) expected_b385 b385 in
  if not test then failwithf "test 3105 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a385; b385 } = r in
  let expected_a385 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3106;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a385 a385 in
  if not test then failwithf "test 3106 failed";
  let expected_b385 = 100 in
  mark_test_run 3107;
  let test = (fun a b -> Int.equal a b) expected_b385 b385 in
  if not test then failwithf "test 3107 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t386 = { #(unit_u, unit_u); int64 }   *)
  (*******************************************)
  let r = { a386 = #((unbox_unit ()), (unbox_unit ())); b386 = 0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a386 *)
  let actual = r.a386 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3108;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3108 failed";
  (* Paths of depth 1 *)
  (* .b386 *)
  let actual = r.b386 in
  let expected = 0L in
  mark_test_run 3109;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3109 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a386 = a3861; b386 = b3861 } { a386 = a3862; b386 = b3862 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3861 a3862 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3861 b3862) in
  let next_r = { a386 = #((unbox_unit ()), (unbox_unit ())); b386 = 100L } in
  let r_expected = { a386 = #((unbox_unit ()), (unbox_unit ())); b386 = 0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a386 *)
  r.a386 <- next_r.a386;
  let r_expected = { r_expected with a386 = next_r.a386 } in
  mark_test_run 3110;
  let test = eq r r_expected in
  if not test then failwithf "test 3110 failed";
  Gc.compact ();
  (* .b386 *)
  r.b386 <- next_r.b386;
  let r_expected = { r_expected with b386 = next_r.b386 } in
  mark_test_run 3111;
  let test = eq r r_expected in
  if not test then failwithf "test 3111 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a386; b386 } = r in
  let expected_a386 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3112;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a386 a386 in
  if not test then failwithf "test 3112 failed";
  let expected_b386 = 100L in
  mark_test_run 3113;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b386 b386 in
  if not test then failwithf "test 3113 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a386; b386 } = r in
  let expected_a386 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3114;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a386 a386 in
  if not test then failwithf "test 3114 failed";
  let expected_b386 = 100L in
  mark_test_run 3115;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b386 b386 in
  if not test then failwithf "test 3115 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t387 = { #(unit_u, unit_u); int64# }   *)
  (********************************************)
  let r = { a387 = #((unbox_unit ()), (unbox_unit ())); b387 = #0L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a387 *)
  let actual = r.a387 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3116;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3116 failed";
  (* Paths of depth 1 *)
  (* .b387 *)
  let actual = r.b387 in
  let expected = #0L in
  mark_test_run 3117;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3117 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a387 = a3871; b387 = b3871 } { a387 = a3872; b387 = b3872 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3871 a3872 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3871 b3872) in
  let next_r = { a387 = #((unbox_unit ()), (unbox_unit ())); b387 = #100L } in
  let r_expected = { a387 = #((unbox_unit ()), (unbox_unit ())); b387 = #0L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a387 *)
  r.a387 <- next_r.a387;
  let r_expected = { r_expected with a387 = next_r.a387 } in
  mark_test_run 3118;
  let test = eq r r_expected in
  if not test then failwithf "test 3118 failed";
  Gc.compact ();
  (* .b387 *)
  r.b387 <- next_r.b387;
  let r_expected = { r_expected with b387 = next_r.b387 } in
  mark_test_run 3119;
  let test = eq r r_expected in
  if not test then failwithf "test 3119 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a387; b387 } = r in
  let expected_a387 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3120;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a387 a387 in
  if not test then failwithf "test 3120 failed";
  let expected_b387 = #100L in
  mark_test_run 3121;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b387 b387 in
  if not test then failwithf "test 3121 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a387; b387 } = r in
  let expected_a387 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3122;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a387 a387 in
  if not test then failwithf "test 3122 failed";
  let expected_b387 = #100L in
  mark_test_run 3123;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b387 b387 in
  if not test then failwithf "test 3123 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t388 = { #(unit_u, unit_u); int32# }   *)
  (********************************************)
  let r = { a388 = #((unbox_unit ()), (unbox_unit ())); b388 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a388 *)
  let actual = r.a388 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3124;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3124 failed";
  (* Paths of depth 1 *)
  (* .b388 *)
  let actual = r.b388 in
  let expected = #0l in
  mark_test_run 3125;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3125 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a388 = a3881; b388 = b3881 } { a388 = a3882; b388 = b3882 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3881 a3882 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b3881 b3882) in
  let next_r = { a388 = #((unbox_unit ()), (unbox_unit ())); b388 = #100l } in
  let r_expected = { a388 = #((unbox_unit ()), (unbox_unit ())); b388 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a388 *)
  r.a388 <- next_r.a388;
  let r_expected = { r_expected with a388 = next_r.a388 } in
  mark_test_run 3126;
  let test = eq r r_expected in
  if not test then failwithf "test 3126 failed";
  Gc.compact ();
  (* .b388 *)
  r.b388 <- next_r.b388;
  let r_expected = { r_expected with b388 = next_r.b388 } in
  mark_test_run 3127;
  let test = eq r r_expected in
  if not test then failwithf "test 3127 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a388; b388 } = r in
  let expected_a388 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3128;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a388 a388 in
  if not test then failwithf "test 3128 failed";
  let expected_b388 = #100l in
  mark_test_run 3129;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b388 b388 in
  if not test then failwithf "test 3129 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a388; b388 } = r in
  let expected_a388 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3130;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a388 a388 in
  if not test then failwithf "test 3130 failed";
  let expected_b388 = #100l in
  mark_test_run 3131;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b388 b388 in
  if not test then failwithf "test 3131 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t389 = { #(unit_u, unit_u); nativeint# }   *)
  (************************************************)
  let r = { a389 = #((unbox_unit ()), (unbox_unit ())); b389 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a389 *)
  let actual = r.a389 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3132;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3132 failed";
  (* Paths of depth 1 *)
  (* .b389 *)
  let actual = r.b389 in
  let expected = #0n in
  mark_test_run 3133;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 3133 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a389 = a3891; b389 = b3891 } { a389 = a3892; b389 = b3892 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3891 a3892 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b3891 b3892) in
  let next_r = { a389 = #((unbox_unit ()), (unbox_unit ())); b389 = #100n } in
  let r_expected = { a389 = #((unbox_unit ()), (unbox_unit ())); b389 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a389 *)
  r.a389 <- next_r.a389;
  let r_expected = { r_expected with a389 = next_r.a389 } in
  mark_test_run 3134;
  let test = eq r r_expected in
  if not test then failwithf "test 3134 failed";
  Gc.compact ();
  (* .b389 *)
  r.b389 <- next_r.b389;
  let r_expected = { r_expected with b389 = next_r.b389 } in
  mark_test_run 3135;
  let test = eq r r_expected in
  if not test then failwithf "test 3135 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a389; b389 } = r in
  let expected_a389 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3136;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a389 a389 in
  if not test then failwithf "test 3136 failed";
  let expected_b389 = #100n in
  mark_test_run 3137;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b389 b389 in
  if not test then failwithf "test 3137 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a389; b389 } = r in
  let expected_a389 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3138;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a389 a389 in
  if not test then failwithf "test 3138 failed";
  let expected_b389 = #100n in
  mark_test_run 3139;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b389 b389 in
  if not test then failwithf "test 3139 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t390 = { #(unit_u, unit_u); float }   *)
  (*******************************************)
  let r = { a390 = #((unbox_unit ()), (unbox_unit ())); b390 = 0. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a390 *)
  let actual = r.a390 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3140;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3140 failed";
  (* Paths of depth 1 *)
  (* .b390 *)
  let actual = r.b390 in
  let expected = 0. in
  mark_test_run 3141;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3141 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a390 = a3901; b390 = b3901 } { a390 = a3902; b390 = b3902 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3901 a3902 && (fun a b -> Float.equal (globalize a) (globalize b)) b3901 b3902) in
  let next_r = { a390 = #((unbox_unit ()), (unbox_unit ())); b390 = 100. } in
  let r_expected = { a390 = #((unbox_unit ()), (unbox_unit ())); b390 = 0. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a390 *)
  r.a390 <- next_r.a390;
  let r_expected = { r_expected with a390 = next_r.a390 } in
  mark_test_run 3142;
  let test = eq r r_expected in
  if not test then failwithf "test 3142 failed";
  Gc.compact ();
  (* .b390 *)
  r.b390 <- next_r.b390;
  let r_expected = { r_expected with b390 = next_r.b390 } in
  mark_test_run 3143;
  let test = eq r r_expected in
  if not test then failwithf "test 3143 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a390; b390 } = r in
  let expected_a390 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3144;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a390 a390 in
  if not test then failwithf "test 3144 failed";
  let expected_b390 = 100. in
  mark_test_run 3145;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b390 b390 in
  if not test then failwithf "test 3145 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a390; b390 } = r in
  let expected_a390 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3146;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a390 a390 in
  if not test then failwithf "test 3146 failed";
  let expected_b390 = 100. in
  mark_test_run 3147;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b390 b390 in
  if not test then failwithf "test 3147 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t391 = { #(unit_u, unit_u); (| unit_u) }   *)
  (************************************************)
  let r = { a391 = #((unbox_unit ()), (unbox_unit ())); b391 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a391 *)
  let actual = r.a391 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3148;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3148 failed";
  (* Paths of depth 1 *)
  (* .b391 *)
  let actual = r.b391 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 3149;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 3149 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a391 = a3911; b391 = b3911 } { a391 = a3912; b391 = b3912 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3911 a3912 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b3911 b3912) in
  let next_r = { a391 = #((unbox_unit ()), (unbox_unit ())); b391 = C19_0((unbox_unit ())) } in
  let r_expected = { a391 = #((unbox_unit ()), (unbox_unit ())); b391 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a391 *)
  r.a391 <- next_r.a391;
  let r_expected = { r_expected with a391 = next_r.a391 } in
  mark_test_run 3150;
  let test = eq r r_expected in
  if not test then failwithf "test 3150 failed";
  Gc.compact ();
  (* .b391 *)
  r.b391 <- next_r.b391;
  let r_expected = { r_expected with b391 = next_r.b391 } in
  mark_test_run 3151;
  let test = eq r r_expected in
  if not test then failwithf "test 3151 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a391; b391 } = r in
  let expected_a391 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3152;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a391 a391 in
  if not test then failwithf "test 3152 failed";
  let expected_b391 = C19_0((unbox_unit ())) in
  mark_test_run 3153;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b391 b391 in
  if not test then failwithf "test 3153 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a391; b391 } = r in
  let expected_a391 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3154;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a391 a391 in
  if not test then failwithf "test 3154 failed";
  let expected_b391 = C19_0((unbox_unit ())) in
  mark_test_run 3155;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b391 b391 in
  if not test then failwithf "test 3155 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t392 = { #(unit_u, unit_u); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (**************************************************************************************)
  let r = { a392 = #((unbox_unit ()), (unbox_unit ())); b392 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a392 *)
  let actual = r.a392 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3156;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3156 failed";
  (* Paths of depth 1 *)
  (* .b392 *)
  let actual = r.b392 in
  let expected = C21_0((unbox_unit ())) in
  mark_test_run 3157;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 3157 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a392 = a3921; b392 = b3921 } { a392 = a3922; b392 = b3922 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3921 a3922 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b3921 b3922) in
  let next_r = { a392 = #((unbox_unit ()), (unbox_unit ())); b392 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a392 = #((unbox_unit ()), (unbox_unit ())); b392 = C21_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a392 *)
  r.a392 <- next_r.a392;
  let r_expected = { r_expected with a392 = next_r.a392 } in
  mark_test_run 3158;
  let test = eq r r_expected in
  if not test then failwithf "test 3158 failed";
  Gc.compact ();
  (* .b392 *)
  r.b392 <- next_r.b392;
  let r_expected = { r_expected with b392 = next_r.b392 } in
  mark_test_run 3159;
  let test = eq r r_expected in
  if not test then failwithf "test 3159 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a392; b392 } = r in
  let expected_a392 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3160;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a392 a392 in
  if not test then failwithf "test 3160 failed";
  let expected_b392 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3161;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b392 b392 in
  if not test then failwithf "test 3161 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a392; b392 } = r in
  let expected_a392 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3162;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a392 a392 in
  if not test then failwithf "test 3162 failed";
  let expected_b392 = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3163;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b392 b392 in
  if not test then failwithf "test 3163 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t393 = { #(unit_u, unit_u); #(unit_u, int) }   *)
  (****************************************************)
  let r = { a393 = #((unbox_unit ()), (unbox_unit ())); b393 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a393 *)
  let actual = r.a393 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3164;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3164 failed";
  (* Paths of depth 1 *)
  (* .b393 *)
  let actual = r.b393 in
  let expected = #((unbox_unit ()), 0) in
  mark_test_run 3165;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 3165 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a393 = a3931; b393 = b3931 } { a393 = a3932; b393 = b3932 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3931 a3932 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b3931 b3932) in
  let next_r = { a393 = #((unbox_unit ()), (unbox_unit ())); b393 = #((unbox_unit ()), 100) } in
  let r_expected = { a393 = #((unbox_unit ()), (unbox_unit ())); b393 = #((unbox_unit ()), 0) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a393 *)
  r.a393 <- next_r.a393;
  let r_expected = { r_expected with a393 = next_r.a393 } in
  mark_test_run 3166;
  let test = eq r r_expected in
  if not test then failwithf "test 3166 failed";
  Gc.compact ();
  (* .b393 *)
  r.b393 <- next_r.b393;
  let r_expected = { r_expected with b393 = next_r.b393 } in
  mark_test_run 3167;
  let test = eq r r_expected in
  if not test then failwithf "test 3167 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a393; b393 } = r in
  let expected_a393 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3168;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a393 a393 in
  if not test then failwithf "test 3168 failed";
  let expected_b393 = #((unbox_unit ()), 100) in
  mark_test_run 3169;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b393 b393 in
  if not test then failwithf "test 3169 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a393; b393 } = r in
  let expected_a393 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3170;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a393 a393 in
  if not test then failwithf "test 3170 failed";
  let expected_b393 = #((unbox_unit ()), 100) in
  mark_test_run 3171;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b393 b393 in
  if not test then failwithf "test 3171 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t394 = { #(unit_u, unit_u); #(unit_u, int64#) }   *)
  (*******************************************************)
  let r = { a394 = #((unbox_unit ()), (unbox_unit ())); b394 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a394 *)
  let actual = r.a394 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3172;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3172 failed";
  (* Paths of depth 1 *)
  (* .b394 *)
  let actual = r.b394 in
  let expected = #((unbox_unit ()), #0L) in
  mark_test_run 3173;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3173 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a394 = a3941; b394 = b3941 } { a394 = a3942; b394 = b3942 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3941 a3942 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b3941 b3942) in
  let next_r = { a394 = #((unbox_unit ()), (unbox_unit ())); b394 = #((unbox_unit ()), #100L) } in
  let r_expected = { a394 = #((unbox_unit ()), (unbox_unit ())); b394 = #((unbox_unit ()), #0L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a394 *)
  r.a394 <- next_r.a394;
  let r_expected = { r_expected with a394 = next_r.a394 } in
  mark_test_run 3174;
  let test = eq r r_expected in
  if not test then failwithf "test 3174 failed";
  Gc.compact ();
  (* .b394 *)
  r.b394 <- next_r.b394;
  let r_expected = { r_expected with b394 = next_r.b394 } in
  mark_test_run 3175;
  let test = eq r r_expected in
  if not test then failwithf "test 3175 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a394; b394 } = r in
  let expected_a394 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3176;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a394 a394 in
  if not test then failwithf "test 3176 failed";
  let expected_b394 = #((unbox_unit ()), #100L) in
  mark_test_run 3177;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b394 b394 in
  if not test then failwithf "test 3177 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a394; b394 } = r in
  let expected_a394 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3178;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a394 a394 in
  if not test then failwithf "test 3178 failed";
  let expected_b394 = #((unbox_unit ()), #100L) in
  mark_test_run 3179;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b394 b394 in
  if not test then failwithf "test 3179 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t395 = { #(unit_u, unit_u); #(unit_u, string) }   *)
  (*******************************************************)
  let r = { a395 = #((unbox_unit ()), (unbox_unit ())); b395 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a395 *)
  let actual = r.a395 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3180;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3180 failed";
  (* Paths of depth 1 *)
  (* .b395 *)
  let actual = r.b395 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3181;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3181 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a395 = a3951; b395 = b3951 } { a395 = a3952; b395 = b3952 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a3951 a3952 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b3951 b3952) in
  let next_r = { a395 = #((unbox_unit ()), (unbox_unit ())); b395 = #((unbox_unit ()), "100") } in
  let r_expected = { a395 = #((unbox_unit ()), (unbox_unit ())); b395 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a395 *)
  r.a395 <- next_r.a395;
  let r_expected = { r_expected with a395 = next_r.a395 } in
  mark_test_run 3182;
  let test = eq r r_expected in
  if not test then failwithf "test 3182 failed";
  Gc.compact ();
  (* .b395 *)
  r.b395 <- next_r.b395;
  let r_expected = { r_expected with b395 = next_r.b395 } in
  mark_test_run 3183;
  let test = eq r r_expected in
  if not test then failwithf "test 3183 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a395; b395 } = r in
  let expected_a395 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3184;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a395 a395 in
  if not test then failwithf "test 3184 failed";
  let expected_b395 = #((unbox_unit ()), "100") in
  mark_test_run 3185;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b395 b395 in
  if not test then failwithf "test 3185 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a395; b395 } = r in
  let expected_a395 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3186;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_a395 a395 in
  if not test then failwithf "test 3186 failed";
  let expected_b395 = #((unbox_unit ()), "100") in
  mark_test_run 3187;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b395 b395 in
  if not test then failwithf "test 3187 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t396 = { #(unit_u, string) }   *)
  (************************************)
  let r = { a396 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a396 *)
  let actual = r.a396 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3188;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3188 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a396 = a3961 } { a396 = a3962 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a3961 a3962) in
  let next_r = { a396 = #((unbox_unit ()), "100") } in
  let r_expected = { a396 = #((unbox_unit ()), "0") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a396 *)
  r.a396 <- next_r.a396;
  let r_expected = { r_expected with a396 = next_r.a396 } in
  mark_test_run 3189;
  let test = eq r r_expected in
  if not test then failwithf "test 3189 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a396 } = r in
  let expected_a396 = #((unbox_unit ()), "100") in
  mark_test_run 3190;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a396 a396 in
  if not test then failwithf "test 3190 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a396 } = r in
  let expected_a396 = #((unbox_unit ()), "100") in
  mark_test_run 3191;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a396 a396 in
  if not test then failwithf "test 3191 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t397 = { #(unit_u, string); int }   *)
  (*****************************************)
  let r = { a397 = #((unbox_unit ()), "0"); b397 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a397 *)
  let actual = r.a397 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3192;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3192 failed";
  (* Paths of depth 1 *)
  (* .b397 *)
  let actual = r.b397 in
  let expected = 1 in
  mark_test_run 3193;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3193 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a397 = a3971; b397 = b3971 } { a397 = a3972; b397 = b3972 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a3971 a3972 && (fun a b -> Int.equal a b) b3971 b3972) in
  let next_r = { a397 = #((unbox_unit ()), "100"); b397 = 101 } in
  let r_expected = { a397 = #((unbox_unit ()), "0"); b397 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a397 *)
  r.a397 <- next_r.a397;
  let r_expected = { r_expected with a397 = next_r.a397 } in
  mark_test_run 3194;
  let test = eq r r_expected in
  if not test then failwithf "test 3194 failed";
  Gc.compact ();
  (* .b397 *)
  r.b397 <- next_r.b397;
  let r_expected = { r_expected with b397 = next_r.b397 } in
  mark_test_run 3195;
  let test = eq r r_expected in
  if not test then failwithf "test 3195 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a397; b397 } = r in
  let expected_a397 = #((unbox_unit ()), "100") in
  mark_test_run 3196;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a397 a397 in
  if not test then failwithf "test 3196 failed";
  let expected_b397 = 101 in
  mark_test_run 3197;
  let test = (fun a b -> Int.equal a b) expected_b397 b397 in
  if not test then failwithf "test 3197 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a397; b397 } = r in
  let expected_a397 = #((unbox_unit ()), "100") in
  mark_test_run 3198;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a397 a397 in
  if not test then failwithf "test 3198 failed";
  let expected_b397 = 101 in
  mark_test_run 3199;
  let test = (fun a b -> Int.equal a b) expected_b397 b397 in
  if not test then failwithf "test 3199 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t398 = { #(unit_u, string); int64 }   *)
  (*******************************************)
  let r = { a398 = #((unbox_unit ()), "0"); b398 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a398 *)
  let actual = r.a398 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3200;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3200 failed";
  (* Paths of depth 1 *)
  (* .b398 *)
  let actual = r.b398 in
  let expected = 1L in
  mark_test_run 3201;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3201 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a398 = a3981; b398 = b3981 } { a398 = a3982; b398 = b3982 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a3981 a3982 && (fun a b -> Int64.equal (globalize a) (globalize b)) b3981 b3982) in
  let next_r = { a398 = #((unbox_unit ()), "100"); b398 = 101L } in
  let r_expected = { a398 = #((unbox_unit ()), "0"); b398 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a398 *)
  r.a398 <- next_r.a398;
  let r_expected = { r_expected with a398 = next_r.a398 } in
  mark_test_run 3202;
  let test = eq r r_expected in
  if not test then failwithf "test 3202 failed";
  Gc.compact ();
  (* .b398 *)
  r.b398 <- next_r.b398;
  let r_expected = { r_expected with b398 = next_r.b398 } in
  mark_test_run 3203;
  let test = eq r r_expected in
  if not test then failwithf "test 3203 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a398; b398 } = r in
  let expected_a398 = #((unbox_unit ()), "100") in
  mark_test_run 3204;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a398 a398 in
  if not test then failwithf "test 3204 failed";
  let expected_b398 = 101L in
  mark_test_run 3205;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b398 b398 in
  if not test then failwithf "test 3205 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a398; b398 } = r in
  let expected_a398 = #((unbox_unit ()), "100") in
  mark_test_run 3206;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a398 a398 in
  if not test then failwithf "test 3206 failed";
  let expected_b398 = 101L in
  mark_test_run 3207;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b398 b398 in
  if not test then failwithf "test 3207 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t399 = { #(unit_u, string); int64# }   *)
  (********************************************)
  let r = { a399 = #((unbox_unit ()), "0"); b399 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a399 *)
  let actual = r.a399 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3208;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3208 failed";
  (* Paths of depth 1 *)
  (* .b399 *)
  let actual = r.b399 in
  let expected = #1L in
  mark_test_run 3209;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3209 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a399 = a3991; b399 = b3991 } { a399 = a3992; b399 = b3992 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a3991 a3992 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b3991 b3992) in
  let next_r = { a399 = #((unbox_unit ()), "100"); b399 = #101L } in
  let r_expected = { a399 = #((unbox_unit ()), "0"); b399 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a399 *)
  r.a399 <- next_r.a399;
  let r_expected = { r_expected with a399 = next_r.a399 } in
  mark_test_run 3210;
  let test = eq r r_expected in
  if not test then failwithf "test 3210 failed";
  Gc.compact ();
  (* .b399 *)
  r.b399 <- next_r.b399;
  let r_expected = { r_expected with b399 = next_r.b399 } in
  mark_test_run 3211;
  let test = eq r r_expected in
  if not test then failwithf "test 3211 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a399; b399 } = r in
  let expected_a399 = #((unbox_unit ()), "100") in
  mark_test_run 3212;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a399 a399 in
  if not test then failwithf "test 3212 failed";
  let expected_b399 = #101L in
  mark_test_run 3213;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b399 b399 in
  if not test then failwithf "test 3213 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a399; b399 } = r in
  let expected_a399 = #((unbox_unit ()), "100") in
  mark_test_run 3214;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a399 a399 in
  if not test then failwithf "test 3214 failed";
  let expected_b399 = #101L in
  mark_test_run 3215;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b399 b399 in
  if not test then failwithf "test 3215 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t400 = { #(unit_u, string); int32# }   *)
  (********************************************)
  let r = { a400 = #((unbox_unit ()), "0"); b400 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a400 *)
  let actual = r.a400 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3216;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3216 failed";
  (* Paths of depth 1 *)
  (* .b400 *)
  let actual = r.b400 in
  let expected = #1l in
  mark_test_run 3217;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3217 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a400 = a4001; b400 = b4001 } { a400 = a4002; b400 = b4002 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4001 a4002 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4001 b4002) in
  let next_r = { a400 = #((unbox_unit ()), "100"); b400 = #101l } in
  let r_expected = { a400 = #((unbox_unit ()), "0"); b400 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a400 *)
  r.a400 <- next_r.a400;
  let r_expected = { r_expected with a400 = next_r.a400 } in
  mark_test_run 3218;
  let test = eq r r_expected in
  if not test then failwithf "test 3218 failed";
  Gc.compact ();
  (* .b400 *)
  r.b400 <- next_r.b400;
  let r_expected = { r_expected with b400 = next_r.b400 } in
  mark_test_run 3219;
  let test = eq r r_expected in
  if not test then failwithf "test 3219 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a400; b400 } = r in
  let expected_a400 = #((unbox_unit ()), "100") in
  mark_test_run 3220;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a400 a400 in
  if not test then failwithf "test 3220 failed";
  let expected_b400 = #101l in
  mark_test_run 3221;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b400 b400 in
  if not test then failwithf "test 3221 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a400; b400 } = r in
  let expected_a400 = #((unbox_unit ()), "100") in
  mark_test_run 3222;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a400 a400 in
  if not test then failwithf "test 3222 failed";
  let expected_b400 = #101l in
  mark_test_run 3223;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b400 b400 in
  if not test then failwithf "test 3223 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t401 = { #(unit_u, string); nativeint# }   *)
  (************************************************)
  let r = { a401 = #((unbox_unit ()), "0"); b401 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a401 *)
  let actual = r.a401 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3224;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3224 failed";
  (* Paths of depth 1 *)
  (* .b401 *)
  let actual = r.b401 in
  let expected = #1n in
  mark_test_run 3225;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 3225 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a401 = a4011; b401 = b4011 } { a401 = a4012; b401 = b4012 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4011 a4012 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b4011 b4012) in
  let next_r = { a401 = #((unbox_unit ()), "100"); b401 = #101n } in
  let r_expected = { a401 = #((unbox_unit ()), "0"); b401 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a401 *)
  r.a401 <- next_r.a401;
  let r_expected = { r_expected with a401 = next_r.a401 } in
  mark_test_run 3226;
  let test = eq r r_expected in
  if not test then failwithf "test 3226 failed";
  Gc.compact ();
  (* .b401 *)
  r.b401 <- next_r.b401;
  let r_expected = { r_expected with b401 = next_r.b401 } in
  mark_test_run 3227;
  let test = eq r r_expected in
  if not test then failwithf "test 3227 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a401; b401 } = r in
  let expected_a401 = #((unbox_unit ()), "100") in
  mark_test_run 3228;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a401 a401 in
  if not test then failwithf "test 3228 failed";
  let expected_b401 = #101n in
  mark_test_run 3229;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b401 b401 in
  if not test then failwithf "test 3229 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a401; b401 } = r in
  let expected_a401 = #((unbox_unit ()), "100") in
  mark_test_run 3230;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a401 a401 in
  if not test then failwithf "test 3230 failed";
  let expected_b401 = #101n in
  mark_test_run 3231;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b401 b401 in
  if not test then failwithf "test 3231 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t402 = { #(unit_u, string); unit_u }   *)
  (********************************************)
  let r = { a402 = #((unbox_unit ()), "0"); b402 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a402 *)
  let actual = r.a402 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3232;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3232 failed";
  (* Paths of depth 1 *)
  (* .b402 *)
  let actual = r.b402 in
  let expected = (unbox_unit ()) in
  mark_test_run 3233;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3233 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a402 = a4021; b402 = b4021 } { a402 = a4022; b402 = b4022 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4021 a4022 && (fun _ _ -> true) b4021 b4022) in
  let next_r = { a402 = #((unbox_unit ()), "100"); b402 = (unbox_unit ()) } in
  let r_expected = { a402 = #((unbox_unit ()), "0"); b402 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a402 *)
  r.a402 <- next_r.a402;
  let r_expected = { r_expected with a402 = next_r.a402 } in
  mark_test_run 3234;
  let test = eq r r_expected in
  if not test then failwithf "test 3234 failed";
  Gc.compact ();
  (* .b402 *)
  r.b402 <- next_r.b402;
  let r_expected = { r_expected with b402 = next_r.b402 } in
  mark_test_run 3235;
  let test = eq r r_expected in
  if not test then failwithf "test 3235 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a402; b402 } = r in
  let expected_a402 = #((unbox_unit ()), "100") in
  mark_test_run 3236;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a402 a402 in
  if not test then failwithf "test 3236 failed";
  let expected_b402 = (unbox_unit ()) in
  mark_test_run 3237;
  let test = (fun _ _ -> true) expected_b402 b402 in
  if not test then failwithf "test 3237 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a402; b402 } = r in
  let expected_a402 = #((unbox_unit ()), "100") in
  mark_test_run 3238;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a402 a402 in
  if not test then failwithf "test 3238 failed";
  let expected_b402 = (unbox_unit ()) in
  mark_test_run 3239;
  let test = (fun _ _ -> true) expected_b402 b402 in
  if not test then failwithf "test 3239 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t403 = { #(unit_u, string); float }   *)
  (*******************************************)
  let r = { a403 = #((unbox_unit ()), "0"); b403 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a403 *)
  let actual = r.a403 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3240;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3240 failed";
  (* Paths of depth 1 *)
  (* .b403 *)
  let actual = r.b403 in
  let expected = 1. in
  mark_test_run 3241;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3241 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a403 = a4031; b403 = b4031 } { a403 = a4032; b403 = b4032 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4031 a4032 && (fun a b -> Float.equal (globalize a) (globalize b)) b4031 b4032) in
  let next_r = { a403 = #((unbox_unit ()), "100"); b403 = 101. } in
  let r_expected = { a403 = #((unbox_unit ()), "0"); b403 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a403 *)
  r.a403 <- next_r.a403;
  let r_expected = { r_expected with a403 = next_r.a403 } in
  mark_test_run 3242;
  let test = eq r r_expected in
  if not test then failwithf "test 3242 failed";
  Gc.compact ();
  (* .b403 *)
  r.b403 <- next_r.b403;
  let r_expected = { r_expected with b403 = next_r.b403 } in
  mark_test_run 3243;
  let test = eq r r_expected in
  if not test then failwithf "test 3243 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a403; b403 } = r in
  let expected_a403 = #((unbox_unit ()), "100") in
  mark_test_run 3244;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a403 a403 in
  if not test then failwithf "test 3244 failed";
  let expected_b403 = 101. in
  mark_test_run 3245;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b403 b403 in
  if not test then failwithf "test 3245 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a403; b403 } = r in
  let expected_a403 = #((unbox_unit ()), "100") in
  mark_test_run 3246;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a403 a403 in
  if not test then failwithf "test 3246 failed";
  let expected_b403 = 101. in
  mark_test_run 3247;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b403 b403 in
  if not test then failwithf "test 3247 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t404 = { #(unit_u, string); (| unit_u) }   *)
  (************************************************)
  let r = { a404 = #((unbox_unit ()), "0"); b404 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a404 *)
  let actual = r.a404 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3248;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3248 failed";
  (* Paths of depth 1 *)
  (* .b404 *)
  let actual = r.b404 in
  let expected = C19_0((unbox_unit ())) in
  mark_test_run 3249;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 3249 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a404 = a4041; b404 = b4041 } { a404 = a4042; b404 = b4042 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4041 a4042 && (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) b4041 b4042) in
  let next_r = { a404 = #((unbox_unit ()), "100"); b404 = C19_0((unbox_unit ())) } in
  let r_expected = { a404 = #((unbox_unit ()), "0"); b404 = C19_0((unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a404 *)
  r.a404 <- next_r.a404;
  let r_expected = { r_expected with a404 = next_r.a404 } in
  mark_test_run 3250;
  let test = eq r r_expected in
  if not test then failwithf "test 3250 failed";
  Gc.compact ();
  (* .b404 *)
  r.b404 <- next_r.b404;
  let r_expected = { r_expected with b404 = next_r.b404 } in
  mark_test_run 3251;
  let test = eq r r_expected in
  if not test then failwithf "test 3251 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a404; b404 } = r in
  let expected_a404 = #((unbox_unit ()), "100") in
  mark_test_run 3252;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a404 a404 in
  if not test then failwithf "test 3252 failed";
  let expected_b404 = C19_0((unbox_unit ())) in
  mark_test_run 3253;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b404 b404 in
  if not test then failwithf "test 3253 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a404; b404 } = r in
  let expected_a404 = #((unbox_unit ()), "100") in
  mark_test_run 3254;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a404 a404 in
  if not test then failwithf "test 3254 failed";
  let expected_b404 = C19_0((unbox_unit ())) in
  mark_test_run 3255;
  let test = (fun a b -> match a, b with C19_0(a0), C19_0(b0) -> (fun _ _ -> true) a0 b0) expected_b404 b404 in
  if not test then failwithf "test 3255 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************************************************)
  (*   t405 = { #(unit_u, string); (| unit_u | unit_u * unit_u | #(unit_u, unit_u)) }   *)
  (**************************************************************************************)
  let r = { a405 = #((unbox_unit ()), "0"); b405 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a405 *)
  let actual = r.a405 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3256;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3256 failed";
  (* Paths of depth 1 *)
  (* .b405 *)
  let actual = r.b405 in
  let expected = C21_1((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3257;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) actual expected in
  if not test then failwithf "test 3257 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a405 = a4051; b405 = b4051 } { a405 = a4052; b405 = b4052 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4051 a4052 && (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) b4051 b4052) in
  let next_r = { a405 = #((unbox_unit ()), "100"); b405 = C21_2(#((unbox_unit ()), (unbox_unit ()))) } in
  let r_expected = { a405 = #((unbox_unit ()), "0"); b405 = C21_1((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a405 *)
  r.a405 <- next_r.a405;
  let r_expected = { r_expected with a405 = next_r.a405 } in
  mark_test_run 3258;
  let test = eq r r_expected in
  if not test then failwithf "test 3258 failed";
  Gc.compact ();
  (* .b405 *)
  r.b405 <- next_r.b405;
  let r_expected = { r_expected with b405 = next_r.b405 } in
  mark_test_run 3259;
  let test = eq r r_expected in
  if not test then failwithf "test 3259 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a405; b405 } = r in
  let expected_a405 = #((unbox_unit ()), "100") in
  mark_test_run 3260;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a405 a405 in
  if not test then failwithf "test 3260 failed";
  let expected_b405 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 3261;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b405 b405 in
  if not test then failwithf "test 3261 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a405; b405 } = r in
  let expected_a405 = #((unbox_unit ()), "100") in
  mark_test_run 3262;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a405 a405 in
  if not test then failwithf "test 3262 failed";
  let expected_b405 = C21_2(#((unbox_unit ()), (unbox_unit ()))) in
  mark_test_run 3263;
  let test = (fun a b -> match a, b with C21_0(a0), C21_0(b0) -> (fun _ _ -> true) a0 b0 | C21_1(a0, a1), C21_1(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1 | C21_2(a0), C21_2(b0) -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) a0 b0 | _, _ -> false) expected_b405 b405 in
  if not test then failwithf "test 3263 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t406 = { #(unit_u, string); #(unit_u, int) }   *)
  (****************************************************)
  let r = { a406 = #((unbox_unit ()), "0"); b406 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a406 *)
  let actual = r.a406 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3264;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3264 failed";
  (* Paths of depth 1 *)
  (* .b406 *)
  let actual = r.b406 in
  let expected = #((unbox_unit ()), 1) in
  mark_test_run 3265;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) actual expected in
  if not test then failwithf "test 3265 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a406 = a4061; b406 = b4061 } { a406 = a4062; b406 = b4062 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4061 a4062 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) b4061 b4062) in
  let next_r = { a406 = #((unbox_unit ()), "100"); b406 = #((unbox_unit ()), 101) } in
  let r_expected = { a406 = #((unbox_unit ()), "0"); b406 = #((unbox_unit ()), 1) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a406 *)
  r.a406 <- next_r.a406;
  let r_expected = { r_expected with a406 = next_r.a406 } in
  mark_test_run 3266;
  let test = eq r r_expected in
  if not test then failwithf "test 3266 failed";
  Gc.compact ();
  (* .b406 *)
  r.b406 <- next_r.b406;
  let r_expected = { r_expected with b406 = next_r.b406 } in
  mark_test_run 3267;
  let test = eq r r_expected in
  if not test then failwithf "test 3267 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a406; b406 } = r in
  let expected_a406 = #((unbox_unit ()), "100") in
  mark_test_run 3268;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a406 a406 in
  if not test then failwithf "test 3268 failed";
  let expected_b406 = #((unbox_unit ()), 101) in
  mark_test_run 3269;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b406 b406 in
  if not test then failwithf "test 3269 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a406; b406 } = r in
  let expected_a406 = #((unbox_unit ()), "100") in
  mark_test_run 3270;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a406 a406 in
  if not test then failwithf "test 3270 failed";
  let expected_b406 = #((unbox_unit ()), 101) in
  mark_test_run 3271;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int.equal a b) a1 b1) expected_b406 b406 in
  if not test then failwithf "test 3271 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t407 = { #(unit_u, string); #(unit_u, int64#) }   *)
  (*******************************************************)
  let r = { a407 = #((unbox_unit ()), "0"); b407 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a407 *)
  let actual = r.a407 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3272;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3272 failed";
  (* Paths of depth 1 *)
  (* .b407 *)
  let actual = r.b407 in
  let expected = #((unbox_unit ()), #1L) in
  mark_test_run 3273;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) actual expected in
  if not test then failwithf "test 3273 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a407 = a4071; b407 = b4071 } { a407 = a4072; b407 = b4072 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4071 a4072 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) b4071 b4072) in
  let next_r = { a407 = #((unbox_unit ()), "100"); b407 = #((unbox_unit ()), #101L) } in
  let r_expected = { a407 = #((unbox_unit ()), "0"); b407 = #((unbox_unit ()), #1L) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a407 *)
  r.a407 <- next_r.a407;
  let r_expected = { r_expected with a407 = next_r.a407 } in
  mark_test_run 3274;
  let test = eq r r_expected in
  if not test then failwithf "test 3274 failed";
  Gc.compact ();
  (* .b407 *)
  r.b407 <- next_r.b407;
  let r_expected = { r_expected with b407 = next_r.b407 } in
  mark_test_run 3275;
  let test = eq r r_expected in
  if not test then failwithf "test 3275 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a407; b407 } = r in
  let expected_a407 = #((unbox_unit ()), "100") in
  mark_test_run 3276;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a407 a407 in
  if not test then failwithf "test 3276 failed";
  let expected_b407 = #((unbox_unit ()), #101L) in
  mark_test_run 3277;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b407 b407 in
  if not test then failwithf "test 3277 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a407; b407 } = r in
  let expected_a407 = #((unbox_unit ()), "100") in
  mark_test_run 3278;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a407 a407 in
  if not test then failwithf "test 3278 failed";
  let expected_b407 = #((unbox_unit ()), #101L) in
  mark_test_run 3279;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) expected_b407 b407 in
  if not test then failwithf "test 3279 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t408 = { #(unit_u, string); #(unit_u, unit_u) }   *)
  (*******************************************************)
  let r = { a408 = #((unbox_unit ()), "0"); b408 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a408 *)
  let actual = r.a408 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3280;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3280 failed";
  (* Paths of depth 1 *)
  (* .b408 *)
  let actual = r.b408 in
  let expected = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3281;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) actual expected in
  if not test then failwithf "test 3281 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a408 = a4081; b408 = b4081 } { a408 = a4082; b408 = b4082 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4081 a4082 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) b4081 b4082) in
  let next_r = { a408 = #((unbox_unit ()), "100"); b408 = #((unbox_unit ()), (unbox_unit ())) } in
  let r_expected = { a408 = #((unbox_unit ()), "0"); b408 = #((unbox_unit ()), (unbox_unit ())) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a408 *)
  r.a408 <- next_r.a408;
  let r_expected = { r_expected with a408 = next_r.a408 } in
  mark_test_run 3282;
  let test = eq r r_expected in
  if not test then failwithf "test 3282 failed";
  Gc.compact ();
  (* .b408 *)
  r.b408 <- next_r.b408;
  let r_expected = { r_expected with b408 = next_r.b408 } in
  mark_test_run 3283;
  let test = eq r r_expected in
  if not test then failwithf "test 3283 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a408; b408 } = r in
  let expected_a408 = #((unbox_unit ()), "100") in
  mark_test_run 3284;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a408 a408 in
  if not test then failwithf "test 3284 failed";
  let expected_b408 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3285;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b408 b408 in
  if not test then failwithf "test 3285 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a408; b408 } = r in
  let expected_a408 = #((unbox_unit ()), "100") in
  mark_test_run 3286;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a408 a408 in
  if not test then failwithf "test 3286 failed";
  let expected_b408 = #((unbox_unit ()), (unbox_unit ())) in
  mark_test_run 3287;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun _ _ -> true) a1 b1) expected_b408 b408 in
  if not test then failwithf "test 3287 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************************)
  (*   t409 = { #(unit_u, string); #(unit_u, string) }   *)
  (*******************************************************)
  let r = { a409 = #((unbox_unit ()), "0"); b409 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a409 *)
  let actual = r.a409 in
  let expected = #((unbox_unit ()), "0") in
  mark_test_run 3288;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3288 failed";
  (* Paths of depth 1 *)
  (* .b409 *)
  let actual = r.b409 in
  let expected = #((unbox_unit ()), "1") in
  mark_test_run 3289;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) actual expected in
  if not test then failwithf "test 3289 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a409 = a4091; b409 = b4091 } { a409 = a4092; b409 = b4092 } -> (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) a4091 a4092 && (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) b4091 b4092) in
  let next_r = { a409 = #((unbox_unit ()), "100"); b409 = #((unbox_unit ()), "101") } in
  let r_expected = { a409 = #((unbox_unit ()), "0"); b409 = #((unbox_unit ()), "1") } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a409 *)
  r.a409 <- next_r.a409;
  let r_expected = { r_expected with a409 = next_r.a409 } in
  mark_test_run 3290;
  let test = eq r r_expected in
  if not test then failwithf "test 3290 failed";
  Gc.compact ();
  (* .b409 *)
  r.b409 <- next_r.b409;
  let r_expected = { r_expected with b409 = next_r.b409 } in
  mark_test_run 3291;
  let test = eq r r_expected in
  if not test then failwithf "test 3291 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a409; b409 } = r in
  let expected_a409 = #((unbox_unit ()), "100") in
  mark_test_run 3292;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a409 a409 in
  if not test then failwithf "test 3292 failed";
  let expected_b409 = #((unbox_unit ()), "101") in
  mark_test_run 3293;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b409 b409 in
  if not test then failwithf "test 3293 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a409; b409 } = r in
  let expected_a409 = #((unbox_unit ()), "100") in
  mark_test_run 3294;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_a409 a409 in
  if not test then failwithf "test 3294 failed";
  let expected_b409 = #((unbox_unit ()), "101") in
  mark_test_run 3295;
  let test = (fun #(a0, a1) #(b0, b1) -> (fun _ _ -> true) a0 b0 && (fun a b -> String.equal (globalize a) (globalize b)) a1 b1) expected_b409 b409 in
  if not test then failwithf "test 3295 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************)
  (*   t410 = { #{ int } }   *)
  (***************************)
  let r = { a410 = #{ a27 = 0 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a410 *)
  let actual = r.a410 in
  let expected = #{ a27 = 0 } in
  mark_test_run 3296;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 3296 failed";
  (* Paths of depth 2 *)
  (* .a410.#a27 *)
  let actual = r.a410.#a27 in
  let expected = 0 in
  mark_test_run 3297;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3297 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a410 = a4101 } { a410 = a4102 } -> (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) a4101 a4102) in
  let next_r = { a410 = #{ a27 = 100 } } in
  let r_expected = { a410 = #{ a27 = 0 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a410 *)
  r.a410 <- next_r.a410;
  let r_expected = { r_expected with a410 = next_r.a410 } in
  mark_test_run 3298;
  let test = eq r r_expected in
  if not test then failwithf "test 3298 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a410 = #{ a27 } } = r in
  let expected_a27 = 100 in
  mark_test_run 3299;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 3299 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a410 } = r in
  let expected_a410 = #{ a27 = 100 } in
  mark_test_run 3300;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_a410 a410 in
  if not test then failwithf "test 3300 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t411 = { #{ int }; int }   *)
  (********************************)
  let r = { a411 = #{ a27 = 0 }; b411 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a411 *)
  let actual = r.a411 in
  let expected = #{ a27 = 0 } in
  mark_test_run 3301;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 3301 failed";
  (* Paths of depth 2 *)
  (* .a411.#a27 *)
  let actual = r.a411.#a27 in
  let expected = 0 in
  mark_test_run 3302;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3302 failed";
  (* Paths of depth 1 *)
  (* .b411 *)
  let actual = r.b411 in
  let expected = 1 in
  mark_test_run 3303;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3303 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a411 = a4111; b411 = b4111 } { a411 = a4112; b411 = b4112 } -> (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) a4111 a4112 && (fun a b -> Int.equal a b) b4111 b4112) in
  let next_r = { a411 = #{ a27 = 100 }; b411 = 101 } in
  let r_expected = { a411 = #{ a27 = 0 }; b411 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a411 *)
  r.a411 <- next_r.a411;
  let r_expected = { r_expected with a411 = next_r.a411 } in
  mark_test_run 3304;
  let test = eq r r_expected in
  if not test then failwithf "test 3304 failed";
  Gc.compact ();
  (* .b411 *)
  r.b411 <- next_r.b411;
  let r_expected = { r_expected with b411 = next_r.b411 } in
  mark_test_run 3305;
  let test = eq r r_expected in
  if not test then failwithf "test 3305 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a411 = #{ a27 }; b411 } = r in
  let expected_a27 = 100 in
  mark_test_run 3306;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 3306 failed";
  let expected_b411 = 101 in
  mark_test_run 3307;
  let test = (fun a b -> Int.equal a b) expected_b411 b411 in
  if not test then failwithf "test 3307 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a411; b411 } = r in
  let expected_a411 = #{ a27 = 100 } in
  mark_test_run 3308;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_a411 a411 in
  if not test then failwithf "test 3308 failed";
  let expected_b411 = 101 in
  mark_test_run 3309;
  let test = (fun a b -> Int.equal a b) expected_b411 b411 in
  if not test then failwithf "test 3309 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t412 = { #{ int }; int32# }   *)
  (***********************************)
  let r = { a412 = #{ a27 = 0 }; b412 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a412 *)
  let actual = r.a412 in
  let expected = #{ a27 = 0 } in
  mark_test_run 3310;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 3310 failed";
  (* Paths of depth 2 *)
  (* .a412.#a27 *)
  let actual = r.a412.#a27 in
  let expected = 0 in
  mark_test_run 3311;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3311 failed";
  (* Paths of depth 1 *)
  (* .b412 *)
  let actual = r.b412 in
  let expected = #1l in
  mark_test_run 3312;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3312 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a412 = a4121; b412 = b4121 } { a412 = a4122; b412 = b4122 } -> (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) a4121 a4122 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4121 b4122) in
  let next_r = { a412 = #{ a27 = 100 }; b412 = #101l } in
  let r_expected = { a412 = #{ a27 = 0 }; b412 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a412 *)
  r.a412 <- next_r.a412;
  let r_expected = { r_expected with a412 = next_r.a412 } in
  mark_test_run 3313;
  let test = eq r r_expected in
  if not test then failwithf "test 3313 failed";
  Gc.compact ();
  (* .b412 *)
  r.b412 <- next_r.b412;
  let r_expected = { r_expected with b412 = next_r.b412 } in
  mark_test_run 3314;
  let test = eq r r_expected in
  if not test then failwithf "test 3314 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a412 = #{ a27 }; b412 } = r in
  let expected_a27 = 100 in
  mark_test_run 3315;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 3315 failed";
  let expected_b412 = #101l in
  mark_test_run 3316;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b412 b412 in
  if not test then failwithf "test 3316 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a412; b412 } = r in
  let expected_a412 = #{ a27 = 100 } in
  mark_test_run 3317;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_a412 a412 in
  if not test then failwithf "test 3317 failed";
  let expected_b412 = #101l in
  mark_test_run 3318;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b412 b412 in
  if not test then failwithf "test 3318 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t413 = { #{ int }; float }   *)
  (**********************************)
  let r = { a413 = #{ a27 = 0 }; b413 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a413 *)
  let actual = r.a413 in
  let expected = #{ a27 = 0 } in
  mark_test_run 3319;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 3319 failed";
  (* Paths of depth 2 *)
  (* .a413.#a27 *)
  let actual = r.a413.#a27 in
  let expected = 0 in
  mark_test_run 3320;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3320 failed";
  (* Paths of depth 1 *)
  (* .b413 *)
  let actual = r.b413 in
  let expected = 1. in
  mark_test_run 3321;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3321 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a413 = a4131; b413 = b4131 } { a413 = a4132; b413 = b4132 } -> (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) a4131 a4132 && (fun a b -> Float.equal (globalize a) (globalize b)) b4131 b4132) in
  let next_r = { a413 = #{ a27 = 100 }; b413 = 101. } in
  let r_expected = { a413 = #{ a27 = 0 }; b413 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a413 *)
  r.a413 <- next_r.a413;
  let r_expected = { r_expected with a413 = next_r.a413 } in
  mark_test_run 3322;
  let test = eq r r_expected in
  if not test then failwithf "test 3322 failed";
  Gc.compact ();
  (* .b413 *)
  r.b413 <- next_r.b413;
  let r_expected = { r_expected with b413 = next_r.b413 } in
  mark_test_run 3323;
  let test = eq r r_expected in
  if not test then failwithf "test 3323 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a413 = #{ a27 }; b413 } = r in
  let expected_a27 = 100 in
  mark_test_run 3324;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 3324 failed";
  let expected_b413 = 101. in
  mark_test_run 3325;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b413 b413 in
  if not test then failwithf "test 3325 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a413; b413 } = r in
  let expected_a413 = #{ a27 = 100 } in
  mark_test_run 3326;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_a413 a413 in
  if not test then failwithf "test 3326 failed";
  let expected_b413 = 101. in
  mark_test_run 3327;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b413 b413 in
  if not test then failwithf "test 3327 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t414 = { #{ int }; int64x2# }   *)
  (*************************************)
  let r = { a414 = #{ a27 = 0 }; b414 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a414 *)
  let actual = r.a414 in
  let expected = #{ a27 = 0 } in
  mark_test_run 3328;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) actual expected in
  if not test then failwithf "test 3328 failed";
  (* Paths of depth 2 *)
  (* .a414.#a27 *)
  let actual = r.a414.#a27 in
  let expected = 0 in
  mark_test_run 3329;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3329 failed";
  (* Paths of depth 1 *)
  (* .b414 *)
  let actual = r.b414 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3330;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3330 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a414 = a4141; b414 = b4141 } { a414 = a4142; b414 = b4142 } -> (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) a4141 a4142 && int64x2_u_equal b4141 b4142) in
  let next_r = { a414 = #{ a27 = 100 }; b414 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  let r_expected = { a414 = #{ a27 = 0 }; b414 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a414 *)
  r.a414 <- next_r.a414;
  let r_expected = { r_expected with a414 = next_r.a414 } in
  mark_test_run 3331;
  let test = eq r r_expected in
  if not test then failwithf "test 3331 failed";
  Gc.compact ();
  (* .b414 *)
  r.b414 <- next_r.b414;
  let r_expected = { r_expected with b414 = next_r.b414 } in
  mark_test_run 3332;
  let test = eq r r_expected in
  if not test then failwithf "test 3332 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a414 = #{ a27 }; b414 } = r in
  let expected_a27 = 100 in
  mark_test_run 3333;
  let test = (fun a b -> Int.equal a b) expected_a27 a27 in
  if not test then failwithf "test 3333 failed";
  let expected_b414 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3334;
  let test = int64x2_u_equal expected_b414 b414 in
  if not test then failwithf "test 3334 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a414; b414 } = r in
  let expected_a414 = #{ a27 = 100 } in
  mark_test_run 3335;
  let test = (fun #{ a27 = a271 } #{ a27 = a272 } -> (fun a b -> Int.equal a b) a271 a272) expected_a414 a414 in
  if not test then failwithf "test 3335 failed";
  let expected_b414 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3336;
  let test = int64x2_u_equal expected_b414 b414 in
  if not test then failwithf "test 3336 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t415 = { #{ int; int } }   *)
  (********************************)
  let r = { a415 = #{ a29 = 0; b29 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a415 *)
  let actual = r.a415 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 3337;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3337 failed";
  (* Paths of depth 2 *)
  (* .a415.#a29 *)
  let actual = r.a415.#a29 in
  let expected = 0 in
  mark_test_run 3338;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3338 failed";
  (* .a415.#b29 *)
  let actual = r.a415.#b29 in
  let expected = 1 in
  mark_test_run 3339;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3339 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a415 = a4151 } { a415 = a4152 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a4151 a4152) in
  let next_r = { a415 = #{ a29 = 100; b29 = 101 } } in
  let r_expected = { a415 = #{ a29 = 0; b29 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a415 *)
  r.a415 <- next_r.a415;
  let r_expected = { r_expected with a415 = next_r.a415 } in
  mark_test_run 3340;
  let test = eq r r_expected in
  if not test then failwithf "test 3340 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a415 = #{ a29; b29 } } = r in
  let expected_a29 = 100 in
  mark_test_run 3341;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3341 failed";
  let expected_b29 = 101 in
  mark_test_run 3342;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3342 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a415 } = r in
  let expected_a415 = #{ a29 = 100; b29 = 101 } in
  mark_test_run 3343;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_a415 a415 in
  if not test then failwithf "test 3343 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t416 = { #{ int; int }; int }   *)
  (*************************************)
  let r = { a416 = #{ a29 = 0; b29 = 1 }; b416 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a416 *)
  let actual = r.a416 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 3344;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3344 failed";
  (* Paths of depth 2 *)
  (* .a416.#a29 *)
  let actual = r.a416.#a29 in
  let expected = 0 in
  mark_test_run 3345;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3345 failed";
  (* .a416.#b29 *)
  let actual = r.a416.#b29 in
  let expected = 1 in
  mark_test_run 3346;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3346 failed";
  (* Paths of depth 1 *)
  (* .b416 *)
  let actual = r.b416 in
  let expected = 2 in
  mark_test_run 3347;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3347 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a416 = a4161; b416 = b4161 } { a416 = a4162; b416 = b4162 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a4161 a4162 && (fun a b -> Int.equal a b) b4161 b4162) in
  let next_r = { a416 = #{ a29 = 100; b29 = 101 }; b416 = 102 } in
  let r_expected = { a416 = #{ a29 = 0; b29 = 1 }; b416 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a416 *)
  r.a416 <- next_r.a416;
  let r_expected = { r_expected with a416 = next_r.a416 } in
  mark_test_run 3348;
  let test = eq r r_expected in
  if not test then failwithf "test 3348 failed";
  Gc.compact ();
  (* .b416 *)
  r.b416 <- next_r.b416;
  let r_expected = { r_expected with b416 = next_r.b416 } in
  mark_test_run 3349;
  let test = eq r r_expected in
  if not test then failwithf "test 3349 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a416 = #{ a29; b29 }; b416 } = r in
  let expected_a29 = 100 in
  mark_test_run 3350;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3350 failed";
  let expected_b29 = 101 in
  mark_test_run 3351;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3351 failed";
  let expected_b416 = 102 in
  mark_test_run 3352;
  let test = (fun a b -> Int.equal a b) expected_b416 b416 in
  if not test then failwithf "test 3352 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a416; b416 } = r in
  let expected_a416 = #{ a29 = 100; b29 = 101 } in
  mark_test_run 3353;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_a416 a416 in
  if not test then failwithf "test 3353 failed";
  let expected_b416 = 102 in
  mark_test_run 3354;
  let test = (fun a b -> Int.equal a b) expected_b416 b416 in
  if not test then failwithf "test 3354 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t417 = { #{ int; int }; int32# }   *)
  (****************************************)
  let r = { a417 = #{ a29 = 0; b29 = 1 }; b417 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a417 *)
  let actual = r.a417 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 3355;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3355 failed";
  (* Paths of depth 2 *)
  (* .a417.#a29 *)
  let actual = r.a417.#a29 in
  let expected = 0 in
  mark_test_run 3356;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3356 failed";
  (* .a417.#b29 *)
  let actual = r.a417.#b29 in
  let expected = 1 in
  mark_test_run 3357;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3357 failed";
  (* Paths of depth 1 *)
  (* .b417 *)
  let actual = r.b417 in
  let expected = #2l in
  mark_test_run 3358;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3358 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a417 = a4171; b417 = b4171 } { a417 = a4172; b417 = b4172 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a4171 a4172 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4171 b4172) in
  let next_r = { a417 = #{ a29 = 100; b29 = 101 }; b417 = #102l } in
  let r_expected = { a417 = #{ a29 = 0; b29 = 1 }; b417 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a417 *)
  r.a417 <- next_r.a417;
  let r_expected = { r_expected with a417 = next_r.a417 } in
  mark_test_run 3359;
  let test = eq r r_expected in
  if not test then failwithf "test 3359 failed";
  Gc.compact ();
  (* .b417 *)
  r.b417 <- next_r.b417;
  let r_expected = { r_expected with b417 = next_r.b417 } in
  mark_test_run 3360;
  let test = eq r r_expected in
  if not test then failwithf "test 3360 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a417 = #{ a29; b29 }; b417 } = r in
  let expected_a29 = 100 in
  mark_test_run 3361;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3361 failed";
  let expected_b29 = 101 in
  mark_test_run 3362;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3362 failed";
  let expected_b417 = #102l in
  mark_test_run 3363;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b417 b417 in
  if not test then failwithf "test 3363 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a417; b417 } = r in
  let expected_a417 = #{ a29 = 100; b29 = 101 } in
  mark_test_run 3364;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_a417 a417 in
  if not test then failwithf "test 3364 failed";
  let expected_b417 = #102l in
  mark_test_run 3365;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b417 b417 in
  if not test then failwithf "test 3365 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t418 = { #{ int; int }; float }   *)
  (***************************************)
  let r = { a418 = #{ a29 = 0; b29 = 1 }; b418 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a418 *)
  let actual = r.a418 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 3366;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3366 failed";
  (* Paths of depth 2 *)
  (* .a418.#a29 *)
  let actual = r.a418.#a29 in
  let expected = 0 in
  mark_test_run 3367;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3367 failed";
  (* .a418.#b29 *)
  let actual = r.a418.#b29 in
  let expected = 1 in
  mark_test_run 3368;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3368 failed";
  (* Paths of depth 1 *)
  (* .b418 *)
  let actual = r.b418 in
  let expected = 2. in
  mark_test_run 3369;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3369 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a418 = a4181; b418 = b4181 } { a418 = a4182; b418 = b4182 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a4181 a4182 && (fun a b -> Float.equal (globalize a) (globalize b)) b4181 b4182) in
  let next_r = { a418 = #{ a29 = 100; b29 = 101 }; b418 = 102. } in
  let r_expected = { a418 = #{ a29 = 0; b29 = 1 }; b418 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a418 *)
  r.a418 <- next_r.a418;
  let r_expected = { r_expected with a418 = next_r.a418 } in
  mark_test_run 3370;
  let test = eq r r_expected in
  if not test then failwithf "test 3370 failed";
  Gc.compact ();
  (* .b418 *)
  r.b418 <- next_r.b418;
  let r_expected = { r_expected with b418 = next_r.b418 } in
  mark_test_run 3371;
  let test = eq r r_expected in
  if not test then failwithf "test 3371 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a418 = #{ a29; b29 }; b418 } = r in
  let expected_a29 = 100 in
  mark_test_run 3372;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3372 failed";
  let expected_b29 = 101 in
  mark_test_run 3373;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3373 failed";
  let expected_b418 = 102. in
  mark_test_run 3374;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b418 b418 in
  if not test then failwithf "test 3374 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a418; b418 } = r in
  let expected_a418 = #{ a29 = 100; b29 = 101 } in
  mark_test_run 3375;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_a418 a418 in
  if not test then failwithf "test 3375 failed";
  let expected_b418 = 102. in
  mark_test_run 3376;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b418 b418 in
  if not test then failwithf "test 3376 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t419 = { #{ int; int }; int64x2# }   *)
  (******************************************)
  let r = { a419 = #{ a29 = 0; b29 = 1 }; b419 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a419 *)
  let actual = r.a419 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 3377;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3377 failed";
  (* Paths of depth 2 *)
  (* .a419.#a29 *)
  let actual = r.a419.#a29 in
  let expected = 0 in
  mark_test_run 3378;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3378 failed";
  (* .a419.#b29 *)
  let actual = r.a419.#b29 in
  let expected = 1 in
  mark_test_run 3379;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3379 failed";
  (* Paths of depth 1 *)
  (* .b419 *)
  let actual = r.b419 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 3380;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3380 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a419 = a4191; b419 = b4191 } { a419 = a4192; b419 = b4192 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a4191 a4192 && int64x2_u_equal b4191 b4192) in
  let next_r = { a419 = #{ a29 = 100; b29 = 101 }; b419 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  let r_expected = { a419 = #{ a29 = 0; b29 = 1 }; b419 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a419 *)
  r.a419 <- next_r.a419;
  let r_expected = { r_expected with a419 = next_r.a419 } in
  mark_test_run 3381;
  let test = eq r r_expected in
  if not test then failwithf "test 3381 failed";
  Gc.compact ();
  (* .b419 *)
  r.b419 <- next_r.b419;
  let r_expected = { r_expected with b419 = next_r.b419 } in
  mark_test_run 3382;
  let test = eq r r_expected in
  if not test then failwithf "test 3382 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a419 = #{ a29; b29 }; b419 } = r in
  let expected_a29 = 100 in
  mark_test_run 3383;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3383 failed";
  let expected_b29 = 101 in
  mark_test_run 3384;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3384 failed";
  let expected_b419 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 3385;
  let test = int64x2_u_equal expected_b419 b419 in
  if not test then failwithf "test 3385 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a419; b419 } = r in
  let expected_a419 = #{ a29 = 100; b29 = 101 } in
  mark_test_run 3386;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) expected_a419 a419 in
  if not test then failwithf "test 3386 failed";
  let expected_b419 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 3387;
  let test = int64x2_u_equal expected_b419 b419 in
  if not test then failwithf "test 3387 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t420 = { #{ int; int32# } }   *)
  (***********************************)
  let r = { a420 = #{ a31 = 0; b31 = #1l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a420 *)
  let actual = r.a420 in
  let expected = #{ a31 = 0; b31 = #1l } in
  mark_test_run 3388;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 3388 failed";
  (* Paths of depth 2 *)
  (* .a420.#a31 *)
  let actual = r.a420.#a31 in
  let expected = 0 in
  mark_test_run 3389;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3389 failed";
  (* .a420.#b31 *)
  let actual = r.a420.#b31 in
  let expected = #1l in
  mark_test_run 3390;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3390 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a420 = a4201 } { a420 = a4202 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a4201 a4202) in
  let next_r = { a420 = #{ a31 = 100; b31 = #101l } } in
  let r_expected = { a420 = #{ a31 = 0; b31 = #1l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a420 *)
  r.a420 <- next_r.a420;
  let r_expected = { r_expected with a420 = next_r.a420 } in
  mark_test_run 3391;
  let test = eq r r_expected in
  if not test then failwithf "test 3391 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a420 = #{ a31; b31 } } = r in
  let expected_a31 = 100 in
  mark_test_run 3392;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 3392 failed";
  let expected_b31 = #101l in
  mark_test_run 3393;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 3393 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a420 } = r in
  let expected_a420 = #{ a31 = 100; b31 = #101l } in
  mark_test_run 3394;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) expected_a420 a420 in
  if not test then failwithf "test 3394 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t421 = { #{ int; int32# }; int }   *)
  (****************************************)
  let r = { a421 = #{ a31 = 0; b31 = #1l }; b421 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a421 *)
  let actual = r.a421 in
  let expected = #{ a31 = 0; b31 = #1l } in
  mark_test_run 3395;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 3395 failed";
  (* Paths of depth 2 *)
  (* .a421.#a31 *)
  let actual = r.a421.#a31 in
  let expected = 0 in
  mark_test_run 3396;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3396 failed";
  (* .a421.#b31 *)
  let actual = r.a421.#b31 in
  let expected = #1l in
  mark_test_run 3397;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3397 failed";
  (* Paths of depth 1 *)
  (* .b421 *)
  let actual = r.b421 in
  let expected = 2 in
  mark_test_run 3398;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3398 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a421 = a4211; b421 = b4211 } { a421 = a4212; b421 = b4212 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a4211 a4212 && (fun a b -> Int.equal a b) b4211 b4212) in
  let next_r = { a421 = #{ a31 = 100; b31 = #101l }; b421 = 102 } in
  let r_expected = { a421 = #{ a31 = 0; b31 = #1l }; b421 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a421 *)
  r.a421 <- next_r.a421;
  let r_expected = { r_expected with a421 = next_r.a421 } in
  mark_test_run 3399;
  let test = eq r r_expected in
  if not test then failwithf "test 3399 failed";
  Gc.compact ();
  (* .b421 *)
  r.b421 <- next_r.b421;
  let r_expected = { r_expected with b421 = next_r.b421 } in
  mark_test_run 3400;
  let test = eq r r_expected in
  if not test then failwithf "test 3400 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a421 = #{ a31; b31 }; b421 } = r in
  let expected_a31 = 100 in
  mark_test_run 3401;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 3401 failed";
  let expected_b31 = #101l in
  mark_test_run 3402;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 3402 failed";
  let expected_b421 = 102 in
  mark_test_run 3403;
  let test = (fun a b -> Int.equal a b) expected_b421 b421 in
  if not test then failwithf "test 3403 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a421; b421 } = r in
  let expected_a421 = #{ a31 = 100; b31 = #101l } in
  mark_test_run 3404;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) expected_a421 a421 in
  if not test then failwithf "test 3404 failed";
  let expected_b421 = 102 in
  mark_test_run 3405;
  let test = (fun a b -> Int.equal a b) expected_b421 b421 in
  if not test then failwithf "test 3405 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t422 = { #{ int; int32# }; int32# }   *)
  (*******************************************)
  let r = { a422 = #{ a31 = 0; b31 = #1l }; b422 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a422 *)
  let actual = r.a422 in
  let expected = #{ a31 = 0; b31 = #1l } in
  mark_test_run 3406;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 3406 failed";
  (* Paths of depth 2 *)
  (* .a422.#a31 *)
  let actual = r.a422.#a31 in
  let expected = 0 in
  mark_test_run 3407;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3407 failed";
  (* .a422.#b31 *)
  let actual = r.a422.#b31 in
  let expected = #1l in
  mark_test_run 3408;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3408 failed";
  (* Paths of depth 1 *)
  (* .b422 *)
  let actual = r.b422 in
  let expected = #2l in
  mark_test_run 3409;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3409 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a422 = a4221; b422 = b4221 } { a422 = a4222; b422 = b4222 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a4221 a4222 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4221 b4222) in
  let next_r = { a422 = #{ a31 = 100; b31 = #101l }; b422 = #102l } in
  let r_expected = { a422 = #{ a31 = 0; b31 = #1l }; b422 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a422 *)
  r.a422 <- next_r.a422;
  let r_expected = { r_expected with a422 = next_r.a422 } in
  mark_test_run 3410;
  let test = eq r r_expected in
  if not test then failwithf "test 3410 failed";
  Gc.compact ();
  (* .b422 *)
  r.b422 <- next_r.b422;
  let r_expected = { r_expected with b422 = next_r.b422 } in
  mark_test_run 3411;
  let test = eq r r_expected in
  if not test then failwithf "test 3411 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a422 = #{ a31; b31 }; b422 } = r in
  let expected_a31 = 100 in
  mark_test_run 3412;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 3412 failed";
  let expected_b31 = #101l in
  mark_test_run 3413;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 3413 failed";
  let expected_b422 = #102l in
  mark_test_run 3414;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b422 b422 in
  if not test then failwithf "test 3414 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a422; b422 } = r in
  let expected_a422 = #{ a31 = 100; b31 = #101l } in
  mark_test_run 3415;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) expected_a422 a422 in
  if not test then failwithf "test 3415 failed";
  let expected_b422 = #102l in
  mark_test_run 3416;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b422 b422 in
  if not test then failwithf "test 3416 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t423 = { #{ int; float } }   *)
  (**********************************)
  let r = { a423 = #{ a33 = 0; b33 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a423 *)
  let actual = r.a423 in
  let expected = #{ a33 = 0; b33 = 1. } in
  mark_test_run 3417;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 3417 failed";
  (* Paths of depth 2 *)
  (* .a423.#a33 *)
  let actual = r.a423.#a33 in
  let expected = 0 in
  mark_test_run 3418;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3418 failed";
  (* .a423.#b33 *)
  let actual = r.a423.#b33 in
  let expected = 1. in
  mark_test_run 3419;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3419 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a423 = a4231 } { a423 = a4232 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a4231 a4232) in
  let next_r = { a423 = #{ a33 = 100; b33 = 101. } } in
  let r_expected = { a423 = #{ a33 = 0; b33 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a423 *)
  r.a423 <- next_r.a423;
  let r_expected = { r_expected with a423 = next_r.a423 } in
  mark_test_run 3420;
  let test = eq r r_expected in
  if not test then failwithf "test 3420 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a423 = #{ a33; b33 } } = r in
  let expected_a33 = 100 in
  mark_test_run 3421;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 3421 failed";
  let expected_b33 = 101. in
  mark_test_run 3422;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 3422 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a423 } = r in
  let expected_a423 = #{ a33 = 100; b33 = 101. } in
  mark_test_run 3423;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) expected_a423 a423 in
  if not test then failwithf "test 3423 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t424 = { #{ int; float }; int }   *)
  (***************************************)
  let r = { a424 = #{ a33 = 0; b33 = 1. }; b424 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a424 *)
  let actual = r.a424 in
  let expected = #{ a33 = 0; b33 = 1. } in
  mark_test_run 3424;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 3424 failed";
  (* Paths of depth 2 *)
  (* .a424.#a33 *)
  let actual = r.a424.#a33 in
  let expected = 0 in
  mark_test_run 3425;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3425 failed";
  (* .a424.#b33 *)
  let actual = r.a424.#b33 in
  let expected = 1. in
  mark_test_run 3426;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3426 failed";
  (* Paths of depth 1 *)
  (* .b424 *)
  let actual = r.b424 in
  let expected = 2 in
  mark_test_run 3427;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3427 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a424 = a4241; b424 = b4241 } { a424 = a4242; b424 = b4242 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a4241 a4242 && (fun a b -> Int.equal a b) b4241 b4242) in
  let next_r = { a424 = #{ a33 = 100; b33 = 101. }; b424 = 102 } in
  let r_expected = { a424 = #{ a33 = 0; b33 = 1. }; b424 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a424 *)
  r.a424 <- next_r.a424;
  let r_expected = { r_expected with a424 = next_r.a424 } in
  mark_test_run 3428;
  let test = eq r r_expected in
  if not test then failwithf "test 3428 failed";
  Gc.compact ();
  (* .b424 *)
  r.b424 <- next_r.b424;
  let r_expected = { r_expected with b424 = next_r.b424 } in
  mark_test_run 3429;
  let test = eq r r_expected in
  if not test then failwithf "test 3429 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a424 = #{ a33; b33 }; b424 } = r in
  let expected_a33 = 100 in
  mark_test_run 3430;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 3430 failed";
  let expected_b33 = 101. in
  mark_test_run 3431;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 3431 failed";
  let expected_b424 = 102 in
  mark_test_run 3432;
  let test = (fun a b -> Int.equal a b) expected_b424 b424 in
  if not test then failwithf "test 3432 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a424; b424 } = r in
  let expected_a424 = #{ a33 = 100; b33 = 101. } in
  mark_test_run 3433;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) expected_a424 a424 in
  if not test then failwithf "test 3433 failed";
  let expected_b424 = 102 in
  mark_test_run 3434;
  let test = (fun a b -> Int.equal a b) expected_b424 b424 in
  if not test then failwithf "test 3434 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t425 = { #{ int; float }; float }   *)
  (*****************************************)
  let r = { a425 = #{ a33 = 0; b33 = 1. }; b425 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a425 *)
  let actual = r.a425 in
  let expected = #{ a33 = 0; b33 = 1. } in
  mark_test_run 3435;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 3435 failed";
  (* Paths of depth 2 *)
  (* .a425.#a33 *)
  let actual = r.a425.#a33 in
  let expected = 0 in
  mark_test_run 3436;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3436 failed";
  (* .a425.#b33 *)
  let actual = r.a425.#b33 in
  let expected = 1. in
  mark_test_run 3437;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3437 failed";
  (* Paths of depth 1 *)
  (* .b425 *)
  let actual = r.b425 in
  let expected = 2. in
  mark_test_run 3438;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3438 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a425 = a4251; b425 = b4251 } { a425 = a4252; b425 = b4252 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a4251 a4252 && (fun a b -> Float.equal (globalize a) (globalize b)) b4251 b4252) in
  let next_r = { a425 = #{ a33 = 100; b33 = 101. }; b425 = 102. } in
  let r_expected = { a425 = #{ a33 = 0; b33 = 1. }; b425 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a425 *)
  r.a425 <- next_r.a425;
  let r_expected = { r_expected with a425 = next_r.a425 } in
  mark_test_run 3439;
  let test = eq r r_expected in
  if not test then failwithf "test 3439 failed";
  Gc.compact ();
  (* .b425 *)
  r.b425 <- next_r.b425;
  let r_expected = { r_expected with b425 = next_r.b425 } in
  mark_test_run 3440;
  let test = eq r r_expected in
  if not test then failwithf "test 3440 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a425 = #{ a33; b33 }; b425 } = r in
  let expected_a33 = 100 in
  mark_test_run 3441;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 3441 failed";
  let expected_b33 = 101. in
  mark_test_run 3442;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 3442 failed";
  let expected_b425 = 102. in
  mark_test_run 3443;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b425 b425 in
  if not test then failwithf "test 3443 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a425; b425 } = r in
  let expected_a425 = #{ a33 = 100; b33 = 101. } in
  mark_test_run 3444;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) expected_a425 a425 in
  if not test then failwithf "test 3444 failed";
  let expected_b425 = 102. in
  mark_test_run 3445;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b425 b425 in
  if not test then failwithf "test 3445 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t426 = { #{ int; int64x2# } }   *)
  (*************************************)
  let r = { a426 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a426 *)
  let actual = r.a426 in
  let expected = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 3446;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 3446 failed";
  (* Paths of depth 2 *)
  (* .a426.#a35 *)
  let actual = r.a426.#a35 in
  let expected = 0 in
  mark_test_run 3447;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3447 failed";
  (* .a426.#b35 *)
  let actual = r.a426.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3448;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3448 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a426 = a4261 } { a426 = a4262 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a4261 a4262) in
  let next_r = { a426 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } } in
  let r_expected = { a426 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a426 *)
  r.a426 <- next_r.a426;
  let r_expected = { r_expected with a426 = next_r.a426 } in
  mark_test_run 3449;
  let test = eq r r_expected in
  if not test then failwithf "test 3449 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a426 = #{ a35; b35 } } = r in
  let expected_a35 = 100 in
  mark_test_run 3450;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 3450 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3451;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 3451 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a426 } = r in
  let expected_a426 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  mark_test_run 3452;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) expected_a426 a426 in
  if not test then failwithf "test 3452 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t427 = { #{ int; int64x2# }; int }   *)
  (******************************************)
  let r = { a427 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b427 = 3 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a427 *)
  let actual = r.a427 in
  let expected = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 3453;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 3453 failed";
  (* Paths of depth 2 *)
  (* .a427.#a35 *)
  let actual = r.a427.#a35 in
  let expected = 0 in
  mark_test_run 3454;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3454 failed";
  (* .a427.#b35 *)
  let actual = r.a427.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3455;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3455 failed";
  (* Paths of depth 1 *)
  (* .b427 *)
  let actual = r.b427 in
  let expected = 3 in
  mark_test_run 3456;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3456 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a427 = a4271; b427 = b4271 } { a427 = a4272; b427 = b4272 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a4271 a4272 && (fun a b -> Int.equal a b) b4271 b4272) in
  let next_r = { a427 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b427 = 103 } in
  let r_expected = { a427 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b427 = 3 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a427 *)
  r.a427 <- next_r.a427;
  let r_expected = { r_expected with a427 = next_r.a427 } in
  mark_test_run 3457;
  let test = eq r r_expected in
  if not test then failwithf "test 3457 failed";
  Gc.compact ();
  (* .b427 *)
  r.b427 <- next_r.b427;
  let r_expected = { r_expected with b427 = next_r.b427 } in
  mark_test_run 3458;
  let test = eq r r_expected in
  if not test then failwithf "test 3458 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a427 = #{ a35; b35 }; b427 } = r in
  let expected_a35 = 100 in
  mark_test_run 3459;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 3459 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3460;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 3460 failed";
  let expected_b427 = 103 in
  mark_test_run 3461;
  let test = (fun a b -> Int.equal a b) expected_b427 b427 in
  if not test then failwithf "test 3461 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a427; b427 } = r in
  let expected_a427 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  mark_test_run 3462;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) expected_a427 a427 in
  if not test then failwithf "test 3462 failed";
  let expected_b427 = 103 in
  mark_test_run 3463;
  let test = (fun a b -> Int.equal a b) expected_b427 b427 in
  if not test then failwithf "test 3463 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t428 = { #{ int; int64x2# }; int64x2# }   *)
  (***********************************************)
  let r = { a428 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b428 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a428 *)
  let actual = r.a428 in
  let expected = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 3464;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 3464 failed";
  (* Paths of depth 2 *)
  (* .a428.#a35 *)
  let actual = r.a428.#a35 in
  let expected = 0 in
  mark_test_run 3465;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3465 failed";
  (* .a428.#b35 *)
  let actual = r.a428.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3466;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3466 failed";
  (* Paths of depth 1 *)
  (* .b428 *)
  let actual = r.b428 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 3467;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3467 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a428 = a4281; b428 = b4281 } { a428 = a4282; b428 = b4282 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a4281 a4282 && int64x2_u_equal b4281 b4282) in
  let next_r = { a428 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b428 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  let r_expected = { a428 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b428 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a428 *)
  r.a428 <- next_r.a428;
  let r_expected = { r_expected with a428 = next_r.a428 } in
  mark_test_run 3468;
  let test = eq r r_expected in
  if not test then failwithf "test 3468 failed";
  Gc.compact ();
  (* .b428 *)
  r.b428 <- next_r.b428;
  let r_expected = { r_expected with b428 = next_r.b428 } in
  mark_test_run 3469;
  let test = eq r r_expected in
  if not test then failwithf "test 3469 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a428 = #{ a35; b35 }; b428 } = r in
  let expected_a35 = 100 in
  mark_test_run 3470;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 3470 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3471;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 3471 failed";
  let expected_b428 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 3472;
  let test = int64x2_u_equal expected_b428 b428 in
  if not test then failwithf "test 3472 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a428; b428 } = r in
  let expected_a428 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) } in
  mark_test_run 3473;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) expected_a428 a428 in
  if not test then failwithf "test 3473 failed";
  let expected_b428 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 3474;
  let test = int64x2_u_equal expected_b428 b428 in
  if not test then failwithf "test 3474 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t430 = { #{ int; #{ int; int } } }   *)
  (******************************************)
  let r = { a430 = #{ a429 = 0; b429 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a430 *)
  let actual = r.a430 in
  let expected = #{ a429 = 0; b429 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 3475;
  let test = (fun #{ a429 = a4291; b429 = b4291 } #{ a429 = a4292; b429 = b4292 } -> (fun a b -> Int.equal a b) a4291 a4292 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4291 b4292) actual expected in
  if not test then failwithf "test 3475 failed";
  (* Paths of depth 2 *)
  (* .a430.#a429 *)
  let actual = r.a430.#a429 in
  let expected = 0 in
  mark_test_run 3476;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3476 failed";
  (* .a430.#b429 *)
  let actual = r.a430.#b429 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 3477;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3477 failed";
  (* Paths of depth 3 *)
  (* .a430.#b429.#a29 *)
  let actual = r.a430.#b429.#a29 in
  let expected = 1 in
  mark_test_run 3478;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3478 failed";
  (* .a430.#b429.#b29 *)
  let actual = r.a430.#b429.#b29 in
  let expected = 2 in
  mark_test_run 3479;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3479 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a430 = a4301 } { a430 = a4302 } -> (fun #{ a429 = a4291; b429 = b4291 } #{ a429 = a4292; b429 = b4292 } -> (fun a b -> Int.equal a b) a4291 a4292 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4291 b4292) a4301 a4302) in
  let next_r = { a430 = #{ a429 = 100; b429 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a430 = #{ a429 = 0; b429 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a430 *)
  r.a430 <- next_r.a430;
  let r_expected = { r_expected with a430 = next_r.a430 } in
  mark_test_run 3480;
  let test = eq r r_expected in
  if not test then failwithf "test 3480 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a430 = #{ a429; b429 = #{ a29; b29 } } } = r in
  let expected_a429 = 100 in
  mark_test_run 3481;
  let test = (fun a b -> Int.equal a b) expected_a429 a429 in
  if not test then failwithf "test 3481 failed";
  let expected_a29 = 101 in
  mark_test_run 3482;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3482 failed";
  let expected_b29 = 102 in
  mark_test_run 3483;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3483 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a430 } = r in
  let expected_a430 = #{ a429 = 100; b429 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 3484;
  let test = (fun #{ a429 = a4291; b429 = b4291 } #{ a429 = a4292; b429 = b4292 } -> (fun a b -> Int.equal a b) a4291 a4292 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4291 b4292) expected_a430 a430 in
  if not test then failwithf "test 3484 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t432 = { #{ int; #{ int; int32# } } }   *)
  (*********************************************)
  let r = { a432 = #{ a431 = 0; b431 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a432 *)
  let actual = r.a432 in
  let expected = #{ a431 = 0; b431 = #{ a31 = 1; b31 = #2l } } in
  mark_test_run 3485;
  let test = (fun #{ a431 = a4311; b431 = b4311 } #{ a431 = a4312; b431 = b4312 } -> (fun a b -> Int.equal a b) a4311 a4312 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4311 b4312) actual expected in
  if not test then failwithf "test 3485 failed";
  (* Paths of depth 2 *)
  (* .a432.#a431 *)
  let actual = r.a432.#a431 in
  let expected = 0 in
  mark_test_run 3486;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3486 failed";
  (* .a432.#b431 *)
  let actual = r.a432.#b431 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 3487;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 3487 failed";
  (* Paths of depth 3 *)
  (* .a432.#b431.#a31 *)
  let actual = r.a432.#b431.#a31 in
  let expected = 1 in
  mark_test_run 3488;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3488 failed";
  (* .a432.#b431.#b31 *)
  let actual = r.a432.#b431.#b31 in
  let expected = #2l in
  mark_test_run 3489;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3489 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a432 = a4321 } { a432 = a4322 } -> (fun #{ a431 = a4311; b431 = b4311 } #{ a431 = a4312; b431 = b4312 } -> (fun a b -> Int.equal a b) a4311 a4312 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4311 b4312) a4321 a4322) in
  let next_r = { a432 = #{ a431 = 100; b431 = #{ a31 = 101; b31 = #102l } } } in
  let r_expected = { a432 = #{ a431 = 0; b431 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a432 *)
  r.a432 <- next_r.a432;
  let r_expected = { r_expected with a432 = next_r.a432 } in
  mark_test_run 3490;
  let test = eq r r_expected in
  if not test then failwithf "test 3490 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a432 = #{ a431; b431 = #{ a31; b31 } } } = r in
  let expected_a431 = 100 in
  mark_test_run 3491;
  let test = (fun a b -> Int.equal a b) expected_a431 a431 in
  if not test then failwithf "test 3491 failed";
  let expected_a31 = 101 in
  mark_test_run 3492;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 3492 failed";
  let expected_b31 = #102l in
  mark_test_run 3493;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 3493 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a432 } = r in
  let expected_a432 = #{ a431 = 100; b431 = #{ a31 = 101; b31 = #102l } } in
  mark_test_run 3494;
  let test = (fun #{ a431 = a4311; b431 = b4311 } #{ a431 = a4312; b431 = b4312 } -> (fun a b -> Int.equal a b) a4311 a4312 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4311 b4312) expected_a432 a432 in
  if not test then failwithf "test 3494 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t434 = { #{ int; #{ int; float } } }   *)
  (********************************************)
  let r = { a434 = #{ a433 = 0; b433 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a434 *)
  let actual = r.a434 in
  let expected = #{ a433 = 0; b433 = #{ a33 = 1; b33 = 2. } } in
  mark_test_run 3495;
  let test = (fun #{ a433 = a4331; b433 = b4331 } #{ a433 = a4332; b433 = b4332 } -> (fun a b -> Int.equal a b) a4331 a4332 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b4331 b4332) actual expected in
  if not test then failwithf "test 3495 failed";
  (* Paths of depth 2 *)
  (* .a434.#a433 *)
  let actual = r.a434.#a433 in
  let expected = 0 in
  mark_test_run 3496;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3496 failed";
  (* .a434.#b433 *)
  let actual = r.a434.#b433 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 3497;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 3497 failed";
  (* Paths of depth 3 *)
  (* .a434.#b433.#a33 *)
  let actual = r.a434.#b433.#a33 in
  let expected = 1 in
  mark_test_run 3498;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3498 failed";
  (* .a434.#b433.#b33 *)
  let actual = r.a434.#b433.#b33 in
  let expected = 2. in
  mark_test_run 3499;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3499 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a434 = a4341 } { a434 = a4342 } -> (fun #{ a433 = a4331; b433 = b4331 } #{ a433 = a4332; b433 = b4332 } -> (fun a b -> Int.equal a b) a4331 a4332 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b4331 b4332) a4341 a4342) in
  let next_r = { a434 = #{ a433 = 100; b433 = #{ a33 = 101; b33 = 102. } } } in
  let r_expected = { a434 = #{ a433 = 0; b433 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a434 *)
  r.a434 <- next_r.a434;
  let r_expected = { r_expected with a434 = next_r.a434 } in
  mark_test_run 3500;
  let test = eq r r_expected in
  if not test then failwithf "test 3500 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a434 = #{ a433; b433 = #{ a33; b33 } } } = r in
  let expected_a433 = 100 in
  mark_test_run 3501;
  let test = (fun a b -> Int.equal a b) expected_a433 a433 in
  if not test then failwithf "test 3501 failed";
  let expected_a33 = 101 in
  mark_test_run 3502;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 3502 failed";
  let expected_b33 = 102. in
  mark_test_run 3503;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 3503 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a434 } = r in
  let expected_a434 = #{ a433 = 100; b433 = #{ a33 = 101; b33 = 102. } } in
  mark_test_run 3504;
  let test = (fun #{ a433 = a4331; b433 = b4331 } #{ a433 = a4332; b433 = b4332 } -> (fun a b -> Int.equal a b) a4331 a4332 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b4331 b4332) expected_a434 a434 in
  if not test then failwithf "test 3504 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t436 = { #{ int; #{ int; int64x2# } } }   *)
  (***********************************************)
  let r = { a436 = #{ a435 = 0; b435 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a436 *)
  let actual = r.a436 in
  let expected = #{ a435 = 0; b435 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  mark_test_run 3505;
  let test = (fun #{ a435 = a4351; b435 = b4351 } #{ a435 = a4352; b435 = b4352 } -> (fun a b -> Int.equal a b) a4351 a4352 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b4351 b4352) actual expected in
  if not test then failwithf "test 3505 failed";
  (* Paths of depth 2 *)
  (* .a436.#a435 *)
  let actual = r.a436.#a435 in
  let expected = 0 in
  mark_test_run 3506;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3506 failed";
  (* .a436.#b435 *)
  let actual = r.a436.#b435 in
  let expected = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 3507;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 3507 failed";
  (* Paths of depth 3 *)
  (* .a436.#b435.#a35 *)
  let actual = r.a436.#b435.#a35 in
  let expected = 1 in
  mark_test_run 3508;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3508 failed";
  (* .a436.#b435.#b35 *)
  let actual = r.a436.#b435.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 3509;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3509 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a436 = a4361 } { a436 = a4362 } -> (fun #{ a435 = a4351; b435 = b4351 } #{ a435 = a4352; b435 = b4352 } -> (fun a b -> Int.equal a b) a4351 a4352 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b4351 b4352) a4361 a4362) in
  let next_r = { a436 = #{ a435 = 100; b435 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } } in
  let r_expected = { a436 = #{ a435 = 0; b435 = #{ a35 = 1; b35 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a436 *)
  r.a436 <- next_r.a436;
  let r_expected = { r_expected with a436 = next_r.a436 } in
  mark_test_run 3510;
  let test = eq r r_expected in
  if not test then failwithf "test 3510 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a436 = #{ a435; b435 = #{ a35; b35 } } } = r in
  let expected_a435 = 100 in
  mark_test_run 3511;
  let test = (fun a b -> Int.equal a b) expected_a435 a435 in
  if not test then failwithf "test 3511 failed";
  let expected_a35 = 101 in
  mark_test_run 3512;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 3512 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 3513;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 3513 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a436 } = r in
  let expected_a436 = #{ a435 = 100; b435 = #{ a35 = 101; b35 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  mark_test_run 3514;
  let test = (fun #{ a435 = a4351; b435 = b4351 } #{ a435 = a4352; b435 = b4352 } -> (fun a b -> Int.equal a b) a4351 a4352 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b4351 b4352) expected_a436 a436 in
  if not test then failwithf "test 3514 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t438 = { #{ int; #{ int32#; int } } }   *)
  (*********************************************)
  let r = { a438 = #{ a437 = 0; b437 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a438 *)
  let actual = r.a438 in
  let expected = #{ a437 = 0; b437 = #{ a49 = #1l; b49 = 2 } } in
  mark_test_run 3515;
  let test = (fun #{ a437 = a4371; b437 = b4371 } #{ a437 = a4372; b437 = b4372 } -> (fun a b -> Int.equal a b) a4371 a4372 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4371 b4372) actual expected in
  if not test then failwithf "test 3515 failed";
  (* Paths of depth 2 *)
  (* .a438.#a437 *)
  let actual = r.a438.#a437 in
  let expected = 0 in
  mark_test_run 3516;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3516 failed";
  (* .a438.#b437 *)
  let actual = r.a438.#b437 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 3517;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 3517 failed";
  (* Paths of depth 3 *)
  (* .a438.#b437.#a49 *)
  let actual = r.a438.#b437.#a49 in
  let expected = #1l in
  mark_test_run 3518;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3518 failed";
  (* .a438.#b437.#b49 *)
  let actual = r.a438.#b437.#b49 in
  let expected = 2 in
  mark_test_run 3519;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3519 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a438 = a4381 } { a438 = a4382 } -> (fun #{ a437 = a4371; b437 = b4371 } #{ a437 = a4372; b437 = b4372 } -> (fun a b -> Int.equal a b) a4371 a4372 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4371 b4372) a4381 a4382) in
  let next_r = { a438 = #{ a437 = 100; b437 = #{ a49 = #101l; b49 = 102 } } } in
  let r_expected = { a438 = #{ a437 = 0; b437 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a438 *)
  r.a438 <- next_r.a438;
  let r_expected = { r_expected with a438 = next_r.a438 } in
  mark_test_run 3520;
  let test = eq r r_expected in
  if not test then failwithf "test 3520 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a438 = #{ a437; b437 = #{ a49; b49 } } } = r in
  let expected_a437 = 100 in
  mark_test_run 3521;
  let test = (fun a b -> Int.equal a b) expected_a437 a437 in
  if not test then failwithf "test 3521 failed";
  let expected_a49 = #101l in
  mark_test_run 3522;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 3522 failed";
  let expected_b49 = 102 in
  mark_test_run 3523;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 3523 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a438 } = r in
  let expected_a438 = #{ a437 = 100; b437 = #{ a49 = #101l; b49 = 102 } } in
  mark_test_run 3524;
  let test = (fun #{ a437 = a4371; b437 = b4371 } #{ a437 = a4372; b437 = b4372 } -> (fun a b -> Int.equal a b) a4371 a4372 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4371 b4372) expected_a438 a438 in
  if not test then failwithf "test 3524 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t440 = { #{ int; #{ int32#; int32# } } }   *)
  (************************************************)
  let r = { a440 = #{ a439 = 0; b439 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a440 *)
  let actual = r.a440 in
  let expected = #{ a439 = 0; b439 = #{ a51 = #1l; b51 = #2l } } in
  mark_test_run 3525;
  let test = (fun #{ a439 = a4391; b439 = b4391 } #{ a439 = a4392; b439 = b4392 } -> (fun a b -> Int.equal a b) a4391 a4392 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4391 b4392) actual expected in
  if not test then failwithf "test 3525 failed";
  (* Paths of depth 2 *)
  (* .a440.#a439 *)
  let actual = r.a440.#a439 in
  let expected = 0 in
  mark_test_run 3526;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3526 failed";
  (* .a440.#b439 *)
  let actual = r.a440.#b439 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 3527;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 3527 failed";
  (* Paths of depth 3 *)
  (* .a440.#b439.#a51 *)
  let actual = r.a440.#b439.#a51 in
  let expected = #1l in
  mark_test_run 3528;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3528 failed";
  (* .a440.#b439.#b51 *)
  let actual = r.a440.#b439.#b51 in
  let expected = #2l in
  mark_test_run 3529;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3529 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a440 = a4401 } { a440 = a4402 } -> (fun #{ a439 = a4391; b439 = b4391 } #{ a439 = a4392; b439 = b4392 } -> (fun a b -> Int.equal a b) a4391 a4392 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4391 b4392) a4401 a4402) in
  let next_r = { a440 = #{ a439 = 100; b439 = #{ a51 = #101l; b51 = #102l } } } in
  let r_expected = { a440 = #{ a439 = 0; b439 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a440 *)
  r.a440 <- next_r.a440;
  let r_expected = { r_expected with a440 = next_r.a440 } in
  mark_test_run 3530;
  let test = eq r r_expected in
  if not test then failwithf "test 3530 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a440 = #{ a439; b439 = #{ a51; b51 } } } = r in
  let expected_a439 = 100 in
  mark_test_run 3531;
  let test = (fun a b -> Int.equal a b) expected_a439 a439 in
  if not test then failwithf "test 3531 failed";
  let expected_a51 = #101l in
  mark_test_run 3532;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 3532 failed";
  let expected_b51 = #102l in
  mark_test_run 3533;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 3533 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a440 } = r in
  let expected_a440 = #{ a439 = 100; b439 = #{ a51 = #101l; b51 = #102l } } in
  mark_test_run 3534;
  let test = (fun #{ a439 = a4391; b439 = b4391 } #{ a439 = a4392; b439 = b4392 } -> (fun a b -> Int.equal a b) a4391 a4392 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4391 b4392) expected_a440 a440 in
  if not test then failwithf "test 3534 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t442 = { #{ int; #{ float; int } } }   *)
  (********************************************)
  let r = { a442 = #{ a441 = 0; b441 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a442 *)
  let actual = r.a442 in
  let expected = #{ a441 = 0; b441 = #{ a58 = 1.; b58 = 2 } } in
  mark_test_run 3535;
  let test = (fun #{ a441 = a4411; b441 = b4411 } #{ a441 = a4412; b441 = b4412 } -> (fun a b -> Int.equal a b) a4411 a4412 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b4411 b4412) actual expected in
  if not test then failwithf "test 3535 failed";
  (* Paths of depth 2 *)
  (* .a442.#a441 *)
  let actual = r.a442.#a441 in
  let expected = 0 in
  mark_test_run 3536;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3536 failed";
  (* .a442.#b441 *)
  let actual = r.a442.#b441 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 3537;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 3537 failed";
  (* Paths of depth 3 *)
  (* .a442.#b441.#a58 *)
  let actual = r.a442.#b441.#a58 in
  let expected = 1. in
  mark_test_run 3538;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3538 failed";
  (* .a442.#b441.#b58 *)
  let actual = r.a442.#b441.#b58 in
  let expected = 2 in
  mark_test_run 3539;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3539 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a442 = a4421 } { a442 = a4422 } -> (fun #{ a441 = a4411; b441 = b4411 } #{ a441 = a4412; b441 = b4412 } -> (fun a b -> Int.equal a b) a4411 a4412 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b4411 b4412) a4421 a4422) in
  let next_r = { a442 = #{ a441 = 100; b441 = #{ a58 = 101.; b58 = 102 } } } in
  let r_expected = { a442 = #{ a441 = 0; b441 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a442 *)
  r.a442 <- next_r.a442;
  let r_expected = { r_expected with a442 = next_r.a442 } in
  mark_test_run 3540;
  let test = eq r r_expected in
  if not test then failwithf "test 3540 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a442 = #{ a441; b441 = #{ a58; b58 } } } = r in
  let expected_a441 = 100 in
  mark_test_run 3541;
  let test = (fun a b -> Int.equal a b) expected_a441 a441 in
  if not test then failwithf "test 3541 failed";
  let expected_a58 = 101. in
  mark_test_run 3542;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 3542 failed";
  let expected_b58 = 102 in
  mark_test_run 3543;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 3543 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a442 } = r in
  let expected_a442 = #{ a441 = 100; b441 = #{ a58 = 101.; b58 = 102 } } in
  mark_test_run 3544;
  let test = (fun #{ a441 = a4411; b441 = b4411 } #{ a441 = a4412; b441 = b4412 } -> (fun a b -> Int.equal a b) a4411 a4412 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b4411 b4412) expected_a442 a442 in
  if not test then failwithf "test 3544 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t444 = { #{ int; #{ float; float } } }   *)
  (**********************************************)
  let r = { a444 = #{ a443 = 0; b443 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a444 *)
  let actual = r.a444 in
  let expected = #{ a443 = 0; b443 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 3545;
  let test = (fun #{ a443 = a4431; b443 = b4431 } #{ a443 = a4432; b443 = b4432 } -> (fun a b -> Int.equal a b) a4431 a4432 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b4431 b4432) actual expected in
  if not test then failwithf "test 3545 failed";
  (* Paths of depth 2 *)
  (* .a444.#a443 *)
  let actual = r.a444.#a443 in
  let expected = 0 in
  mark_test_run 3546;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3546 failed";
  (* .a444.#b443 *)
  let actual = r.a444.#b443 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 3547;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3547 failed";
  (* Paths of depth 3 *)
  (* .a444.#b443.#a60 *)
  let actual = r.a444.#b443.#a60 in
  let expected = 1. in
  mark_test_run 3548;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3548 failed";
  (* .a444.#b443.#b60 *)
  let actual = r.a444.#b443.#b60 in
  let expected = 2. in
  mark_test_run 3549;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3549 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a444 = a4441 } { a444 = a4442 } -> (fun #{ a443 = a4431; b443 = b4431 } #{ a443 = a4432; b443 = b4432 } -> (fun a b -> Int.equal a b) a4431 a4432 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b4431 b4432) a4441 a4442) in
  let next_r = { a444 = #{ a443 = 100; b443 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a444 = #{ a443 = 0; b443 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a444 *)
  r.a444 <- next_r.a444;
  let r_expected = { r_expected with a444 = next_r.a444 } in
  mark_test_run 3550;
  let test = eq r r_expected in
  if not test then failwithf "test 3550 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a444 = #{ a443; b443 = #{ a60; b60 } } } = r in
  let expected_a443 = 100 in
  mark_test_run 3551;
  let test = (fun a b -> Int.equal a b) expected_a443 a443 in
  if not test then failwithf "test 3551 failed";
  let expected_a60 = 101. in
  mark_test_run 3552;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3552 failed";
  let expected_b60 = 102. in
  mark_test_run 3553;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3553 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a444 } = r in
  let expected_a444 = #{ a443 = 100; b443 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 3554;
  let test = (fun #{ a443 = a4431; b443 = b4431 } #{ a443 = a4432; b443 = b4432 } -> (fun a b -> Int.equal a b) a4431 a4432 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b4431 b4432) expected_a444 a444 in
  if not test then failwithf "test 3554 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t446 = { #{ int; #{ int64x2#; int } } }   *)
  (***********************************************)
  let r = { a446 = #{ a445 = 0; b445 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a446 *)
  let actual = r.a446 in
  let expected = #{ a445 = 0; b445 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } in
  mark_test_run 3555;
  let test = (fun #{ a445 = a4451; b445 = b4451 } #{ a445 = a4452; b445 = b4452 } -> (fun a b -> Int.equal a b) a4451 a4452 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b4451 b4452) actual expected in
  if not test then failwithf "test 3555 failed";
  (* Paths of depth 2 *)
  (* .a446.#a445 *)
  let actual = r.a446.#a445 in
  let expected = 0 in
  mark_test_run 3556;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3556 failed";
  (* .a446.#b445 *)
  let actual = r.a446.#b445 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } in
  mark_test_run 3557;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 3557 failed";
  (* Paths of depth 3 *)
  (* .a446.#b445.#a67 *)
  let actual = r.a446.#b445.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3558;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3558 failed";
  (* .a446.#b445.#b67 *)
  let actual = r.a446.#b445.#b67 in
  let expected = 3 in
  mark_test_run 3559;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3559 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a446 = a4461 } { a446 = a4462 } -> (fun #{ a445 = a4451; b445 = b4451 } #{ a445 = a4452; b445 = b4452 } -> (fun a b -> Int.equal a b) a4451 a4452 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b4451 b4452) a4461 a4462) in
  let next_r = { a446 = #{ a445 = 100; b445 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } } } in
  let r_expected = { a446 = #{ a445 = 0; b445 = #{ a67 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b67 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a446 *)
  r.a446 <- next_r.a446;
  let r_expected = { r_expected with a446 = next_r.a446 } in
  mark_test_run 3560;
  let test = eq r r_expected in
  if not test then failwithf "test 3560 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a446 = #{ a445; b445 = #{ a67; b67 } } } = r in
  let expected_a445 = 100 in
  mark_test_run 3561;
  let test = (fun a b -> Int.equal a b) expected_a445 a445 in
  if not test then failwithf "test 3561 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3562;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 3562 failed";
  let expected_b67 = 103 in
  mark_test_run 3563;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 3563 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a446 } = r in
  let expected_a446 = #{ a445 = 100; b445 = #{ a67 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b67 = 103 } } in
  mark_test_run 3564;
  let test = (fun #{ a445 = a4451; b445 = b4451 } #{ a445 = a4452; b445 = b4452 } -> (fun a b -> Int.equal a b) a4451 a4452 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b4451 b4452) expected_a446 a446 in
  if not test then failwithf "test 3564 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t448 = { #{ int; #{ int64x2#; int64x2# } } }   *)
  (****************************************************)
  let r = { a448 = #{ a447 = 0; b447 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a448 *)
  let actual = r.a448 in
  let expected = #{ a447 = 0; b447 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 3565;
  let test = (fun #{ a447 = a4471; b447 = b4471 } #{ a447 = a4472; b447 = b4472 } -> (fun a b -> Int.equal a b) a4471 a4472 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b4471 b4472) actual expected in
  if not test then failwithf "test 3565 failed";
  (* Paths of depth 2 *)
  (* .a448.#a447 *)
  let actual = r.a448.#a447 in
  let expected = 0 in
  mark_test_run 3566;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3566 failed";
  (* .a448.#b447 *)
  let actual = r.a448.#b447 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 3567;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 3567 failed";
  (* Paths of depth 3 *)
  (* .a448.#b447.#a69 *)
  let actual = r.a448.#b447.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 3568;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3568 failed";
  (* .a448.#b447.#b69 *)
  let actual = r.a448.#b447.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 3569;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 3569 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a448 = a4481 } { a448 = a4482 } -> (fun #{ a447 = a4471; b447 = b4471 } #{ a447 = a4472; b447 = b4472 } -> (fun a b -> Int.equal a b) a4471 a4472 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b4471 b4472) a4481 a4482) in
  let next_r = { a448 = #{ a447 = 100; b447 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a448 = #{ a447 = 0; b447 = #{ a69 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b69 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a448 *)
  r.a448 <- next_r.a448;
  let r_expected = { r_expected with a448 = next_r.a448 } in
  mark_test_run 3570;
  let test = eq r r_expected in
  if not test then failwithf "test 3570 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a448 = #{ a447; b447 = #{ a69; b69 } } } = r in
  let expected_a447 = 100 in
  mark_test_run 3571;
  let test = (fun a b -> Int.equal a b) expected_a447 a447 in
  if not test then failwithf "test 3571 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 3572;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 3572 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 3573;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 3573 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a448 } = r in
  let expected_a448 = #{ a447 = 100; b447 = #{ a69 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b69 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 3574;
  let test = (fun #{ a447 = a4471; b447 = b4471 } #{ a447 = a4472; b447 = b4472 } -> (fun a b -> Int.equal a b) a4471 a4472 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b4471 b4472) expected_a448 a448 in
  if not test then failwithf "test 3574 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************************)
  (*   t451 = { #{ int64; int64# }; #{ int64#; float# } }   *)
  (**********************************************************)
  let r = { a451 = #{ a449 = 0L; b449 = #1L }; b451 = #{ a450 = #2L; b450 = #3. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a451 *)
  let actual = r.a451 in
  let expected = #{ a449 = 0L; b449 = #1L } in
  mark_test_run 3575;
  let test = (fun #{ a449 = a4491; b449 = b4491 } #{ a449 = a4492; b449 = b4492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4491 a4492 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b4491 b4492) actual expected in
  if not test then failwithf "test 3575 failed";
  (* Paths of depth 2 *)
  (* .a451.#a449 *)
  let actual = r.a451.#a449 in
  let expected = 0L in
  mark_test_run 3576;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3576 failed";
  (* .a451.#b449 *)
  let actual = r.a451.#b449 in
  let expected = #1L in
  mark_test_run 3577;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3577 failed";
  (* Paths of depth 1 *)
  (* .b451 *)
  let actual = r.b451 in
  let expected = #{ a450 = #2L; b450 = #3. } in
  mark_test_run 3578;
  let test = (fun #{ a450 = a4501; b450 = b4501 } #{ a450 = a4502; b450 = b4502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4501 a4502 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b4501 b4502) actual expected in
  if not test then failwithf "test 3578 failed";
  (* Paths of depth 2 *)
  (* .b451.#a450 *)
  let actual = r.b451.#a450 in
  let expected = #2L in
  mark_test_run 3579;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3579 failed";
  (* .b451.#b450 *)
  let actual = r.b451.#b450 in
  let expected = #3. in
  mark_test_run 3580;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3580 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a451 = a4511; b451 = b4511 } { a451 = a4512; b451 = b4512 } -> (fun #{ a449 = a4491; b449 = b4491 } #{ a449 = a4492; b449 = b4492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4491 a4492 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b4491 b4492) a4511 a4512 && (fun #{ a450 = a4501; b450 = b4501 } #{ a450 = a4502; b450 = b4502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4501 a4502 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b4501 b4502) b4511 b4512) in
  let next_r = { a451 = #{ a449 = 100L; b449 = #101L }; b451 = #{ a450 = #102L; b450 = #103. } } in
  let r_expected = { a451 = #{ a449 = 0L; b449 = #1L }; b451 = #{ a450 = #2L; b450 = #3. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a451 *)
  r.a451 <- next_r.a451;
  let r_expected = { r_expected with a451 = next_r.a451 } in
  mark_test_run 3581;
  let test = eq r r_expected in
  if not test then failwithf "test 3581 failed";
  Gc.compact ();
  (* .b451 *)
  r.b451 <- next_r.b451;
  let r_expected = { r_expected with b451 = next_r.b451 } in
  mark_test_run 3582;
  let test = eq r r_expected in
  if not test then failwithf "test 3582 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a451 = #{ a449; b449 }; b451 = #{ a450; b450 } } = r in
  let expected_a449 = 100L in
  mark_test_run 3583;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a449 a449 in
  if not test then failwithf "test 3583 failed";
  let expected_b449 = #101L in
  mark_test_run 3584;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b449 b449 in
  if not test then failwithf "test 3584 failed";
  let expected_a450 = #102L in
  mark_test_run 3585;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a450 a450 in
  if not test then failwithf "test 3585 failed";
  let expected_b450 = #103. in
  mark_test_run 3586;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b450 b450 in
  if not test then failwithf "test 3586 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a451; b451 } = r in
  let expected_a451 = #{ a449 = 100L; b449 = #101L } in
  mark_test_run 3587;
  let test = (fun #{ a449 = a4491; b449 = b4491 } #{ a449 = a4492; b449 = b4492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4491 a4492 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b4491 b4492) expected_a451 a451 in
  if not test then failwithf "test 3587 failed";
  let expected_b451 = #{ a450 = #102L; b450 = #103. } in
  mark_test_run 3588;
  let test = (fun #{ a450 = a4501; b450 = b4501 } #{ a450 = a4502; b450 = b4502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4501 a4502 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b4501 b4502) expected_b451 b451 in
  if not test then failwithf "test 3588 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************************)
  (*   t454 = { #{ int64; string }; #{ int64#; string } }   *)
  (**********************************************************)
  let r = { a454 = #{ a452 = 0L; b452 = "1" }; b454 = #{ a453 = #2L; b453 = "3" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a454 *)
  let actual = r.a454 in
  let expected = #{ a452 = 0L; b452 = "1" } in
  mark_test_run 3589;
  let test = (fun #{ a452 = a4521; b452 = b4521 } #{ a452 = a4522; b452 = b4522 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4521 a4522 && (fun a b -> String.equal (globalize a) (globalize b)) b4521 b4522) actual expected in
  if not test then failwithf "test 3589 failed";
  (* Paths of depth 2 *)
  (* .a454.#a452 *)
  let actual = r.a454.#a452 in
  let expected = 0L in
  mark_test_run 3590;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3590 failed";
  (* .a454.#b452 *)
  let actual = r.a454.#b452 in
  let expected = "1" in
  mark_test_run 3591;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3591 failed";
  (* Paths of depth 1 *)
  (* .b454 *)
  let actual = r.b454 in
  let expected = #{ a453 = #2L; b453 = "3" } in
  mark_test_run 3592;
  let test = (fun #{ a453 = a4531; b453 = b4531 } #{ a453 = a4532; b453 = b4532 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4531 a4532 && (fun a b -> String.equal (globalize a) (globalize b)) b4531 b4532) actual expected in
  if not test then failwithf "test 3592 failed";
  (* Paths of depth 2 *)
  (* .b454.#a453 *)
  let actual = r.b454.#a453 in
  let expected = #2L in
  mark_test_run 3593;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3593 failed";
  (* .b454.#b453 *)
  let actual = r.b454.#b453 in
  let expected = "3" in
  mark_test_run 3594;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3594 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a454 = a4541; b454 = b4541 } { a454 = a4542; b454 = b4542 } -> (fun #{ a452 = a4521; b452 = b4521 } #{ a452 = a4522; b452 = b4522 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4521 a4522 && (fun a b -> String.equal (globalize a) (globalize b)) b4521 b4522) a4541 a4542 && (fun #{ a453 = a4531; b453 = b4531 } #{ a453 = a4532; b453 = b4532 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4531 a4532 && (fun a b -> String.equal (globalize a) (globalize b)) b4531 b4532) b4541 b4542) in
  let next_r = { a454 = #{ a452 = 100L; b452 = "101" }; b454 = #{ a453 = #102L; b453 = "103" } } in
  let r_expected = { a454 = #{ a452 = 0L; b452 = "1" }; b454 = #{ a453 = #2L; b453 = "3" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a454 *)
  r.a454 <- next_r.a454;
  let r_expected = { r_expected with a454 = next_r.a454 } in
  mark_test_run 3595;
  let test = eq r r_expected in
  if not test then failwithf "test 3595 failed";
  Gc.compact ();
  (* .b454 *)
  r.b454 <- next_r.b454;
  let r_expected = { r_expected with b454 = next_r.b454 } in
  mark_test_run 3596;
  let test = eq r r_expected in
  if not test then failwithf "test 3596 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a454 = #{ a452; b452 }; b454 = #{ a453; b453 } } = r in
  let expected_a452 = 100L in
  mark_test_run 3597;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a452 a452 in
  if not test then failwithf "test 3597 failed";
  let expected_b452 = "101" in
  mark_test_run 3598;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b452 b452 in
  if not test then failwithf "test 3598 failed";
  let expected_a453 = #102L in
  mark_test_run 3599;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a453 a453 in
  if not test then failwithf "test 3599 failed";
  let expected_b453 = "103" in
  mark_test_run 3600;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b453 b453 in
  if not test then failwithf "test 3600 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a454; b454 } = r in
  let expected_a454 = #{ a452 = 100L; b452 = "101" } in
  mark_test_run 3601;
  let test = (fun #{ a452 = a4521; b452 = b4521 } #{ a452 = a4522; b452 = b4522 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4521 a4522 && (fun a b -> String.equal (globalize a) (globalize b)) b4521 b4522) expected_a454 a454 in
  if not test then failwithf "test 3601 failed";
  let expected_b454 = #{ a453 = #102L; b453 = "103" } in
  mark_test_run 3602;
  let test = (fun #{ a453 = a4531; b453 = b4531 } #{ a453 = a4532; b453 = b4532 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4531 a4532 && (fun a b -> String.equal (globalize a) (globalize b)) b4531 b4532) expected_b454 b454 in
  if not test then failwithf "test 3602 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************************)
  (*   t457 = { #{ int64#; int64 }; #{ int64; int64 } }   *)
  (********************************************************)
  let r = { a457 = #{ a455 = #0L; b455 = 1L }; b457 = #{ a456 = 2L; b456 = 3L } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a457 *)
  let actual = r.a457 in
  let expected = #{ a455 = #0L; b455 = 1L } in
  mark_test_run 3603;
  let test = (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) actual expected in
  if not test then failwithf "test 3603 failed";
  (* Paths of depth 2 *)
  (* .a457.#a455 *)
  let actual = r.a457.#a455 in
  let expected = #0L in
  mark_test_run 3604;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3604 failed";
  (* .a457.#b455 *)
  let actual = r.a457.#b455 in
  let expected = 1L in
  mark_test_run 3605;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3605 failed";
  (* Paths of depth 1 *)
  (* .b457 *)
  let actual = r.b457 in
  let expected = #{ a456 = 2L; b456 = 3L } in
  mark_test_run 3606;
  let test = (fun #{ a456 = a4561; b456 = b4561 } #{ a456 = a4562; b456 = b4562 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4561 a4562 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4561 b4562) actual expected in
  if not test then failwithf "test 3606 failed";
  (* Paths of depth 2 *)
  (* .b457.#a456 *)
  let actual = r.b457.#a456 in
  let expected = 2L in
  mark_test_run 3607;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3607 failed";
  (* .b457.#b456 *)
  let actual = r.b457.#b456 in
  let expected = 3L in
  mark_test_run 3608;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3608 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a457 = a4571; b457 = b4571 } { a457 = a4572; b457 = b4572 } -> (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) a4571 a4572 && (fun #{ a456 = a4561; b456 = b4561 } #{ a456 = a4562; b456 = b4562 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4561 a4562 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4561 b4562) b4571 b4572) in
  let next_r = { a457 = #{ a455 = #100L; b455 = 101L }; b457 = #{ a456 = 102L; b456 = 103L } } in
  let r_expected = { a457 = #{ a455 = #0L; b455 = 1L }; b457 = #{ a456 = 2L; b456 = 3L } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a457 *)
  r.a457 <- next_r.a457;
  let r_expected = { r_expected with a457 = next_r.a457 } in
  mark_test_run 3609;
  let test = eq r r_expected in
  if not test then failwithf "test 3609 failed";
  Gc.compact ();
  (* .b457 *)
  r.b457 <- next_r.b457;
  let r_expected = { r_expected with b457 = next_r.b457 } in
  mark_test_run 3610;
  let test = eq r r_expected in
  if not test then failwithf "test 3610 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a457 = #{ a455; b455 }; b457 = #{ a456; b456 } } = r in
  let expected_a455 = #100L in
  mark_test_run 3611;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a455 a455 in
  if not test then failwithf "test 3611 failed";
  let expected_b455 = 101L in
  mark_test_run 3612;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b455 b455 in
  if not test then failwithf "test 3612 failed";
  let expected_a456 = 102L in
  mark_test_run 3613;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a456 a456 in
  if not test then failwithf "test 3613 failed";
  let expected_b456 = 103L in
  mark_test_run 3614;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b456 b456 in
  if not test then failwithf "test 3614 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a457; b457 } = r in
  let expected_a457 = #{ a455 = #100L; b455 = 101L } in
  mark_test_run 3615;
  let test = (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) expected_a457 a457 in
  if not test then failwithf "test 3615 failed";
  let expected_b457 = #{ a456 = 102L; b456 = 103L } in
  mark_test_run 3616;
  let test = (fun #{ a456 = a4561; b456 = b4561 } #{ a456 = a4562; b456 = b4562 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a4561 a4562 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4561 b4562) expected_b457 b457 in
  if not test then failwithf "test 3616 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************************)
  (*   t459 = { #{ int64#; int64 }; #{ float32#; float } }   *)
  (***********************************************************)
  let r = { a459 = #{ a455 = #0L; b455 = 1L }; b459 = #{ a458 = #2.s; b458 = 3. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a459 *)
  let actual = r.a459 in
  let expected = #{ a455 = #0L; b455 = 1L } in
  mark_test_run 3617;
  let test = (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) actual expected in
  if not test then failwithf "test 3617 failed";
  (* Paths of depth 2 *)
  (* .a459.#a455 *)
  let actual = r.a459.#a455 in
  let expected = #0L in
  mark_test_run 3618;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 3618 failed";
  (* .a459.#b455 *)
  let actual = r.a459.#b455 in
  let expected = 1L in
  mark_test_run 3619;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3619 failed";
  (* Paths of depth 1 *)
  (* .b459 *)
  let actual = r.b459 in
  let expected = #{ a458 = #2.s; b458 = 3. } in
  mark_test_run 3620;
  let test = (fun #{ a458 = a4581; b458 = b4581 } #{ a458 = a4582; b458 = b4582 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a4581 a4582 && (fun a b -> Float.equal (globalize a) (globalize b)) b4581 b4582) actual expected in
  if not test then failwithf "test 3620 failed";
  (* Paths of depth 2 *)
  (* .b459.#a458 *)
  let actual = r.b459.#a458 in
  let expected = #2.s in
  mark_test_run 3621;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) actual expected in
  if not test then failwithf "test 3621 failed";
  (* .b459.#b458 *)
  let actual = r.b459.#b458 in
  let expected = 3. in
  mark_test_run 3622;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3622 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a459 = a4591; b459 = b4591 } { a459 = a4592; b459 = b4592 } -> (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) a4591 a4592 && (fun #{ a458 = a4581; b458 = b4581 } #{ a458 = a4582; b458 = b4582 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a4581 a4582 && (fun a b -> Float.equal (globalize a) (globalize b)) b4581 b4582) b4591 b4592) in
  let next_r = { a459 = #{ a455 = #100L; b455 = 101L }; b459 = #{ a458 = #102.s; b458 = 103. } } in
  let r_expected = { a459 = #{ a455 = #0L; b455 = 1L }; b459 = #{ a458 = #2.s; b458 = 3. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a459 *)
  r.a459 <- next_r.a459;
  let r_expected = { r_expected with a459 = next_r.a459 } in
  mark_test_run 3623;
  let test = eq r r_expected in
  if not test then failwithf "test 3623 failed";
  Gc.compact ();
  (* .b459 *)
  r.b459 <- next_r.b459;
  let r_expected = { r_expected with b459 = next_r.b459 } in
  mark_test_run 3624;
  let test = eq r r_expected in
  if not test then failwithf "test 3624 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a459 = #{ a455; b455 }; b459 = #{ a458; b458 } } = r in
  let expected_a455 = #100L in
  mark_test_run 3625;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a455 a455 in
  if not test then failwithf "test 3625 failed";
  let expected_b455 = 101L in
  mark_test_run 3626;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b455 b455 in
  if not test then failwithf "test 3626 failed";
  let expected_a458 = #102.s in
  mark_test_run 3627;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) expected_a458 a458 in
  if not test then failwithf "test 3627 failed";
  let expected_b458 = 103. in
  mark_test_run 3628;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b458 b458 in
  if not test then failwithf "test 3628 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a459; b459 } = r in
  let expected_a459 = #{ a455 = #100L; b455 = 101L } in
  mark_test_run 3629;
  let test = (fun #{ a455 = a4551; b455 = b4551 } #{ a455 = a4552; b455 = b4552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4551 a4552 && (fun a b -> Int64.equal (globalize a) (globalize b)) b4551 b4552) expected_a459 a459 in
  if not test then failwithf "test 3629 failed";
  let expected_b459 = #{ a458 = #102.s; b458 = 103. } in
  mark_test_run 3630;
  let test = (fun #{ a458 = a4581; b458 = b4581 } #{ a458 = a4582; b458 = b4582 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a4581 a4582 && (fun a b -> Float.equal (globalize a) (globalize b)) b4581 b4582) expected_b459 b459 in
  if not test then failwithf "test 3630 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t460 = { #{ int32# } }   *)
  (******************************)
  let r = { a460 = #{ a39 = #0l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a460 *)
  let actual = r.a460 in
  let expected = #{ a39 = #0l } in
  mark_test_run 3631;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 3631 failed";
  (* Paths of depth 2 *)
  (* .a460.#a39 *)
  let actual = r.a460.#a39 in
  let expected = #0l in
  mark_test_run 3632;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3632 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a460 = a4601 } { a460 = a4602 } -> (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) a4601 a4602) in
  let next_r = { a460 = #{ a39 = #100l } } in
  let r_expected = { a460 = #{ a39 = #0l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a460 *)
  r.a460 <- next_r.a460;
  let r_expected = { r_expected with a460 = next_r.a460 } in
  mark_test_run 3633;
  let test = eq r r_expected in
  if not test then failwithf "test 3633 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a460 = #{ a39 } } = r in
  let expected_a39 = #100l in
  mark_test_run 3634;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 3634 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a460 } = r in
  let expected_a460 = #{ a39 = #100l } in
  mark_test_run 3635;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) expected_a460 a460 in
  if not test then failwithf "test 3635 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t461 = { #{ int32# }; int }   *)
  (***********************************)
  let r = { a461 = #{ a39 = #0l }; b461 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a461 *)
  let actual = r.a461 in
  let expected = #{ a39 = #0l } in
  mark_test_run 3636;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 3636 failed";
  (* Paths of depth 2 *)
  (* .a461.#a39 *)
  let actual = r.a461.#a39 in
  let expected = #0l in
  mark_test_run 3637;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3637 failed";
  (* Paths of depth 1 *)
  (* .b461 *)
  let actual = r.b461 in
  let expected = 1 in
  mark_test_run 3638;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3638 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a461 = a4611; b461 = b4611 } { a461 = a4612; b461 = b4612 } -> (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) a4611 a4612 && (fun a b -> Int.equal a b) b4611 b4612) in
  let next_r = { a461 = #{ a39 = #100l }; b461 = 101 } in
  let r_expected = { a461 = #{ a39 = #0l }; b461 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a461 *)
  r.a461 <- next_r.a461;
  let r_expected = { r_expected with a461 = next_r.a461 } in
  mark_test_run 3639;
  let test = eq r r_expected in
  if not test then failwithf "test 3639 failed";
  Gc.compact ();
  (* .b461 *)
  r.b461 <- next_r.b461;
  let r_expected = { r_expected with b461 = next_r.b461 } in
  mark_test_run 3640;
  let test = eq r r_expected in
  if not test then failwithf "test 3640 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a461 = #{ a39 }; b461 } = r in
  let expected_a39 = #100l in
  mark_test_run 3641;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 3641 failed";
  let expected_b461 = 101 in
  mark_test_run 3642;
  let test = (fun a b -> Int.equal a b) expected_b461 b461 in
  if not test then failwithf "test 3642 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a461; b461 } = r in
  let expected_a461 = #{ a39 = #100l } in
  mark_test_run 3643;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) expected_a461 a461 in
  if not test then failwithf "test 3643 failed";
  let expected_b461 = 101 in
  mark_test_run 3644;
  let test = (fun a b -> Int.equal a b) expected_b461 b461 in
  if not test then failwithf "test 3644 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t462 = { #{ int32# }; int32# }   *)
  (**************************************)
  let r = { a462 = #{ a39 = #0l }; b462 = #1l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a462 *)
  let actual = r.a462 in
  let expected = #{ a39 = #0l } in
  mark_test_run 3645;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) actual expected in
  if not test then failwithf "test 3645 failed";
  (* Paths of depth 2 *)
  (* .a462.#a39 *)
  let actual = r.a462.#a39 in
  let expected = #0l in
  mark_test_run 3646;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3646 failed";
  (* Paths of depth 1 *)
  (* .b462 *)
  let actual = r.b462 in
  let expected = #1l in
  mark_test_run 3647;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3647 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a462 = a4621; b462 = b4621 } { a462 = a4622; b462 = b4622 } -> (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) a4621 a4622 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4621 b4622) in
  let next_r = { a462 = #{ a39 = #100l }; b462 = #101l } in
  let r_expected = { a462 = #{ a39 = #0l }; b462 = #1l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a462 *)
  r.a462 <- next_r.a462;
  let r_expected = { r_expected with a462 = next_r.a462 } in
  mark_test_run 3648;
  let test = eq r r_expected in
  if not test then failwithf "test 3648 failed";
  Gc.compact ();
  (* .b462 *)
  r.b462 <- next_r.b462;
  let r_expected = { r_expected with b462 = next_r.b462 } in
  mark_test_run 3649;
  let test = eq r r_expected in
  if not test then failwithf "test 3649 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a462 = #{ a39 }; b462 } = r in
  let expected_a39 = #100l in
  mark_test_run 3650;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a39 a39 in
  if not test then failwithf "test 3650 failed";
  let expected_b462 = #101l in
  mark_test_run 3651;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b462 b462 in
  if not test then failwithf "test 3651 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a462; b462 } = r in
  let expected_a462 = #{ a39 = #100l } in
  mark_test_run 3652;
  let test = (fun #{ a39 = a391 } #{ a39 = a392 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392) expected_a462 a462 in
  if not test then failwithf "test 3652 failed";
  let expected_b462 = #101l in
  mark_test_run 3653;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b462 b462 in
  if not test then failwithf "test 3653 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t463 = { #{ int32#; int } }   *)
  (***********************************)
  let r = { a463 = #{ a49 = #0l; b49 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a463 *)
  let actual = r.a463 in
  let expected = #{ a49 = #0l; b49 = 1 } in
  mark_test_run 3654;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 3654 failed";
  (* Paths of depth 2 *)
  (* .a463.#a49 *)
  let actual = r.a463.#a49 in
  let expected = #0l in
  mark_test_run 3655;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3655 failed";
  (* .a463.#b49 *)
  let actual = r.a463.#b49 in
  let expected = 1 in
  mark_test_run 3656;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3656 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a463 = a4631 } { a463 = a4632 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a4631 a4632) in
  let next_r = { a463 = #{ a49 = #100l; b49 = 101 } } in
  let r_expected = { a463 = #{ a49 = #0l; b49 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a463 *)
  r.a463 <- next_r.a463;
  let r_expected = { r_expected with a463 = next_r.a463 } in
  mark_test_run 3657;
  let test = eq r r_expected in
  if not test then failwithf "test 3657 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a463 = #{ a49; b49 } } = r in
  let expected_a49 = #100l in
  mark_test_run 3658;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 3658 failed";
  let expected_b49 = 101 in
  mark_test_run 3659;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 3659 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a463 } = r in
  let expected_a463 = #{ a49 = #100l; b49 = 101 } in
  mark_test_run 3660;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) expected_a463 a463 in
  if not test then failwithf "test 3660 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t464 = { #{ int32#; int }; int }   *)
  (****************************************)
  let r = { a464 = #{ a49 = #0l; b49 = 1 }; b464 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a464 *)
  let actual = r.a464 in
  let expected = #{ a49 = #0l; b49 = 1 } in
  mark_test_run 3661;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 3661 failed";
  (* Paths of depth 2 *)
  (* .a464.#a49 *)
  let actual = r.a464.#a49 in
  let expected = #0l in
  mark_test_run 3662;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3662 failed";
  (* .a464.#b49 *)
  let actual = r.a464.#b49 in
  let expected = 1 in
  mark_test_run 3663;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3663 failed";
  (* Paths of depth 1 *)
  (* .b464 *)
  let actual = r.b464 in
  let expected = 2 in
  mark_test_run 3664;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3664 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a464 = a4641; b464 = b4641 } { a464 = a4642; b464 = b4642 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a4641 a4642 && (fun a b -> Int.equal a b) b4641 b4642) in
  let next_r = { a464 = #{ a49 = #100l; b49 = 101 }; b464 = 102 } in
  let r_expected = { a464 = #{ a49 = #0l; b49 = 1 }; b464 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a464 *)
  r.a464 <- next_r.a464;
  let r_expected = { r_expected with a464 = next_r.a464 } in
  mark_test_run 3665;
  let test = eq r r_expected in
  if not test then failwithf "test 3665 failed";
  Gc.compact ();
  (* .b464 *)
  r.b464 <- next_r.b464;
  let r_expected = { r_expected with b464 = next_r.b464 } in
  mark_test_run 3666;
  let test = eq r r_expected in
  if not test then failwithf "test 3666 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a464 = #{ a49; b49 }; b464 } = r in
  let expected_a49 = #100l in
  mark_test_run 3667;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 3667 failed";
  let expected_b49 = 101 in
  mark_test_run 3668;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 3668 failed";
  let expected_b464 = 102 in
  mark_test_run 3669;
  let test = (fun a b -> Int.equal a b) expected_b464 b464 in
  if not test then failwithf "test 3669 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a464; b464 } = r in
  let expected_a464 = #{ a49 = #100l; b49 = 101 } in
  mark_test_run 3670;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) expected_a464 a464 in
  if not test then failwithf "test 3670 failed";
  let expected_b464 = 102 in
  mark_test_run 3671;
  let test = (fun a b -> Int.equal a b) expected_b464 b464 in
  if not test then failwithf "test 3671 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t465 = { #{ int32#; int }; int32# }   *)
  (*******************************************)
  let r = { a465 = #{ a49 = #0l; b49 = 1 }; b465 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a465 *)
  let actual = r.a465 in
  let expected = #{ a49 = #0l; b49 = 1 } in
  mark_test_run 3672;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 3672 failed";
  (* Paths of depth 2 *)
  (* .a465.#a49 *)
  let actual = r.a465.#a49 in
  let expected = #0l in
  mark_test_run 3673;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3673 failed";
  (* .a465.#b49 *)
  let actual = r.a465.#b49 in
  let expected = 1 in
  mark_test_run 3674;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3674 failed";
  (* Paths of depth 1 *)
  (* .b465 *)
  let actual = r.b465 in
  let expected = #2l in
  mark_test_run 3675;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3675 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a465 = a4651; b465 = b4651 } { a465 = a4652; b465 = b4652 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a4651 a4652 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4651 b4652) in
  let next_r = { a465 = #{ a49 = #100l; b49 = 101 }; b465 = #102l } in
  let r_expected = { a465 = #{ a49 = #0l; b49 = 1 }; b465 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a465 *)
  r.a465 <- next_r.a465;
  let r_expected = { r_expected with a465 = next_r.a465 } in
  mark_test_run 3676;
  let test = eq r r_expected in
  if not test then failwithf "test 3676 failed";
  Gc.compact ();
  (* .b465 *)
  r.b465 <- next_r.b465;
  let r_expected = { r_expected with b465 = next_r.b465 } in
  mark_test_run 3677;
  let test = eq r r_expected in
  if not test then failwithf "test 3677 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a465 = #{ a49; b49 }; b465 } = r in
  let expected_a49 = #100l in
  mark_test_run 3678;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 3678 failed";
  let expected_b49 = 101 in
  mark_test_run 3679;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 3679 failed";
  let expected_b465 = #102l in
  mark_test_run 3680;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b465 b465 in
  if not test then failwithf "test 3680 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a465; b465 } = r in
  let expected_a465 = #{ a49 = #100l; b49 = 101 } in
  mark_test_run 3681;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) expected_a465 a465 in
  if not test then failwithf "test 3681 failed";
  let expected_b465 = #102l in
  mark_test_run 3682;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b465 b465 in
  if not test then failwithf "test 3682 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t466 = { #{ int32#; int32# } }   *)
  (**************************************)
  let r = { a466 = #{ a51 = #0l; b51 = #1l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a466 *)
  let actual = r.a466 in
  let expected = #{ a51 = #0l; b51 = #1l } in
  mark_test_run 3683;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 3683 failed";
  (* Paths of depth 2 *)
  (* .a466.#a51 *)
  let actual = r.a466.#a51 in
  let expected = #0l in
  mark_test_run 3684;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3684 failed";
  (* .a466.#b51 *)
  let actual = r.a466.#b51 in
  let expected = #1l in
  mark_test_run 3685;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3685 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a466 = a4661 } { a466 = a4662 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a4661 a4662) in
  let next_r = { a466 = #{ a51 = #100l; b51 = #101l } } in
  let r_expected = { a466 = #{ a51 = #0l; b51 = #1l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a466 *)
  r.a466 <- next_r.a466;
  let r_expected = { r_expected with a466 = next_r.a466 } in
  mark_test_run 3686;
  let test = eq r r_expected in
  if not test then failwithf "test 3686 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a466 = #{ a51; b51 } } = r in
  let expected_a51 = #100l in
  mark_test_run 3687;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 3687 failed";
  let expected_b51 = #101l in
  mark_test_run 3688;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 3688 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a466 } = r in
  let expected_a466 = #{ a51 = #100l; b51 = #101l } in
  mark_test_run 3689;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) expected_a466 a466 in
  if not test then failwithf "test 3689 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t467 = { #{ int32#; int32# }; int }   *)
  (*******************************************)
  let r = { a467 = #{ a51 = #0l; b51 = #1l }; b467 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a467 *)
  let actual = r.a467 in
  let expected = #{ a51 = #0l; b51 = #1l } in
  mark_test_run 3690;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 3690 failed";
  (* Paths of depth 2 *)
  (* .a467.#a51 *)
  let actual = r.a467.#a51 in
  let expected = #0l in
  mark_test_run 3691;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3691 failed";
  (* .a467.#b51 *)
  let actual = r.a467.#b51 in
  let expected = #1l in
  mark_test_run 3692;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3692 failed";
  (* Paths of depth 1 *)
  (* .b467 *)
  let actual = r.b467 in
  let expected = 2 in
  mark_test_run 3693;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3693 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a467 = a4671; b467 = b4671 } { a467 = a4672; b467 = b4672 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a4671 a4672 && (fun a b -> Int.equal a b) b4671 b4672) in
  let next_r = { a467 = #{ a51 = #100l; b51 = #101l }; b467 = 102 } in
  let r_expected = { a467 = #{ a51 = #0l; b51 = #1l }; b467 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a467 *)
  r.a467 <- next_r.a467;
  let r_expected = { r_expected with a467 = next_r.a467 } in
  mark_test_run 3694;
  let test = eq r r_expected in
  if not test then failwithf "test 3694 failed";
  Gc.compact ();
  (* .b467 *)
  r.b467 <- next_r.b467;
  let r_expected = { r_expected with b467 = next_r.b467 } in
  mark_test_run 3695;
  let test = eq r r_expected in
  if not test then failwithf "test 3695 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a467 = #{ a51; b51 }; b467 } = r in
  let expected_a51 = #100l in
  mark_test_run 3696;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 3696 failed";
  let expected_b51 = #101l in
  mark_test_run 3697;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 3697 failed";
  let expected_b467 = 102 in
  mark_test_run 3698;
  let test = (fun a b -> Int.equal a b) expected_b467 b467 in
  if not test then failwithf "test 3698 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a467; b467 } = r in
  let expected_a467 = #{ a51 = #100l; b51 = #101l } in
  mark_test_run 3699;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) expected_a467 a467 in
  if not test then failwithf "test 3699 failed";
  let expected_b467 = 102 in
  mark_test_run 3700;
  let test = (fun a b -> Int.equal a b) expected_b467 b467 in
  if not test then failwithf "test 3700 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t468 = { #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let r = { a468 = #{ a51 = #0l; b51 = #1l }; b468 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a468 *)
  let actual = r.a468 in
  let expected = #{ a51 = #0l; b51 = #1l } in
  mark_test_run 3701;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 3701 failed";
  (* Paths of depth 2 *)
  (* .a468.#a51 *)
  let actual = r.a468.#a51 in
  let expected = #0l in
  mark_test_run 3702;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3702 failed";
  (* .a468.#b51 *)
  let actual = r.a468.#b51 in
  let expected = #1l in
  mark_test_run 3703;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3703 failed";
  (* Paths of depth 1 *)
  (* .b468 *)
  let actual = r.b468 in
  let expected = #2l in
  mark_test_run 3704;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3704 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a468 = a4681; b468 = b4681 } { a468 = a4682; b468 = b4682 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a4681 a4682 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b4681 b4682) in
  let next_r = { a468 = #{ a51 = #100l; b51 = #101l }; b468 = #102l } in
  let r_expected = { a468 = #{ a51 = #0l; b51 = #1l }; b468 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a468 *)
  r.a468 <- next_r.a468;
  let r_expected = { r_expected with a468 = next_r.a468 } in
  mark_test_run 3705;
  let test = eq r r_expected in
  if not test then failwithf "test 3705 failed";
  Gc.compact ();
  (* .b468 *)
  r.b468 <- next_r.b468;
  let r_expected = { r_expected with b468 = next_r.b468 } in
  mark_test_run 3706;
  let test = eq r r_expected in
  if not test then failwithf "test 3706 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a468 = #{ a51; b51 }; b468 } = r in
  let expected_a51 = #100l in
  mark_test_run 3707;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 3707 failed";
  let expected_b51 = #101l in
  mark_test_run 3708;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 3708 failed";
  let expected_b468 = #102l in
  mark_test_run 3709;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b468 b468 in
  if not test then failwithf "test 3709 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a468; b468 } = r in
  let expected_a468 = #{ a51 = #100l; b51 = #101l } in
  mark_test_run 3710;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) expected_a468 a468 in
  if not test then failwithf "test 3710 failed";
  let expected_b468 = #102l in
  mark_test_run 3711;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b468 b468 in
  if not test then failwithf "test 3711 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t470 = { #{ int32#; #{ int; int } } }   *)
  (*********************************************)
  let r = { a470 = #{ a469 = #0l; b469 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a470 *)
  let actual = r.a470 in
  let expected = #{ a469 = #0l; b469 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 3712;
  let test = (fun #{ a469 = a4691; b469 = b4691 } #{ a469 = a4692; b469 = b4692 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4691 a4692 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4691 b4692) actual expected in
  if not test then failwithf "test 3712 failed";
  (* Paths of depth 2 *)
  (* .a470.#a469 *)
  let actual = r.a470.#a469 in
  let expected = #0l in
  mark_test_run 3713;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3713 failed";
  (* .a470.#b469 *)
  let actual = r.a470.#b469 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 3714;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3714 failed";
  (* Paths of depth 3 *)
  (* .a470.#b469.#a29 *)
  let actual = r.a470.#b469.#a29 in
  let expected = 1 in
  mark_test_run 3715;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3715 failed";
  (* .a470.#b469.#b29 *)
  let actual = r.a470.#b469.#b29 in
  let expected = 2 in
  mark_test_run 3716;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3716 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a470 = a4701 } { a470 = a4702 } -> (fun #{ a469 = a4691; b469 = b4691 } #{ a469 = a4692; b469 = b4692 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4691 a4692 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4691 b4692) a4701 a4702) in
  let next_r = { a470 = #{ a469 = #100l; b469 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a470 = #{ a469 = #0l; b469 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a470 *)
  r.a470 <- next_r.a470;
  let r_expected = { r_expected with a470 = next_r.a470 } in
  mark_test_run 3717;
  let test = eq r r_expected in
  if not test then failwithf "test 3717 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a470 = #{ a469; b469 = #{ a29; b29 } } } = r in
  let expected_a469 = #100l in
  mark_test_run 3718;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a469 a469 in
  if not test then failwithf "test 3718 failed";
  let expected_a29 = 101 in
  mark_test_run 3719;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3719 failed";
  let expected_b29 = 102 in
  mark_test_run 3720;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3720 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a470 } = r in
  let expected_a470 = #{ a469 = #100l; b469 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 3721;
  let test = (fun #{ a469 = a4691; b469 = b4691 } #{ a469 = a4692; b469 = b4692 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4691 a4692 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b4691 b4692) expected_a470 a470 in
  if not test then failwithf "test 3721 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t472 = { #{ int32#; #{ int; int32# } } }   *)
  (************************************************)
  let r = { a472 = #{ a471 = #0l; b471 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a472 *)
  let actual = r.a472 in
  let expected = #{ a471 = #0l; b471 = #{ a31 = 1; b31 = #2l } } in
  mark_test_run 3722;
  let test = (fun #{ a471 = a4711; b471 = b4711 } #{ a471 = a4712; b471 = b4712 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4711 a4712 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4711 b4712) actual expected in
  if not test then failwithf "test 3722 failed";
  (* Paths of depth 2 *)
  (* .a472.#a471 *)
  let actual = r.a472.#a471 in
  let expected = #0l in
  mark_test_run 3723;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3723 failed";
  (* .a472.#b471 *)
  let actual = r.a472.#b471 in
  let expected = #{ a31 = 1; b31 = #2l } in
  mark_test_run 3724;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 3724 failed";
  (* Paths of depth 3 *)
  (* .a472.#b471.#a31 *)
  let actual = r.a472.#b471.#a31 in
  let expected = 1 in
  mark_test_run 3725;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3725 failed";
  (* .a472.#b471.#b31 *)
  let actual = r.a472.#b471.#b31 in
  let expected = #2l in
  mark_test_run 3726;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3726 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a472 = a4721 } { a472 = a4722 } -> (fun #{ a471 = a4711; b471 = b4711 } #{ a471 = a4712; b471 = b4712 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4711 a4712 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4711 b4712) a4721 a4722) in
  let next_r = { a472 = #{ a471 = #100l; b471 = #{ a31 = 101; b31 = #102l } } } in
  let r_expected = { a472 = #{ a471 = #0l; b471 = #{ a31 = 1; b31 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a472 *)
  r.a472 <- next_r.a472;
  let r_expected = { r_expected with a472 = next_r.a472 } in
  mark_test_run 3727;
  let test = eq r r_expected in
  if not test then failwithf "test 3727 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a472 = #{ a471; b471 = #{ a31; b31 } } } = r in
  let expected_a471 = #100l in
  mark_test_run 3728;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a471 a471 in
  if not test then failwithf "test 3728 failed";
  let expected_a31 = 101 in
  mark_test_run 3729;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 3729 failed";
  let expected_b31 = #102l in
  mark_test_run 3730;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 3730 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a472 } = r in
  let expected_a472 = #{ a471 = #100l; b471 = #{ a31 = 101; b31 = #102l } } in
  mark_test_run 3731;
  let test = (fun #{ a471 = a4711; b471 = b4711 } #{ a471 = a4712; b471 = b4712 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4711 a4712 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) b4711 b4712) expected_a472 a472 in
  if not test then failwithf "test 3731 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t474 = { #{ int32#; #{ int32#; int } } }   *)
  (************************************************)
  let r = { a474 = #{ a473 = #0l; b473 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a474 *)
  let actual = r.a474 in
  let expected = #{ a473 = #0l; b473 = #{ a49 = #1l; b49 = 2 } } in
  mark_test_run 3732;
  let test = (fun #{ a473 = a4731; b473 = b4731 } #{ a473 = a4732; b473 = b4732 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4731 a4732 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4731 b4732) actual expected in
  if not test then failwithf "test 3732 failed";
  (* Paths of depth 2 *)
  (* .a474.#a473 *)
  let actual = r.a474.#a473 in
  let expected = #0l in
  mark_test_run 3733;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3733 failed";
  (* .a474.#b473 *)
  let actual = r.a474.#b473 in
  let expected = #{ a49 = #1l; b49 = 2 } in
  mark_test_run 3734;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 3734 failed";
  (* Paths of depth 3 *)
  (* .a474.#b473.#a49 *)
  let actual = r.a474.#b473.#a49 in
  let expected = #1l in
  mark_test_run 3735;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3735 failed";
  (* .a474.#b473.#b49 *)
  let actual = r.a474.#b473.#b49 in
  let expected = 2 in
  mark_test_run 3736;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3736 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a474 = a4741 } { a474 = a4742 } -> (fun #{ a473 = a4731; b473 = b4731 } #{ a473 = a4732; b473 = b4732 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4731 a4732 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4731 b4732) a4741 a4742) in
  let next_r = { a474 = #{ a473 = #100l; b473 = #{ a49 = #101l; b49 = 102 } } } in
  let r_expected = { a474 = #{ a473 = #0l; b473 = #{ a49 = #1l; b49 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a474 *)
  r.a474 <- next_r.a474;
  let r_expected = { r_expected with a474 = next_r.a474 } in
  mark_test_run 3737;
  let test = eq r r_expected in
  if not test then failwithf "test 3737 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a474 = #{ a473; b473 = #{ a49; b49 } } } = r in
  let expected_a473 = #100l in
  mark_test_run 3738;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a473 a473 in
  if not test then failwithf "test 3738 failed";
  let expected_a49 = #101l in
  mark_test_run 3739;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 3739 failed";
  let expected_b49 = 102 in
  mark_test_run 3740;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 3740 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a474 } = r in
  let expected_a474 = #{ a473 = #100l; b473 = #{ a49 = #101l; b49 = 102 } } in
  mark_test_run 3741;
  let test = (fun #{ a473 = a4731; b473 = b4731 } #{ a473 = a4732; b473 = b4732 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4731 a4732 && (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) b4731 b4732) expected_a474 a474 in
  if not test then failwithf "test 3741 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t476 = { #{ int32#; #{ int32#; int32# } } }   *)
  (***************************************************)
  let r = { a476 = #{ a475 = #0l; b475 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a476 *)
  let actual = r.a476 in
  let expected = #{ a475 = #0l; b475 = #{ a51 = #1l; b51 = #2l } } in
  mark_test_run 3742;
  let test = (fun #{ a475 = a4751; b475 = b4751 } #{ a475 = a4752; b475 = b4752 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4751 a4752 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4751 b4752) actual expected in
  if not test then failwithf "test 3742 failed";
  (* Paths of depth 2 *)
  (* .a476.#a475 *)
  let actual = r.a476.#a475 in
  let expected = #0l in
  mark_test_run 3743;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3743 failed";
  (* .a476.#b475 *)
  let actual = r.a476.#b475 in
  let expected = #{ a51 = #1l; b51 = #2l } in
  mark_test_run 3744;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 3744 failed";
  (* Paths of depth 3 *)
  (* .a476.#b475.#a51 *)
  let actual = r.a476.#b475.#a51 in
  let expected = #1l in
  mark_test_run 3745;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3745 failed";
  (* .a476.#b475.#b51 *)
  let actual = r.a476.#b475.#b51 in
  let expected = #2l in
  mark_test_run 3746;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 3746 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a476 = a4761 } { a476 = a4762 } -> (fun #{ a475 = a4751; b475 = b4751 } #{ a475 = a4752; b475 = b4752 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4751 a4752 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4751 b4752) a4761 a4762) in
  let next_r = { a476 = #{ a475 = #100l; b475 = #{ a51 = #101l; b51 = #102l } } } in
  let r_expected = { a476 = #{ a475 = #0l; b475 = #{ a51 = #1l; b51 = #2l } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a476 *)
  r.a476 <- next_r.a476;
  let r_expected = { r_expected with a476 = next_r.a476 } in
  mark_test_run 3747;
  let test = eq r r_expected in
  if not test then failwithf "test 3747 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a476 = #{ a475; b475 = #{ a51; b51 } } } = r in
  let expected_a475 = #100l in
  mark_test_run 3748;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a475 a475 in
  if not test then failwithf "test 3748 failed";
  let expected_a51 = #101l in
  mark_test_run 3749;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 3749 failed";
  let expected_b51 = #102l in
  mark_test_run 3750;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 3750 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a476 } = r in
  let expected_a476 = #{ a475 = #100l; b475 = #{ a51 = #101l; b51 = #102l } } in
  mark_test_run 3751;
  let test = (fun #{ a475 = a4751; b475 = b4751 } #{ a475 = a4752; b475 = b4752 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a4751 a4752 && (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) b4751 b4752) expected_a476 a476 in
  if not test then failwithf "test 3751 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t477 = { #{ unit_u }; string }   *)
  (**************************************)
  let r = { a477 = #{ a194 = (unbox_unit ()) }; b477 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a477 *)
  let actual = r.a477 in
  let expected = #{ a194 = (unbox_unit ()) } in
  mark_test_run 3752;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) actual expected in
  if not test then failwithf "test 3752 failed";
  (* Paths of depth 2 *)
  (* .a477.#a194 *)
  let actual = r.a477.#a194 in
  let expected = (unbox_unit ()) in
  mark_test_run 3753;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3753 failed";
  (* Paths of depth 1 *)
  (* .b477 *)
  let actual = r.b477 in
  let expected = "0" in
  mark_test_run 3754;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3754 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a477 = a4771; b477 = b4771 } { a477 = a4772; b477 = b4772 } -> (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) a4771 a4772 && (fun a b -> String.equal (globalize a) (globalize b)) b4771 b4772) in
  let next_r = { a477 = #{ a194 = (unbox_unit ()) }; b477 = "100" } in
  let r_expected = { a477 = #{ a194 = (unbox_unit ()) }; b477 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a477 *)
  r.a477 <- next_r.a477;
  let r_expected = { r_expected with a477 = next_r.a477 } in
  mark_test_run 3755;
  let test = eq r r_expected in
  if not test then failwithf "test 3755 failed";
  Gc.compact ();
  (* .b477 *)
  r.b477 <- next_r.b477;
  let r_expected = { r_expected with b477 = next_r.b477 } in
  mark_test_run 3756;
  let test = eq r r_expected in
  if not test then failwithf "test 3756 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a477 = #{ a194 }; b477 } = r in
  let expected_a194 = (unbox_unit ()) in
  mark_test_run 3757;
  let test = (fun _ _ -> true) expected_a194 a194 in
  if not test then failwithf "test 3757 failed";
  let expected_b477 = "100" in
  mark_test_run 3758;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b477 b477 in
  if not test then failwithf "test 3758 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a477; b477 } = r in
  let expected_a477 = #{ a194 = (unbox_unit ()) } in
  mark_test_run 3759;
  let test = (fun #{ a194 = a1941 } #{ a194 = a1942 } -> (fun _ _ -> true) a1941 a1942) expected_a477 a477 in
  if not test then failwithf "test 3759 failed";
  let expected_b477 = "100" in
  mark_test_run 3760;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b477 b477 in
  if not test then failwithf "test 3760 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t478 = { #{ unit_u; unit_u }; string }   *)
  (**********************************************)
  let r = { a478 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b478 = "0" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a478 *)
  let actual = r.a478 in
  let expected = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 3761;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) actual expected in
  if not test then failwithf "test 3761 failed";
  (* Paths of depth 2 *)
  (* .a478.#a290 *)
  let actual = r.a478.#a290 in
  let expected = (unbox_unit ()) in
  mark_test_run 3762;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3762 failed";
  (* .a478.#b290 *)
  let actual = r.a478.#b290 in
  let expected = (unbox_unit ()) in
  mark_test_run 3763;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3763 failed";
  (* Paths of depth 1 *)
  (* .b478 *)
  let actual = r.b478 in
  let expected = "0" in
  mark_test_run 3764;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3764 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a478 = a4781; b478 = b4781 } { a478 = a4782; b478 = b4782 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a4781 a4782 && (fun a b -> String.equal (globalize a) (globalize b)) b4781 b4782) in
  let next_r = { a478 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b478 = "100" } in
  let r_expected = { a478 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b478 = "0" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a478 *)
  r.a478 <- next_r.a478;
  let r_expected = { r_expected with a478 = next_r.a478 } in
  mark_test_run 3765;
  let test = eq r r_expected in
  if not test then failwithf "test 3765 failed";
  Gc.compact ();
  (* .b478 *)
  r.b478 <- next_r.b478;
  let r_expected = { r_expected with b478 = next_r.b478 } in
  mark_test_run 3766;
  let test = eq r r_expected in
  if not test then failwithf "test 3766 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a478 = #{ a290; b290 }; b478 } = r in
  let expected_a290 = (unbox_unit ()) in
  mark_test_run 3767;
  let test = (fun _ _ -> true) expected_a290 a290 in
  if not test then failwithf "test 3767 failed";
  let expected_b290 = (unbox_unit ()) in
  mark_test_run 3768;
  let test = (fun _ _ -> true) expected_b290 b290 in
  if not test then failwithf "test 3768 failed";
  let expected_b478 = "100" in
  mark_test_run 3769;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b478 b478 in
  if not test then failwithf "test 3769 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a478; b478 } = r in
  let expected_a478 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 3770;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) expected_a478 a478 in
  if not test then failwithf "test 3770 failed";
  let expected_b478 = "100" in
  mark_test_run 3771;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b478 b478 in
  if not test then failwithf "test 3771 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t479 = { #{ unit_u; string } }   *)
  (**************************************)
  let r = { a479 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a479 *)
  let actual = r.a479 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 3772;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 3772 failed";
  (* Paths of depth 2 *)
  (* .a479.#a184 *)
  let actual = r.a479.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 3773;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3773 failed";
  (* .a479.#b184 *)
  let actual = r.a479.#b184 in
  let expected = "0" in
  mark_test_run 3774;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3774 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a479 = a4791 } { a479 = a4792 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a4791 a4792) in
  let next_r = { a479 = #{ a184 = (unbox_unit ()); b184 = "100" } } in
  let r_expected = { a479 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a479 *)
  r.a479 <- next_r.a479;
  let r_expected = { r_expected with a479 = next_r.a479 } in
  mark_test_run 3775;
  let test = eq r r_expected in
  if not test then failwithf "test 3775 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a479 = #{ a184; b184 } } = r in
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 3776;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 3776 failed";
  let expected_b184 = "100" in
  mark_test_run 3777;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 3777 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a479 } = r in
  let expected_a479 = #{ a184 = (unbox_unit ()); b184 = "100" } in
  mark_test_run 3778;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) expected_a479 a479 in
  if not test then failwithf "test 3778 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t480 = { #{ unit_u; string }; unit_u }   *)
  (**********************************************)
  let r = { a480 = #{ a184 = (unbox_unit ()); b184 = "0" }; b480 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a480 *)
  let actual = r.a480 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 3779;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 3779 failed";
  (* Paths of depth 2 *)
  (* .a480.#a184 *)
  let actual = r.a480.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 3780;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3780 failed";
  (* .a480.#b184 *)
  let actual = r.a480.#b184 in
  let expected = "0" in
  mark_test_run 3781;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3781 failed";
  (* Paths of depth 1 *)
  (* .b480 *)
  let actual = r.b480 in
  let expected = (unbox_unit ()) in
  mark_test_run 3782;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3782 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a480 = a4801; b480 = b4801 } { a480 = a4802; b480 = b4802 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a4801 a4802 && (fun _ _ -> true) b4801 b4802) in
  let next_r = { a480 = #{ a184 = (unbox_unit ()); b184 = "100" }; b480 = (unbox_unit ()) } in
  let r_expected = { a480 = #{ a184 = (unbox_unit ()); b184 = "0" }; b480 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a480 *)
  r.a480 <- next_r.a480;
  let r_expected = { r_expected with a480 = next_r.a480 } in
  mark_test_run 3783;
  let test = eq r r_expected in
  if not test then failwithf "test 3783 failed";
  Gc.compact ();
  (* .b480 *)
  r.b480 <- next_r.b480;
  let r_expected = { r_expected with b480 = next_r.b480 } in
  mark_test_run 3784;
  let test = eq r r_expected in
  if not test then failwithf "test 3784 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a480 = #{ a184; b184 }; b480 } = r in
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 3785;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 3785 failed";
  let expected_b184 = "100" in
  mark_test_run 3786;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 3786 failed";
  let expected_b480 = (unbox_unit ()) in
  mark_test_run 3787;
  let test = (fun _ _ -> true) expected_b480 b480 in
  if not test then failwithf "test 3787 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a480; b480 } = r in
  let expected_a480 = #{ a184 = (unbox_unit ()); b184 = "100" } in
  mark_test_run 3788;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) expected_a480 a480 in
  if not test then failwithf "test 3788 failed";
  let expected_b480 = (unbox_unit ()) in
  mark_test_run 3789;
  let test = (fun _ _ -> true) expected_b480 b480 in
  if not test then failwithf "test 3789 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t481 = { #{ unit_u; string }; string }   *)
  (**********************************************)
  let r = { a481 = #{ a184 = (unbox_unit ()); b184 = "0" }; b481 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a481 *)
  let actual = r.a481 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 3790;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 3790 failed";
  (* Paths of depth 2 *)
  (* .a481.#a184 *)
  let actual = r.a481.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 3791;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3791 failed";
  (* .a481.#b184 *)
  let actual = r.a481.#b184 in
  let expected = "0" in
  mark_test_run 3792;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3792 failed";
  (* Paths of depth 1 *)
  (* .b481 *)
  let actual = r.b481 in
  let expected = "1" in
  mark_test_run 3793;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3793 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a481 = a4811; b481 = b4811 } { a481 = a4812; b481 = b4812 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a4811 a4812 && (fun a b -> String.equal (globalize a) (globalize b)) b4811 b4812) in
  let next_r = { a481 = #{ a184 = (unbox_unit ()); b184 = "100" }; b481 = "101" } in
  let r_expected = { a481 = #{ a184 = (unbox_unit ()); b184 = "0" }; b481 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a481 *)
  r.a481 <- next_r.a481;
  let r_expected = { r_expected with a481 = next_r.a481 } in
  mark_test_run 3794;
  let test = eq r r_expected in
  if not test then failwithf "test 3794 failed";
  Gc.compact ();
  (* .b481 *)
  r.b481 <- next_r.b481;
  let r_expected = { r_expected with b481 = next_r.b481 } in
  mark_test_run 3795;
  let test = eq r r_expected in
  if not test then failwithf "test 3795 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a481 = #{ a184; b184 }; b481 } = r in
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 3796;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 3796 failed";
  let expected_b184 = "100" in
  mark_test_run 3797;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 3797 failed";
  let expected_b481 = "101" in
  mark_test_run 3798;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b481 b481 in
  if not test then failwithf "test 3798 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a481; b481 } = r in
  let expected_a481 = #{ a184 = (unbox_unit ()); b184 = "100" } in
  mark_test_run 3799;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) expected_a481 a481 in
  if not test then failwithf "test 3799 failed";
  let expected_b481 = "101" in
  mark_test_run 3800;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b481 b481 in
  if not test then failwithf "test 3800 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t483 = { #{ unit_u; #{ unit_u; string } } }   *)
  (***************************************************)
  let r = { a483 = #{ a482 = (unbox_unit ()); b482 = #{ a184 = (unbox_unit ()); b184 = "0" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a483 *)
  let actual = r.a483 in
  let expected = #{ a482 = (unbox_unit ()); b482 = #{ a184 = (unbox_unit ()); b184 = "0" } } in
  mark_test_run 3801;
  let test = (fun #{ a482 = a4821; b482 = b4821 } #{ a482 = a4822; b482 = b4822 } -> (fun _ _ -> true) a4821 a4822 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b4821 b4822) actual expected in
  if not test then failwithf "test 3801 failed";
  (* Paths of depth 2 *)
  (* .a483.#a482 *)
  let actual = r.a483.#a482 in
  let expected = (unbox_unit ()) in
  mark_test_run 3802;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3802 failed";
  (* .a483.#b482 *)
  let actual = r.a483.#b482 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 3803;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 3803 failed";
  (* Paths of depth 3 *)
  (* .a483.#b482.#a184 *)
  let actual = r.a483.#b482.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 3804;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3804 failed";
  (* .a483.#b482.#b184 *)
  let actual = r.a483.#b482.#b184 in
  let expected = "0" in
  mark_test_run 3805;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3805 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a483 = a4831 } { a483 = a4832 } -> (fun #{ a482 = a4821; b482 = b4821 } #{ a482 = a4822; b482 = b4822 } -> (fun _ _ -> true) a4821 a4822 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b4821 b4822) a4831 a4832) in
  let next_r = { a483 = #{ a482 = (unbox_unit ()); b482 = #{ a184 = (unbox_unit ()); b184 = "100" } } } in
  let r_expected = { a483 = #{ a482 = (unbox_unit ()); b482 = #{ a184 = (unbox_unit ()); b184 = "0" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a483 *)
  r.a483 <- next_r.a483;
  let r_expected = { r_expected with a483 = next_r.a483 } in
  mark_test_run 3806;
  let test = eq r r_expected in
  if not test then failwithf "test 3806 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a483 = #{ a482; b482 = #{ a184; b184 } } } = r in
  let expected_a482 = (unbox_unit ()) in
  mark_test_run 3807;
  let test = (fun _ _ -> true) expected_a482 a482 in
  if not test then failwithf "test 3807 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 3808;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 3808 failed";
  let expected_b184 = "100" in
  mark_test_run 3809;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 3809 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a483 } = r in
  let expected_a483 = #{ a482 = (unbox_unit ()); b482 = #{ a184 = (unbox_unit ()); b184 = "100" } } in
  mark_test_run 3810;
  let test = (fun #{ a482 = a4821; b482 = b4821 } #{ a482 = a4822; b482 = b4822 } -> (fun _ _ -> true) a4821 a4822 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b4821 b4822) expected_a483 a483 in
  if not test then failwithf "test 3810 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t485 = { #{ unit_u; #{ string; unit_u } } }   *)
  (***************************************************)
  let r = { a485 = #{ a484 = (unbox_unit ()); b484 = #{ a190 = "0"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a485 *)
  let actual = r.a485 in
  let expected = #{ a484 = (unbox_unit ()); b484 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  mark_test_run 3811;
  let test = (fun #{ a484 = a4841; b484 = b4841 } #{ a484 = a4842; b484 = b4842 } -> (fun _ _ -> true) a4841 a4842 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b4841 b4842) actual expected in
  if not test then failwithf "test 3811 failed";
  (* Paths of depth 2 *)
  (* .a485.#a484 *)
  let actual = r.a485.#a484 in
  let expected = (unbox_unit ()) in
  mark_test_run 3812;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3812 failed";
  (* .a485.#b484 *)
  let actual = r.a485.#b484 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 3813;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 3813 failed";
  (* Paths of depth 3 *)
  (* .a485.#b484.#a190 *)
  let actual = r.a485.#b484.#a190 in
  let expected = "0" in
  mark_test_run 3814;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3814 failed";
  (* .a485.#b484.#b190 *)
  let actual = r.a485.#b484.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 3815;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3815 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a485 = a4851 } { a485 = a4852 } -> (fun #{ a484 = a4841; b484 = b4841 } #{ a484 = a4842; b484 = b4842 } -> (fun _ _ -> true) a4841 a4842 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b4841 b4842) a4851 a4852) in
  let next_r = { a485 = #{ a484 = (unbox_unit ()); b484 = #{ a190 = "100"; b190 = (unbox_unit ()) } } } in
  let r_expected = { a485 = #{ a484 = (unbox_unit ()); b484 = #{ a190 = "0"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a485 *)
  r.a485 <- next_r.a485;
  let r_expected = { r_expected with a485 = next_r.a485 } in
  mark_test_run 3816;
  let test = eq r r_expected in
  if not test then failwithf "test 3816 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a485 = #{ a484; b484 = #{ a190; b190 } } } = r in
  let expected_a484 = (unbox_unit ()) in
  mark_test_run 3817;
  let test = (fun _ _ -> true) expected_a484 a484 in
  if not test then failwithf "test 3817 failed";
  let expected_a190 = "100" in
  mark_test_run 3818;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 3818 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 3819;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 3819 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a485 } = r in
  let expected_a485 = #{ a484 = (unbox_unit ()); b484 = #{ a190 = "100"; b190 = (unbox_unit ()) } } in
  mark_test_run 3820;
  let test = (fun #{ a484 = a4841; b484 = b4841 } #{ a484 = a4842; b484 = b4842 } -> (fun _ _ -> true) a4841 a4842 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b4841 b4842) expected_a485 a485 in
  if not test then failwithf "test 3820 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t487 = { #{ unit_u; #{ string; string } } }   *)
  (***************************************************)
  let r = { a487 = #{ a486 = (unbox_unit ()); b486 = #{ a192 = "0"; b192 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a487 *)
  let actual = r.a487 in
  let expected = #{ a486 = (unbox_unit ()); b486 = #{ a192 = "0"; b192 = "1" } } in
  mark_test_run 3821;
  let test = (fun #{ a486 = a4861; b486 = b4861 } #{ a486 = a4862; b486 = b4862 } -> (fun _ _ -> true) a4861 a4862 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b4861 b4862) actual expected in
  if not test then failwithf "test 3821 failed";
  (* Paths of depth 2 *)
  (* .a487.#a486 *)
  let actual = r.a487.#a486 in
  let expected = (unbox_unit ()) in
  mark_test_run 3822;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 3822 failed";
  (* .a487.#b486 *)
  let actual = r.a487.#b486 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 3823;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 3823 failed";
  (* Paths of depth 3 *)
  (* .a487.#b486.#a192 *)
  let actual = r.a487.#b486.#a192 in
  let expected = "0" in
  mark_test_run 3824;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3824 failed";
  (* .a487.#b486.#b192 *)
  let actual = r.a487.#b486.#b192 in
  let expected = "1" in
  mark_test_run 3825;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3825 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a487 = a4871 } { a487 = a4872 } -> (fun #{ a486 = a4861; b486 = b4861 } #{ a486 = a4862; b486 = b4862 } -> (fun _ _ -> true) a4861 a4862 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b4861 b4862) a4871 a4872) in
  let next_r = { a487 = #{ a486 = (unbox_unit ()); b486 = #{ a192 = "100"; b192 = "101" } } } in
  let r_expected = { a487 = #{ a486 = (unbox_unit ()); b486 = #{ a192 = "0"; b192 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a487 *)
  r.a487 <- next_r.a487;
  let r_expected = { r_expected with a487 = next_r.a487 } in
  mark_test_run 3826;
  let test = eq r r_expected in
  if not test then failwithf "test 3826 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a487 = #{ a486; b486 = #{ a192; b192 } } } = r in
  let expected_a486 = (unbox_unit ()) in
  mark_test_run 3827;
  let test = (fun _ _ -> true) expected_a486 a486 in
  if not test then failwithf "test 3827 failed";
  let expected_a192 = "100" in
  mark_test_run 3828;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 3828 failed";
  let expected_b192 = "101" in
  mark_test_run 3829;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 3829 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a487 } = r in
  let expected_a487 = #{ a486 = (unbox_unit ()); b486 = #{ a192 = "100"; b192 = "101" } } in
  mark_test_run 3830;
  let test = (fun #{ a486 = a4861; b486 = b4861 } #{ a486 = a4862; b486 = b4862 } -> (fun _ _ -> true) a4861 a4862 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b4861 b4862) expected_a487 a487 in
  if not test then failwithf "test 3830 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t488 = { #{ float } }   *)
  (*****************************)
  let r = { a488 = #{ a42 = 0. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a488 *)
  let actual = r.a488 in
  let expected = #{ a42 = 0. } in
  mark_test_run 3831;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 3831 failed";
  (* Paths of depth 2 *)
  (* .a488.#a42 *)
  let actual = r.a488.#a42 in
  let expected = 0. in
  mark_test_run 3832;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3832 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a488 = a4881 } { a488 = a4882 } -> (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) a4881 a4882) in
  let next_r = { a488 = #{ a42 = 100. } } in
  let r_expected = { a488 = #{ a42 = 0. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a488 *)
  r.a488 <- next_r.a488;
  let r_expected = { r_expected with a488 = next_r.a488 } in
  mark_test_run 3833;
  let test = eq r r_expected in
  if not test then failwithf "test 3833 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a488 = #{ a42 } } = r in
  let expected_a42 = 100. in
  mark_test_run 3834;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 3834 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a488 } = r in
  let expected_a488 = #{ a42 = 100. } in
  mark_test_run 3835;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_a488 a488 in
  if not test then failwithf "test 3835 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t489 = { #{ float }; int }   *)
  (**********************************)
  let r = { a489 = #{ a42 = 0. }; b489 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a489 *)
  let actual = r.a489 in
  let expected = #{ a42 = 0. } in
  mark_test_run 3836;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 3836 failed";
  (* Paths of depth 2 *)
  (* .a489.#a42 *)
  let actual = r.a489.#a42 in
  let expected = 0. in
  mark_test_run 3837;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3837 failed";
  (* Paths of depth 1 *)
  (* .b489 *)
  let actual = r.b489 in
  let expected = 1 in
  mark_test_run 3838;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3838 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a489 = a4891; b489 = b4891 } { a489 = a4892; b489 = b4892 } -> (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) a4891 a4892 && (fun a b -> Int.equal a b) b4891 b4892) in
  let next_r = { a489 = #{ a42 = 100. }; b489 = 101 } in
  let r_expected = { a489 = #{ a42 = 0. }; b489 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a489 *)
  r.a489 <- next_r.a489;
  let r_expected = { r_expected with a489 = next_r.a489 } in
  mark_test_run 3839;
  let test = eq r r_expected in
  if not test then failwithf "test 3839 failed";
  Gc.compact ();
  (* .b489 *)
  r.b489 <- next_r.b489;
  let r_expected = { r_expected with b489 = next_r.b489 } in
  mark_test_run 3840;
  let test = eq r r_expected in
  if not test then failwithf "test 3840 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a489 = #{ a42 }; b489 } = r in
  let expected_a42 = 100. in
  mark_test_run 3841;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 3841 failed";
  let expected_b489 = 101 in
  mark_test_run 3842;
  let test = (fun a b -> Int.equal a b) expected_b489 b489 in
  if not test then failwithf "test 3842 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a489; b489 } = r in
  let expected_a489 = #{ a42 = 100. } in
  mark_test_run 3843;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_a489 a489 in
  if not test then failwithf "test 3843 failed";
  let expected_b489 = 101 in
  mark_test_run 3844;
  let test = (fun a b -> Int.equal a b) expected_b489 b489 in
  if not test then failwithf "test 3844 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t490 = { #{ float }; float }   *)
  (************************************)
  let r = { a490 = #{ a42 = 0. }; b490 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a490 *)
  let actual = r.a490 in
  let expected = #{ a42 = 0. } in
  mark_test_run 3845;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 3845 failed";
  (* Paths of depth 2 *)
  (* .a490.#a42 *)
  let actual = r.a490.#a42 in
  let expected = 0. in
  mark_test_run 3846;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3846 failed";
  (* Paths of depth 1 *)
  (* .b490 *)
  let actual = r.b490 in
  let expected = 1. in
  mark_test_run 3847;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3847 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a490 = a4901; b490 = b4901 } { a490 = a4902; b490 = b4902 } -> (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) a4901 a4902 && (fun a b -> Float.equal (globalize a) (globalize b)) b4901 b4902) in
  let next_r = { a490 = #{ a42 = 100. }; b490 = 101. } in
  let r_expected = { a490 = #{ a42 = 0. }; b490 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a490 *)
  r.a490 <- next_r.a490;
  let r_expected = { r_expected with a490 = next_r.a490 } in
  mark_test_run 3848;
  let test = eq r r_expected in
  if not test then failwithf "test 3848 failed";
  Gc.compact ();
  (* .b490 *)
  r.b490 <- next_r.b490;
  let r_expected = { r_expected with b490 = next_r.b490 } in
  mark_test_run 3849;
  let test = eq r r_expected in
  if not test then failwithf "test 3849 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a490 = #{ a42 }; b490 } = r in
  let expected_a42 = 100. in
  mark_test_run 3850;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 3850 failed";
  let expected_b490 = 101. in
  mark_test_run 3851;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b490 b490 in
  if not test then failwithf "test 3851 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a490; b490 } = r in
  let expected_a490 = #{ a42 = 100. } in
  mark_test_run 3852;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_a490 a490 in
  if not test then failwithf "test 3852 failed";
  let expected_b490 = 101. in
  mark_test_run 3853;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b490 b490 in
  if not test then failwithf "test 3853 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t491 = { #{ float }; float# }   *)
  (*************************************)
  let r = { a491 = #{ a42 = 0. }; b491 = #1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a491 *)
  let actual = r.a491 in
  let expected = #{ a42 = 0. } in
  mark_test_run 3854;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) actual expected in
  if not test then failwithf "test 3854 failed";
  (* Paths of depth 2 *)
  (* .a491.#a42 *)
  let actual = r.a491.#a42 in
  let expected = 0. in
  mark_test_run 3855;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3855 failed";
  (* Paths of depth 1 *)
  (* .b491 *)
  let actual = r.b491 in
  let expected = #1. in
  mark_test_run 3856;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3856 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a491 = a4911; b491 = b4911 } { a491 = a4912; b491 = b4912 } -> (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) a4911 a4912 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b4911 b4912) in
  let next_r = { a491 = #{ a42 = 100. }; b491 = #101. } in
  let r_expected = { a491 = #{ a42 = 0. }; b491 = #1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a491 *)
  r.a491 <- next_r.a491;
  let r_expected = { r_expected with a491 = next_r.a491 } in
  mark_test_run 3857;
  let test = eq r r_expected in
  if not test then failwithf "test 3857 failed";
  Gc.compact ();
  (* .b491 *)
  r.b491 <- next_r.b491;
  let r_expected = { r_expected with b491 = next_r.b491 } in
  mark_test_run 3858;
  let test = eq r r_expected in
  if not test then failwithf "test 3858 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a491 = #{ a42 }; b491 } = r in
  let expected_a42 = 100. in
  mark_test_run 3859;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a42 a42 in
  if not test then failwithf "test 3859 failed";
  let expected_b491 = #101. in
  mark_test_run 3860;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b491 b491 in
  if not test then failwithf "test 3860 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a491; b491 } = r in
  let expected_a491 = #{ a42 = 100. } in
  mark_test_run 3861;
  let test = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a421 a422) expected_a491 a491 in
  if not test then failwithf "test 3861 failed";
  let expected_b491 = #101. in
  mark_test_run 3862;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b491 b491 in
  if not test then failwithf "test 3862 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************)
  (*   t492 = { #{ float; int } }   *)
  (**********************************)
  let r = { a492 = #{ a58 = 0.; b58 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a492 *)
  let actual = r.a492 in
  let expected = #{ a58 = 0.; b58 = 1 } in
  mark_test_run 3863;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 3863 failed";
  (* Paths of depth 2 *)
  (* .a492.#a58 *)
  let actual = r.a492.#a58 in
  let expected = 0. in
  mark_test_run 3864;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3864 failed";
  (* .a492.#b58 *)
  let actual = r.a492.#b58 in
  let expected = 1 in
  mark_test_run 3865;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3865 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a492 = a4921 } { a492 = a4922 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a4921 a4922) in
  let next_r = { a492 = #{ a58 = 100.; b58 = 101 } } in
  let r_expected = { a492 = #{ a58 = 0.; b58 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a492 *)
  r.a492 <- next_r.a492;
  let r_expected = { r_expected with a492 = next_r.a492 } in
  mark_test_run 3866;
  let test = eq r r_expected in
  if not test then failwithf "test 3866 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a492 = #{ a58; b58 } } = r in
  let expected_a58 = 100. in
  mark_test_run 3867;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 3867 failed";
  let expected_b58 = 101 in
  mark_test_run 3868;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 3868 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a492 } = r in
  let expected_a492 = #{ a58 = 100.; b58 = 101 } in
  mark_test_run 3869;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) expected_a492 a492 in
  if not test then failwithf "test 3869 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t493 = { #{ float; int }; int }   *)
  (***************************************)
  let r = { a493 = #{ a58 = 0.; b58 = 1 }; b493 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a493 *)
  let actual = r.a493 in
  let expected = #{ a58 = 0.; b58 = 1 } in
  mark_test_run 3870;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 3870 failed";
  (* Paths of depth 2 *)
  (* .a493.#a58 *)
  let actual = r.a493.#a58 in
  let expected = 0. in
  mark_test_run 3871;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3871 failed";
  (* .a493.#b58 *)
  let actual = r.a493.#b58 in
  let expected = 1 in
  mark_test_run 3872;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3872 failed";
  (* Paths of depth 1 *)
  (* .b493 *)
  let actual = r.b493 in
  let expected = 2 in
  mark_test_run 3873;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3873 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a493 = a4931; b493 = b4931 } { a493 = a4932; b493 = b4932 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a4931 a4932 && (fun a b -> Int.equal a b) b4931 b4932) in
  let next_r = { a493 = #{ a58 = 100.; b58 = 101 }; b493 = 102 } in
  let r_expected = { a493 = #{ a58 = 0.; b58 = 1 }; b493 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a493 *)
  r.a493 <- next_r.a493;
  let r_expected = { r_expected with a493 = next_r.a493 } in
  mark_test_run 3874;
  let test = eq r r_expected in
  if not test then failwithf "test 3874 failed";
  Gc.compact ();
  (* .b493 *)
  r.b493 <- next_r.b493;
  let r_expected = { r_expected with b493 = next_r.b493 } in
  mark_test_run 3875;
  let test = eq r r_expected in
  if not test then failwithf "test 3875 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a493 = #{ a58; b58 }; b493 } = r in
  let expected_a58 = 100. in
  mark_test_run 3876;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 3876 failed";
  let expected_b58 = 101 in
  mark_test_run 3877;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 3877 failed";
  let expected_b493 = 102 in
  mark_test_run 3878;
  let test = (fun a b -> Int.equal a b) expected_b493 b493 in
  if not test then failwithf "test 3878 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a493; b493 } = r in
  let expected_a493 = #{ a58 = 100.; b58 = 101 } in
  mark_test_run 3879;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) expected_a493 a493 in
  if not test then failwithf "test 3879 failed";
  let expected_b493 = 102 in
  mark_test_run 3880;
  let test = (fun a b -> Int.equal a b) expected_b493 b493 in
  if not test then failwithf "test 3880 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t494 = { #{ float; int }; float }   *)
  (*****************************************)
  let r = { a494 = #{ a58 = 0.; b58 = 1 }; b494 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a494 *)
  let actual = r.a494 in
  let expected = #{ a58 = 0.; b58 = 1 } in
  mark_test_run 3881;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 3881 failed";
  (* Paths of depth 2 *)
  (* .a494.#a58 *)
  let actual = r.a494.#a58 in
  let expected = 0. in
  mark_test_run 3882;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3882 failed";
  (* .a494.#b58 *)
  let actual = r.a494.#b58 in
  let expected = 1 in
  mark_test_run 3883;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3883 failed";
  (* Paths of depth 1 *)
  (* .b494 *)
  let actual = r.b494 in
  let expected = 2. in
  mark_test_run 3884;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3884 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a494 = a4941; b494 = b4941 } { a494 = a4942; b494 = b4942 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a4941 a4942 && (fun a b -> Float.equal (globalize a) (globalize b)) b4941 b4942) in
  let next_r = { a494 = #{ a58 = 100.; b58 = 101 }; b494 = 102. } in
  let r_expected = { a494 = #{ a58 = 0.; b58 = 1 }; b494 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a494 *)
  r.a494 <- next_r.a494;
  let r_expected = { r_expected with a494 = next_r.a494 } in
  mark_test_run 3885;
  let test = eq r r_expected in
  if not test then failwithf "test 3885 failed";
  Gc.compact ();
  (* .b494 *)
  r.b494 <- next_r.b494;
  let r_expected = { r_expected with b494 = next_r.b494 } in
  mark_test_run 3886;
  let test = eq r r_expected in
  if not test then failwithf "test 3886 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a494 = #{ a58; b58 }; b494 } = r in
  let expected_a58 = 100. in
  mark_test_run 3887;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 3887 failed";
  let expected_b58 = 101 in
  mark_test_run 3888;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 3888 failed";
  let expected_b494 = 102. in
  mark_test_run 3889;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b494 b494 in
  if not test then failwithf "test 3889 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a494; b494 } = r in
  let expected_a494 = #{ a58 = 100.; b58 = 101 } in
  mark_test_run 3890;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) expected_a494 a494 in
  if not test then failwithf "test 3890 failed";
  let expected_b494 = 102. in
  mark_test_run 3891;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b494 b494 in
  if not test then failwithf "test 3891 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t495 = { #{ float; float } }   *)
  (************************************)
  let r = { a495 = #{ a60 = 0.; b60 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a495 *)
  let actual = r.a495 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 3892;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3892 failed";
  (* Paths of depth 2 *)
  (* .a495.#a60 *)
  let actual = r.a495.#a60 in
  let expected = 0. in
  mark_test_run 3893;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3893 failed";
  (* .a495.#b60 *)
  let actual = r.a495.#b60 in
  let expected = 1. in
  mark_test_run 3894;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3894 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a495 = a4951 } { a495 = a4952 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a4951 a4952) in
  let next_r = { a495 = #{ a60 = 100.; b60 = 101. } } in
  let r_expected = { a495 = #{ a60 = 0.; b60 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a495 *)
  r.a495 <- next_r.a495;
  let r_expected = { r_expected with a495 = next_r.a495 } in
  mark_test_run 3895;
  let test = eq r r_expected in
  if not test then failwithf "test 3895 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a495 = #{ a60; b60 } } = r in
  let expected_a60 = 100. in
  mark_test_run 3896;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3896 failed";
  let expected_b60 = 101. in
  mark_test_run 3897;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3897 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a495 } = r in
  let expected_a495 = #{ a60 = 100.; b60 = 101. } in
  mark_test_run 3898;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_a495 a495 in
  if not test then failwithf "test 3898 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t496 = { #{ float; float }; int }   *)
  (*****************************************)
  let r = { a496 = #{ a60 = 0.; b60 = 1. }; b496 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a496 *)
  let actual = r.a496 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 3899;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3899 failed";
  (* Paths of depth 2 *)
  (* .a496.#a60 *)
  let actual = r.a496.#a60 in
  let expected = 0. in
  mark_test_run 3900;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3900 failed";
  (* .a496.#b60 *)
  let actual = r.a496.#b60 in
  let expected = 1. in
  mark_test_run 3901;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3901 failed";
  (* Paths of depth 1 *)
  (* .b496 *)
  let actual = r.b496 in
  let expected = 2 in
  mark_test_run 3902;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3902 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a496 = a4961; b496 = b4961 } { a496 = a4962; b496 = b4962 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a4961 a4962 && (fun a b -> Int.equal a b) b4961 b4962) in
  let next_r = { a496 = #{ a60 = 100.; b60 = 101. }; b496 = 102 } in
  let r_expected = { a496 = #{ a60 = 0.; b60 = 1. }; b496 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a496 *)
  r.a496 <- next_r.a496;
  let r_expected = { r_expected with a496 = next_r.a496 } in
  mark_test_run 3903;
  let test = eq r r_expected in
  if not test then failwithf "test 3903 failed";
  Gc.compact ();
  (* .b496 *)
  r.b496 <- next_r.b496;
  let r_expected = { r_expected with b496 = next_r.b496 } in
  mark_test_run 3904;
  let test = eq r r_expected in
  if not test then failwithf "test 3904 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a496 = #{ a60; b60 }; b496 } = r in
  let expected_a60 = 100. in
  mark_test_run 3905;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3905 failed";
  let expected_b60 = 101. in
  mark_test_run 3906;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3906 failed";
  let expected_b496 = 102 in
  mark_test_run 3907;
  let test = (fun a b -> Int.equal a b) expected_b496 b496 in
  if not test then failwithf "test 3907 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a496; b496 } = r in
  let expected_a496 = #{ a60 = 100.; b60 = 101. } in
  mark_test_run 3908;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_a496 a496 in
  if not test then failwithf "test 3908 failed";
  let expected_b496 = 102 in
  mark_test_run 3909;
  let test = (fun a b -> Int.equal a b) expected_b496 b496 in
  if not test then failwithf "test 3909 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t497 = { #{ float; float }; float }   *)
  (*******************************************)
  let r = { a497 = #{ a60 = 0.; b60 = 1. }; b497 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a497 *)
  let actual = r.a497 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 3910;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3910 failed";
  (* Paths of depth 2 *)
  (* .a497.#a60 *)
  let actual = r.a497.#a60 in
  let expected = 0. in
  mark_test_run 3911;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3911 failed";
  (* .a497.#b60 *)
  let actual = r.a497.#b60 in
  let expected = 1. in
  mark_test_run 3912;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3912 failed";
  (* Paths of depth 1 *)
  (* .b497 *)
  let actual = r.b497 in
  let expected = 2. in
  mark_test_run 3913;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3913 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a497 = a4971; b497 = b4971 } { a497 = a4972; b497 = b4972 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a4971 a4972 && (fun a b -> Float.equal (globalize a) (globalize b)) b4971 b4972) in
  let next_r = { a497 = #{ a60 = 100.; b60 = 101. }; b497 = 102. } in
  let r_expected = { a497 = #{ a60 = 0.; b60 = 1. }; b497 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a497 *)
  r.a497 <- next_r.a497;
  let r_expected = { r_expected with a497 = next_r.a497 } in
  mark_test_run 3914;
  let test = eq r r_expected in
  if not test then failwithf "test 3914 failed";
  Gc.compact ();
  (* .b497 *)
  r.b497 <- next_r.b497;
  let r_expected = { r_expected with b497 = next_r.b497 } in
  mark_test_run 3915;
  let test = eq r r_expected in
  if not test then failwithf "test 3915 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a497 = #{ a60; b60 }; b497 } = r in
  let expected_a60 = 100. in
  mark_test_run 3916;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3916 failed";
  let expected_b60 = 101. in
  mark_test_run 3917;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3917 failed";
  let expected_b497 = 102. in
  mark_test_run 3918;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b497 b497 in
  if not test then failwithf "test 3918 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a497; b497 } = r in
  let expected_a497 = #{ a60 = 100.; b60 = 101. } in
  mark_test_run 3919;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_a497 a497 in
  if not test then failwithf "test 3919 failed";
  let expected_b497 = 102. in
  mark_test_run 3920;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b497 b497 in
  if not test then failwithf "test 3920 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t498 = { #{ float; float }; float# }   *)
  (********************************************)
  let r = { a498 = #{ a60 = 0.; b60 = 1. }; b498 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a498 *)
  let actual = r.a498 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 3921;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3921 failed";
  (* Paths of depth 2 *)
  (* .a498.#a60 *)
  let actual = r.a498.#a60 in
  let expected = 0. in
  mark_test_run 3922;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3922 failed";
  (* .a498.#b60 *)
  let actual = r.a498.#b60 in
  let expected = 1. in
  mark_test_run 3923;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3923 failed";
  (* Paths of depth 1 *)
  (* .b498 *)
  let actual = r.b498 in
  let expected = #2. in
  mark_test_run 3924;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3924 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a498 = a4981; b498 = b4981 } { a498 = a4982; b498 = b4982 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a4981 a4982 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b4981 b4982) in
  let next_r = { a498 = #{ a60 = 100.; b60 = 101. }; b498 = #102. } in
  let r_expected = { a498 = #{ a60 = 0.; b60 = 1. }; b498 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a498 *)
  r.a498 <- next_r.a498;
  let r_expected = { r_expected with a498 = next_r.a498 } in
  mark_test_run 3925;
  let test = eq r r_expected in
  if not test then failwithf "test 3925 failed";
  Gc.compact ();
  (* .b498 *)
  r.b498 <- next_r.b498;
  let r_expected = { r_expected with b498 = next_r.b498 } in
  mark_test_run 3926;
  let test = eq r r_expected in
  if not test then failwithf "test 3926 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a498 = #{ a60; b60 }; b498 } = r in
  let expected_a60 = 100. in
  mark_test_run 3927;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3927 failed";
  let expected_b60 = 101. in
  mark_test_run 3928;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3928 failed";
  let expected_b498 = #102. in
  mark_test_run 3929;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b498 b498 in
  if not test then failwithf "test 3929 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a498; b498 } = r in
  let expected_a498 = #{ a60 = 100.; b60 = 101. } in
  mark_test_run 3930;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) expected_a498 a498 in
  if not test then failwithf "test 3930 failed";
  let expected_b498 = #102. in
  mark_test_run 3931;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b498 b498 in
  if not test then failwithf "test 3931 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t499 = { #{ float; float# } }   *)
  (*************************************)
  let r = { a499 = #{ a235 = 0.; b235 = #1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a499 *)
  let actual = r.a499 in
  let expected = #{ a235 = 0.; b235 = #1. } in
  mark_test_run 3932;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 3932 failed";
  (* Paths of depth 2 *)
  (* .a499.#a235 *)
  let actual = r.a499.#a235 in
  let expected = 0. in
  mark_test_run 3933;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3933 failed";
  (* .a499.#b235 *)
  let actual = r.a499.#b235 in
  let expected = #1. in
  mark_test_run 3934;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3934 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a499 = a4991 } { a499 = a4992 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a4991 a4992) in
  let next_r = { a499 = #{ a235 = 100.; b235 = #101. } } in
  let r_expected = { a499 = #{ a235 = 0.; b235 = #1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a499 *)
  r.a499 <- next_r.a499;
  let r_expected = { r_expected with a499 = next_r.a499 } in
  mark_test_run 3935;
  let test = eq r r_expected in
  if not test then failwithf "test 3935 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a499 = #{ a235; b235 } } = r in
  let expected_a235 = 100. in
  mark_test_run 3936;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 3936 failed";
  let expected_b235 = #101. in
  mark_test_run 3937;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 3937 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a499 } = r in
  let expected_a499 = #{ a235 = 100.; b235 = #101. } in
  mark_test_run 3938;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) expected_a499 a499 in
  if not test then failwithf "test 3938 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t500 = { #{ float; float# }; float }   *)
  (********************************************)
  let r = { a500 = #{ a235 = 0.; b235 = #1. }; b500 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a500 *)
  let actual = r.a500 in
  let expected = #{ a235 = 0.; b235 = #1. } in
  mark_test_run 3939;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 3939 failed";
  (* Paths of depth 2 *)
  (* .a500.#a235 *)
  let actual = r.a500.#a235 in
  let expected = 0. in
  mark_test_run 3940;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3940 failed";
  (* .a500.#b235 *)
  let actual = r.a500.#b235 in
  let expected = #1. in
  mark_test_run 3941;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3941 failed";
  (* Paths of depth 1 *)
  (* .b500 *)
  let actual = r.b500 in
  let expected = 2. in
  mark_test_run 3942;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3942 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a500 = a5001; b500 = b5001 } { a500 = a5002; b500 = b5002 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a5001 a5002 && (fun a b -> Float.equal (globalize a) (globalize b)) b5001 b5002) in
  let next_r = { a500 = #{ a235 = 100.; b235 = #101. }; b500 = 102. } in
  let r_expected = { a500 = #{ a235 = 0.; b235 = #1. }; b500 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a500 *)
  r.a500 <- next_r.a500;
  let r_expected = { r_expected with a500 = next_r.a500 } in
  mark_test_run 3943;
  let test = eq r r_expected in
  if not test then failwithf "test 3943 failed";
  Gc.compact ();
  (* .b500 *)
  r.b500 <- next_r.b500;
  let r_expected = { r_expected with b500 = next_r.b500 } in
  mark_test_run 3944;
  let test = eq r r_expected in
  if not test then failwithf "test 3944 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a500 = #{ a235; b235 }; b500 } = r in
  let expected_a235 = 100. in
  mark_test_run 3945;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 3945 failed";
  let expected_b235 = #101. in
  mark_test_run 3946;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 3946 failed";
  let expected_b500 = 102. in
  mark_test_run 3947;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b500 b500 in
  if not test then failwithf "test 3947 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a500; b500 } = r in
  let expected_a500 = #{ a235 = 100.; b235 = #101. } in
  mark_test_run 3948;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) expected_a500 a500 in
  if not test then failwithf "test 3948 failed";
  let expected_b500 = 102. in
  mark_test_run 3949;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b500 b500 in
  if not test then failwithf "test 3949 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t501 = { #{ float; float# }; float# }   *)
  (*********************************************)
  let r = { a501 = #{ a235 = 0.; b235 = #1. }; b501 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a501 *)
  let actual = r.a501 in
  let expected = #{ a235 = 0.; b235 = #1. } in
  mark_test_run 3950;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 3950 failed";
  (* Paths of depth 2 *)
  (* .a501.#a235 *)
  let actual = r.a501.#a235 in
  let expected = 0. in
  mark_test_run 3951;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3951 failed";
  (* .a501.#b235 *)
  let actual = r.a501.#b235 in
  let expected = #1. in
  mark_test_run 3952;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3952 failed";
  (* Paths of depth 1 *)
  (* .b501 *)
  let actual = r.b501 in
  let expected = #2. in
  mark_test_run 3953;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 3953 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a501 = a5011; b501 = b5011 } { a501 = a5012; b501 = b5012 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a5011 a5012 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5011 b5012) in
  let next_r = { a501 = #{ a235 = 100.; b235 = #101. }; b501 = #102. } in
  let r_expected = { a501 = #{ a235 = 0.; b235 = #1. }; b501 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a501 *)
  r.a501 <- next_r.a501;
  let r_expected = { r_expected with a501 = next_r.a501 } in
  mark_test_run 3954;
  let test = eq r r_expected in
  if not test then failwithf "test 3954 failed";
  Gc.compact ();
  (* .b501 *)
  r.b501 <- next_r.b501;
  let r_expected = { r_expected with b501 = next_r.b501 } in
  mark_test_run 3955;
  let test = eq r r_expected in
  if not test then failwithf "test 3955 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a501 = #{ a235; b235 }; b501 } = r in
  let expected_a235 = 100. in
  mark_test_run 3956;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 3956 failed";
  let expected_b235 = #101. in
  mark_test_run 3957;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 3957 failed";
  let expected_b501 = #102. in
  mark_test_run 3958;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b501 b501 in
  if not test then failwithf "test 3958 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a501; b501 } = r in
  let expected_a501 = #{ a235 = 100.; b235 = #101. } in
  mark_test_run 3959;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) expected_a501 a501 in
  if not test then failwithf "test 3959 failed";
  let expected_b501 = #102. in
  mark_test_run 3960;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b501 b501 in
  if not test then failwithf "test 3960 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t503 = { #{ float; #{ int; int } } }   *)
  (********************************************)
  let r = { a503 = #{ a502 = 0.; b502 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a503 *)
  let actual = r.a503 in
  let expected = #{ a502 = 0.; b502 = #{ a29 = 1; b29 = 2 } } in
  mark_test_run 3961;
  let test = (fun #{ a502 = a5021; b502 = b5021 } #{ a502 = a5022; b502 = b5022 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5021 a5022 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5021 b5022) actual expected in
  if not test then failwithf "test 3961 failed";
  (* Paths of depth 2 *)
  (* .a503.#a502 *)
  let actual = r.a503.#a502 in
  let expected = 0. in
  mark_test_run 3962;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3962 failed";
  (* .a503.#b502 *)
  let actual = r.a503.#b502 in
  let expected = #{ a29 = 1; b29 = 2 } in
  mark_test_run 3963;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 3963 failed";
  (* Paths of depth 3 *)
  (* .a503.#b502.#a29 *)
  let actual = r.a503.#b502.#a29 in
  let expected = 1 in
  mark_test_run 3964;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3964 failed";
  (* .a503.#b502.#b29 *)
  let actual = r.a503.#b502.#b29 in
  let expected = 2 in
  mark_test_run 3965;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3965 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a503 = a5031 } { a503 = a5032 } -> (fun #{ a502 = a5021; b502 = b5021 } #{ a502 = a5022; b502 = b5022 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5021 a5022 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5021 b5022) a5031 a5032) in
  let next_r = { a503 = #{ a502 = 100.; b502 = #{ a29 = 101; b29 = 102 } } } in
  let r_expected = { a503 = #{ a502 = 0.; b502 = #{ a29 = 1; b29 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a503 *)
  r.a503 <- next_r.a503;
  let r_expected = { r_expected with a503 = next_r.a503 } in
  mark_test_run 3966;
  let test = eq r r_expected in
  if not test then failwithf "test 3966 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a503 = #{ a502; b502 = #{ a29; b29 } } } = r in
  let expected_a502 = 100. in
  mark_test_run 3967;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a502 a502 in
  if not test then failwithf "test 3967 failed";
  let expected_a29 = 101 in
  mark_test_run 3968;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 3968 failed";
  let expected_b29 = 102 in
  mark_test_run 3969;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 3969 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a503 } = r in
  let expected_a503 = #{ a502 = 100.; b502 = #{ a29 = 101; b29 = 102 } } in
  mark_test_run 3970;
  let test = (fun #{ a502 = a5021; b502 = b5021 } #{ a502 = a5022; b502 = b5022 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5021 a5022 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5021 b5022) expected_a503 a503 in
  if not test then failwithf "test 3970 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t505 = { #{ float; #{ int; float } } }   *)
  (**********************************************)
  let r = { a505 = #{ a504 = 0.; b504 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a505 *)
  let actual = r.a505 in
  let expected = #{ a504 = 0.; b504 = #{ a33 = 1; b33 = 2. } } in
  mark_test_run 3971;
  let test = (fun #{ a504 = a5041; b504 = b5041 } #{ a504 = a5042; b504 = b5042 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5041 a5042 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b5041 b5042) actual expected in
  if not test then failwithf "test 3971 failed";
  (* Paths of depth 2 *)
  (* .a505.#a504 *)
  let actual = r.a505.#a504 in
  let expected = 0. in
  mark_test_run 3972;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3972 failed";
  (* .a505.#b504 *)
  let actual = r.a505.#b504 in
  let expected = #{ a33 = 1; b33 = 2. } in
  mark_test_run 3973;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 3973 failed";
  (* Paths of depth 3 *)
  (* .a505.#b504.#a33 *)
  let actual = r.a505.#b504.#a33 in
  let expected = 1 in
  mark_test_run 3974;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3974 failed";
  (* .a505.#b504.#b33 *)
  let actual = r.a505.#b504.#b33 in
  let expected = 2. in
  mark_test_run 3975;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3975 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a505 = a5051 } { a505 = a5052 } -> (fun #{ a504 = a5041; b504 = b5041 } #{ a504 = a5042; b504 = b5042 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5041 a5042 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b5041 b5042) a5051 a5052) in
  let next_r = { a505 = #{ a504 = 100.; b504 = #{ a33 = 101; b33 = 102. } } } in
  let r_expected = { a505 = #{ a504 = 0.; b504 = #{ a33 = 1; b33 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a505 *)
  r.a505 <- next_r.a505;
  let r_expected = { r_expected with a505 = next_r.a505 } in
  mark_test_run 3976;
  let test = eq r r_expected in
  if not test then failwithf "test 3976 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a505 = #{ a504; b504 = #{ a33; b33 } } } = r in
  let expected_a504 = 100. in
  mark_test_run 3977;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a504 a504 in
  if not test then failwithf "test 3977 failed";
  let expected_a33 = 101 in
  mark_test_run 3978;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 3978 failed";
  let expected_b33 = 102. in
  mark_test_run 3979;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 3979 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a505 } = r in
  let expected_a505 = #{ a504 = 100.; b504 = #{ a33 = 101; b33 = 102. } } in
  mark_test_run 3980;
  let test = (fun #{ a504 = a5041; b504 = b5041 } #{ a504 = a5042; b504 = b5042 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5041 a5042 && (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) b5041 b5042) expected_a505 a505 in
  if not test then failwithf "test 3980 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t507 = { #{ float; #{ float; int } } }   *)
  (**********************************************)
  let r = { a507 = #{ a506 = 0.; b506 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a507 *)
  let actual = r.a507 in
  let expected = #{ a506 = 0.; b506 = #{ a58 = 1.; b58 = 2 } } in
  mark_test_run 3981;
  let test = (fun #{ a506 = a5061; b506 = b5061 } #{ a506 = a5062; b506 = b5062 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5061 a5062 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b5061 b5062) actual expected in
  if not test then failwithf "test 3981 failed";
  (* Paths of depth 2 *)
  (* .a507.#a506 *)
  let actual = r.a507.#a506 in
  let expected = 0. in
  mark_test_run 3982;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3982 failed";
  (* .a507.#b506 *)
  let actual = r.a507.#b506 in
  let expected = #{ a58 = 1.; b58 = 2 } in
  mark_test_run 3983;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 3983 failed";
  (* Paths of depth 3 *)
  (* .a507.#b506.#a58 *)
  let actual = r.a507.#b506.#a58 in
  let expected = 1. in
  mark_test_run 3984;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3984 failed";
  (* .a507.#b506.#b58 *)
  let actual = r.a507.#b506.#b58 in
  let expected = 2 in
  mark_test_run 3985;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 3985 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a507 = a5071 } { a507 = a5072 } -> (fun #{ a506 = a5061; b506 = b5061 } #{ a506 = a5062; b506 = b5062 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5061 a5062 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b5061 b5062) a5071 a5072) in
  let next_r = { a507 = #{ a506 = 100.; b506 = #{ a58 = 101.; b58 = 102 } } } in
  let r_expected = { a507 = #{ a506 = 0.; b506 = #{ a58 = 1.; b58 = 2 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a507 *)
  r.a507 <- next_r.a507;
  let r_expected = { r_expected with a507 = next_r.a507 } in
  mark_test_run 3986;
  let test = eq r r_expected in
  if not test then failwithf "test 3986 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a507 = #{ a506; b506 = #{ a58; b58 } } } = r in
  let expected_a506 = 100. in
  mark_test_run 3987;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a506 a506 in
  if not test then failwithf "test 3987 failed";
  let expected_a58 = 101. in
  mark_test_run 3988;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 3988 failed";
  let expected_b58 = 102 in
  mark_test_run 3989;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 3989 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a507 } = r in
  let expected_a507 = #{ a506 = 100.; b506 = #{ a58 = 101.; b58 = 102 } } in
  mark_test_run 3990;
  let test = (fun #{ a506 = a5061; b506 = b5061 } #{ a506 = a5062; b506 = b5062 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5061 a5062 && (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) b5061 b5062) expected_a507 a507 in
  if not test then failwithf "test 3990 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t509 = { #{ float; #{ float; float } } }   *)
  (************************************************)
  let r = { a509 = #{ a508 = 0.; b508 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a509 *)
  let actual = r.a509 in
  let expected = #{ a508 = 0.; b508 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 3991;
  let test = (fun #{ a508 = a5081; b508 = b5081 } #{ a508 = a5082; b508 = b5082 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5081 a5082 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5081 b5082) actual expected in
  if not test then failwithf "test 3991 failed";
  (* Paths of depth 2 *)
  (* .a509.#a508 *)
  let actual = r.a509.#a508 in
  let expected = 0. in
  mark_test_run 3992;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3992 failed";
  (* .a509.#b508 *)
  let actual = r.a509.#b508 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 3993;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 3993 failed";
  (* Paths of depth 3 *)
  (* .a509.#b508.#a60 *)
  let actual = r.a509.#b508.#a60 in
  let expected = 1. in
  mark_test_run 3994;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3994 failed";
  (* .a509.#b508.#b60 *)
  let actual = r.a509.#b508.#b60 in
  let expected = 2. in
  mark_test_run 3995;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 3995 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a509 = a5091 } { a509 = a5092 } -> (fun #{ a508 = a5081; b508 = b5081 } #{ a508 = a5082; b508 = b5082 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5081 a5082 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5081 b5082) a5091 a5092) in
  let next_r = { a509 = #{ a508 = 100.; b508 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a509 = #{ a508 = 0.; b508 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a509 *)
  r.a509 <- next_r.a509;
  let r_expected = { r_expected with a509 = next_r.a509 } in
  mark_test_run 3996;
  let test = eq r r_expected in
  if not test then failwithf "test 3996 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a509 = #{ a508; b508 = #{ a60; b60 } } } = r in
  let expected_a508 = 100. in
  mark_test_run 3997;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a508 a508 in
  if not test then failwithf "test 3997 failed";
  let expected_a60 = 101. in
  mark_test_run 3998;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 3998 failed";
  let expected_b60 = 102. in
  mark_test_run 3999;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 3999 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a509 } = r in
  let expected_a509 = #{ a508 = 100.; b508 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 4000;
  let test = (fun #{ a508 = a5081; b508 = b5081 } #{ a508 = a5082; b508 = b5082 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5081 a5082 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5081 b5082) expected_a509 a509 in
  if not test then failwithf "test 4000 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t511 = { #{ float; #{ float; float# } } }   *)
  (*************************************************)
  let r = { a511 = #{ a510 = 0.; b510 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a511 *)
  let actual = r.a511 in
  let expected = #{ a510 = 0.; b510 = #{ a235 = 1.; b235 = #2. } } in
  mark_test_run 4001;
  let test = (fun #{ a510 = a5101; b510 = b5101 } #{ a510 = a5102; b510 = b5102 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5101 a5102 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5101 b5102) actual expected in
  if not test then failwithf "test 4001 failed";
  (* Paths of depth 2 *)
  (* .a511.#a510 *)
  let actual = r.a511.#a510 in
  let expected = 0. in
  mark_test_run 4002;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4002 failed";
  (* .a511.#b510 *)
  let actual = r.a511.#b510 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 4003;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 4003 failed";
  (* Paths of depth 3 *)
  (* .a511.#b510.#a235 *)
  let actual = r.a511.#b510.#a235 in
  let expected = 1. in
  mark_test_run 4004;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4004 failed";
  (* .a511.#b510.#b235 *)
  let actual = r.a511.#b510.#b235 in
  let expected = #2. in
  mark_test_run 4005;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4005 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a511 = a5111 } { a511 = a5112 } -> (fun #{ a510 = a5101; b510 = b5101 } #{ a510 = a5102; b510 = b5102 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5101 a5102 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5101 b5102) a5111 a5112) in
  let next_r = { a511 = #{ a510 = 100.; b510 = #{ a235 = 101.; b235 = #102. } } } in
  let r_expected = { a511 = #{ a510 = 0.; b510 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a511 *)
  r.a511 <- next_r.a511;
  let r_expected = { r_expected with a511 = next_r.a511 } in
  mark_test_run 4006;
  let test = eq r r_expected in
  if not test then failwithf "test 4006 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a511 = #{ a510; b510 = #{ a235; b235 } } } = r in
  let expected_a510 = 100. in
  mark_test_run 4007;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a510 a510 in
  if not test then failwithf "test 4007 failed";
  let expected_a235 = 101. in
  mark_test_run 4008;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 4008 failed";
  let expected_b235 = #102. in
  mark_test_run 4009;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 4009 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a511 } = r in
  let expected_a511 = #{ a510 = 100.; b510 = #{ a235 = 101.; b235 = #102. } } in
  mark_test_run 4010;
  let test = (fun #{ a510 = a5101; b510 = b5101 } #{ a510 = a5102; b510 = b5102 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5101 a5102 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5101 b5102) expected_a511 a511 in
  if not test then failwithf "test 4010 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t513 = { #{ float; #{ float#; float } } }   *)
  (*************************************************)
  let r = { a513 = #{ a512 = 0.; b512 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a513 *)
  let actual = r.a513 in
  let expected = #{ a512 = 0.; b512 = #{ a243 = #1.; b243 = 2. } } in
  mark_test_run 4011;
  let test = (fun #{ a512 = a5121; b512 = b5121 } #{ a512 = a5122; b512 = b5122 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5121 a5122 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5121 b5122) actual expected in
  if not test then failwithf "test 4011 failed";
  (* Paths of depth 2 *)
  (* .a513.#a512 *)
  let actual = r.a513.#a512 in
  let expected = 0. in
  mark_test_run 4012;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4012 failed";
  (* .a513.#b512 *)
  let actual = r.a513.#b512 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 4013;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4013 failed";
  (* Paths of depth 3 *)
  (* .a513.#b512.#a243 *)
  let actual = r.a513.#b512.#a243 in
  let expected = #1. in
  mark_test_run 4014;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4014 failed";
  (* .a513.#b512.#b243 *)
  let actual = r.a513.#b512.#b243 in
  let expected = 2. in
  mark_test_run 4015;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4015 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a513 = a5131 } { a513 = a5132 } -> (fun #{ a512 = a5121; b512 = b5121 } #{ a512 = a5122; b512 = b5122 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5121 a5122 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5121 b5122) a5131 a5132) in
  let next_r = { a513 = #{ a512 = 100.; b512 = #{ a243 = #101.; b243 = 102. } } } in
  let r_expected = { a513 = #{ a512 = 0.; b512 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a513 *)
  r.a513 <- next_r.a513;
  let r_expected = { r_expected with a513 = next_r.a513 } in
  mark_test_run 4016;
  let test = eq r r_expected in
  if not test then failwithf "test 4016 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a513 = #{ a512; b512 = #{ a243; b243 } } } = r in
  let expected_a512 = 100. in
  mark_test_run 4017;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a512 a512 in
  if not test then failwithf "test 4017 failed";
  let expected_a243 = #101. in
  mark_test_run 4018;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4018 failed";
  let expected_b243 = 102. in
  mark_test_run 4019;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4019 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a513 } = r in
  let expected_a513 = #{ a512 = 100.; b512 = #{ a243 = #101.; b243 = 102. } } in
  mark_test_run 4020;
  let test = (fun #{ a512 = a5121; b512 = b5121 } #{ a512 = a5122; b512 = b5122 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5121 a5122 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5121 b5122) expected_a513 a513 in
  if not test then failwithf "test 4020 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t515 = { #{ float; #{ float#; float# } } }   *)
  (**************************************************)
  let r = { a515 = #{ a514 = 0.; b514 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a515 *)
  let actual = r.a515 in
  let expected = #{ a514 = 0.; b514 = #{ a245 = #1.; b245 = #2. } } in
  mark_test_run 4021;
  let test = (fun #{ a514 = a5141; b514 = b5141 } #{ a514 = a5142; b514 = b5142 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5141 a5142 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5141 b5142) actual expected in
  if not test then failwithf "test 4021 failed";
  (* Paths of depth 2 *)
  (* .a515.#a514 *)
  let actual = r.a515.#a514 in
  let expected = 0. in
  mark_test_run 4022;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4022 failed";
  (* .a515.#b514 *)
  let actual = r.a515.#b514 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 4023;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4023 failed";
  (* Paths of depth 3 *)
  (* .a515.#b514.#a245 *)
  let actual = r.a515.#b514.#a245 in
  let expected = #1. in
  mark_test_run 4024;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4024 failed";
  (* .a515.#b514.#b245 *)
  let actual = r.a515.#b514.#b245 in
  let expected = #2. in
  mark_test_run 4025;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4025 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a515 = a5151 } { a515 = a5152 } -> (fun #{ a514 = a5141; b514 = b5141 } #{ a514 = a5142; b514 = b5142 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5141 a5142 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5141 b5142) a5151 a5152) in
  let next_r = { a515 = #{ a514 = 100.; b514 = #{ a245 = #101.; b245 = #102. } } } in
  let r_expected = { a515 = #{ a514 = 0.; b514 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a515 *)
  r.a515 <- next_r.a515;
  let r_expected = { r_expected with a515 = next_r.a515 } in
  mark_test_run 4026;
  let test = eq r r_expected in
  if not test then failwithf "test 4026 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a515 = #{ a514; b514 = #{ a245; b245 } } } = r in
  let expected_a514 = 100. in
  mark_test_run 4027;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a514 a514 in
  if not test then failwithf "test 4027 failed";
  let expected_a245 = #101. in
  mark_test_run 4028;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4028 failed";
  let expected_b245 = #102. in
  mark_test_run 4029;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4029 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a515 } = r in
  let expected_a515 = #{ a514 = 100.; b514 = #{ a245 = #101.; b245 = #102. } } in
  mark_test_run 4030;
  let test = (fun #{ a514 = a5141; b514 = b5141 } #{ a514 = a5142; b514 = b5142 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a5141 a5142 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5141 b5142) expected_a515 a515 in
  if not test then failwithf "test 4030 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t516 = { #{ float# } }   *)
  (******************************)
  let r = { a516 = #{ a239 = #0. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a516 *)
  let actual = r.a516 in
  let expected = #{ a239 = #0. } in
  mark_test_run 4031;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 4031 failed";
  (* Paths of depth 2 *)
  (* .a516.#a239 *)
  let actual = r.a516.#a239 in
  let expected = #0. in
  mark_test_run 4032;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4032 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a516 = a5161 } { a516 = a5162 } -> (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) a5161 a5162) in
  let next_r = { a516 = #{ a239 = #100. } } in
  let r_expected = { a516 = #{ a239 = #0. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a516 *)
  r.a516 <- next_r.a516;
  let r_expected = { r_expected with a516 = next_r.a516 } in
  mark_test_run 4033;
  let test = eq r r_expected in
  if not test then failwithf "test 4033 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a516 = #{ a239 } } = r in
  let expected_a239 = #100. in
  mark_test_run 4034;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 4034 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a516 } = r in
  let expected_a516 = #{ a239 = #100. } in
  mark_test_run 4035;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) expected_a516 a516 in
  if not test then failwithf "test 4035 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t517 = { #{ float# }; float }   *)
  (*************************************)
  let r = { a517 = #{ a239 = #0. }; b517 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a517 *)
  let actual = r.a517 in
  let expected = #{ a239 = #0. } in
  mark_test_run 4036;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 4036 failed";
  (* Paths of depth 2 *)
  (* .a517.#a239 *)
  let actual = r.a517.#a239 in
  let expected = #0. in
  mark_test_run 4037;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4037 failed";
  (* Paths of depth 1 *)
  (* .b517 *)
  let actual = r.b517 in
  let expected = 1. in
  mark_test_run 4038;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4038 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a517 = a5171; b517 = b5171 } { a517 = a5172; b517 = b5172 } -> (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) a5171 a5172 && (fun a b -> Float.equal (globalize a) (globalize b)) b5171 b5172) in
  let next_r = { a517 = #{ a239 = #100. }; b517 = 101. } in
  let r_expected = { a517 = #{ a239 = #0. }; b517 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a517 *)
  r.a517 <- next_r.a517;
  let r_expected = { r_expected with a517 = next_r.a517 } in
  mark_test_run 4039;
  let test = eq r r_expected in
  if not test then failwithf "test 4039 failed";
  Gc.compact ();
  (* .b517 *)
  r.b517 <- next_r.b517;
  let r_expected = { r_expected with b517 = next_r.b517 } in
  mark_test_run 4040;
  let test = eq r r_expected in
  if not test then failwithf "test 4040 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a517 = #{ a239 }; b517 } = r in
  let expected_a239 = #100. in
  mark_test_run 4041;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 4041 failed";
  let expected_b517 = 101. in
  mark_test_run 4042;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b517 b517 in
  if not test then failwithf "test 4042 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a517; b517 } = r in
  let expected_a517 = #{ a239 = #100. } in
  mark_test_run 4043;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) expected_a517 a517 in
  if not test then failwithf "test 4043 failed";
  let expected_b517 = 101. in
  mark_test_run 4044;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b517 b517 in
  if not test then failwithf "test 4044 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t518 = { #{ float# }; float# }   *)
  (**************************************)
  let r = { a518 = #{ a239 = #0. }; b518 = #1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a518 *)
  let actual = r.a518 in
  let expected = #{ a239 = #0. } in
  mark_test_run 4045;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) actual expected in
  if not test then failwithf "test 4045 failed";
  (* Paths of depth 2 *)
  (* .a518.#a239 *)
  let actual = r.a518.#a239 in
  let expected = #0. in
  mark_test_run 4046;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4046 failed";
  (* Paths of depth 1 *)
  (* .b518 *)
  let actual = r.b518 in
  let expected = #1. in
  mark_test_run 4047;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4047 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a518 = a5181; b518 = b5181 } { a518 = a5182; b518 = b5182 } -> (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) a5181 a5182 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5181 b5182) in
  let next_r = { a518 = #{ a239 = #100. }; b518 = #101. } in
  let r_expected = { a518 = #{ a239 = #0. }; b518 = #1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a518 *)
  r.a518 <- next_r.a518;
  let r_expected = { r_expected with a518 = next_r.a518 } in
  mark_test_run 4048;
  let test = eq r r_expected in
  if not test then failwithf "test 4048 failed";
  Gc.compact ();
  (* .b518 *)
  r.b518 <- next_r.b518;
  let r_expected = { r_expected with b518 = next_r.b518 } in
  mark_test_run 4049;
  let test = eq r r_expected in
  if not test then failwithf "test 4049 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a518 = #{ a239 }; b518 } = r in
  let expected_a239 = #100. in
  mark_test_run 4050;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a239 a239 in
  if not test then failwithf "test 4050 failed";
  let expected_b518 = #101. in
  mark_test_run 4051;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b518 b518 in
  if not test then failwithf "test 4051 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a518; b518 } = r in
  let expected_a518 = #{ a239 = #100. } in
  mark_test_run 4052;
  let test = (fun #{ a239 = a2391 } #{ a239 = a2392 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2391 a2392) expected_a518 a518 in
  if not test then failwithf "test 4052 failed";
  let expected_b518 = #101. in
  mark_test_run 4053;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b518 b518 in
  if not test then failwithf "test 4053 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t519 = { #{ float#; float } }   *)
  (*************************************)
  let r = { a519 = #{ a243 = #0.; b243 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a519 *)
  let actual = r.a519 in
  let expected = #{ a243 = #0.; b243 = 1. } in
  mark_test_run 4054;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4054 failed";
  (* Paths of depth 2 *)
  (* .a519.#a243 *)
  let actual = r.a519.#a243 in
  let expected = #0. in
  mark_test_run 4055;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4055 failed";
  (* .a519.#b243 *)
  let actual = r.a519.#b243 in
  let expected = 1. in
  mark_test_run 4056;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4056 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a519 = a5191 } { a519 = a5192 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a5191 a5192) in
  let next_r = { a519 = #{ a243 = #100.; b243 = 101. } } in
  let r_expected = { a519 = #{ a243 = #0.; b243 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a519 *)
  r.a519 <- next_r.a519;
  let r_expected = { r_expected with a519 = next_r.a519 } in
  mark_test_run 4057;
  let test = eq r r_expected in
  if not test then failwithf "test 4057 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a519 = #{ a243; b243 } } = r in
  let expected_a243 = #100. in
  mark_test_run 4058;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4058 failed";
  let expected_b243 = 101. in
  mark_test_run 4059;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4059 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a519 } = r in
  let expected_a519 = #{ a243 = #100.; b243 = 101. } in
  mark_test_run 4060;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) expected_a519 a519 in
  if not test then failwithf "test 4060 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t520 = { #{ float#; float }; float }   *)
  (********************************************)
  let r = { a520 = #{ a243 = #0.; b243 = 1. }; b520 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a520 *)
  let actual = r.a520 in
  let expected = #{ a243 = #0.; b243 = 1. } in
  mark_test_run 4061;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4061 failed";
  (* Paths of depth 2 *)
  (* .a520.#a243 *)
  let actual = r.a520.#a243 in
  let expected = #0. in
  mark_test_run 4062;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4062 failed";
  (* .a520.#b243 *)
  let actual = r.a520.#b243 in
  let expected = 1. in
  mark_test_run 4063;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4063 failed";
  (* Paths of depth 1 *)
  (* .b520 *)
  let actual = r.b520 in
  let expected = 2. in
  mark_test_run 4064;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4064 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a520 = a5201; b520 = b5201 } { a520 = a5202; b520 = b5202 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a5201 a5202 && (fun a b -> Float.equal (globalize a) (globalize b)) b5201 b5202) in
  let next_r = { a520 = #{ a243 = #100.; b243 = 101. }; b520 = 102. } in
  let r_expected = { a520 = #{ a243 = #0.; b243 = 1. }; b520 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a520 *)
  r.a520 <- next_r.a520;
  let r_expected = { r_expected with a520 = next_r.a520 } in
  mark_test_run 4065;
  let test = eq r r_expected in
  if not test then failwithf "test 4065 failed";
  Gc.compact ();
  (* .b520 *)
  r.b520 <- next_r.b520;
  let r_expected = { r_expected with b520 = next_r.b520 } in
  mark_test_run 4066;
  let test = eq r r_expected in
  if not test then failwithf "test 4066 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a520 = #{ a243; b243 }; b520 } = r in
  let expected_a243 = #100. in
  mark_test_run 4067;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4067 failed";
  let expected_b243 = 101. in
  mark_test_run 4068;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4068 failed";
  let expected_b520 = 102. in
  mark_test_run 4069;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b520 b520 in
  if not test then failwithf "test 4069 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a520; b520 } = r in
  let expected_a520 = #{ a243 = #100.; b243 = 101. } in
  mark_test_run 4070;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) expected_a520 a520 in
  if not test then failwithf "test 4070 failed";
  let expected_b520 = 102. in
  mark_test_run 4071;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b520 b520 in
  if not test then failwithf "test 4071 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t521 = { #{ float#; float }; float# }   *)
  (*********************************************)
  let r = { a521 = #{ a243 = #0.; b243 = 1. }; b521 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a521 *)
  let actual = r.a521 in
  let expected = #{ a243 = #0.; b243 = 1. } in
  mark_test_run 4072;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4072 failed";
  (* Paths of depth 2 *)
  (* .a521.#a243 *)
  let actual = r.a521.#a243 in
  let expected = #0. in
  mark_test_run 4073;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4073 failed";
  (* .a521.#b243 *)
  let actual = r.a521.#b243 in
  let expected = 1. in
  mark_test_run 4074;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4074 failed";
  (* Paths of depth 1 *)
  (* .b521 *)
  let actual = r.b521 in
  let expected = #2. in
  mark_test_run 4075;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4075 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a521 = a5211; b521 = b5211 } { a521 = a5212; b521 = b5212 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a5211 a5212 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5211 b5212) in
  let next_r = { a521 = #{ a243 = #100.; b243 = 101. }; b521 = #102. } in
  let r_expected = { a521 = #{ a243 = #0.; b243 = 1. }; b521 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a521 *)
  r.a521 <- next_r.a521;
  let r_expected = { r_expected with a521 = next_r.a521 } in
  mark_test_run 4076;
  let test = eq r r_expected in
  if not test then failwithf "test 4076 failed";
  Gc.compact ();
  (* .b521 *)
  r.b521 <- next_r.b521;
  let r_expected = { r_expected with b521 = next_r.b521 } in
  mark_test_run 4077;
  let test = eq r r_expected in
  if not test then failwithf "test 4077 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a521 = #{ a243; b243 }; b521 } = r in
  let expected_a243 = #100. in
  mark_test_run 4078;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4078 failed";
  let expected_b243 = 101. in
  mark_test_run 4079;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4079 failed";
  let expected_b521 = #102. in
  mark_test_run 4080;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b521 b521 in
  if not test then failwithf "test 4080 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a521; b521 } = r in
  let expected_a521 = #{ a243 = #100.; b243 = 101. } in
  mark_test_run 4081;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) expected_a521 a521 in
  if not test then failwithf "test 4081 failed";
  let expected_b521 = #102. in
  mark_test_run 4082;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b521 b521 in
  if not test then failwithf "test 4082 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t522 = { #{ float#; float# } }   *)
  (**************************************)
  let r = { a522 = #{ a245 = #0.; b245 = #1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a522 *)
  let actual = r.a522 in
  let expected = #{ a245 = #0.; b245 = #1. } in
  mark_test_run 4083;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4083 failed";
  (* Paths of depth 2 *)
  (* .a522.#a245 *)
  let actual = r.a522.#a245 in
  let expected = #0. in
  mark_test_run 4084;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4084 failed";
  (* .a522.#b245 *)
  let actual = r.a522.#b245 in
  let expected = #1. in
  mark_test_run 4085;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4085 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a522 = a5221 } { a522 = a5222 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a5221 a5222) in
  let next_r = { a522 = #{ a245 = #100.; b245 = #101. } } in
  let r_expected = { a522 = #{ a245 = #0.; b245 = #1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a522 *)
  r.a522 <- next_r.a522;
  let r_expected = { r_expected with a522 = next_r.a522 } in
  mark_test_run 4086;
  let test = eq r r_expected in
  if not test then failwithf "test 4086 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a522 = #{ a245; b245 } } = r in
  let expected_a245 = #100. in
  mark_test_run 4087;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4087 failed";
  let expected_b245 = #101. in
  mark_test_run 4088;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4088 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a522 } = r in
  let expected_a522 = #{ a245 = #100.; b245 = #101. } in
  mark_test_run 4089;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) expected_a522 a522 in
  if not test then failwithf "test 4089 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t523 = { #{ float#; float# }; float }   *)
  (*********************************************)
  let r = { a523 = #{ a245 = #0.; b245 = #1. }; b523 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a523 *)
  let actual = r.a523 in
  let expected = #{ a245 = #0.; b245 = #1. } in
  mark_test_run 4090;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4090 failed";
  (* Paths of depth 2 *)
  (* .a523.#a245 *)
  let actual = r.a523.#a245 in
  let expected = #0. in
  mark_test_run 4091;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4091 failed";
  (* .a523.#b245 *)
  let actual = r.a523.#b245 in
  let expected = #1. in
  mark_test_run 4092;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4092 failed";
  (* Paths of depth 1 *)
  (* .b523 *)
  let actual = r.b523 in
  let expected = 2. in
  mark_test_run 4093;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4093 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a523 = a5231; b523 = b5231 } { a523 = a5232; b523 = b5232 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a5231 a5232 && (fun a b -> Float.equal (globalize a) (globalize b)) b5231 b5232) in
  let next_r = { a523 = #{ a245 = #100.; b245 = #101. }; b523 = 102. } in
  let r_expected = { a523 = #{ a245 = #0.; b245 = #1. }; b523 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a523 *)
  r.a523 <- next_r.a523;
  let r_expected = { r_expected with a523 = next_r.a523 } in
  mark_test_run 4094;
  let test = eq r r_expected in
  if not test then failwithf "test 4094 failed";
  Gc.compact ();
  (* .b523 *)
  r.b523 <- next_r.b523;
  let r_expected = { r_expected with b523 = next_r.b523 } in
  mark_test_run 4095;
  let test = eq r r_expected in
  if not test then failwithf "test 4095 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a523 = #{ a245; b245 }; b523 } = r in
  let expected_a245 = #100. in
  mark_test_run 4096;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4096 failed";
  let expected_b245 = #101. in
  mark_test_run 4097;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4097 failed";
  let expected_b523 = 102. in
  mark_test_run 4098;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b523 b523 in
  if not test then failwithf "test 4098 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a523; b523 } = r in
  let expected_a523 = #{ a245 = #100.; b245 = #101. } in
  mark_test_run 4099;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) expected_a523 a523 in
  if not test then failwithf "test 4099 failed";
  let expected_b523 = 102. in
  mark_test_run 4100;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b523 b523 in
  if not test then failwithf "test 4100 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t524 = { #{ float#; float# }; float# }   *)
  (**********************************************)
  let r = { a524 = #{ a245 = #0.; b245 = #1. }; b524 = #2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a524 *)
  let actual = r.a524 in
  let expected = #{ a245 = #0.; b245 = #1. } in
  mark_test_run 4101;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4101 failed";
  (* Paths of depth 2 *)
  (* .a524.#a245 *)
  let actual = r.a524.#a245 in
  let expected = #0. in
  mark_test_run 4102;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4102 failed";
  (* .a524.#b245 *)
  let actual = r.a524.#b245 in
  let expected = #1. in
  mark_test_run 4103;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4103 failed";
  (* Paths of depth 1 *)
  (* .b524 *)
  let actual = r.b524 in
  let expected = #2. in
  mark_test_run 4104;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4104 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a524 = a5241; b524 = b5241 } { a524 = a5242; b524 = b5242 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a5241 a5242 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5241 b5242) in
  let next_r = { a524 = #{ a245 = #100.; b245 = #101. }; b524 = #102. } in
  let r_expected = { a524 = #{ a245 = #0.; b245 = #1. }; b524 = #2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a524 *)
  r.a524 <- next_r.a524;
  let r_expected = { r_expected with a524 = next_r.a524 } in
  mark_test_run 4105;
  let test = eq r r_expected in
  if not test then failwithf "test 4105 failed";
  Gc.compact ();
  (* .b524 *)
  r.b524 <- next_r.b524;
  let r_expected = { r_expected with b524 = next_r.b524 } in
  mark_test_run 4106;
  let test = eq r r_expected in
  if not test then failwithf "test 4106 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a524 = #{ a245; b245 }; b524 } = r in
  let expected_a245 = #100. in
  mark_test_run 4107;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4107 failed";
  let expected_b245 = #101. in
  mark_test_run 4108;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4108 failed";
  let expected_b524 = #102. in
  mark_test_run 4109;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b524 b524 in
  if not test then failwithf "test 4109 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a524; b524 } = r in
  let expected_a524 = #{ a245 = #100.; b245 = #101. } in
  mark_test_run 4110;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) expected_a524 a524 in
  if not test then failwithf "test 4110 failed";
  let expected_b524 = #102. in
  mark_test_run 4111;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b524 b524 in
  if not test then failwithf "test 4111 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t526 = { #{ float#; #{ float; float } } }   *)
  (*************************************************)
  let r = { a526 = #{ a525 = #0.; b525 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a526 *)
  let actual = r.a526 in
  let expected = #{ a525 = #0.; b525 = #{ a60 = 1.; b60 = 2. } } in
  mark_test_run 4112;
  let test = (fun #{ a525 = a5251; b525 = b5251 } #{ a525 = a5252; b525 = b5252 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5251 a5252 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5251 b5252) actual expected in
  if not test then failwithf "test 4112 failed";
  (* Paths of depth 2 *)
  (* .a526.#a525 *)
  let actual = r.a526.#a525 in
  let expected = #0. in
  mark_test_run 4113;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4113 failed";
  (* .a526.#b525 *)
  let actual = r.a526.#b525 in
  let expected = #{ a60 = 1.; b60 = 2. } in
  mark_test_run 4114;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 4114 failed";
  (* Paths of depth 3 *)
  (* .a526.#b525.#a60 *)
  let actual = r.a526.#b525.#a60 in
  let expected = 1. in
  mark_test_run 4115;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4115 failed";
  (* .a526.#b525.#b60 *)
  let actual = r.a526.#b525.#b60 in
  let expected = 2. in
  mark_test_run 4116;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4116 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a526 = a5261 } { a526 = a5262 } -> (fun #{ a525 = a5251; b525 = b5251 } #{ a525 = a5252; b525 = b5252 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5251 a5252 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5251 b5252) a5261 a5262) in
  let next_r = { a526 = #{ a525 = #100.; b525 = #{ a60 = 101.; b60 = 102. } } } in
  let r_expected = { a526 = #{ a525 = #0.; b525 = #{ a60 = 1.; b60 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a526 *)
  r.a526 <- next_r.a526;
  let r_expected = { r_expected with a526 = next_r.a526 } in
  mark_test_run 4117;
  let test = eq r r_expected in
  if not test then failwithf "test 4117 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a526 = #{ a525; b525 = #{ a60; b60 } } } = r in
  let expected_a525 = #100. in
  mark_test_run 4118;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a525 a525 in
  if not test then failwithf "test 4118 failed";
  let expected_a60 = 101. in
  mark_test_run 4119;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 4119 failed";
  let expected_b60 = 102. in
  mark_test_run 4120;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 4120 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a526 } = r in
  let expected_a526 = #{ a525 = #100.; b525 = #{ a60 = 101.; b60 = 102. } } in
  mark_test_run 4121;
  let test = (fun #{ a525 = a5251; b525 = b5251 } #{ a525 = a5252; b525 = b5252 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5251 a5252 && (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) b5251 b5252) expected_a526 a526 in
  if not test then failwithf "test 4121 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t528 = { #{ float#; #{ float; float# } } }   *)
  (**************************************************)
  let r = { a528 = #{ a527 = #0.; b527 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a528 *)
  let actual = r.a528 in
  let expected = #{ a527 = #0.; b527 = #{ a235 = 1.; b235 = #2. } } in
  mark_test_run 4122;
  let test = (fun #{ a527 = a5271; b527 = b5271 } #{ a527 = a5272; b527 = b5272 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5271 a5272 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5271 b5272) actual expected in
  if not test then failwithf "test 4122 failed";
  (* Paths of depth 2 *)
  (* .a528.#a527 *)
  let actual = r.a528.#a527 in
  let expected = #0. in
  mark_test_run 4123;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4123 failed";
  (* .a528.#b527 *)
  let actual = r.a528.#b527 in
  let expected = #{ a235 = 1.; b235 = #2. } in
  mark_test_run 4124;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 4124 failed";
  (* Paths of depth 3 *)
  (* .a528.#b527.#a235 *)
  let actual = r.a528.#b527.#a235 in
  let expected = 1. in
  mark_test_run 4125;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4125 failed";
  (* .a528.#b527.#b235 *)
  let actual = r.a528.#b527.#b235 in
  let expected = #2. in
  mark_test_run 4126;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4126 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a528 = a5281 } { a528 = a5282 } -> (fun #{ a527 = a5271; b527 = b5271 } #{ a527 = a5272; b527 = b5272 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5271 a5272 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5271 b5272) a5281 a5282) in
  let next_r = { a528 = #{ a527 = #100.; b527 = #{ a235 = 101.; b235 = #102. } } } in
  let r_expected = { a528 = #{ a527 = #0.; b527 = #{ a235 = 1.; b235 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a528 *)
  r.a528 <- next_r.a528;
  let r_expected = { r_expected with a528 = next_r.a528 } in
  mark_test_run 4127;
  let test = eq r r_expected in
  if not test then failwithf "test 4127 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a528 = #{ a527; b527 = #{ a235; b235 } } } = r in
  let expected_a527 = #100. in
  mark_test_run 4128;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a527 a527 in
  if not test then failwithf "test 4128 failed";
  let expected_a235 = 101. in
  mark_test_run 4129;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 4129 failed";
  let expected_b235 = #102. in
  mark_test_run 4130;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 4130 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a528 } = r in
  let expected_a528 = #{ a527 = #100.; b527 = #{ a235 = 101.; b235 = #102. } } in
  mark_test_run 4131;
  let test = (fun #{ a527 = a5271; b527 = b5271 } #{ a527 = a5272; b527 = b5272 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5271 a5272 && (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) b5271 b5272) expected_a528 a528 in
  if not test then failwithf "test 4131 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t530 = { #{ float#; #{ float#; float } } }   *)
  (**************************************************)
  let r = { a530 = #{ a529 = #0.; b529 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a530 *)
  let actual = r.a530 in
  let expected = #{ a529 = #0.; b529 = #{ a243 = #1.; b243 = 2. } } in
  mark_test_run 4132;
  let test = (fun #{ a529 = a5291; b529 = b5291 } #{ a529 = a5292; b529 = b5292 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5291 a5292 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5291 b5292) actual expected in
  if not test then failwithf "test 4132 failed";
  (* Paths of depth 2 *)
  (* .a530.#a529 *)
  let actual = r.a530.#a529 in
  let expected = #0. in
  mark_test_run 4133;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4133 failed";
  (* .a530.#b529 *)
  let actual = r.a530.#b529 in
  let expected = #{ a243 = #1.; b243 = 2. } in
  mark_test_run 4134;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4134 failed";
  (* Paths of depth 3 *)
  (* .a530.#b529.#a243 *)
  let actual = r.a530.#b529.#a243 in
  let expected = #1. in
  mark_test_run 4135;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4135 failed";
  (* .a530.#b529.#b243 *)
  let actual = r.a530.#b529.#b243 in
  let expected = 2. in
  mark_test_run 4136;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4136 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a530 = a5301 } { a530 = a5302 } -> (fun #{ a529 = a5291; b529 = b5291 } #{ a529 = a5292; b529 = b5292 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5291 a5292 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5291 b5292) a5301 a5302) in
  let next_r = { a530 = #{ a529 = #100.; b529 = #{ a243 = #101.; b243 = 102. } } } in
  let r_expected = { a530 = #{ a529 = #0.; b529 = #{ a243 = #1.; b243 = 2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a530 *)
  r.a530 <- next_r.a530;
  let r_expected = { r_expected with a530 = next_r.a530 } in
  mark_test_run 4137;
  let test = eq r r_expected in
  if not test then failwithf "test 4137 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a530 = #{ a529; b529 = #{ a243; b243 } } } = r in
  let expected_a529 = #100. in
  mark_test_run 4138;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a529 a529 in
  if not test then failwithf "test 4138 failed";
  let expected_a243 = #101. in
  mark_test_run 4139;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4139 failed";
  let expected_b243 = 102. in
  mark_test_run 4140;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4140 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a530 } = r in
  let expected_a530 = #{ a529 = #100.; b529 = #{ a243 = #101.; b243 = 102. } } in
  mark_test_run 4141;
  let test = (fun #{ a529 = a5291; b529 = b5291 } #{ a529 = a5292; b529 = b5292 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5291 a5292 && (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) b5291 b5292) expected_a530 a530 in
  if not test then failwithf "test 4141 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t532 = { #{ float#; #{ float#; float# } } }   *)
  (***************************************************)
  let r = { a532 = #{ a531 = #0.; b531 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a532 *)
  let actual = r.a532 in
  let expected = #{ a531 = #0.; b531 = #{ a245 = #1.; b245 = #2. } } in
  mark_test_run 4142;
  let test = (fun #{ a531 = a5311; b531 = b5311 } #{ a531 = a5312; b531 = b5312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5311 a5312 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5311 b5312) actual expected in
  if not test then failwithf "test 4142 failed";
  (* Paths of depth 2 *)
  (* .a532.#a531 *)
  let actual = r.a532.#a531 in
  let expected = #0. in
  mark_test_run 4143;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4143 failed";
  (* .a532.#b531 *)
  let actual = r.a532.#b531 in
  let expected = #{ a245 = #1.; b245 = #2. } in
  mark_test_run 4144;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4144 failed";
  (* Paths of depth 3 *)
  (* .a532.#b531.#a245 *)
  let actual = r.a532.#b531.#a245 in
  let expected = #1. in
  mark_test_run 4145;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4145 failed";
  (* .a532.#b531.#b245 *)
  let actual = r.a532.#b531.#b245 in
  let expected = #2. in
  mark_test_run 4146;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4146 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a532 = a5321 } { a532 = a5322 } -> (fun #{ a531 = a5311; b531 = b5311 } #{ a531 = a5312; b531 = b5312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5311 a5312 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5311 b5312) a5321 a5322) in
  let next_r = { a532 = #{ a531 = #100.; b531 = #{ a245 = #101.; b245 = #102. } } } in
  let r_expected = { a532 = #{ a531 = #0.; b531 = #{ a245 = #1.; b245 = #2. } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a532 *)
  r.a532 <- next_r.a532;
  let r_expected = { r_expected with a532 = next_r.a532 } in
  mark_test_run 4147;
  let test = eq r r_expected in
  if not test then failwithf "test 4147 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a532 = #{ a531; b531 = #{ a245; b245 } } } = r in
  let expected_a531 = #100. in
  mark_test_run 4148;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a531 a531 in
  if not test then failwithf "test 4148 failed";
  let expected_a245 = #101. in
  mark_test_run 4149;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4149 failed";
  let expected_b245 = #102. in
  mark_test_run 4150;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4150 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a532 } = r in
  let expected_a532 = #{ a531 = #100.; b531 = #{ a245 = #101.; b245 = #102. } } in
  mark_test_run 4151;
  let test = (fun #{ a531 = a5311; b531 = b5311 } #{ a531 = a5312; b531 = b5312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a5311 a5312 && (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) b5311 b5312) expected_a532 a532 in
  if not test then failwithf "test 4151 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************************)
  (*   t535 = { #{ float32#; int64# }; #{ string; int64# } }   *)
  (*************************************************************)
  let r = { a535 = #{ a533 = #0.s; b533 = #1L }; b535 = #{ a534 = "2"; b534 = #3L } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a535 *)
  let actual = r.a535 in
  let expected = #{ a533 = #0.s; b533 = #1L } in
  mark_test_run 4152;
  let test = (fun #{ a533 = a5331; b533 = b5331 } #{ a533 = a5332; b533 = b5332 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a5331 a5332 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5331 b5332) actual expected in
  if not test then failwithf "test 4152 failed";
  (* Paths of depth 2 *)
  (* .a535.#a533 *)
  let actual = r.a535.#a533 in
  let expected = #0.s in
  mark_test_run 4153;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) actual expected in
  if not test then failwithf "test 4153 failed";
  (* .a535.#b533 *)
  let actual = r.a535.#b533 in
  let expected = #1L in
  mark_test_run 4154;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 4154 failed";
  (* Paths of depth 1 *)
  (* .b535 *)
  let actual = r.b535 in
  let expected = #{ a534 = "2"; b534 = #3L } in
  mark_test_run 4155;
  let test = (fun #{ a534 = a5341; b534 = b5341 } #{ a534 = a5342; b534 = b5342 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5341 a5342 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5341 b5342) actual expected in
  if not test then failwithf "test 4155 failed";
  (* Paths of depth 2 *)
  (* .b535.#a534 *)
  let actual = r.b535.#a534 in
  let expected = "2" in
  mark_test_run 4156;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4156 failed";
  (* .b535.#b534 *)
  let actual = r.b535.#b534 in
  let expected = #3L in
  mark_test_run 4157;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 4157 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a535 = a5351; b535 = b5351 } { a535 = a5352; b535 = b5352 } -> (fun #{ a533 = a5331; b533 = b5331 } #{ a533 = a5332; b533 = b5332 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a5331 a5332 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5331 b5332) a5351 a5352 && (fun #{ a534 = a5341; b534 = b5341 } #{ a534 = a5342; b534 = b5342 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5341 a5342 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5341 b5342) b5351 b5352) in
  let next_r = { a535 = #{ a533 = #100.s; b533 = #101L }; b535 = #{ a534 = "102"; b534 = #103L } } in
  let r_expected = { a535 = #{ a533 = #0.s; b533 = #1L }; b535 = #{ a534 = "2"; b534 = #3L } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a535 *)
  r.a535 <- next_r.a535;
  let r_expected = { r_expected with a535 = next_r.a535 } in
  mark_test_run 4158;
  let test = eq r r_expected in
  if not test then failwithf "test 4158 failed";
  Gc.compact ();
  (* .b535 *)
  r.b535 <- next_r.b535;
  let r_expected = { r_expected with b535 = next_r.b535 } in
  mark_test_run 4159;
  let test = eq r r_expected in
  if not test then failwithf "test 4159 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a535 = #{ a533; b533 }; b535 = #{ a534; b534 } } = r in
  let expected_a533 = #100.s in
  mark_test_run 4160;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) expected_a533 a533 in
  if not test then failwithf "test 4160 failed";
  let expected_b533 = #101L in
  mark_test_run 4161;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b533 b533 in
  if not test then failwithf "test 4161 failed";
  let expected_a534 = "102" in
  mark_test_run 4162;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a534 a534 in
  if not test then failwithf "test 4162 failed";
  let expected_b534 = #103L in
  mark_test_run 4163;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b534 b534 in
  if not test then failwithf "test 4163 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a535; b535 } = r in
  let expected_a535 = #{ a533 = #100.s; b533 = #101L } in
  mark_test_run 4164;
  let test = (fun #{ a533 = a5331; b533 = b5331 } #{ a533 = a5332; b533 = b5332 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a5331 a5332 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5331 b5332) expected_a535 a535 in
  if not test then failwithf "test 4164 failed";
  let expected_b535 = #{ a534 = "102"; b534 = #103L } in
  mark_test_run 4165;
  let test = (fun #{ a534 = a5341; b534 = b5341 } #{ a534 = a5342; b534 = b5342 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5341 a5342 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b5341 b5342) expected_b535 b535 in
  if not test then failwithf "test 4165 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t536 = { #{ string } }   *)
  (******************************)
  let r = { a536 = #{ a186 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a536 *)
  let actual = r.a536 in
  let expected = #{ a186 = "0" } in
  mark_test_run 4166;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 4166 failed";
  (* Paths of depth 2 *)
  (* .a536.#a186 *)
  let actual = r.a536.#a186 in
  let expected = "0" in
  mark_test_run 4167;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4167 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a536 = a5361 } { a536 = a5362 } -> (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) a5361 a5362) in
  let next_r = { a536 = #{ a186 = "100" } } in
  let r_expected = { a536 = #{ a186 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a536 *)
  r.a536 <- next_r.a536;
  let r_expected = { r_expected with a536 = next_r.a536 } in
  mark_test_run 4168;
  let test = eq r r_expected in
  if not test then failwithf "test 4168 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a536 = #{ a186 } } = r in
  let expected_a186 = "100" in
  mark_test_run 4169;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 4169 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a536 } = r in
  let expected_a536 = #{ a186 = "100" } in
  mark_test_run 4170;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) expected_a536 a536 in
  if not test then failwithf "test 4170 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t537 = { #{ string }; unit_u }   *)
  (**************************************)
  let r = { a537 = #{ a186 = "0" }; b537 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a537 *)
  let actual = r.a537 in
  let expected = #{ a186 = "0" } in
  mark_test_run 4171;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 4171 failed";
  (* Paths of depth 2 *)
  (* .a537.#a186 *)
  let actual = r.a537.#a186 in
  let expected = "0" in
  mark_test_run 4172;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4172 failed";
  (* Paths of depth 1 *)
  (* .b537 *)
  let actual = r.b537 in
  let expected = (unbox_unit ()) in
  mark_test_run 4173;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4173 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a537 = a5371; b537 = b5371 } { a537 = a5372; b537 = b5372 } -> (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) a5371 a5372 && (fun _ _ -> true) b5371 b5372) in
  let next_r = { a537 = #{ a186 = "100" }; b537 = (unbox_unit ()) } in
  let r_expected = { a537 = #{ a186 = "0" }; b537 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a537 *)
  r.a537 <- next_r.a537;
  let r_expected = { r_expected with a537 = next_r.a537 } in
  mark_test_run 4174;
  let test = eq r r_expected in
  if not test then failwithf "test 4174 failed";
  Gc.compact ();
  (* .b537 *)
  r.b537 <- next_r.b537;
  let r_expected = { r_expected with b537 = next_r.b537 } in
  mark_test_run 4175;
  let test = eq r r_expected in
  if not test then failwithf "test 4175 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a537 = #{ a186 }; b537 } = r in
  let expected_a186 = "100" in
  mark_test_run 4176;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 4176 failed";
  let expected_b537 = (unbox_unit ()) in
  mark_test_run 4177;
  let test = (fun _ _ -> true) expected_b537 b537 in
  if not test then failwithf "test 4177 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a537; b537 } = r in
  let expected_a537 = #{ a186 = "100" } in
  mark_test_run 4178;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) expected_a537 a537 in
  if not test then failwithf "test 4178 failed";
  let expected_b537 = (unbox_unit ()) in
  mark_test_run 4179;
  let test = (fun _ _ -> true) expected_b537 b537 in
  if not test then failwithf "test 4179 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t538 = { #{ string }; string }   *)
  (**************************************)
  let r = { a538 = #{ a186 = "0" }; b538 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a538 *)
  let actual = r.a538 in
  let expected = #{ a186 = "0" } in
  mark_test_run 4180;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) actual expected in
  if not test then failwithf "test 4180 failed";
  (* Paths of depth 2 *)
  (* .a538.#a186 *)
  let actual = r.a538.#a186 in
  let expected = "0" in
  mark_test_run 4181;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4181 failed";
  (* Paths of depth 1 *)
  (* .b538 *)
  let actual = r.b538 in
  let expected = "1" in
  mark_test_run 4182;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4182 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a538 = a5381; b538 = b5381 } { a538 = a5382; b538 = b5382 } -> (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) a5381 a5382 && (fun a b -> String.equal (globalize a) (globalize b)) b5381 b5382) in
  let next_r = { a538 = #{ a186 = "100" }; b538 = "101" } in
  let r_expected = { a538 = #{ a186 = "0" }; b538 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a538 *)
  r.a538 <- next_r.a538;
  let r_expected = { r_expected with a538 = next_r.a538 } in
  mark_test_run 4183;
  let test = eq r r_expected in
  if not test then failwithf "test 4183 failed";
  Gc.compact ();
  (* .b538 *)
  r.b538 <- next_r.b538;
  let r_expected = { r_expected with b538 = next_r.b538 } in
  mark_test_run 4184;
  let test = eq r r_expected in
  if not test then failwithf "test 4184 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a538 = #{ a186 }; b538 } = r in
  let expected_a186 = "100" in
  mark_test_run 4185;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a186 a186 in
  if not test then failwithf "test 4185 failed";
  let expected_b538 = "101" in
  mark_test_run 4186;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b538 b538 in
  if not test then failwithf "test 4186 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a538; b538 } = r in
  let expected_a538 = #{ a186 = "100" } in
  mark_test_run 4187;
  let test = (fun #{ a186 = a1861 } #{ a186 = a1862 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1861 a1862) expected_a538 a538 in
  if not test then failwithf "test 4187 failed";
  let expected_b538 = "101" in
  mark_test_run 4188;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b538 b538 in
  if not test then failwithf "test 4188 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t539 = { #{ string; unit_u } }   *)
  (**************************************)
  let r = { a539 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a539 *)
  let actual = r.a539 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 4189;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4189 failed";
  (* Paths of depth 2 *)
  (* .a539.#a190 *)
  let actual = r.a539.#a190 in
  let expected = "0" in
  mark_test_run 4190;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4190 failed";
  (* .a539.#b190 *)
  let actual = r.a539.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4191;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4191 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a539 = a5391 } { a539 = a5392 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a5391 a5392) in
  let next_r = { a539 = #{ a190 = "100"; b190 = (unbox_unit ()) } } in
  let r_expected = { a539 = #{ a190 = "0"; b190 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a539 *)
  r.a539 <- next_r.a539;
  let r_expected = { r_expected with a539 = next_r.a539 } in
  mark_test_run 4192;
  let test = eq r r_expected in
  if not test then failwithf "test 4192 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a539 = #{ a190; b190 } } = r in
  let expected_a190 = "100" in
  mark_test_run 4193;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4193 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4194;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4194 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a539 } = r in
  let expected_a539 = #{ a190 = "100"; b190 = (unbox_unit ()) } in
  mark_test_run 4195;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) expected_a539 a539 in
  if not test then failwithf "test 4195 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t540 = { #{ string; unit_u }; unit_u }   *)
  (**********************************************)
  let r = { a540 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b540 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a540 *)
  let actual = r.a540 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 4196;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4196 failed";
  (* Paths of depth 2 *)
  (* .a540.#a190 *)
  let actual = r.a540.#a190 in
  let expected = "0" in
  mark_test_run 4197;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4197 failed";
  (* .a540.#b190 *)
  let actual = r.a540.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4198;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4198 failed";
  (* Paths of depth 1 *)
  (* .b540 *)
  let actual = r.b540 in
  let expected = (unbox_unit ()) in
  mark_test_run 4199;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4199 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a540 = a5401; b540 = b5401 } { a540 = a5402; b540 = b5402 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a5401 a5402 && (fun _ _ -> true) b5401 b5402) in
  let next_r = { a540 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b540 = (unbox_unit ()) } in
  let r_expected = { a540 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b540 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a540 *)
  r.a540 <- next_r.a540;
  let r_expected = { r_expected with a540 = next_r.a540 } in
  mark_test_run 4200;
  let test = eq r r_expected in
  if not test then failwithf "test 4200 failed";
  Gc.compact ();
  (* .b540 *)
  r.b540 <- next_r.b540;
  let r_expected = { r_expected with b540 = next_r.b540 } in
  mark_test_run 4201;
  let test = eq r r_expected in
  if not test then failwithf "test 4201 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a540 = #{ a190; b190 }; b540 } = r in
  let expected_a190 = "100" in
  mark_test_run 4202;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4202 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4203;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4203 failed";
  let expected_b540 = (unbox_unit ()) in
  mark_test_run 4204;
  let test = (fun _ _ -> true) expected_b540 b540 in
  if not test then failwithf "test 4204 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a540; b540 } = r in
  let expected_a540 = #{ a190 = "100"; b190 = (unbox_unit ()) } in
  mark_test_run 4205;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) expected_a540 a540 in
  if not test then failwithf "test 4205 failed";
  let expected_b540 = (unbox_unit ()) in
  mark_test_run 4206;
  let test = (fun _ _ -> true) expected_b540 b540 in
  if not test then failwithf "test 4206 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t541 = { #{ string; unit_u }; string }   *)
  (**********************************************)
  let r = { a541 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b541 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a541 *)
  let actual = r.a541 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 4207;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4207 failed";
  (* Paths of depth 2 *)
  (* .a541.#a190 *)
  let actual = r.a541.#a190 in
  let expected = "0" in
  mark_test_run 4208;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4208 failed";
  (* .a541.#b190 *)
  let actual = r.a541.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4209;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4209 failed";
  (* Paths of depth 1 *)
  (* .b541 *)
  let actual = r.b541 in
  let expected = "1" in
  mark_test_run 4210;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4210 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a541 = a5411; b541 = b5411 } { a541 = a5412; b541 = b5412 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a5411 a5412 && (fun a b -> String.equal (globalize a) (globalize b)) b5411 b5412) in
  let next_r = { a541 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b541 = "101" } in
  let r_expected = { a541 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b541 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a541 *)
  r.a541 <- next_r.a541;
  let r_expected = { r_expected with a541 = next_r.a541 } in
  mark_test_run 4211;
  let test = eq r r_expected in
  if not test then failwithf "test 4211 failed";
  Gc.compact ();
  (* .b541 *)
  r.b541 <- next_r.b541;
  let r_expected = { r_expected with b541 = next_r.b541 } in
  mark_test_run 4212;
  let test = eq r r_expected in
  if not test then failwithf "test 4212 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a541 = #{ a190; b190 }; b541 } = r in
  let expected_a190 = "100" in
  mark_test_run 4213;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4213 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4214;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4214 failed";
  let expected_b541 = "101" in
  mark_test_run 4215;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b541 b541 in
  if not test then failwithf "test 4215 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a541; b541 } = r in
  let expected_a541 = #{ a190 = "100"; b190 = (unbox_unit ()) } in
  mark_test_run 4216;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) expected_a541 a541 in
  if not test then failwithf "test 4216 failed";
  let expected_b541 = "101" in
  mark_test_run 4217;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b541 b541 in
  if not test then failwithf "test 4217 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t542 = { #{ string; string } }   *)
  (**************************************)
  let r = { a542 = #{ a192 = "0"; b192 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a542 *)
  let actual = r.a542 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 4218;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4218 failed";
  (* Paths of depth 2 *)
  (* .a542.#a192 *)
  let actual = r.a542.#a192 in
  let expected = "0" in
  mark_test_run 4219;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4219 failed";
  (* .a542.#b192 *)
  let actual = r.a542.#b192 in
  let expected = "1" in
  mark_test_run 4220;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4220 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a542 = a5421 } { a542 = a5422 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a5421 a5422) in
  let next_r = { a542 = #{ a192 = "100"; b192 = "101" } } in
  let r_expected = { a542 = #{ a192 = "0"; b192 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a542 *)
  r.a542 <- next_r.a542;
  let r_expected = { r_expected with a542 = next_r.a542 } in
  mark_test_run 4221;
  let test = eq r r_expected in
  if not test then failwithf "test 4221 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a542 = #{ a192; b192 } } = r in
  let expected_a192 = "100" in
  mark_test_run 4222;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4222 failed";
  let expected_b192 = "101" in
  mark_test_run 4223;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4223 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a542 } = r in
  let expected_a542 = #{ a192 = "100"; b192 = "101" } in
  mark_test_run 4224;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) expected_a542 a542 in
  if not test then failwithf "test 4224 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t543 = { #{ string; string }; unit_u }   *)
  (**********************************************)
  let r = { a543 = #{ a192 = "0"; b192 = "1" }; b543 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a543 *)
  let actual = r.a543 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 4225;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4225 failed";
  (* Paths of depth 2 *)
  (* .a543.#a192 *)
  let actual = r.a543.#a192 in
  let expected = "0" in
  mark_test_run 4226;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4226 failed";
  (* .a543.#b192 *)
  let actual = r.a543.#b192 in
  let expected = "1" in
  mark_test_run 4227;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4227 failed";
  (* Paths of depth 1 *)
  (* .b543 *)
  let actual = r.b543 in
  let expected = (unbox_unit ()) in
  mark_test_run 4228;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4228 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a543 = a5431; b543 = b5431 } { a543 = a5432; b543 = b5432 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a5431 a5432 && (fun _ _ -> true) b5431 b5432) in
  let next_r = { a543 = #{ a192 = "100"; b192 = "101" }; b543 = (unbox_unit ()) } in
  let r_expected = { a543 = #{ a192 = "0"; b192 = "1" }; b543 = (unbox_unit ()) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a543 *)
  r.a543 <- next_r.a543;
  let r_expected = { r_expected with a543 = next_r.a543 } in
  mark_test_run 4229;
  let test = eq r r_expected in
  if not test then failwithf "test 4229 failed";
  Gc.compact ();
  (* .b543 *)
  r.b543 <- next_r.b543;
  let r_expected = { r_expected with b543 = next_r.b543 } in
  mark_test_run 4230;
  let test = eq r r_expected in
  if not test then failwithf "test 4230 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a543 = #{ a192; b192 }; b543 } = r in
  let expected_a192 = "100" in
  mark_test_run 4231;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4231 failed";
  let expected_b192 = "101" in
  mark_test_run 4232;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4232 failed";
  let expected_b543 = (unbox_unit ()) in
  mark_test_run 4233;
  let test = (fun _ _ -> true) expected_b543 b543 in
  if not test then failwithf "test 4233 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a543; b543 } = r in
  let expected_a543 = #{ a192 = "100"; b192 = "101" } in
  mark_test_run 4234;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) expected_a543 a543 in
  if not test then failwithf "test 4234 failed";
  let expected_b543 = (unbox_unit ()) in
  mark_test_run 4235;
  let test = (fun _ _ -> true) expected_b543 b543 in
  if not test then failwithf "test 4235 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t544 = { #{ string; string }; string }   *)
  (**********************************************)
  let r = { a544 = #{ a192 = "0"; b192 = "1" }; b544 = "2" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a544 *)
  let actual = r.a544 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 4236;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4236 failed";
  (* Paths of depth 2 *)
  (* .a544.#a192 *)
  let actual = r.a544.#a192 in
  let expected = "0" in
  mark_test_run 4237;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4237 failed";
  (* .a544.#b192 *)
  let actual = r.a544.#b192 in
  let expected = "1" in
  mark_test_run 4238;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4238 failed";
  (* Paths of depth 1 *)
  (* .b544 *)
  let actual = r.b544 in
  let expected = "2" in
  mark_test_run 4239;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4239 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a544 = a5441; b544 = b5441 } { a544 = a5442; b544 = b5442 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a5441 a5442 && (fun a b -> String.equal (globalize a) (globalize b)) b5441 b5442) in
  let next_r = { a544 = #{ a192 = "100"; b192 = "101" }; b544 = "102" } in
  let r_expected = { a544 = #{ a192 = "0"; b192 = "1" }; b544 = "2" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a544 *)
  r.a544 <- next_r.a544;
  let r_expected = { r_expected with a544 = next_r.a544 } in
  mark_test_run 4240;
  let test = eq r r_expected in
  if not test then failwithf "test 4240 failed";
  Gc.compact ();
  (* .b544 *)
  r.b544 <- next_r.b544;
  let r_expected = { r_expected with b544 = next_r.b544 } in
  mark_test_run 4241;
  let test = eq r r_expected in
  if not test then failwithf "test 4241 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a544 = #{ a192; b192 }; b544 } = r in
  let expected_a192 = "100" in
  mark_test_run 4242;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4242 failed";
  let expected_b192 = "101" in
  mark_test_run 4243;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4243 failed";
  let expected_b544 = "102" in
  mark_test_run 4244;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b544 b544 in
  if not test then failwithf "test 4244 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a544; b544 } = r in
  let expected_a544 = #{ a192 = "100"; b192 = "101" } in
  mark_test_run 4245;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) expected_a544 a544 in
  if not test then failwithf "test 4245 failed";
  let expected_b544 = "102" in
  mark_test_run 4246;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b544 b544 in
  if not test then failwithf "test 4246 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t546 = { #{ string; #{ unit_u; unit_u } } }   *)
  (***************************************************)
  let r = { a546 = #{ a545 = "0"; b545 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a546 *)
  let actual = r.a546 in
  let expected = #{ a545 = "0"; b545 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  mark_test_run 4247;
  let test = (fun #{ a545 = a5451; b545 = b5451 } #{ a545 = a5452; b545 = b5452 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5451 a5452 && (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) b5451 b5452) actual expected in
  if not test then failwithf "test 4247 failed";
  (* Paths of depth 2 *)
  (* .a546.#a545 *)
  let actual = r.a546.#a545 in
  let expected = "0" in
  mark_test_run 4248;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4248 failed";
  (* .a546.#b545 *)
  let actual = r.a546.#b545 in
  let expected = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 4249;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) actual expected in
  if not test then failwithf "test 4249 failed";
  (* Paths of depth 3 *)
  (* .a546.#b545.#a290 *)
  let actual = r.a546.#b545.#a290 in
  let expected = (unbox_unit ()) in
  mark_test_run 4250;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4250 failed";
  (* .a546.#b545.#b290 *)
  let actual = r.a546.#b545.#b290 in
  let expected = (unbox_unit ()) in
  mark_test_run 4251;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4251 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a546 = a5461 } { a546 = a5462 } -> (fun #{ a545 = a5451; b545 = b5451 } #{ a545 = a5452; b545 = b5452 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5451 a5452 && (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) b5451 b5452) a5461 a5462) in
  let next_r = { a546 = #{ a545 = "100"; b545 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  let r_expected = { a546 = #{ a545 = "0"; b545 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a546 *)
  r.a546 <- next_r.a546;
  let r_expected = { r_expected with a546 = next_r.a546 } in
  mark_test_run 4252;
  let test = eq r r_expected in
  if not test then failwithf "test 4252 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a546 = #{ a545; b545 = #{ a290; b290 } } } = r in
  let expected_a545 = "100" in
  mark_test_run 4253;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a545 a545 in
  if not test then failwithf "test 4253 failed";
  let expected_a290 = (unbox_unit ()) in
  mark_test_run 4254;
  let test = (fun _ _ -> true) expected_a290 a290 in
  if not test then failwithf "test 4254 failed";
  let expected_b290 = (unbox_unit ()) in
  mark_test_run 4255;
  let test = (fun _ _ -> true) expected_b290 b290 in
  if not test then failwithf "test 4255 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a546 } = r in
  let expected_a546 = #{ a545 = "100"; b545 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } } in
  mark_test_run 4256;
  let test = (fun #{ a545 = a5451; b545 = b5451 } #{ a545 = a5452; b545 = b5452 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5451 a5452 && (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) b5451 b5452) expected_a546 a546 in
  if not test then failwithf "test 4256 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t548 = { #{ string; #{ unit_u; string } } }   *)
  (***************************************************)
  let r = { a548 = #{ a547 = "0"; b547 = #{ a184 = (unbox_unit ()); b184 = "1" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a548 *)
  let actual = r.a548 in
  let expected = #{ a547 = "0"; b547 = #{ a184 = (unbox_unit ()); b184 = "1" } } in
  mark_test_run 4257;
  let test = (fun #{ a547 = a5471; b547 = b5471 } #{ a547 = a5472; b547 = b5472 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5471 a5472 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b5471 b5472) actual expected in
  if not test then failwithf "test 4257 failed";
  (* Paths of depth 2 *)
  (* .a548.#a547 *)
  let actual = r.a548.#a547 in
  let expected = "0" in
  mark_test_run 4258;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4258 failed";
  (* .a548.#b547 *)
  let actual = r.a548.#b547 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "1" } in
  mark_test_run 4259;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 4259 failed";
  (* Paths of depth 3 *)
  (* .a548.#b547.#a184 *)
  let actual = r.a548.#b547.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 4260;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4260 failed";
  (* .a548.#b547.#b184 *)
  let actual = r.a548.#b547.#b184 in
  let expected = "1" in
  mark_test_run 4261;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4261 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a548 = a5481 } { a548 = a5482 } -> (fun #{ a547 = a5471; b547 = b5471 } #{ a547 = a5472; b547 = b5472 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5471 a5472 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b5471 b5472) a5481 a5482) in
  let next_r = { a548 = #{ a547 = "100"; b547 = #{ a184 = (unbox_unit ()); b184 = "101" } } } in
  let r_expected = { a548 = #{ a547 = "0"; b547 = #{ a184 = (unbox_unit ()); b184 = "1" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a548 *)
  r.a548 <- next_r.a548;
  let r_expected = { r_expected with a548 = next_r.a548 } in
  mark_test_run 4262;
  let test = eq r r_expected in
  if not test then failwithf "test 4262 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a548 = #{ a547; b547 = #{ a184; b184 } } } = r in
  let expected_a547 = "100" in
  mark_test_run 4263;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a547 a547 in
  if not test then failwithf "test 4263 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 4264;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 4264 failed";
  let expected_b184 = "101" in
  mark_test_run 4265;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 4265 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a548 } = r in
  let expected_a548 = #{ a547 = "100"; b547 = #{ a184 = (unbox_unit ()); b184 = "101" } } in
  mark_test_run 4266;
  let test = (fun #{ a547 = a5471; b547 = b5471 } #{ a547 = a5472; b547 = b5472 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5471 a5472 && (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) b5471 b5472) expected_a548 a548 in
  if not test then failwithf "test 4266 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t550 = { #{ string; #{ string; unit_u } } }   *)
  (***************************************************)
  let r = { a550 = #{ a549 = "0"; b549 = #{ a190 = "1"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a550 *)
  let actual = r.a550 in
  let expected = #{ a549 = "0"; b549 = #{ a190 = "1"; b190 = (unbox_unit ()) } } in
  mark_test_run 4267;
  let test = (fun #{ a549 = a5491; b549 = b5491 } #{ a549 = a5492; b549 = b5492 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5491 a5492 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b5491 b5492) actual expected in
  if not test then failwithf "test 4267 failed";
  (* Paths of depth 2 *)
  (* .a550.#a549 *)
  let actual = r.a550.#a549 in
  let expected = "0" in
  mark_test_run 4268;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4268 failed";
  (* .a550.#b549 *)
  let actual = r.a550.#b549 in
  let expected = #{ a190 = "1"; b190 = (unbox_unit ()) } in
  mark_test_run 4269;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4269 failed";
  (* Paths of depth 3 *)
  (* .a550.#b549.#a190 *)
  let actual = r.a550.#b549.#a190 in
  let expected = "1" in
  mark_test_run 4270;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4270 failed";
  (* .a550.#b549.#b190 *)
  let actual = r.a550.#b549.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4271;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4271 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a550 = a5501 } { a550 = a5502 } -> (fun #{ a549 = a5491; b549 = b5491 } #{ a549 = a5492; b549 = b5492 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5491 a5492 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b5491 b5492) a5501 a5502) in
  let next_r = { a550 = #{ a549 = "100"; b549 = #{ a190 = "101"; b190 = (unbox_unit ()) } } } in
  let r_expected = { a550 = #{ a549 = "0"; b549 = #{ a190 = "1"; b190 = (unbox_unit ()) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a550 *)
  r.a550 <- next_r.a550;
  let r_expected = { r_expected with a550 = next_r.a550 } in
  mark_test_run 4272;
  let test = eq r r_expected in
  if not test then failwithf "test 4272 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a550 = #{ a549; b549 = #{ a190; b190 } } } = r in
  let expected_a549 = "100" in
  mark_test_run 4273;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a549 a549 in
  if not test then failwithf "test 4273 failed";
  let expected_a190 = "101" in
  mark_test_run 4274;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4274 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4275;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4275 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a550 } = r in
  let expected_a550 = #{ a549 = "100"; b549 = #{ a190 = "101"; b190 = (unbox_unit ()) } } in
  mark_test_run 4276;
  let test = (fun #{ a549 = a5491; b549 = b5491 } #{ a549 = a5492; b549 = b5492 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5491 a5492 && (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) b5491 b5492) expected_a550 a550 in
  if not test then failwithf "test 4276 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t552 = { #{ string; #{ string; string } } }   *)
  (***************************************************)
  let r = { a552 = #{ a551 = "0"; b551 = #{ a192 = "1"; b192 = "2" } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a552 *)
  let actual = r.a552 in
  let expected = #{ a551 = "0"; b551 = #{ a192 = "1"; b192 = "2" } } in
  mark_test_run 4277;
  let test = (fun #{ a551 = a5511; b551 = b5511 } #{ a551 = a5512; b551 = b5512 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5511 a5512 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b5511 b5512) actual expected in
  if not test then failwithf "test 4277 failed";
  (* Paths of depth 2 *)
  (* .a552.#a551 *)
  let actual = r.a552.#a551 in
  let expected = "0" in
  mark_test_run 4278;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4278 failed";
  (* .a552.#b551 *)
  let actual = r.a552.#b551 in
  let expected = #{ a192 = "1"; b192 = "2" } in
  mark_test_run 4279;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4279 failed";
  (* Paths of depth 3 *)
  (* .a552.#b551.#a192 *)
  let actual = r.a552.#b551.#a192 in
  let expected = "1" in
  mark_test_run 4280;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4280 failed";
  (* .a552.#b551.#b192 *)
  let actual = r.a552.#b551.#b192 in
  let expected = "2" in
  mark_test_run 4281;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4281 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a552 = a5521 } { a552 = a5522 } -> (fun #{ a551 = a5511; b551 = b5511 } #{ a551 = a5512; b551 = b5512 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5511 a5512 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b5511 b5512) a5521 a5522) in
  let next_r = { a552 = #{ a551 = "100"; b551 = #{ a192 = "101"; b192 = "102" } } } in
  let r_expected = { a552 = #{ a551 = "0"; b551 = #{ a192 = "1"; b192 = "2" } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a552 *)
  r.a552 <- next_r.a552;
  let r_expected = { r_expected with a552 = next_r.a552 } in
  mark_test_run 4282;
  let test = eq r r_expected in
  if not test then failwithf "test 4282 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a552 = #{ a551; b551 = #{ a192; b192 } } } = r in
  let expected_a551 = "100" in
  mark_test_run 4283;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a551 a551 in
  if not test then failwithf "test 4283 failed";
  let expected_a192 = "101" in
  mark_test_run 4284;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4284 failed";
  let expected_b192 = "102" in
  mark_test_run 4285;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4285 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a552 } = r in
  let expected_a552 = #{ a551 = "100"; b551 = #{ a192 = "101"; b192 = "102" } } in
  mark_test_run 4286;
  let test = (fun #{ a551 = a5511; b551 = b5511 } #{ a551 = a5512; b551 = b5512 } -> (fun a b -> String.equal (globalize a) (globalize b)) a5511 a5512 && (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) b5511 b5512) expected_a552 a552 in
  if not test then failwithf "test 4286 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t553 = { #{ int64x2# } }   *)
  (********************************)
  let r = { a553 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a553 *)
  let actual = r.a553 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  mark_test_run 4287;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 4287 failed";
  (* Paths of depth 2 *)
  (* .a553.#a45 *)
  let actual = r.a553.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4288;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4288 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a553 = a5531 } { a553 = a5532 } -> (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) a5531 a5532) in
  let next_r = { a553 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } } in
  let r_expected = { a553 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a553 *)
  r.a553 <- next_r.a553;
  let r_expected = { r_expected with a553 = next_r.a553 } in
  mark_test_run 4289;
  let test = eq r r_expected in
  if not test then failwithf "test 4289 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a553 = #{ a45 } } = r in
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4290;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 4290 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a553 } = r in
  let expected_a553 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } in
  mark_test_run 4291;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) expected_a553 a553 in
  if not test then failwithf "test 4291 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t554 = { #{ int64x2# }; int }   *)
  (*************************************)
  let r = { a554 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b554 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a554 *)
  let actual = r.a554 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  mark_test_run 4292;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 4292 failed";
  (* Paths of depth 2 *)
  (* .a554.#a45 *)
  let actual = r.a554.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4293;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4293 failed";
  (* Paths of depth 1 *)
  (* .b554 *)
  let actual = r.b554 in
  let expected = 2 in
  mark_test_run 4294;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4294 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a554 = a5541; b554 = b5541 } { a554 = a5542; b554 = b5542 } -> (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) a5541 a5542 && (fun a b -> Int.equal a b) b5541 b5542) in
  let next_r = { a554 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) }; b554 = 102 } in
  let r_expected = { a554 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b554 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a554 *)
  r.a554 <- next_r.a554;
  let r_expected = { r_expected with a554 = next_r.a554 } in
  mark_test_run 4295;
  let test = eq r r_expected in
  if not test then failwithf "test 4295 failed";
  Gc.compact ();
  (* .b554 *)
  r.b554 <- next_r.b554;
  let r_expected = { r_expected with b554 = next_r.b554 } in
  mark_test_run 4296;
  let test = eq r r_expected in
  if not test then failwithf "test 4296 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a554 = #{ a45 }; b554 } = r in
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4297;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 4297 failed";
  let expected_b554 = 102 in
  mark_test_run 4298;
  let test = (fun a b -> Int.equal a b) expected_b554 b554 in
  if not test then failwithf "test 4298 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a554; b554 } = r in
  let expected_a554 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } in
  mark_test_run 4299;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) expected_a554 a554 in
  if not test then failwithf "test 4299 failed";
  let expected_b554 = 102 in
  mark_test_run 4300;
  let test = (fun a b -> Int.equal a b) expected_b554 b554 in
  if not test then failwithf "test 4300 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t555 = { #{ int64x2# }; int64x2# }   *)
  (******************************************)
  let r = { a555 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b555 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a555 *)
  let actual = r.a555 in
  let expected = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  mark_test_run 4301;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) actual expected in
  if not test then failwithf "test 4301 failed";
  (* Paths of depth 2 *)
  (* .a555.#a45 *)
  let actual = r.a555.#a45 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4302;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4302 failed";
  (* Paths of depth 1 *)
  (* .b555 *)
  let actual = r.b555 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4303;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4303 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a555 = a5551; b555 = b5551 } { a555 = a5552; b555 = b5552 } -> (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) a5551 a5552 && int64x2_u_equal b5551 b5552) in
  let next_r = { a555 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) }; b555 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  let r_expected = { a555 = #{ a45 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b555 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a555 *)
  r.a555 <- next_r.a555;
  let r_expected = { r_expected with a555 = next_r.a555 } in
  mark_test_run 4304;
  let test = eq r r_expected in
  if not test then failwithf "test 4304 failed";
  Gc.compact ();
  (* .b555 *)
  r.b555 <- next_r.b555;
  let r_expected = { r_expected with b555 = next_r.b555 } in
  mark_test_run 4305;
  let test = eq r r_expected in
  if not test then failwithf "test 4305 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a555 = #{ a45 }; b555 } = r in
  let expected_a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4306;
  let test = int64x2_u_equal expected_a45 a45 in
  if not test then failwithf "test 4306 failed";
  let expected_b555 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4307;
  let test = int64x2_u_equal expected_b555 b555 in
  if not test then failwithf "test 4307 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a555; b555 } = r in
  let expected_a555 = #{ a45 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } in
  mark_test_run 4308;
  let test = (fun #{ a45 = a451 } #{ a45 = a452 } -> int64x2_u_equal a451 a452) expected_a555 a555 in
  if not test then failwithf "test 4308 failed";
  let expected_b555 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4309;
  let test = int64x2_u_equal expected_b555 b555 in
  if not test then failwithf "test 4309 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t556 = { #{ int64x2#; int } }   *)
  (*************************************)
  let r = { a556 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a556 *)
  let actual = r.a556 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } in
  mark_test_run 4310;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4310 failed";
  (* Paths of depth 2 *)
  (* .a556.#a67 *)
  let actual = r.a556.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4311;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4311 failed";
  (* .a556.#b67 *)
  let actual = r.a556.#b67 in
  let expected = 2 in
  mark_test_run 4312;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4312 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a556 = a5561 } { a556 = a5562 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a5561 a5562) in
  let next_r = { a556 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 } } in
  let r_expected = { a556 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a556 *)
  r.a556 <- next_r.a556;
  let r_expected = { r_expected with a556 = next_r.a556 } in
  mark_test_run 4313;
  let test = eq r r_expected in
  if not test then failwithf "test 4313 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a556 = #{ a67; b67 } } = r in
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4314;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4314 failed";
  let expected_b67 = 102 in
  mark_test_run 4315;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4315 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a556 } = r in
  let expected_a556 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 } in
  mark_test_run 4316;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) expected_a556 a556 in
  if not test then failwithf "test 4316 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t557 = { #{ int64x2#; int }; int }   *)
  (******************************************)
  let r = { a557 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b557 = 3 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a557 *)
  let actual = r.a557 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } in
  mark_test_run 4317;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4317 failed";
  (* Paths of depth 2 *)
  (* .a557.#a67 *)
  let actual = r.a557.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4318;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4318 failed";
  (* .a557.#b67 *)
  let actual = r.a557.#b67 in
  let expected = 2 in
  mark_test_run 4319;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4319 failed";
  (* Paths of depth 1 *)
  (* .b557 *)
  let actual = r.b557 in
  let expected = 3 in
  mark_test_run 4320;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4320 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a557 = a5571; b557 = b5571 } { a557 = a5572; b557 = b5572 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a5571 a5572 && (fun a b -> Int.equal a b) b5571 b5572) in
  let next_r = { a557 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b557 = 103 } in
  let r_expected = { a557 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b557 = 3 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a557 *)
  r.a557 <- next_r.a557;
  let r_expected = { r_expected with a557 = next_r.a557 } in
  mark_test_run 4321;
  let test = eq r r_expected in
  if not test then failwithf "test 4321 failed";
  Gc.compact ();
  (* .b557 *)
  r.b557 <- next_r.b557;
  let r_expected = { r_expected with b557 = next_r.b557 } in
  mark_test_run 4322;
  let test = eq r r_expected in
  if not test then failwithf "test 4322 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a557 = #{ a67; b67 }; b557 } = r in
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4323;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4323 failed";
  let expected_b67 = 102 in
  mark_test_run 4324;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4324 failed";
  let expected_b557 = 103 in
  mark_test_run 4325;
  let test = (fun a b -> Int.equal a b) expected_b557 b557 in
  if not test then failwithf "test 4325 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a557; b557 } = r in
  let expected_a557 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 } in
  mark_test_run 4326;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) expected_a557 a557 in
  if not test then failwithf "test 4326 failed";
  let expected_b557 = 103 in
  mark_test_run 4327;
  let test = (fun a b -> Int.equal a b) expected_b557 b557 in
  if not test then failwithf "test 4327 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t558 = { #{ int64x2#; int }; int64x2# }   *)
  (***********************************************)
  let r = { a558 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b558 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a558 *)
  let actual = r.a558 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } in
  mark_test_run 4328;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4328 failed";
  (* Paths of depth 2 *)
  (* .a558.#a67 *)
  let actual = r.a558.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4329;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4329 failed";
  (* .a558.#b67 *)
  let actual = r.a558.#b67 in
  let expected = 2 in
  mark_test_run 4330;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4330 failed";
  (* Paths of depth 1 *)
  (* .b558 *)
  let actual = r.b558 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 4331;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4331 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a558 = a5581; b558 = b5581 } { a558 = a5582; b558 = b5582 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a5581 a5582 && int64x2_u_equal b5581 b5582) in
  let next_r = { a558 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b558 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  let r_expected = { a558 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b558 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a558 *)
  r.a558 <- next_r.a558;
  let r_expected = { r_expected with a558 = next_r.a558 } in
  mark_test_run 4332;
  let test = eq r r_expected in
  if not test then failwithf "test 4332 failed";
  Gc.compact ();
  (* .b558 *)
  r.b558 <- next_r.b558;
  let r_expected = { r_expected with b558 = next_r.b558 } in
  mark_test_run 4333;
  let test = eq r r_expected in
  if not test then failwithf "test 4333 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a558 = #{ a67; b67 }; b558 } = r in
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4334;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4334 failed";
  let expected_b67 = 102 in
  mark_test_run 4335;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4335 failed";
  let expected_b558 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 4336;
  let test = int64x2_u_equal expected_b558 b558 in
  if not test then failwithf "test 4336 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a558; b558 } = r in
  let expected_a558 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 } in
  mark_test_run 4337;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) expected_a558 a558 in
  if not test then failwithf "test 4337 failed";
  let expected_b558 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 4338;
  let test = int64x2_u_equal expected_b558 b558 in
  if not test then failwithf "test 4338 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************************)
  (*   t561 = { #{ int64x2#; string }; #{ int64; float# } }   *)
  (************************************************************)
  let r = { a561 = #{ a559 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b559 = "2" }; b561 = #{ a560 = 3L; b560 = #4. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a561 *)
  let actual = r.a561 in
  let expected = #{ a559 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b559 = "2" } in
  mark_test_run 4339;
  let test = (fun #{ a559 = a5591; b559 = b5591 } #{ a559 = a5592; b559 = b5592 } -> int64x2_u_equal a5591 a5592 && (fun a b -> String.equal (globalize a) (globalize b)) b5591 b5592) actual expected in
  if not test then failwithf "test 4339 failed";
  (* Paths of depth 2 *)
  (* .a561.#a559 *)
  let actual = r.a561.#a559 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4340;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4340 failed";
  (* .a561.#b559 *)
  let actual = r.a561.#b559 in
  let expected = "2" in
  mark_test_run 4341;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4341 failed";
  (* Paths of depth 1 *)
  (* .b561 *)
  let actual = r.b561 in
  let expected = #{ a560 = 3L; b560 = #4. } in
  mark_test_run 4342;
  let test = (fun #{ a560 = a5601; b560 = b5601 } #{ a560 = a5602; b560 = b5602 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a5601 a5602 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5601 b5602) actual expected in
  if not test then failwithf "test 4342 failed";
  (* Paths of depth 2 *)
  (* .b561.#a560 *)
  let actual = r.b561.#a560 in
  let expected = 3L in
  mark_test_run 4343;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4343 failed";
  (* .b561.#b560 *)
  let actual = r.b561.#b560 in
  let expected = #4. in
  mark_test_run 4344;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4344 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a561 = a5611; b561 = b5611 } { a561 = a5612; b561 = b5612 } -> (fun #{ a559 = a5591; b559 = b5591 } #{ a559 = a5592; b559 = b5592 } -> int64x2_u_equal a5591 a5592 && (fun a b -> String.equal (globalize a) (globalize b)) b5591 b5592) a5611 a5612 && (fun #{ a560 = a5601; b560 = b5601 } #{ a560 = a5602; b560 = b5602 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a5601 a5602 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5601 b5602) b5611 b5612) in
  let next_r = { a561 = #{ a559 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b559 = "102" }; b561 = #{ a560 = 103L; b560 = #104. } } in
  let r_expected = { a561 = #{ a559 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b559 = "2" }; b561 = #{ a560 = 3L; b560 = #4. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a561 *)
  r.a561 <- next_r.a561;
  let r_expected = { r_expected with a561 = next_r.a561 } in
  mark_test_run 4345;
  let test = eq r r_expected in
  if not test then failwithf "test 4345 failed";
  Gc.compact ();
  (* .b561 *)
  r.b561 <- next_r.b561;
  let r_expected = { r_expected with b561 = next_r.b561 } in
  mark_test_run 4346;
  let test = eq r r_expected in
  if not test then failwithf "test 4346 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a561 = #{ a559; b559 }; b561 = #{ a560; b560 } } = r in
  let expected_a559 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4347;
  let test = int64x2_u_equal expected_a559 a559 in
  if not test then failwithf "test 4347 failed";
  let expected_b559 = "102" in
  mark_test_run 4348;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b559 b559 in
  if not test then failwithf "test 4348 failed";
  let expected_a560 = 103L in
  mark_test_run 4349;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a560 a560 in
  if not test then failwithf "test 4349 failed";
  let expected_b560 = #104. in
  mark_test_run 4350;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b560 b560 in
  if not test then failwithf "test 4350 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a561; b561 } = r in
  let expected_a561 = #{ a559 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b559 = "102" } in
  mark_test_run 4351;
  let test = (fun #{ a559 = a5591; b559 = b5591 } #{ a559 = a5592; b559 = b5592 } -> int64x2_u_equal a5591 a5592 && (fun a b -> String.equal (globalize a) (globalize b)) b5591 b5592) expected_a561 a561 in
  if not test then failwithf "test 4351 failed";
  let expected_b561 = #{ a560 = 103L; b560 = #104. } in
  mark_test_run 4352;
  let test = (fun #{ a560 = a5601; b560 = b5601 } #{ a560 = a5602; b560 = b5602 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a5601 a5602 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b5601 b5602) expected_b561 b561 in
  if not test then failwithf "test 4352 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t562 = { #{ int64x2#; int64x2# } }   *)
  (******************************************)
  let r = { a562 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a562 *)
  let actual = r.a562 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4353;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4353 failed";
  (* Paths of depth 2 *)
  (* .a562.#a69 *)
  let actual = r.a562.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4354;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4354 failed";
  (* .a562.#b69 *)
  let actual = r.a562.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4355;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4355 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a562 = a5621 } { a562 = a5622 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a5621 a5622) in
  let next_r = { a562 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  let r_expected = { a562 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a562 *)
  r.a562 <- next_r.a562;
  let r_expected = { r_expected with a562 = next_r.a562 } in
  mark_test_run 4356;
  let test = eq r r_expected in
  if not test then failwithf "test 4356 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a562 = #{ a69; b69 } } = r in
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4357;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4357 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4358;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4358 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a562 } = r in
  let expected_a562 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 4359;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) expected_a562 a562 in
  if not test then failwithf "test 4359 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t563 = { #{ int64x2#; int64x2# }; int }   *)
  (***********************************************)
  let r = { a563 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b563 = 4 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a563 *)
  let actual = r.a563 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4360;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4360 failed";
  (* Paths of depth 2 *)
  (* .a563.#a69 *)
  let actual = r.a563.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4361;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4361 failed";
  (* .a563.#b69 *)
  let actual = r.a563.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4362;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4362 failed";
  (* Paths of depth 1 *)
  (* .b563 *)
  let actual = r.b563 in
  let expected = 4 in
  mark_test_run 4363;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4363 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a563 = a5631; b563 = b5631 } { a563 = a5632; b563 = b5632 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a5631 a5632 && (fun a b -> Int.equal a b) b5631 b5632) in
  let next_r = { a563 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b563 = 104 } in
  let r_expected = { a563 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b563 = 4 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a563 *)
  r.a563 <- next_r.a563;
  let r_expected = { r_expected with a563 = next_r.a563 } in
  mark_test_run 4364;
  let test = eq r r_expected in
  if not test then failwithf "test 4364 failed";
  Gc.compact ();
  (* .b563 *)
  r.b563 <- next_r.b563;
  let r_expected = { r_expected with b563 = next_r.b563 } in
  mark_test_run 4365;
  let test = eq r r_expected in
  if not test then failwithf "test 4365 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a563 = #{ a69; b69 }; b563 } = r in
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4366;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4366 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4367;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4367 failed";
  let expected_b563 = 104 in
  mark_test_run 4368;
  let test = (fun a b -> Int.equal a b) expected_b563 b563 in
  if not test then failwithf "test 4368 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a563; b563 } = r in
  let expected_a563 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 4369;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) expected_a563 a563 in
  if not test then failwithf "test 4369 failed";
  let expected_b563 = 104 in
  mark_test_run 4370;
  let test = (fun a b -> Int.equal a b) expected_b563 b563 in
  if not test then failwithf "test 4370 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t564 = { #{ int64x2#; int64x2# }; int64x2# }   *)
  (****************************************************)
  let r = { a564 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b564 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a564 *)
  let actual = r.a564 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4371;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4371 failed";
  (* Paths of depth 2 *)
  (* .a564.#a69 *)
  let actual = r.a564.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4372;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4372 failed";
  (* .a564.#b69 *)
  let actual = r.a564.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4373;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4373 failed";
  (* Paths of depth 1 *)
  (* .b564 *)
  let actual = r.b564 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 4374;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4374 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a564 = a5641; b564 = b5641 } { a564 = a5642; b564 = b5642 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a5641 a5642 && int64x2_u_equal b5641 b5642) in
  let next_r = { a564 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b564 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } in
  let r_expected = { a564 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b564 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a564 *)
  r.a564 <- next_r.a564;
  let r_expected = { r_expected with a564 = next_r.a564 } in
  mark_test_run 4375;
  let test = eq r r_expected in
  if not test then failwithf "test 4375 failed";
  Gc.compact ();
  (* .b564 *)
  r.b564 <- next_r.b564;
  let r_expected = { r_expected with b564 = next_r.b564 } in
  mark_test_run 4376;
  let test = eq r r_expected in
  if not test then failwithf "test 4376 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a564 = #{ a69; b69 }; b564 } = r in
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4377;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4377 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4378;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4378 failed";
  let expected_b564 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 4379;
  let test = int64x2_u_equal expected_b564 b564 in
  if not test then failwithf "test 4379 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a564; b564 } = r in
  let expected_a564 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 4380;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) expected_a564 a564 in
  if not test then failwithf "test 4380 failed";
  let expected_b564 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 4381;
  let test = int64x2_u_equal expected_b564 b564 in
  if not test then failwithf "test 4381 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t566 = { #{ int64x2#; #{ int; int } } }   *)
  (***********************************************)
  let r = { a566 = #{ a565 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b565 = #{ a29 = 2; b29 = 3 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a566 *)
  let actual = r.a566 in
  let expected = #{ a565 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b565 = #{ a29 = 2; b29 = 3 } } in
  mark_test_run 4382;
  let test = (fun #{ a565 = a5651; b565 = b5651 } #{ a565 = a5652; b565 = b5652 } -> int64x2_u_equal a5651 a5652 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5651 b5652) actual expected in
  if not test then failwithf "test 4382 failed";
  (* Paths of depth 2 *)
  (* .a566.#a565 *)
  let actual = r.a566.#a565 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4383;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4383 failed";
  (* .a566.#b565 *)
  let actual = r.a566.#b565 in
  let expected = #{ a29 = 2; b29 = 3 } in
  mark_test_run 4384;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 4384 failed";
  (* Paths of depth 3 *)
  (* .a566.#b565.#a29 *)
  let actual = r.a566.#b565.#a29 in
  let expected = 2 in
  mark_test_run 4385;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4385 failed";
  (* .a566.#b565.#b29 *)
  let actual = r.a566.#b565.#b29 in
  let expected = 3 in
  mark_test_run 4386;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4386 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a566 = a5661 } { a566 = a5662 } -> (fun #{ a565 = a5651; b565 = b5651 } #{ a565 = a5652; b565 = b5652 } -> int64x2_u_equal a5651 a5652 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5651 b5652) a5661 a5662) in
  let next_r = { a566 = #{ a565 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b565 = #{ a29 = 102; b29 = 103 } } } in
  let r_expected = { a566 = #{ a565 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b565 = #{ a29 = 2; b29 = 3 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a566 *)
  r.a566 <- next_r.a566;
  let r_expected = { r_expected with a566 = next_r.a566 } in
  mark_test_run 4387;
  let test = eq r r_expected in
  if not test then failwithf "test 4387 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a566 = #{ a565; b565 = #{ a29; b29 } } } = r in
  let expected_a565 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4388;
  let test = int64x2_u_equal expected_a565 a565 in
  if not test then failwithf "test 4388 failed";
  let expected_a29 = 102 in
  mark_test_run 4389;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 4389 failed";
  let expected_b29 = 103 in
  mark_test_run 4390;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 4390 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a566 } = r in
  let expected_a566 = #{ a565 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b565 = #{ a29 = 102; b29 = 103 } } in
  mark_test_run 4391;
  let test = (fun #{ a565 = a5651; b565 = b5651 } #{ a565 = a5652; b565 = b5652 } -> int64x2_u_equal a5651 a5652 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) b5651 b5652) expected_a566 a566 in
  if not test then failwithf "test 4391 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t568 = { #{ int64x2#; #{ int; int64x2# } } }   *)
  (****************************************************)
  let r = { a568 = #{ a567 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b567 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a568 *)
  let actual = r.a568 in
  let expected = #{ a567 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b567 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  mark_test_run 4392;
  let test = (fun #{ a567 = a5671; b567 = b5671 } #{ a567 = a5672; b567 = b5672 } -> int64x2_u_equal a5671 a5672 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b5671 b5672) actual expected in
  if not test then failwithf "test 4392 failed";
  (* Paths of depth 2 *)
  (* .a568.#a567 *)
  let actual = r.a568.#a567 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4393;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4393 failed";
  (* .a568.#b567 *)
  let actual = r.a568.#b567 in
  let expected = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 4394;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 4394 failed";
  (* Paths of depth 3 *)
  (* .a568.#b567.#a35 *)
  let actual = r.a568.#b567.#a35 in
  let expected = 2 in
  mark_test_run 4395;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4395 failed";
  (* .a568.#b567.#b35 *)
  let actual = r.a568.#b567.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 4396;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4396 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a568 = a5681 } { a568 = a5682 } -> (fun #{ a567 = a5671; b567 = b5671 } #{ a567 = a5672; b567 = b5672 } -> int64x2_u_equal a5671 a5672 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b5671 b5672) a5681 a5682) in
  let next_r = { a568 = #{ a567 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b567 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } } in
  let r_expected = { a568 = #{ a567 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b567 = #{ a35 = 2; b35 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a568 *)
  r.a568 <- next_r.a568;
  let r_expected = { r_expected with a568 = next_r.a568 } in
  mark_test_run 4397;
  let test = eq r r_expected in
  if not test then failwithf "test 4397 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a568 = #{ a567; b567 = #{ a35; b35 } } } = r in
  let expected_a567 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4398;
  let test = int64x2_u_equal expected_a567 a567 in
  if not test then failwithf "test 4398 failed";
  let expected_a35 = 102 in
  mark_test_run 4399;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 4399 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 4400;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 4400 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a568 } = r in
  let expected_a568 = #{ a567 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b567 = #{ a35 = 102; b35 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  mark_test_run 4401;
  let test = (fun #{ a567 = a5671; b567 = b5671 } #{ a567 = a5672; b567 = b5672 } -> int64x2_u_equal a5671 a5672 && (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) b5671 b5672) expected_a568 a568 in
  if not test then failwithf "test 4401 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t570 = { #{ int64x2#; #{ int64x2#; int } } }   *)
  (****************************************************)
  let r = { a570 = #{ a569 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b569 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a570 *)
  let actual = r.a570 in
  let expected = #{ a569 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b569 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } in
  mark_test_run 4402;
  let test = (fun #{ a569 = a5691; b569 = b5691 } #{ a569 = a5692; b569 = b5692 } -> int64x2_u_equal a5691 a5692 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b5691 b5692) actual expected in
  if not test then failwithf "test 4402 failed";
  (* Paths of depth 2 *)
  (* .a570.#a569 *)
  let actual = r.a570.#a569 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4403;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4403 failed";
  (* .a570.#b569 *)
  let actual = r.a570.#b569 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } in
  mark_test_run 4404;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4404 failed";
  (* Paths of depth 3 *)
  (* .a570.#b569.#a67 *)
  let actual = r.a570.#b569.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4405;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4405 failed";
  (* .a570.#b569.#b67 *)
  let actual = r.a570.#b569.#b67 in
  let expected = 4 in
  mark_test_run 4406;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4406 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a570 = a5701 } { a570 = a5702 } -> (fun #{ a569 = a5691; b569 = b5691 } #{ a569 = a5692; b569 = b5692 } -> int64x2_u_equal a5691 a5692 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b5691 b5692) a5701 a5702) in
  let next_r = { a570 = #{ a569 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b569 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } } } in
  let r_expected = { a570 = #{ a569 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b569 = #{ a67 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b67 = 4 } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a570 *)
  r.a570 <- next_r.a570;
  let r_expected = { r_expected with a570 = next_r.a570 } in
  mark_test_run 4407;
  let test = eq r r_expected in
  if not test then failwithf "test 4407 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a570 = #{ a569; b569 = #{ a67; b67 } } } = r in
  let expected_a569 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4408;
  let test = int64x2_u_equal expected_a569 a569 in
  if not test then failwithf "test 4408 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4409;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4409 failed";
  let expected_b67 = 104 in
  mark_test_run 4410;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4410 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a570 } = r in
  let expected_a570 = #{ a569 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b569 = #{ a67 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b67 = 104 } } in
  mark_test_run 4411;
  let test = (fun #{ a569 = a5691; b569 = b5691 } #{ a569 = a5692; b569 = b5692 } -> int64x2_u_equal a5691 a5692 && (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) b5691 b5692) expected_a570 a570 in
  if not test then failwithf "test 4411 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t572 = { #{ int64x2#; #{ int64x2#; int64x2# } } }   *)
  (*********************************************************)
  let r = { a572 = #{ a571 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b571 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a572 *)
  let actual = r.a572 in
  let expected = #{ a571 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b571 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  mark_test_run 4412;
  let test = (fun #{ a571 = a5711; b571 = b5711 } #{ a571 = a5712; b571 = b5712 } -> int64x2_u_equal a5711 a5712 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b5711 b5712) actual expected in
  if not test then failwithf "test 4412 failed";
  (* Paths of depth 2 *)
  (* .a572.#a571 *)
  let actual = r.a572.#a571 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4413;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4413 failed";
  (* .a572.#b571 *)
  let actual = r.a572.#b571 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  mark_test_run 4414;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4414 failed";
  (* Paths of depth 3 *)
  (* .a572.#b571.#a69 *)
  let actual = r.a572.#b571.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4415;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4415 failed";
  (* .a572.#b571.#b69 *)
  let actual = r.a572.#b571.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 4416;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4416 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a572 = a5721 } { a572 = a5722 } -> (fun #{ a571 = a5711; b571 = b5711 } #{ a571 = a5712; b571 = b5712 } -> int64x2_u_equal a5711 a5712 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b5711 b5712) a5721 a5722) in
  let next_r = { a572 = #{ a571 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b571 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } } in
  let r_expected = { a572 = #{ a571 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b571 = #{ a69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); b69 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a572 *)
  r.a572 <- next_r.a572;
  let r_expected = { r_expected with a572 = next_r.a572 } in
  mark_test_run 4417;
  let test = eq r r_expected in
  if not test then failwithf "test 4417 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a572 = #{ a571; b571 = #{ a69; b69 } } } = r in
  let expected_a571 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4418;
  let test = int64x2_u_equal expected_a571 a571 in
  if not test then failwithf "test 4418 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4419;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4419 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 4420;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4420 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a572 } = r in
  let expected_a572 = #{ a571 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b571 = #{ a69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); b69 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } in
  mark_test_run 4421;
  let test = (fun #{ a571 = a5711; b571 = b5711 } #{ a571 = a5712; b571 = b5712 } -> int64x2_u_equal a5711 a5712 && (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) b5711 b5712) expected_a572 a572 in
  if not test then failwithf "test 4421 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t574 = { #{ #{ int; int }; int } }   *)
  (******************************************)
  let r = { a574 = #{ a573 = #{ a29 = 0; b29 = 1 }; b573 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a574 *)
  let actual = r.a574 in
  let expected = #{ a573 = #{ a29 = 0; b29 = 1 }; b573 = 2 } in
  mark_test_run 4422;
  let test = (fun #{ a573 = a5731; b573 = b5731 } #{ a573 = a5732; b573 = b5732 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5731 a5732 && (fun a b -> Int.equal a b) b5731 b5732) actual expected in
  if not test then failwithf "test 4422 failed";
  (* Paths of depth 2 *)
  (* .a574.#a573 *)
  let actual = r.a574.#a573 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 4423;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 4423 failed";
  (* .a574.#b573 *)
  let actual = r.a574.#b573 in
  let expected = 2 in
  mark_test_run 4424;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4424 failed";
  (* Paths of depth 3 *)
  (* .a574.#a573.#a29 *)
  let actual = r.a574.#a573.#a29 in
  let expected = 0 in
  mark_test_run 4425;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4425 failed";
  (* .a574.#a573.#b29 *)
  let actual = r.a574.#a573.#b29 in
  let expected = 1 in
  mark_test_run 4426;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4426 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a574 = a5741 } { a574 = a5742 } -> (fun #{ a573 = a5731; b573 = b5731 } #{ a573 = a5732; b573 = b5732 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5731 a5732 && (fun a b -> Int.equal a b) b5731 b5732) a5741 a5742) in
  let next_r = { a574 = #{ a573 = #{ a29 = 100; b29 = 101 }; b573 = 102 } } in
  let r_expected = { a574 = #{ a573 = #{ a29 = 0; b29 = 1 }; b573 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a574 *)
  r.a574 <- next_r.a574;
  let r_expected = { r_expected with a574 = next_r.a574 } in
  mark_test_run 4427;
  let test = eq r r_expected in
  if not test then failwithf "test 4427 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a574 = #{ a573 = #{ a29; b29 }; b573 } } = r in
  let expected_b573 = 102 in
  mark_test_run 4428;
  let test = (fun a b -> Int.equal a b) expected_b573 b573 in
  if not test then failwithf "test 4428 failed";
  let expected_a29 = 100 in
  mark_test_run 4429;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 4429 failed";
  let expected_b29 = 101 in
  mark_test_run 4430;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 4430 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a574 } = r in
  let expected_a574 = #{ a573 = #{ a29 = 100; b29 = 101 }; b573 = 102 } in
  mark_test_run 4431;
  let test = (fun #{ a573 = a5731; b573 = b5731 } #{ a573 = a5732; b573 = b5732 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5731 a5732 && (fun a b -> Int.equal a b) b5731 b5732) expected_a574 a574 in
  if not test then failwithf "test 4431 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t576 = { #{ #{ int; int }; int32# } }   *)
  (*********************************************)
  let r = { a576 = #{ a575 = #{ a29 = 0; b29 = 1 }; b575 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a576 *)
  let actual = r.a576 in
  let expected = #{ a575 = #{ a29 = 0; b29 = 1 }; b575 = #2l } in
  mark_test_run 4432;
  let test = (fun #{ a575 = a5751; b575 = b5751 } #{ a575 = a5752; b575 = b5752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5751 a5752 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5751 b5752) actual expected in
  if not test then failwithf "test 4432 failed";
  (* Paths of depth 2 *)
  (* .a576.#a575 *)
  let actual = r.a576.#a575 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 4433;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 4433 failed";
  (* .a576.#b575 *)
  let actual = r.a576.#b575 in
  let expected = #2l in
  mark_test_run 4434;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4434 failed";
  (* Paths of depth 3 *)
  (* .a576.#a575.#a29 *)
  let actual = r.a576.#a575.#a29 in
  let expected = 0 in
  mark_test_run 4435;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4435 failed";
  (* .a576.#a575.#b29 *)
  let actual = r.a576.#a575.#b29 in
  let expected = 1 in
  mark_test_run 4436;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4436 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a576 = a5761 } { a576 = a5762 } -> (fun #{ a575 = a5751; b575 = b5751 } #{ a575 = a5752; b575 = b5752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5751 a5752 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5751 b5752) a5761 a5762) in
  let next_r = { a576 = #{ a575 = #{ a29 = 100; b29 = 101 }; b575 = #102l } } in
  let r_expected = { a576 = #{ a575 = #{ a29 = 0; b29 = 1 }; b575 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a576 *)
  r.a576 <- next_r.a576;
  let r_expected = { r_expected with a576 = next_r.a576 } in
  mark_test_run 4437;
  let test = eq r r_expected in
  if not test then failwithf "test 4437 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a576 = #{ a575 = #{ a29; b29 }; b575 } } = r in
  let expected_b575 = #102l in
  mark_test_run 4438;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b575 b575 in
  if not test then failwithf "test 4438 failed";
  let expected_a29 = 100 in
  mark_test_run 4439;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 4439 failed";
  let expected_b29 = 101 in
  mark_test_run 4440;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 4440 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a576 } = r in
  let expected_a576 = #{ a575 = #{ a29 = 100; b29 = 101 }; b575 = #102l } in
  mark_test_run 4441;
  let test = (fun #{ a575 = a5751; b575 = b5751 } #{ a575 = a5752; b575 = b5752 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5751 a5752 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5751 b5752) expected_a576 a576 in
  if not test then failwithf "test 4441 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t578 = { #{ #{ int; int }; float } }   *)
  (********************************************)
  let r = { a578 = #{ a577 = #{ a29 = 0; b29 = 1 }; b577 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a578 *)
  let actual = r.a578 in
  let expected = #{ a577 = #{ a29 = 0; b29 = 1 }; b577 = 2. } in
  mark_test_run 4442;
  let test = (fun #{ a577 = a5771; b577 = b5771 } #{ a577 = a5772; b577 = b5772 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5771 a5772 && (fun a b -> Float.equal (globalize a) (globalize b)) b5771 b5772) actual expected in
  if not test then failwithf "test 4442 failed";
  (* Paths of depth 2 *)
  (* .a578.#a577 *)
  let actual = r.a578.#a577 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 4443;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 4443 failed";
  (* .a578.#b577 *)
  let actual = r.a578.#b577 in
  let expected = 2. in
  mark_test_run 4444;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4444 failed";
  (* Paths of depth 3 *)
  (* .a578.#a577.#a29 *)
  let actual = r.a578.#a577.#a29 in
  let expected = 0 in
  mark_test_run 4445;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4445 failed";
  (* .a578.#a577.#b29 *)
  let actual = r.a578.#a577.#b29 in
  let expected = 1 in
  mark_test_run 4446;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4446 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a578 = a5781 } { a578 = a5782 } -> (fun #{ a577 = a5771; b577 = b5771 } #{ a577 = a5772; b577 = b5772 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5771 a5772 && (fun a b -> Float.equal (globalize a) (globalize b)) b5771 b5772) a5781 a5782) in
  let next_r = { a578 = #{ a577 = #{ a29 = 100; b29 = 101 }; b577 = 102. } } in
  let r_expected = { a578 = #{ a577 = #{ a29 = 0; b29 = 1 }; b577 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a578 *)
  r.a578 <- next_r.a578;
  let r_expected = { r_expected with a578 = next_r.a578 } in
  mark_test_run 4447;
  let test = eq r r_expected in
  if not test then failwithf "test 4447 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a578 = #{ a577 = #{ a29; b29 }; b577 } } = r in
  let expected_b577 = 102. in
  mark_test_run 4448;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b577 b577 in
  if not test then failwithf "test 4448 failed";
  let expected_a29 = 100 in
  mark_test_run 4449;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 4449 failed";
  let expected_b29 = 101 in
  mark_test_run 4450;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 4450 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a578 } = r in
  let expected_a578 = #{ a577 = #{ a29 = 100; b29 = 101 }; b577 = 102. } in
  mark_test_run 4451;
  let test = (fun #{ a577 = a5771; b577 = b5771 } #{ a577 = a5772; b577 = b5772 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5771 a5772 && (fun a b -> Float.equal (globalize a) (globalize b)) b5771 b5772) expected_a578 a578 in
  if not test then failwithf "test 4451 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t580 = { #{ #{ int; int }; int64x2# } }   *)
  (***********************************************)
  let r = { a580 = #{ a579 = #{ a29 = 0; b29 = 1 }; b579 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a580 *)
  let actual = r.a580 in
  let expected = #{ a579 = #{ a29 = 0; b29 = 1 }; b579 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4452;
  let test = (fun #{ a579 = a5791; b579 = b5791 } #{ a579 = a5792; b579 = b5792 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5791 a5792 && int64x2_u_equal b5791 b5792) actual expected in
  if not test then failwithf "test 4452 failed";
  (* Paths of depth 2 *)
  (* .a580.#a579 *)
  let actual = r.a580.#a579 in
  let expected = #{ a29 = 0; b29 = 1 } in
  mark_test_run 4453;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) actual expected in
  if not test then failwithf "test 4453 failed";
  (* .a580.#b579 *)
  let actual = r.a580.#b579 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4454;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4454 failed";
  (* Paths of depth 3 *)
  (* .a580.#a579.#a29 *)
  let actual = r.a580.#a579.#a29 in
  let expected = 0 in
  mark_test_run 4455;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4455 failed";
  (* .a580.#a579.#b29 *)
  let actual = r.a580.#a579.#b29 in
  let expected = 1 in
  mark_test_run 4456;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4456 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a580 = a5801 } { a580 = a5802 } -> (fun #{ a579 = a5791; b579 = b5791 } #{ a579 = a5792; b579 = b5792 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5791 a5792 && int64x2_u_equal b5791 b5792) a5801 a5802) in
  let next_r = { a580 = #{ a579 = #{ a29 = 100; b29 = 101 }; b579 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } } in
  let r_expected = { a580 = #{ a579 = #{ a29 = 0; b29 = 1 }; b579 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a580 *)
  r.a580 <- next_r.a580;
  let r_expected = { r_expected with a580 = next_r.a580 } in
  mark_test_run 4457;
  let test = eq r r_expected in
  if not test then failwithf "test 4457 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a580 = #{ a579 = #{ a29; b29 }; b579 } } = r in
  let expected_b579 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4458;
  let test = int64x2_u_equal expected_b579 b579 in
  if not test then failwithf "test 4458 failed";
  let expected_a29 = 100 in
  mark_test_run 4459;
  let test = (fun a b -> Int.equal a b) expected_a29 a29 in
  if not test then failwithf "test 4459 failed";
  let expected_b29 = 101 in
  mark_test_run 4460;
  let test = (fun a b -> Int.equal a b) expected_b29 b29 in
  if not test then failwithf "test 4460 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a580 } = r in
  let expected_a580 = #{ a579 = #{ a29 = 100; b29 = 101 }; b579 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  mark_test_run 4461;
  let test = (fun #{ a579 = a5791; b579 = b5791 } #{ a579 = a5792; b579 = b5792 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun a b -> Int.equal a b) b291 b292) a5791 a5792 && int64x2_u_equal b5791 b5792) expected_a580 a580 in
  if not test then failwithf "test 4461 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t582 = { #{ #{ int; int32# }; int } }   *)
  (*********************************************)
  let r = { a582 = #{ a581 = #{ a31 = 0; b31 = #1l }; b581 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a582 *)
  let actual = r.a582 in
  let expected = #{ a581 = #{ a31 = 0; b31 = #1l }; b581 = 2 } in
  mark_test_run 4462;
  let test = (fun #{ a581 = a5811; b581 = b5811 } #{ a581 = a5812; b581 = b5812 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5811 a5812 && (fun a b -> Int.equal a b) b5811 b5812) actual expected in
  if not test then failwithf "test 4462 failed";
  (* Paths of depth 2 *)
  (* .a582.#a581 *)
  let actual = r.a582.#a581 in
  let expected = #{ a31 = 0; b31 = #1l } in
  mark_test_run 4463;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 4463 failed";
  (* .a582.#b581 *)
  let actual = r.a582.#b581 in
  let expected = 2 in
  mark_test_run 4464;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4464 failed";
  (* Paths of depth 3 *)
  (* .a582.#a581.#a31 *)
  let actual = r.a582.#a581.#a31 in
  let expected = 0 in
  mark_test_run 4465;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4465 failed";
  (* .a582.#a581.#b31 *)
  let actual = r.a582.#a581.#b31 in
  let expected = #1l in
  mark_test_run 4466;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4466 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a582 = a5821 } { a582 = a5822 } -> (fun #{ a581 = a5811; b581 = b5811 } #{ a581 = a5812; b581 = b5812 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5811 a5812 && (fun a b -> Int.equal a b) b5811 b5812) a5821 a5822) in
  let next_r = { a582 = #{ a581 = #{ a31 = 100; b31 = #101l }; b581 = 102 } } in
  let r_expected = { a582 = #{ a581 = #{ a31 = 0; b31 = #1l }; b581 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a582 *)
  r.a582 <- next_r.a582;
  let r_expected = { r_expected with a582 = next_r.a582 } in
  mark_test_run 4467;
  let test = eq r r_expected in
  if not test then failwithf "test 4467 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a582 = #{ a581 = #{ a31; b31 }; b581 } } = r in
  let expected_b581 = 102 in
  mark_test_run 4468;
  let test = (fun a b -> Int.equal a b) expected_b581 b581 in
  if not test then failwithf "test 4468 failed";
  let expected_a31 = 100 in
  mark_test_run 4469;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 4469 failed";
  let expected_b31 = #101l in
  mark_test_run 4470;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 4470 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a582 } = r in
  let expected_a582 = #{ a581 = #{ a31 = 100; b31 = #101l }; b581 = 102 } in
  mark_test_run 4471;
  let test = (fun #{ a581 = a5811; b581 = b5811 } #{ a581 = a5812; b581 = b5812 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5811 a5812 && (fun a b -> Int.equal a b) b5811 b5812) expected_a582 a582 in
  if not test then failwithf "test 4471 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t584 = { #{ #{ int; int32# }; int32# } }   *)
  (************************************************)
  let r = { a584 = #{ a583 = #{ a31 = 0; b31 = #1l }; b583 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a584 *)
  let actual = r.a584 in
  let expected = #{ a583 = #{ a31 = 0; b31 = #1l }; b583 = #2l } in
  mark_test_run 4472;
  let test = (fun #{ a583 = a5831; b583 = b5831 } #{ a583 = a5832; b583 = b5832 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5831 a5832 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5831 b5832) actual expected in
  if not test then failwithf "test 4472 failed";
  (* Paths of depth 2 *)
  (* .a584.#a583 *)
  let actual = r.a584.#a583 in
  let expected = #{ a31 = 0; b31 = #1l } in
  mark_test_run 4473;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) actual expected in
  if not test then failwithf "test 4473 failed";
  (* .a584.#b583 *)
  let actual = r.a584.#b583 in
  let expected = #2l in
  mark_test_run 4474;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4474 failed";
  (* Paths of depth 3 *)
  (* .a584.#a583.#a31 *)
  let actual = r.a584.#a583.#a31 in
  let expected = 0 in
  mark_test_run 4475;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4475 failed";
  (* .a584.#a583.#b31 *)
  let actual = r.a584.#a583.#b31 in
  let expected = #1l in
  mark_test_run 4476;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4476 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a584 = a5841 } { a584 = a5842 } -> (fun #{ a583 = a5831; b583 = b5831 } #{ a583 = a5832; b583 = b5832 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5831 a5832 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5831 b5832) a5841 a5842) in
  let next_r = { a584 = #{ a583 = #{ a31 = 100; b31 = #101l }; b583 = #102l } } in
  let r_expected = { a584 = #{ a583 = #{ a31 = 0; b31 = #1l }; b583 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a584 *)
  r.a584 <- next_r.a584;
  let r_expected = { r_expected with a584 = next_r.a584 } in
  mark_test_run 4477;
  let test = eq r r_expected in
  if not test then failwithf "test 4477 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a584 = #{ a583 = #{ a31; b31 }; b583 } } = r in
  let expected_b583 = #102l in
  mark_test_run 4478;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b583 b583 in
  if not test then failwithf "test 4478 failed";
  let expected_a31 = 100 in
  mark_test_run 4479;
  let test = (fun a b -> Int.equal a b) expected_a31 a31 in
  if not test then failwithf "test 4479 failed";
  let expected_b31 = #101l in
  mark_test_run 4480;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b31 b31 in
  if not test then failwithf "test 4480 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a584 } = r in
  let expected_a584 = #{ a583 = #{ a31 = 100; b31 = #101l }; b583 = #102l } in
  mark_test_run 4481;
  let test = (fun #{ a583 = a5831; b583 = b5831 } #{ a583 = a5832; b583 = b5832 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b311 b312) a5831 a5832 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5831 b5832) expected_a584 a584 in
  if not test then failwithf "test 4481 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t586 = { #{ #{ int; float }; int } }   *)
  (********************************************)
  let r = { a586 = #{ a585 = #{ a33 = 0; b33 = 1. }; b585 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a586 *)
  let actual = r.a586 in
  let expected = #{ a585 = #{ a33 = 0; b33 = 1. }; b585 = 2 } in
  mark_test_run 4482;
  let test = (fun #{ a585 = a5851; b585 = b5851 } #{ a585 = a5852; b585 = b5852 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5851 a5852 && (fun a b -> Int.equal a b) b5851 b5852) actual expected in
  if not test then failwithf "test 4482 failed";
  (* Paths of depth 2 *)
  (* .a586.#a585 *)
  let actual = r.a586.#a585 in
  let expected = #{ a33 = 0; b33 = 1. } in
  mark_test_run 4483;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 4483 failed";
  (* .a586.#b585 *)
  let actual = r.a586.#b585 in
  let expected = 2 in
  mark_test_run 4484;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4484 failed";
  (* Paths of depth 3 *)
  (* .a586.#a585.#a33 *)
  let actual = r.a586.#a585.#a33 in
  let expected = 0 in
  mark_test_run 4485;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4485 failed";
  (* .a586.#a585.#b33 *)
  let actual = r.a586.#a585.#b33 in
  let expected = 1. in
  mark_test_run 4486;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4486 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a586 = a5861 } { a586 = a5862 } -> (fun #{ a585 = a5851; b585 = b5851 } #{ a585 = a5852; b585 = b5852 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5851 a5852 && (fun a b -> Int.equal a b) b5851 b5852) a5861 a5862) in
  let next_r = { a586 = #{ a585 = #{ a33 = 100; b33 = 101. }; b585 = 102 } } in
  let r_expected = { a586 = #{ a585 = #{ a33 = 0; b33 = 1. }; b585 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a586 *)
  r.a586 <- next_r.a586;
  let r_expected = { r_expected with a586 = next_r.a586 } in
  mark_test_run 4487;
  let test = eq r r_expected in
  if not test then failwithf "test 4487 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a586 = #{ a585 = #{ a33; b33 }; b585 } } = r in
  let expected_b585 = 102 in
  mark_test_run 4488;
  let test = (fun a b -> Int.equal a b) expected_b585 b585 in
  if not test then failwithf "test 4488 failed";
  let expected_a33 = 100 in
  mark_test_run 4489;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 4489 failed";
  let expected_b33 = 101. in
  mark_test_run 4490;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 4490 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a586 } = r in
  let expected_a586 = #{ a585 = #{ a33 = 100; b33 = 101. }; b585 = 102 } in
  mark_test_run 4491;
  let test = (fun #{ a585 = a5851; b585 = b5851 } #{ a585 = a5852; b585 = b5852 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5851 a5852 && (fun a b -> Int.equal a b) b5851 b5852) expected_a586 a586 in
  if not test then failwithf "test 4491 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t588 = { #{ #{ int; float }; float } }   *)
  (**********************************************)
  let r = { a588 = #{ a587 = #{ a33 = 0; b33 = 1. }; b587 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a588 *)
  let actual = r.a588 in
  let expected = #{ a587 = #{ a33 = 0; b33 = 1. }; b587 = 2. } in
  mark_test_run 4492;
  let test = (fun #{ a587 = a5871; b587 = b5871 } #{ a587 = a5872; b587 = b5872 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5871 a5872 && (fun a b -> Float.equal (globalize a) (globalize b)) b5871 b5872) actual expected in
  if not test then failwithf "test 4492 failed";
  (* Paths of depth 2 *)
  (* .a588.#a587 *)
  let actual = r.a588.#a587 in
  let expected = #{ a33 = 0; b33 = 1. } in
  mark_test_run 4493;
  let test = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) actual expected in
  if not test then failwithf "test 4493 failed";
  (* .a588.#b587 *)
  let actual = r.a588.#b587 in
  let expected = 2. in
  mark_test_run 4494;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4494 failed";
  (* Paths of depth 3 *)
  (* .a588.#a587.#a33 *)
  let actual = r.a588.#a587.#a33 in
  let expected = 0 in
  mark_test_run 4495;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4495 failed";
  (* .a588.#a587.#b33 *)
  let actual = r.a588.#a587.#b33 in
  let expected = 1. in
  mark_test_run 4496;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4496 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a588 = a5881 } { a588 = a5882 } -> (fun #{ a587 = a5871; b587 = b5871 } #{ a587 = a5872; b587 = b5872 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5871 a5872 && (fun a b -> Float.equal (globalize a) (globalize b)) b5871 b5872) a5881 a5882) in
  let next_r = { a588 = #{ a587 = #{ a33 = 100; b33 = 101. }; b587 = 102. } } in
  let r_expected = { a588 = #{ a587 = #{ a33 = 0; b33 = 1. }; b587 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a588 *)
  r.a588 <- next_r.a588;
  let r_expected = { r_expected with a588 = next_r.a588 } in
  mark_test_run 4497;
  let test = eq r r_expected in
  if not test then failwithf "test 4497 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a588 = #{ a587 = #{ a33; b33 }; b587 } } = r in
  let expected_b587 = 102. in
  mark_test_run 4498;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b587 b587 in
  if not test then failwithf "test 4498 failed";
  let expected_a33 = 100 in
  mark_test_run 4499;
  let test = (fun a b -> Int.equal a b) expected_a33 a33 in
  if not test then failwithf "test 4499 failed";
  let expected_b33 = 101. in
  mark_test_run 4500;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 4500 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a588 } = r in
  let expected_a588 = #{ a587 = #{ a33 = 100; b33 = 101. }; b587 = 102. } in
  mark_test_run 4501;
  let test = (fun #{ a587 = a5871; b587 = b5871 } #{ a587 = a5872; b587 = b5872 } -> (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) a5871 a5872 && (fun a b -> Float.equal (globalize a) (globalize b)) b5871 b5872) expected_a588 a588 in
  if not test then failwithf "test 4501 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t590 = { #{ #{ int; int64x2# }; int } }   *)
  (***********************************************)
  let r = { a590 = #{ a589 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b589 = 3 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a590 *)
  let actual = r.a590 in
  let expected = #{ a589 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b589 = 3 } in
  mark_test_run 4502;
  let test = (fun #{ a589 = a5891; b589 = b5891 } #{ a589 = a5892; b589 = b5892 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5891 a5892 && (fun a b -> Int.equal a b) b5891 b5892) actual expected in
  if not test then failwithf "test 4502 failed";
  (* Paths of depth 2 *)
  (* .a590.#a589 *)
  let actual = r.a590.#a589 in
  let expected = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 4503;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 4503 failed";
  (* .a590.#b589 *)
  let actual = r.a590.#b589 in
  let expected = 3 in
  mark_test_run 4504;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4504 failed";
  (* Paths of depth 3 *)
  (* .a590.#a589.#a35 *)
  let actual = r.a590.#a589.#a35 in
  let expected = 0 in
  mark_test_run 4505;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4505 failed";
  (* .a590.#a589.#b35 *)
  let actual = r.a590.#a589.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 4506;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4506 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a590 = a5901 } { a590 = a5902 } -> (fun #{ a589 = a5891; b589 = b5891 } #{ a589 = a5892; b589 = b5892 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5891 a5892 && (fun a b -> Int.equal a b) b5891 b5892) a5901 a5902) in
  let next_r = { a590 = #{ a589 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b589 = 103 } } in
  let r_expected = { a590 = #{ a589 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b589 = 3 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a590 *)
  r.a590 <- next_r.a590;
  let r_expected = { r_expected with a590 = next_r.a590 } in
  mark_test_run 4507;
  let test = eq r r_expected in
  if not test then failwithf "test 4507 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a590 = #{ a589 = #{ a35; b35 }; b589 } } = r in
  let expected_b589 = 103 in
  mark_test_run 4508;
  let test = (fun a b -> Int.equal a b) expected_b589 b589 in
  if not test then failwithf "test 4508 failed";
  let expected_a35 = 100 in
  mark_test_run 4509;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 4509 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 4510;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 4510 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a590 } = r in
  let expected_a590 = #{ a589 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b589 = 103 } in
  mark_test_run 4511;
  let test = (fun #{ a589 = a5891; b589 = b5891 } #{ a589 = a5892; b589 = b5892 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5891 a5892 && (fun a b -> Int.equal a b) b5891 b5892) expected_a590 a590 in
  if not test then failwithf "test 4511 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t592 = { #{ #{ int; int64x2# }; int64x2# } }   *)
  (****************************************************)
  let r = { a592 = #{ a591 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b591 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a592 *)
  let actual = r.a592 in
  let expected = #{ a591 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b591 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 4512;
  let test = (fun #{ a591 = a5911; b591 = b5911 } #{ a591 = a5912; b591 = b5912 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5911 a5912 && int64x2_u_equal b5911 b5912) actual expected in
  if not test then failwithf "test 4512 failed";
  (* Paths of depth 2 *)
  (* .a592.#a591 *)
  let actual = r.a592.#a591 in
  let expected = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) } in
  mark_test_run 4513;
  let test = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) actual expected in
  if not test then failwithf "test 4513 failed";
  (* .a592.#b591 *)
  let actual = r.a592.#b591 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 4514;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4514 failed";
  (* Paths of depth 3 *)
  (* .a592.#a591.#a35 *)
  let actual = r.a592.#a591.#a35 in
  let expected = 0 in
  mark_test_run 4515;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4515 failed";
  (* .a592.#a591.#b35 *)
  let actual = r.a592.#a591.#b35 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 4516;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4516 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a592 = a5921 } { a592 = a5922 } -> (fun #{ a591 = a5911; b591 = b5911 } #{ a591 = a5912; b591 = b5912 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5911 a5912 && int64x2_u_equal b5911 b5912) a5921 a5922) in
  let next_r = { a592 = #{ a591 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b591 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  let r_expected = { a592 = #{ a591 = #{ a35 = 0; b35 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) }; b591 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a592 *)
  r.a592 <- next_r.a592;
  let r_expected = { r_expected with a592 = next_r.a592 } in
  mark_test_run 4517;
  let test = eq r r_expected in
  if not test then failwithf "test 4517 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a592 = #{ a591 = #{ a35; b35 }; b591 } } = r in
  let expected_b591 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 4518;
  let test = int64x2_u_equal expected_b591 b591 in
  if not test then failwithf "test 4518 failed";
  let expected_a35 = 100 in
  mark_test_run 4519;
  let test = (fun a b -> Int.equal a b) expected_a35 a35 in
  if not test then failwithf "test 4519 failed";
  let expected_b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 4520;
  let test = int64x2_u_equal expected_b35 b35 in
  if not test then failwithf "test 4520 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a592 } = r in
  let expected_a592 = #{ a591 = #{ a35 = 100; b35 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) }; b591 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  mark_test_run 4521;
  let test = (fun #{ a591 = a5911; b591 = b5911 } #{ a591 = a5912; b591 = b5912 } -> (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && int64x2_u_equal b351 b352) a5911 a5912 && int64x2_u_equal b5911 b5912) expected_a592 a592 in
  if not test then failwithf "test 4521 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t594 = { #{ #{ int32#; int }; int } }   *)
  (*********************************************)
  let r = { a594 = #{ a593 = #{ a49 = #0l; b49 = 1 }; b593 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a594 *)
  let actual = r.a594 in
  let expected = #{ a593 = #{ a49 = #0l; b49 = 1 }; b593 = 2 } in
  mark_test_run 4522;
  let test = (fun #{ a593 = a5931; b593 = b5931 } #{ a593 = a5932; b593 = b5932 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5931 a5932 && (fun a b -> Int.equal a b) b5931 b5932) actual expected in
  if not test then failwithf "test 4522 failed";
  (* Paths of depth 2 *)
  (* .a594.#a593 *)
  let actual = r.a594.#a593 in
  let expected = #{ a49 = #0l; b49 = 1 } in
  mark_test_run 4523;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 4523 failed";
  (* .a594.#b593 *)
  let actual = r.a594.#b593 in
  let expected = 2 in
  mark_test_run 4524;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4524 failed";
  (* Paths of depth 3 *)
  (* .a594.#a593.#a49 *)
  let actual = r.a594.#a593.#a49 in
  let expected = #0l in
  mark_test_run 4525;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4525 failed";
  (* .a594.#a593.#b49 *)
  let actual = r.a594.#a593.#b49 in
  let expected = 1 in
  mark_test_run 4526;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4526 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a594 = a5941 } { a594 = a5942 } -> (fun #{ a593 = a5931; b593 = b5931 } #{ a593 = a5932; b593 = b5932 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5931 a5932 && (fun a b -> Int.equal a b) b5931 b5932) a5941 a5942) in
  let next_r = { a594 = #{ a593 = #{ a49 = #100l; b49 = 101 }; b593 = 102 } } in
  let r_expected = { a594 = #{ a593 = #{ a49 = #0l; b49 = 1 }; b593 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a594 *)
  r.a594 <- next_r.a594;
  let r_expected = { r_expected with a594 = next_r.a594 } in
  mark_test_run 4527;
  let test = eq r r_expected in
  if not test then failwithf "test 4527 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a594 = #{ a593 = #{ a49; b49 }; b593 } } = r in
  let expected_b593 = 102 in
  mark_test_run 4528;
  let test = (fun a b -> Int.equal a b) expected_b593 b593 in
  if not test then failwithf "test 4528 failed";
  let expected_a49 = #100l in
  mark_test_run 4529;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 4529 failed";
  let expected_b49 = 101 in
  mark_test_run 4530;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 4530 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a594 } = r in
  let expected_a594 = #{ a593 = #{ a49 = #100l; b49 = 101 }; b593 = 102 } in
  mark_test_run 4531;
  let test = (fun #{ a593 = a5931; b593 = b5931 } #{ a593 = a5932; b593 = b5932 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5931 a5932 && (fun a b -> Int.equal a b) b5931 b5932) expected_a594 a594 in
  if not test then failwithf "test 4531 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t596 = { #{ #{ int32#; int }; int32# } }   *)
  (************************************************)
  let r = { a596 = #{ a595 = #{ a49 = #0l; b49 = 1 }; b595 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a596 *)
  let actual = r.a596 in
  let expected = #{ a595 = #{ a49 = #0l; b49 = 1 }; b595 = #2l } in
  mark_test_run 4532;
  let test = (fun #{ a595 = a5951; b595 = b5951 } #{ a595 = a5952; b595 = b5952 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5951 a5952 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5951 b5952) actual expected in
  if not test then failwithf "test 4532 failed";
  (* Paths of depth 2 *)
  (* .a596.#a595 *)
  let actual = r.a596.#a595 in
  let expected = #{ a49 = #0l; b49 = 1 } in
  mark_test_run 4533;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) actual expected in
  if not test then failwithf "test 4533 failed";
  (* .a596.#b595 *)
  let actual = r.a596.#b595 in
  let expected = #2l in
  mark_test_run 4534;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4534 failed";
  (* Paths of depth 3 *)
  (* .a596.#a595.#a49 *)
  let actual = r.a596.#a595.#a49 in
  let expected = #0l in
  mark_test_run 4535;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4535 failed";
  (* .a596.#a595.#b49 *)
  let actual = r.a596.#a595.#b49 in
  let expected = 1 in
  mark_test_run 4536;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4536 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a596 = a5961 } { a596 = a5962 } -> (fun #{ a595 = a5951; b595 = b5951 } #{ a595 = a5952; b595 = b5952 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5951 a5952 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5951 b5952) a5961 a5962) in
  let next_r = { a596 = #{ a595 = #{ a49 = #100l; b49 = 101 }; b595 = #102l } } in
  let r_expected = { a596 = #{ a595 = #{ a49 = #0l; b49 = 1 }; b595 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a596 *)
  r.a596 <- next_r.a596;
  let r_expected = { r_expected with a596 = next_r.a596 } in
  mark_test_run 4537;
  let test = eq r r_expected in
  if not test then failwithf "test 4537 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a596 = #{ a595 = #{ a49; b49 }; b595 } } = r in
  let expected_b595 = #102l in
  mark_test_run 4538;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b595 b595 in
  if not test then failwithf "test 4538 failed";
  let expected_a49 = #100l in
  mark_test_run 4539;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a49 a49 in
  if not test then failwithf "test 4539 failed";
  let expected_b49 = 101 in
  mark_test_run 4540;
  let test = (fun a b -> Int.equal a b) expected_b49 b49 in
  if not test then failwithf "test 4540 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a596 } = r in
  let expected_a596 = #{ a595 = #{ a49 = #100l; b49 = 101 }; b595 = #102l } in
  mark_test_run 4541;
  let test = (fun #{ a595 = a5951; b595 = b5951 } #{ a595 = a5952; b595 = b5952 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a491 a492 && (fun a b -> Int.equal a b) b491 b492) a5951 a5952 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5951 b5952) expected_a596 a596 in
  if not test then failwithf "test 4541 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t598 = { #{ #{ int32#; int32# }; int } }   *)
  (************************************************)
  let r = { a598 = #{ a597 = #{ a51 = #0l; b51 = #1l }; b597 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a598 *)
  let actual = r.a598 in
  let expected = #{ a597 = #{ a51 = #0l; b51 = #1l }; b597 = 2 } in
  mark_test_run 4542;
  let test = (fun #{ a597 = a5971; b597 = b5971 } #{ a597 = a5972; b597 = b5972 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5971 a5972 && (fun a b -> Int.equal a b) b5971 b5972) actual expected in
  if not test then failwithf "test 4542 failed";
  (* Paths of depth 2 *)
  (* .a598.#a597 *)
  let actual = r.a598.#a597 in
  let expected = #{ a51 = #0l; b51 = #1l } in
  mark_test_run 4543;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 4543 failed";
  (* .a598.#b597 *)
  let actual = r.a598.#b597 in
  let expected = 2 in
  mark_test_run 4544;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4544 failed";
  (* Paths of depth 3 *)
  (* .a598.#a597.#a51 *)
  let actual = r.a598.#a597.#a51 in
  let expected = #0l in
  mark_test_run 4545;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4545 failed";
  (* .a598.#a597.#b51 *)
  let actual = r.a598.#a597.#b51 in
  let expected = #1l in
  mark_test_run 4546;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4546 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a598 = a5981 } { a598 = a5982 } -> (fun #{ a597 = a5971; b597 = b5971 } #{ a597 = a5972; b597 = b5972 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5971 a5972 && (fun a b -> Int.equal a b) b5971 b5972) a5981 a5982) in
  let next_r = { a598 = #{ a597 = #{ a51 = #100l; b51 = #101l }; b597 = 102 } } in
  let r_expected = { a598 = #{ a597 = #{ a51 = #0l; b51 = #1l }; b597 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a598 *)
  r.a598 <- next_r.a598;
  let r_expected = { r_expected with a598 = next_r.a598 } in
  mark_test_run 4547;
  let test = eq r r_expected in
  if not test then failwithf "test 4547 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a598 = #{ a597 = #{ a51; b51 }; b597 } } = r in
  let expected_b597 = 102 in
  mark_test_run 4548;
  let test = (fun a b -> Int.equal a b) expected_b597 b597 in
  if not test then failwithf "test 4548 failed";
  let expected_a51 = #100l in
  mark_test_run 4549;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 4549 failed";
  let expected_b51 = #101l in
  mark_test_run 4550;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 4550 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a598 } = r in
  let expected_a598 = #{ a597 = #{ a51 = #100l; b51 = #101l }; b597 = 102 } in
  mark_test_run 4551;
  let test = (fun #{ a597 = a5971; b597 = b5971 } #{ a597 = a5972; b597 = b5972 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5971 a5972 && (fun a b -> Int.equal a b) b5971 b5972) expected_a598 a598 in
  if not test then failwithf "test 4551 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t600 = { #{ #{ int32#; int32# }; int32# } }   *)
  (***************************************************)
  let r = { a600 = #{ a599 = #{ a51 = #0l; b51 = #1l }; b599 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a600 *)
  let actual = r.a600 in
  let expected = #{ a599 = #{ a51 = #0l; b51 = #1l }; b599 = #2l } in
  mark_test_run 4552;
  let test = (fun #{ a599 = a5991; b599 = b5991 } #{ a599 = a5992; b599 = b5992 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5991 a5992 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5991 b5992) actual expected in
  if not test then failwithf "test 4552 failed";
  (* Paths of depth 2 *)
  (* .a600.#a599 *)
  let actual = r.a600.#a599 in
  let expected = #{ a51 = #0l; b51 = #1l } in
  mark_test_run 4553;
  let test = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) actual expected in
  if not test then failwithf "test 4553 failed";
  (* .a600.#b599 *)
  let actual = r.a600.#b599 in
  let expected = #2l in
  mark_test_run 4554;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4554 failed";
  (* Paths of depth 3 *)
  (* .a600.#a599.#a51 *)
  let actual = r.a600.#a599.#a51 in
  let expected = #0l in
  mark_test_run 4555;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4555 failed";
  (* .a600.#a599.#b51 *)
  let actual = r.a600.#a599.#b51 in
  let expected = #1l in
  mark_test_run 4556;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 4556 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a600 = a6001 } { a600 = a6002 } -> (fun #{ a599 = a5991; b599 = b5991 } #{ a599 = a5992; b599 = b5992 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5991 a5992 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5991 b5992) a6001 a6002) in
  let next_r = { a600 = #{ a599 = #{ a51 = #100l; b51 = #101l }; b599 = #102l } } in
  let r_expected = { a600 = #{ a599 = #{ a51 = #0l; b51 = #1l }; b599 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a600 *)
  r.a600 <- next_r.a600;
  let r_expected = { r_expected with a600 = next_r.a600 } in
  mark_test_run 4557;
  let test = eq r r_expected in
  if not test then failwithf "test 4557 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a600 = #{ a599 = #{ a51; b51 }; b599 } } = r in
  let expected_b599 = #102l in
  mark_test_run 4558;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b599 b599 in
  if not test then failwithf "test 4558 failed";
  let expected_a51 = #100l in
  mark_test_run 4559;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a51 a51 in
  if not test then failwithf "test 4559 failed";
  let expected_b51 = #101l in
  mark_test_run 4560;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b51 b51 in
  if not test then failwithf "test 4560 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a600 } = r in
  let expected_a600 = #{ a599 = #{ a51 = #100l; b51 = #101l }; b599 = #102l } in
  mark_test_run 4561;
  let test = (fun #{ a599 = a5991; b599 = b5991 } #{ a599 = a5992; b599 = b5992 } -> (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a511 a512 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b511 b512) a5991 a5992 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b5991 b5992) expected_a600 a600 in
  if not test then failwithf "test 4561 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t602 = { #{ #{ unit_u; unit_u }; string } }   *)
  (***************************************************)
  let r = { a602 = #{ a601 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b601 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a602 *)
  let actual = r.a602 in
  let expected = #{ a601 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b601 = "0" } in
  mark_test_run 4562;
  let test = (fun #{ a601 = a6011; b601 = b6011 } #{ a601 = a6012; b601 = b6012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a6011 a6012 && (fun a b -> String.equal (globalize a) (globalize b)) b6011 b6012) actual expected in
  if not test then failwithf "test 4562 failed";
  (* Paths of depth 2 *)
  (* .a602.#a601 *)
  let actual = r.a602.#a601 in
  let expected = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) } in
  mark_test_run 4563;
  let test = (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) actual expected in
  if not test then failwithf "test 4563 failed";
  (* .a602.#b601 *)
  let actual = r.a602.#b601 in
  let expected = "0" in
  mark_test_run 4564;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4564 failed";
  (* Paths of depth 3 *)
  (* .a602.#a601.#a290 *)
  let actual = r.a602.#a601.#a290 in
  let expected = (unbox_unit ()) in
  mark_test_run 4565;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4565 failed";
  (* .a602.#a601.#b290 *)
  let actual = r.a602.#a601.#b290 in
  let expected = (unbox_unit ()) in
  mark_test_run 4566;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4566 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a602 = a6021 } { a602 = a6022 } -> (fun #{ a601 = a6011; b601 = b6011 } #{ a601 = a6012; b601 = b6012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a6011 a6012 && (fun a b -> String.equal (globalize a) (globalize b)) b6011 b6012) a6021 a6022) in
  let next_r = { a602 = #{ a601 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b601 = "100" } } in
  let r_expected = { a602 = #{ a601 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b601 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a602 *)
  r.a602 <- next_r.a602;
  let r_expected = { r_expected with a602 = next_r.a602 } in
  mark_test_run 4567;
  let test = eq r r_expected in
  if not test then failwithf "test 4567 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a602 = #{ a601 = #{ a290; b290 }; b601 } } = r in
  let expected_b601 = "100" in
  mark_test_run 4568;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b601 b601 in
  if not test then failwithf "test 4568 failed";
  let expected_a290 = (unbox_unit ()) in
  mark_test_run 4569;
  let test = (fun _ _ -> true) expected_a290 a290 in
  if not test then failwithf "test 4569 failed";
  let expected_b290 = (unbox_unit ()) in
  mark_test_run 4570;
  let test = (fun _ _ -> true) expected_b290 b290 in
  if not test then failwithf "test 4570 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a602 } = r in
  let expected_a602 = #{ a601 = #{ a290 = (unbox_unit ()); b290 = (unbox_unit ()) }; b601 = "100" } in
  mark_test_run 4571;
  let test = (fun #{ a601 = a6011; b601 = b6011 } #{ a601 = a6012; b601 = b6012 } -> (fun #{ a290 = a2901; b290 = b2901 } #{ a290 = a2902; b290 = b2902 } -> (fun _ _ -> true) a2901 a2902 && (fun _ _ -> true) b2901 b2902) a6011 a6012 && (fun a b -> String.equal (globalize a) (globalize b)) b6011 b6012) expected_a602 a602 in
  if not test then failwithf "test 4571 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t604 = { #{ #{ unit_u; string }; unit_u } }   *)
  (***************************************************)
  let r = { a604 = #{ a603 = #{ a184 = (unbox_unit ()); b184 = "0" }; b603 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a604 *)
  let actual = r.a604 in
  let expected = #{ a603 = #{ a184 = (unbox_unit ()); b184 = "0" }; b603 = (unbox_unit ()) } in
  mark_test_run 4572;
  let test = (fun #{ a603 = a6031; b603 = b6031 } #{ a603 = a6032; b603 = b6032 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6031 a6032 && (fun _ _ -> true) b6031 b6032) actual expected in
  if not test then failwithf "test 4572 failed";
  (* Paths of depth 2 *)
  (* .a604.#a603 *)
  let actual = r.a604.#a603 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 4573;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 4573 failed";
  (* .a604.#b603 *)
  let actual = r.a604.#b603 in
  let expected = (unbox_unit ()) in
  mark_test_run 4574;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4574 failed";
  (* Paths of depth 3 *)
  (* .a604.#a603.#a184 *)
  let actual = r.a604.#a603.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 4575;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4575 failed";
  (* .a604.#a603.#b184 *)
  let actual = r.a604.#a603.#b184 in
  let expected = "0" in
  mark_test_run 4576;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4576 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a604 = a6041 } { a604 = a6042 } -> (fun #{ a603 = a6031; b603 = b6031 } #{ a603 = a6032; b603 = b6032 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6031 a6032 && (fun _ _ -> true) b6031 b6032) a6041 a6042) in
  let next_r = { a604 = #{ a603 = #{ a184 = (unbox_unit ()); b184 = "100" }; b603 = (unbox_unit ()) } } in
  let r_expected = { a604 = #{ a603 = #{ a184 = (unbox_unit ()); b184 = "0" }; b603 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a604 *)
  r.a604 <- next_r.a604;
  let r_expected = { r_expected with a604 = next_r.a604 } in
  mark_test_run 4577;
  let test = eq r r_expected in
  if not test then failwithf "test 4577 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a604 = #{ a603 = #{ a184; b184 }; b603 } } = r in
  let expected_b603 = (unbox_unit ()) in
  mark_test_run 4578;
  let test = (fun _ _ -> true) expected_b603 b603 in
  if not test then failwithf "test 4578 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 4579;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 4579 failed";
  let expected_b184 = "100" in
  mark_test_run 4580;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 4580 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a604 } = r in
  let expected_a604 = #{ a603 = #{ a184 = (unbox_unit ()); b184 = "100" }; b603 = (unbox_unit ()) } in
  mark_test_run 4581;
  let test = (fun #{ a603 = a6031; b603 = b6031 } #{ a603 = a6032; b603 = b6032 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6031 a6032 && (fun _ _ -> true) b6031 b6032) expected_a604 a604 in
  if not test then failwithf "test 4581 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t606 = { #{ #{ unit_u; string }; string } }   *)
  (***************************************************)
  let r = { a606 = #{ a605 = #{ a184 = (unbox_unit ()); b184 = "0" }; b605 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a606 *)
  let actual = r.a606 in
  let expected = #{ a605 = #{ a184 = (unbox_unit ()); b184 = "0" }; b605 = "1" } in
  mark_test_run 4582;
  let test = (fun #{ a605 = a6051; b605 = b6051 } #{ a605 = a6052; b605 = b6052 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6051 a6052 && (fun a b -> String.equal (globalize a) (globalize b)) b6051 b6052) actual expected in
  if not test then failwithf "test 4582 failed";
  (* Paths of depth 2 *)
  (* .a606.#a605 *)
  let actual = r.a606.#a605 in
  let expected = #{ a184 = (unbox_unit ()); b184 = "0" } in
  mark_test_run 4583;
  let test = (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) actual expected in
  if not test then failwithf "test 4583 failed";
  (* .a606.#b605 *)
  let actual = r.a606.#b605 in
  let expected = "1" in
  mark_test_run 4584;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4584 failed";
  (* Paths of depth 3 *)
  (* .a606.#a605.#a184 *)
  let actual = r.a606.#a605.#a184 in
  let expected = (unbox_unit ()) in
  mark_test_run 4585;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4585 failed";
  (* .a606.#a605.#b184 *)
  let actual = r.a606.#a605.#b184 in
  let expected = "0" in
  mark_test_run 4586;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4586 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a606 = a6061 } { a606 = a6062 } -> (fun #{ a605 = a6051; b605 = b6051 } #{ a605 = a6052; b605 = b6052 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6051 a6052 && (fun a b -> String.equal (globalize a) (globalize b)) b6051 b6052) a6061 a6062) in
  let next_r = { a606 = #{ a605 = #{ a184 = (unbox_unit ()); b184 = "100" }; b605 = "101" } } in
  let r_expected = { a606 = #{ a605 = #{ a184 = (unbox_unit ()); b184 = "0" }; b605 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a606 *)
  r.a606 <- next_r.a606;
  let r_expected = { r_expected with a606 = next_r.a606 } in
  mark_test_run 4587;
  let test = eq r r_expected in
  if not test then failwithf "test 4587 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a606 = #{ a605 = #{ a184; b184 }; b605 } } = r in
  let expected_b605 = "101" in
  mark_test_run 4588;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b605 b605 in
  if not test then failwithf "test 4588 failed";
  let expected_a184 = (unbox_unit ()) in
  mark_test_run 4589;
  let test = (fun _ _ -> true) expected_a184 a184 in
  if not test then failwithf "test 4589 failed";
  let expected_b184 = "100" in
  mark_test_run 4590;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b184 b184 in
  if not test then failwithf "test 4590 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a606 } = r in
  let expected_a606 = #{ a605 = #{ a184 = (unbox_unit ()); b184 = "100" }; b605 = "101" } in
  mark_test_run 4591;
  let test = (fun #{ a605 = a6051; b605 = b6051 } #{ a605 = a6052; b605 = b6052 } -> (fun #{ a184 = a1841; b184 = b1841 } #{ a184 = a1842; b184 = b1842 } -> (fun _ _ -> true) a1841 a1842 && (fun a b -> String.equal (globalize a) (globalize b)) b1841 b1842) a6051 a6052 && (fun a b -> String.equal (globalize a) (globalize b)) b6051 b6052) expected_a606 a606 in
  if not test then failwithf "test 4591 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t608 = { #{ #{ float; int }; int } }   *)
  (********************************************)
  let r = { a608 = #{ a607 = #{ a58 = 0.; b58 = 1 }; b607 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a608 *)
  let actual = r.a608 in
  let expected = #{ a607 = #{ a58 = 0.; b58 = 1 }; b607 = 2 } in
  mark_test_run 4592;
  let test = (fun #{ a607 = a6071; b607 = b6071 } #{ a607 = a6072; b607 = b6072 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6071 a6072 && (fun a b -> Int.equal a b) b6071 b6072) actual expected in
  if not test then failwithf "test 4592 failed";
  (* Paths of depth 2 *)
  (* .a608.#a607 *)
  let actual = r.a608.#a607 in
  let expected = #{ a58 = 0.; b58 = 1 } in
  mark_test_run 4593;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 4593 failed";
  (* .a608.#b607 *)
  let actual = r.a608.#b607 in
  let expected = 2 in
  mark_test_run 4594;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4594 failed";
  (* Paths of depth 3 *)
  (* .a608.#a607.#a58 *)
  let actual = r.a608.#a607.#a58 in
  let expected = 0. in
  mark_test_run 4595;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4595 failed";
  (* .a608.#a607.#b58 *)
  let actual = r.a608.#a607.#b58 in
  let expected = 1 in
  mark_test_run 4596;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4596 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a608 = a6081 } { a608 = a6082 } -> (fun #{ a607 = a6071; b607 = b6071 } #{ a607 = a6072; b607 = b6072 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6071 a6072 && (fun a b -> Int.equal a b) b6071 b6072) a6081 a6082) in
  let next_r = { a608 = #{ a607 = #{ a58 = 100.; b58 = 101 }; b607 = 102 } } in
  let r_expected = { a608 = #{ a607 = #{ a58 = 0.; b58 = 1 }; b607 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a608 *)
  r.a608 <- next_r.a608;
  let r_expected = { r_expected with a608 = next_r.a608 } in
  mark_test_run 4597;
  let test = eq r r_expected in
  if not test then failwithf "test 4597 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a608 = #{ a607 = #{ a58; b58 }; b607 } } = r in
  let expected_b607 = 102 in
  mark_test_run 4598;
  let test = (fun a b -> Int.equal a b) expected_b607 b607 in
  if not test then failwithf "test 4598 failed";
  let expected_a58 = 100. in
  mark_test_run 4599;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 4599 failed";
  let expected_b58 = 101 in
  mark_test_run 4600;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 4600 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a608 } = r in
  let expected_a608 = #{ a607 = #{ a58 = 100.; b58 = 101 }; b607 = 102 } in
  mark_test_run 4601;
  let test = (fun #{ a607 = a6071; b607 = b6071 } #{ a607 = a6072; b607 = b6072 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6071 a6072 && (fun a b -> Int.equal a b) b6071 b6072) expected_a608 a608 in
  if not test then failwithf "test 4601 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t610 = { #{ #{ float; int }; float } }   *)
  (**********************************************)
  let r = { a610 = #{ a609 = #{ a58 = 0.; b58 = 1 }; b609 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a610 *)
  let actual = r.a610 in
  let expected = #{ a609 = #{ a58 = 0.; b58 = 1 }; b609 = 2. } in
  mark_test_run 4602;
  let test = (fun #{ a609 = a6091; b609 = b6091 } #{ a609 = a6092; b609 = b6092 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6091 a6092 && (fun a b -> Float.equal (globalize a) (globalize b)) b6091 b6092) actual expected in
  if not test then failwithf "test 4602 failed";
  (* Paths of depth 2 *)
  (* .a610.#a609 *)
  let actual = r.a610.#a609 in
  let expected = #{ a58 = 0.; b58 = 1 } in
  mark_test_run 4603;
  let test = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) actual expected in
  if not test then failwithf "test 4603 failed";
  (* .a610.#b609 *)
  let actual = r.a610.#b609 in
  let expected = 2. in
  mark_test_run 4604;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4604 failed";
  (* Paths of depth 3 *)
  (* .a610.#a609.#a58 *)
  let actual = r.a610.#a609.#a58 in
  let expected = 0. in
  mark_test_run 4605;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4605 failed";
  (* .a610.#a609.#b58 *)
  let actual = r.a610.#a609.#b58 in
  let expected = 1 in
  mark_test_run 4606;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4606 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a610 = a6101 } { a610 = a6102 } -> (fun #{ a609 = a6091; b609 = b6091 } #{ a609 = a6092; b609 = b6092 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6091 a6092 && (fun a b -> Float.equal (globalize a) (globalize b)) b6091 b6092) a6101 a6102) in
  let next_r = { a610 = #{ a609 = #{ a58 = 100.; b58 = 101 }; b609 = 102. } } in
  let r_expected = { a610 = #{ a609 = #{ a58 = 0.; b58 = 1 }; b609 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a610 *)
  r.a610 <- next_r.a610;
  let r_expected = { r_expected with a610 = next_r.a610 } in
  mark_test_run 4607;
  let test = eq r r_expected in
  if not test then failwithf "test 4607 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a610 = #{ a609 = #{ a58; b58 }; b609 } } = r in
  let expected_b609 = 102. in
  mark_test_run 4608;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b609 b609 in
  if not test then failwithf "test 4608 failed";
  let expected_a58 = 100. in
  mark_test_run 4609;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a58 a58 in
  if not test then failwithf "test 4609 failed";
  let expected_b58 = 101 in
  mark_test_run 4610;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 4610 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a610 } = r in
  let expected_a610 = #{ a609 = #{ a58 = 100.; b58 = 101 }; b609 = 102. } in
  mark_test_run 4611;
  let test = (fun #{ a609 = a6091; b609 = b6091 } #{ a609 = a6092; b609 = b6092 } -> (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a581 a582 && (fun a b -> Int.equal a b) b581 b582) a6091 a6092 && (fun a b -> Float.equal (globalize a) (globalize b)) b6091 b6092) expected_a610 a610 in
  if not test then failwithf "test 4611 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t612 = { #{ #{ float; float }; int } }   *)
  (**********************************************)
  let r = { a612 = #{ a611 = #{ a60 = 0.; b60 = 1. }; b611 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a612 *)
  let actual = r.a612 in
  let expected = #{ a611 = #{ a60 = 0.; b60 = 1. }; b611 = 2 } in
  mark_test_run 4612;
  let test = (fun #{ a611 = a6111; b611 = b6111 } #{ a611 = a6112; b611 = b6112 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6111 a6112 && (fun a b -> Int.equal a b) b6111 b6112) actual expected in
  if not test then failwithf "test 4612 failed";
  (* Paths of depth 2 *)
  (* .a612.#a611 *)
  let actual = r.a612.#a611 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 4613;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 4613 failed";
  (* .a612.#b611 *)
  let actual = r.a612.#b611 in
  let expected = 2 in
  mark_test_run 4614;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4614 failed";
  (* Paths of depth 3 *)
  (* .a612.#a611.#a60 *)
  let actual = r.a612.#a611.#a60 in
  let expected = 0. in
  mark_test_run 4615;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4615 failed";
  (* .a612.#a611.#b60 *)
  let actual = r.a612.#a611.#b60 in
  let expected = 1. in
  mark_test_run 4616;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4616 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a612 = a6121 } { a612 = a6122 } -> (fun #{ a611 = a6111; b611 = b6111 } #{ a611 = a6112; b611 = b6112 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6111 a6112 && (fun a b -> Int.equal a b) b6111 b6112) a6121 a6122) in
  let next_r = { a612 = #{ a611 = #{ a60 = 100.; b60 = 101. }; b611 = 102 } } in
  let r_expected = { a612 = #{ a611 = #{ a60 = 0.; b60 = 1. }; b611 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a612 *)
  r.a612 <- next_r.a612;
  let r_expected = { r_expected with a612 = next_r.a612 } in
  mark_test_run 4617;
  let test = eq r r_expected in
  if not test then failwithf "test 4617 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a612 = #{ a611 = #{ a60; b60 }; b611 } } = r in
  let expected_b611 = 102 in
  mark_test_run 4618;
  let test = (fun a b -> Int.equal a b) expected_b611 b611 in
  if not test then failwithf "test 4618 failed";
  let expected_a60 = 100. in
  mark_test_run 4619;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 4619 failed";
  let expected_b60 = 101. in
  mark_test_run 4620;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 4620 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a612 } = r in
  let expected_a612 = #{ a611 = #{ a60 = 100.; b60 = 101. }; b611 = 102 } in
  mark_test_run 4621;
  let test = (fun #{ a611 = a6111; b611 = b6111 } #{ a611 = a6112; b611 = b6112 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6111 a6112 && (fun a b -> Int.equal a b) b6111 b6112) expected_a612 a612 in
  if not test then failwithf "test 4621 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************)
  (*   t614 = { #{ #{ float; float }; float } }   *)
  (************************************************)
  let r = { a614 = #{ a613 = #{ a60 = 0.; b60 = 1. }; b613 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a614 *)
  let actual = r.a614 in
  let expected = #{ a613 = #{ a60 = 0.; b60 = 1. }; b613 = 2. } in
  mark_test_run 4622;
  let test = (fun #{ a613 = a6131; b613 = b6131 } #{ a613 = a6132; b613 = b6132 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6131 a6132 && (fun a b -> Float.equal (globalize a) (globalize b)) b6131 b6132) actual expected in
  if not test then failwithf "test 4622 failed";
  (* Paths of depth 2 *)
  (* .a614.#a613 *)
  let actual = r.a614.#a613 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 4623;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 4623 failed";
  (* .a614.#b613 *)
  let actual = r.a614.#b613 in
  let expected = 2. in
  mark_test_run 4624;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4624 failed";
  (* Paths of depth 3 *)
  (* .a614.#a613.#a60 *)
  let actual = r.a614.#a613.#a60 in
  let expected = 0. in
  mark_test_run 4625;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4625 failed";
  (* .a614.#a613.#b60 *)
  let actual = r.a614.#a613.#b60 in
  let expected = 1. in
  mark_test_run 4626;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4626 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a614 = a6141 } { a614 = a6142 } -> (fun #{ a613 = a6131; b613 = b6131 } #{ a613 = a6132; b613 = b6132 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6131 a6132 && (fun a b -> Float.equal (globalize a) (globalize b)) b6131 b6132) a6141 a6142) in
  let next_r = { a614 = #{ a613 = #{ a60 = 100.; b60 = 101. }; b613 = 102. } } in
  let r_expected = { a614 = #{ a613 = #{ a60 = 0.; b60 = 1. }; b613 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a614 *)
  r.a614 <- next_r.a614;
  let r_expected = { r_expected with a614 = next_r.a614 } in
  mark_test_run 4627;
  let test = eq r r_expected in
  if not test then failwithf "test 4627 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a614 = #{ a613 = #{ a60; b60 }; b613 } } = r in
  let expected_b613 = 102. in
  mark_test_run 4628;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b613 b613 in
  if not test then failwithf "test 4628 failed";
  let expected_a60 = 100. in
  mark_test_run 4629;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 4629 failed";
  let expected_b60 = 101. in
  mark_test_run 4630;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 4630 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a614 } = r in
  let expected_a614 = #{ a613 = #{ a60 = 100.; b60 = 101. }; b613 = 102. } in
  mark_test_run 4631;
  let test = (fun #{ a613 = a6131; b613 = b6131 } #{ a613 = a6132; b613 = b6132 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6131 a6132 && (fun a b -> Float.equal (globalize a) (globalize b)) b6131 b6132) expected_a614 a614 in
  if not test then failwithf "test 4631 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t616 = { #{ #{ float; float }; float# } }   *)
  (*************************************************)
  let r = { a616 = #{ a615 = #{ a60 = 0.; b60 = 1. }; b615 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a616 *)
  let actual = r.a616 in
  let expected = #{ a615 = #{ a60 = 0.; b60 = 1. }; b615 = #2. } in
  mark_test_run 4632;
  let test = (fun #{ a615 = a6151; b615 = b6151 } #{ a615 = a6152; b615 = b6152 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6151 a6152 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6151 b6152) actual expected in
  if not test then failwithf "test 4632 failed";
  (* Paths of depth 2 *)
  (* .a616.#a615 *)
  let actual = r.a616.#a615 in
  let expected = #{ a60 = 0.; b60 = 1. } in
  mark_test_run 4633;
  let test = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) actual expected in
  if not test then failwithf "test 4633 failed";
  (* .a616.#b615 *)
  let actual = r.a616.#b615 in
  let expected = #2. in
  mark_test_run 4634;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4634 failed";
  (* Paths of depth 3 *)
  (* .a616.#a615.#a60 *)
  let actual = r.a616.#a615.#a60 in
  let expected = 0. in
  mark_test_run 4635;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4635 failed";
  (* .a616.#a615.#b60 *)
  let actual = r.a616.#a615.#b60 in
  let expected = 1. in
  mark_test_run 4636;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4636 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a616 = a6161 } { a616 = a6162 } -> (fun #{ a615 = a6151; b615 = b6151 } #{ a615 = a6152; b615 = b6152 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6151 a6152 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6151 b6152) a6161 a6162) in
  let next_r = { a616 = #{ a615 = #{ a60 = 100.; b60 = 101. }; b615 = #102. } } in
  let r_expected = { a616 = #{ a615 = #{ a60 = 0.; b60 = 1. }; b615 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a616 *)
  r.a616 <- next_r.a616;
  let r_expected = { r_expected with a616 = next_r.a616 } in
  mark_test_run 4637;
  let test = eq r r_expected in
  if not test then failwithf "test 4637 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a616 = #{ a615 = #{ a60; b60 }; b615 } } = r in
  let expected_b615 = #102. in
  mark_test_run 4638;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b615 b615 in
  if not test then failwithf "test 4638 failed";
  let expected_a60 = 100. in
  mark_test_run 4639;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a60 a60 in
  if not test then failwithf "test 4639 failed";
  let expected_b60 = 101. in
  mark_test_run 4640;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 4640 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a616 } = r in
  let expected_a616 = #{ a615 = #{ a60 = 100.; b60 = 101. }; b615 = #102. } in
  mark_test_run 4641;
  let test = (fun #{ a615 = a6151; b615 = b6151 } #{ a615 = a6152; b615 = b6152 } -> (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) a6151 a6152 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6151 b6152) expected_a616 a616 in
  if not test then failwithf "test 4641 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t618 = { #{ #{ float; float# }; float } }   *)
  (*************************************************)
  let r = { a618 = #{ a617 = #{ a235 = 0.; b235 = #1. }; b617 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a618 *)
  let actual = r.a618 in
  let expected = #{ a617 = #{ a235 = 0.; b235 = #1. }; b617 = 2. } in
  mark_test_run 4642;
  let test = (fun #{ a617 = a6171; b617 = b6171 } #{ a617 = a6172; b617 = b6172 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6171 a6172 && (fun a b -> Float.equal (globalize a) (globalize b)) b6171 b6172) actual expected in
  if not test then failwithf "test 4642 failed";
  (* Paths of depth 2 *)
  (* .a618.#a617 *)
  let actual = r.a618.#a617 in
  let expected = #{ a235 = 0.; b235 = #1. } in
  mark_test_run 4643;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 4643 failed";
  (* .a618.#b617 *)
  let actual = r.a618.#b617 in
  let expected = 2. in
  mark_test_run 4644;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4644 failed";
  (* Paths of depth 3 *)
  (* .a618.#a617.#a235 *)
  let actual = r.a618.#a617.#a235 in
  let expected = 0. in
  mark_test_run 4645;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4645 failed";
  (* .a618.#a617.#b235 *)
  let actual = r.a618.#a617.#b235 in
  let expected = #1. in
  mark_test_run 4646;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4646 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a618 = a6181 } { a618 = a6182 } -> (fun #{ a617 = a6171; b617 = b6171 } #{ a617 = a6172; b617 = b6172 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6171 a6172 && (fun a b -> Float.equal (globalize a) (globalize b)) b6171 b6172) a6181 a6182) in
  let next_r = { a618 = #{ a617 = #{ a235 = 100.; b235 = #101. }; b617 = 102. } } in
  let r_expected = { a618 = #{ a617 = #{ a235 = 0.; b235 = #1. }; b617 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a618 *)
  r.a618 <- next_r.a618;
  let r_expected = { r_expected with a618 = next_r.a618 } in
  mark_test_run 4647;
  let test = eq r r_expected in
  if not test then failwithf "test 4647 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a618 = #{ a617 = #{ a235; b235 }; b617 } } = r in
  let expected_b617 = 102. in
  mark_test_run 4648;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b617 b617 in
  if not test then failwithf "test 4648 failed";
  let expected_a235 = 100. in
  mark_test_run 4649;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 4649 failed";
  let expected_b235 = #101. in
  mark_test_run 4650;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 4650 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a618 } = r in
  let expected_a618 = #{ a617 = #{ a235 = 100.; b235 = #101. }; b617 = 102. } in
  mark_test_run 4651;
  let test = (fun #{ a617 = a6171; b617 = b6171 } #{ a617 = a6172; b617 = b6172 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6171 a6172 && (fun a b -> Float.equal (globalize a) (globalize b)) b6171 b6172) expected_a618 a618 in
  if not test then failwithf "test 4651 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t620 = { #{ #{ float; float# }; float# } }   *)
  (**************************************************)
  let r = { a620 = #{ a619 = #{ a235 = 0.; b235 = #1. }; b619 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a620 *)
  let actual = r.a620 in
  let expected = #{ a619 = #{ a235 = 0.; b235 = #1. }; b619 = #2. } in
  mark_test_run 4652;
  let test = (fun #{ a619 = a6191; b619 = b6191 } #{ a619 = a6192; b619 = b6192 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6191 a6192 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6191 b6192) actual expected in
  if not test then failwithf "test 4652 failed";
  (* Paths of depth 2 *)
  (* .a620.#a619 *)
  let actual = r.a620.#a619 in
  let expected = #{ a235 = 0.; b235 = #1. } in
  mark_test_run 4653;
  let test = (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) actual expected in
  if not test then failwithf "test 4653 failed";
  (* .a620.#b619 *)
  let actual = r.a620.#b619 in
  let expected = #2. in
  mark_test_run 4654;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4654 failed";
  (* Paths of depth 3 *)
  (* .a620.#a619.#a235 *)
  let actual = r.a620.#a619.#a235 in
  let expected = 0. in
  mark_test_run 4655;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4655 failed";
  (* .a620.#a619.#b235 *)
  let actual = r.a620.#a619.#b235 in
  let expected = #1. in
  mark_test_run 4656;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4656 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a620 = a6201 } { a620 = a6202 } -> (fun #{ a619 = a6191; b619 = b6191 } #{ a619 = a6192; b619 = b6192 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6191 a6192 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6191 b6192) a6201 a6202) in
  let next_r = { a620 = #{ a619 = #{ a235 = 100.; b235 = #101. }; b619 = #102. } } in
  let r_expected = { a620 = #{ a619 = #{ a235 = 0.; b235 = #1. }; b619 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a620 *)
  r.a620 <- next_r.a620;
  let r_expected = { r_expected with a620 = next_r.a620 } in
  mark_test_run 4657;
  let test = eq r r_expected in
  if not test then failwithf "test 4657 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a620 = #{ a619 = #{ a235; b235 }; b619 } } = r in
  let expected_b619 = #102. in
  mark_test_run 4658;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b619 b619 in
  if not test then failwithf "test 4658 failed";
  let expected_a235 = 100. in
  mark_test_run 4659;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a235 a235 in
  if not test then failwithf "test 4659 failed";
  let expected_b235 = #101. in
  mark_test_run 4660;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b235 b235 in
  if not test then failwithf "test 4660 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a620 } = r in
  let expected_a620 = #{ a619 = #{ a235 = 100.; b235 = #101. }; b619 = #102. } in
  mark_test_run 4661;
  let test = (fun #{ a619 = a6191; b619 = b6191 } #{ a619 = a6192; b619 = b6192 } -> (fun #{ a235 = a2351; b235 = b2351 } #{ a235 = a2352; b235 = b2352 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a2351 a2352 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2351 b2352) a6191 a6192 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6191 b6192) expected_a620 a620 in
  if not test then failwithf "test 4661 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************************)
  (*   t622 = { #{ #{ float#; float }; float } }   *)
  (*************************************************)
  let r = { a622 = #{ a621 = #{ a243 = #0.; b243 = 1. }; b621 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a622 *)
  let actual = r.a622 in
  let expected = #{ a621 = #{ a243 = #0.; b243 = 1. }; b621 = 2. } in
  mark_test_run 4662;
  let test = (fun #{ a621 = a6211; b621 = b6211 } #{ a621 = a6212; b621 = b6212 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6211 a6212 && (fun a b -> Float.equal (globalize a) (globalize b)) b6211 b6212) actual expected in
  if not test then failwithf "test 4662 failed";
  (* Paths of depth 2 *)
  (* .a622.#a621 *)
  let actual = r.a622.#a621 in
  let expected = #{ a243 = #0.; b243 = 1. } in
  mark_test_run 4663;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4663 failed";
  (* .a622.#b621 *)
  let actual = r.a622.#b621 in
  let expected = 2. in
  mark_test_run 4664;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4664 failed";
  (* Paths of depth 3 *)
  (* .a622.#a621.#a243 *)
  let actual = r.a622.#a621.#a243 in
  let expected = #0. in
  mark_test_run 4665;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4665 failed";
  (* .a622.#a621.#b243 *)
  let actual = r.a622.#a621.#b243 in
  let expected = 1. in
  mark_test_run 4666;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4666 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a622 = a6221 } { a622 = a6222 } -> (fun #{ a621 = a6211; b621 = b6211 } #{ a621 = a6212; b621 = b6212 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6211 a6212 && (fun a b -> Float.equal (globalize a) (globalize b)) b6211 b6212) a6221 a6222) in
  let next_r = { a622 = #{ a621 = #{ a243 = #100.; b243 = 101. }; b621 = 102. } } in
  let r_expected = { a622 = #{ a621 = #{ a243 = #0.; b243 = 1. }; b621 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a622 *)
  r.a622 <- next_r.a622;
  let r_expected = { r_expected with a622 = next_r.a622 } in
  mark_test_run 4667;
  let test = eq r r_expected in
  if not test then failwithf "test 4667 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a622 = #{ a621 = #{ a243; b243 }; b621 } } = r in
  let expected_b621 = 102. in
  mark_test_run 4668;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b621 b621 in
  if not test then failwithf "test 4668 failed";
  let expected_a243 = #100. in
  mark_test_run 4669;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4669 failed";
  let expected_b243 = 101. in
  mark_test_run 4670;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4670 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a622 } = r in
  let expected_a622 = #{ a621 = #{ a243 = #100.; b243 = 101. }; b621 = 102. } in
  mark_test_run 4671;
  let test = (fun #{ a621 = a6211; b621 = b6211 } #{ a621 = a6212; b621 = b6212 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6211 a6212 && (fun a b -> Float.equal (globalize a) (globalize b)) b6211 b6212) expected_a622 a622 in
  if not test then failwithf "test 4671 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t624 = { #{ #{ float#; float }; float# } }   *)
  (**************************************************)
  let r = { a624 = #{ a623 = #{ a243 = #0.; b243 = 1. }; b623 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a624 *)
  let actual = r.a624 in
  let expected = #{ a623 = #{ a243 = #0.; b243 = 1. }; b623 = #2. } in
  mark_test_run 4672;
  let test = (fun #{ a623 = a6231; b623 = b6231 } #{ a623 = a6232; b623 = b6232 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6231 a6232 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6231 b6232) actual expected in
  if not test then failwithf "test 4672 failed";
  (* Paths of depth 2 *)
  (* .a624.#a623 *)
  let actual = r.a624.#a623 in
  let expected = #{ a243 = #0.; b243 = 1. } in
  mark_test_run 4673;
  let test = (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) actual expected in
  if not test then failwithf "test 4673 failed";
  (* .a624.#b623 *)
  let actual = r.a624.#b623 in
  let expected = #2. in
  mark_test_run 4674;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4674 failed";
  (* Paths of depth 3 *)
  (* .a624.#a623.#a243 *)
  let actual = r.a624.#a623.#a243 in
  let expected = #0. in
  mark_test_run 4675;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4675 failed";
  (* .a624.#a623.#b243 *)
  let actual = r.a624.#a623.#b243 in
  let expected = 1. in
  mark_test_run 4676;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4676 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a624 = a6241 } { a624 = a6242 } -> (fun #{ a623 = a6231; b623 = b6231 } #{ a623 = a6232; b623 = b6232 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6231 a6232 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6231 b6232) a6241 a6242) in
  let next_r = { a624 = #{ a623 = #{ a243 = #100.; b243 = 101. }; b623 = #102. } } in
  let r_expected = { a624 = #{ a623 = #{ a243 = #0.; b243 = 1. }; b623 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a624 *)
  r.a624 <- next_r.a624;
  let r_expected = { r_expected with a624 = next_r.a624 } in
  mark_test_run 4677;
  let test = eq r r_expected in
  if not test then failwithf "test 4677 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a624 = #{ a623 = #{ a243; b243 }; b623 } } = r in
  let expected_b623 = #102. in
  mark_test_run 4678;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b623 b623 in
  if not test then failwithf "test 4678 failed";
  let expected_a243 = #100. in
  mark_test_run 4679;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a243 a243 in
  if not test then failwithf "test 4679 failed";
  let expected_b243 = 101. in
  mark_test_run 4680;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b243 b243 in
  if not test then failwithf "test 4680 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a624 } = r in
  let expected_a624 = #{ a623 = #{ a243 = #100.; b243 = 101. }; b623 = #102. } in
  mark_test_run 4681;
  let test = (fun #{ a623 = a6231; b623 = b6231 } #{ a623 = a6232; b623 = b6232 } -> (fun #{ a243 = a2431; b243 = b2431 } #{ a243 = a2432; b243 = b2432 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2431 a2432 && (fun a b -> Float.equal (globalize a) (globalize b)) b2431 b2432) a6231 a6232 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6231 b6232) expected_a624 a624 in
  if not test then failwithf "test 4681 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************************)
  (*   t626 = { #{ #{ float#; float# }; float } }   *)
  (**************************************************)
  let r = { a626 = #{ a625 = #{ a245 = #0.; b245 = #1. }; b625 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a626 *)
  let actual = r.a626 in
  let expected = #{ a625 = #{ a245 = #0.; b245 = #1. }; b625 = 2. } in
  mark_test_run 4682;
  let test = (fun #{ a625 = a6251; b625 = b6251 } #{ a625 = a6252; b625 = b6252 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6251 a6252 && (fun a b -> Float.equal (globalize a) (globalize b)) b6251 b6252) actual expected in
  if not test then failwithf "test 4682 failed";
  (* Paths of depth 2 *)
  (* .a626.#a625 *)
  let actual = r.a626.#a625 in
  let expected = #{ a245 = #0.; b245 = #1. } in
  mark_test_run 4683;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4683 failed";
  (* .a626.#b625 *)
  let actual = r.a626.#b625 in
  let expected = 2. in
  mark_test_run 4684;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4684 failed";
  (* Paths of depth 3 *)
  (* .a626.#a625.#a245 *)
  let actual = r.a626.#a625.#a245 in
  let expected = #0. in
  mark_test_run 4685;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4685 failed";
  (* .a626.#a625.#b245 *)
  let actual = r.a626.#a625.#b245 in
  let expected = #1. in
  mark_test_run 4686;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4686 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a626 = a6261 } { a626 = a6262 } -> (fun #{ a625 = a6251; b625 = b6251 } #{ a625 = a6252; b625 = b6252 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6251 a6252 && (fun a b -> Float.equal (globalize a) (globalize b)) b6251 b6252) a6261 a6262) in
  let next_r = { a626 = #{ a625 = #{ a245 = #100.; b245 = #101. }; b625 = 102. } } in
  let r_expected = { a626 = #{ a625 = #{ a245 = #0.; b245 = #1. }; b625 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a626 *)
  r.a626 <- next_r.a626;
  let r_expected = { r_expected with a626 = next_r.a626 } in
  mark_test_run 4687;
  let test = eq r r_expected in
  if not test then failwithf "test 4687 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a626 = #{ a625 = #{ a245; b245 }; b625 } } = r in
  let expected_b625 = 102. in
  mark_test_run 4688;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b625 b625 in
  if not test then failwithf "test 4688 failed";
  let expected_a245 = #100. in
  mark_test_run 4689;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4689 failed";
  let expected_b245 = #101. in
  mark_test_run 4690;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4690 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a626 } = r in
  let expected_a626 = #{ a625 = #{ a245 = #100.; b245 = #101. }; b625 = 102. } in
  mark_test_run 4691;
  let test = (fun #{ a625 = a6251; b625 = b6251 } #{ a625 = a6252; b625 = b6252 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6251 a6252 && (fun a b -> Float.equal (globalize a) (globalize b)) b6251 b6252) expected_a626 a626 in
  if not test then failwithf "test 4691 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t628 = { #{ #{ float#; float# }; float# } }   *)
  (***************************************************)
  let r = { a628 = #{ a627 = #{ a245 = #0.; b245 = #1. }; b627 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a628 *)
  let actual = r.a628 in
  let expected = #{ a627 = #{ a245 = #0.; b245 = #1. }; b627 = #2. } in
  mark_test_run 4692;
  let test = (fun #{ a627 = a6271; b627 = b6271 } #{ a627 = a6272; b627 = b6272 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6271 a6272 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6271 b6272) actual expected in
  if not test then failwithf "test 4692 failed";
  (* Paths of depth 2 *)
  (* .a628.#a627 *)
  let actual = r.a628.#a627 in
  let expected = #{ a245 = #0.; b245 = #1. } in
  mark_test_run 4693;
  let test = (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) actual expected in
  if not test then failwithf "test 4693 failed";
  (* .a628.#b627 *)
  let actual = r.a628.#b627 in
  let expected = #2. in
  mark_test_run 4694;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4694 failed";
  (* Paths of depth 3 *)
  (* .a628.#a627.#a245 *)
  let actual = r.a628.#a627.#a245 in
  let expected = #0. in
  mark_test_run 4695;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4695 failed";
  (* .a628.#a627.#b245 *)
  let actual = r.a628.#a627.#b245 in
  let expected = #1. in
  mark_test_run 4696;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 4696 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a628 = a6281 } { a628 = a6282 } -> (fun #{ a627 = a6271; b627 = b6271 } #{ a627 = a6272; b627 = b6272 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6271 a6272 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6271 b6272) a6281 a6282) in
  let next_r = { a628 = #{ a627 = #{ a245 = #100.; b245 = #101. }; b627 = #102. } } in
  let r_expected = { a628 = #{ a627 = #{ a245 = #0.; b245 = #1. }; b627 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a628 *)
  r.a628 <- next_r.a628;
  let r_expected = { r_expected with a628 = next_r.a628 } in
  mark_test_run 4697;
  let test = eq r r_expected in
  if not test then failwithf "test 4697 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a628 = #{ a627 = #{ a245; b245 }; b627 } } = r in
  let expected_b627 = #102. in
  mark_test_run 4698;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b627 b627 in
  if not test then failwithf "test 4698 failed";
  let expected_a245 = #100. in
  mark_test_run 4699;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a245 a245 in
  if not test then failwithf "test 4699 failed";
  let expected_b245 = #101. in
  mark_test_run 4700;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b245 b245 in
  if not test then failwithf "test 4700 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a628 } = r in
  let expected_a628 = #{ a627 = #{ a245 = #100.; b245 = #101. }; b627 = #102. } in
  mark_test_run 4701;
  let test = (fun #{ a627 = a6271; b627 = b6271 } #{ a627 = a6272; b627 = b6272 } -> (fun #{ a245 = a2451; b245 = b2451 } #{ a245 = a2452; b245 = b2452 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a2451 a2452 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b2451 b2452) a6271 a6272 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b6271 b6272) expected_a628 a628 in
  if not test then failwithf "test 4701 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t630 = { #{ #{ string; unit_u }; unit_u } }   *)
  (***************************************************)
  let r = { a630 = #{ a629 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b629 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a630 *)
  let actual = r.a630 in
  let expected = #{ a629 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b629 = (unbox_unit ()) } in
  mark_test_run 4702;
  let test = (fun #{ a629 = a6291; b629 = b6291 } #{ a629 = a6292; b629 = b6292 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6291 a6292 && (fun _ _ -> true) b6291 b6292) actual expected in
  if not test then failwithf "test 4702 failed";
  (* Paths of depth 2 *)
  (* .a630.#a629 *)
  let actual = r.a630.#a629 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 4703;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4703 failed";
  (* .a630.#b629 *)
  let actual = r.a630.#b629 in
  let expected = (unbox_unit ()) in
  mark_test_run 4704;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4704 failed";
  (* Paths of depth 3 *)
  (* .a630.#a629.#a190 *)
  let actual = r.a630.#a629.#a190 in
  let expected = "0" in
  mark_test_run 4705;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4705 failed";
  (* .a630.#a629.#b190 *)
  let actual = r.a630.#a629.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4706;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4706 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a630 = a6301 } { a630 = a6302 } -> (fun #{ a629 = a6291; b629 = b6291 } #{ a629 = a6292; b629 = b6292 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6291 a6292 && (fun _ _ -> true) b6291 b6292) a6301 a6302) in
  let next_r = { a630 = #{ a629 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b629 = (unbox_unit ()) } } in
  let r_expected = { a630 = #{ a629 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b629 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a630 *)
  r.a630 <- next_r.a630;
  let r_expected = { r_expected with a630 = next_r.a630 } in
  mark_test_run 4707;
  let test = eq r r_expected in
  if not test then failwithf "test 4707 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a630 = #{ a629 = #{ a190; b190 }; b629 } } = r in
  let expected_b629 = (unbox_unit ()) in
  mark_test_run 4708;
  let test = (fun _ _ -> true) expected_b629 b629 in
  if not test then failwithf "test 4708 failed";
  let expected_a190 = "100" in
  mark_test_run 4709;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4709 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4710;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4710 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a630 } = r in
  let expected_a630 = #{ a629 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b629 = (unbox_unit ()) } in
  mark_test_run 4711;
  let test = (fun #{ a629 = a6291; b629 = b6291 } #{ a629 = a6292; b629 = b6292 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6291 a6292 && (fun _ _ -> true) b6291 b6292) expected_a630 a630 in
  if not test then failwithf "test 4711 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t632 = { #{ #{ string; unit_u }; string } }   *)
  (***************************************************)
  let r = { a632 = #{ a631 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b631 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a632 *)
  let actual = r.a632 in
  let expected = #{ a631 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b631 = "1" } in
  mark_test_run 4712;
  let test = (fun #{ a631 = a6311; b631 = b6311 } #{ a631 = a6312; b631 = b6312 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6311 a6312 && (fun a b -> String.equal (globalize a) (globalize b)) b6311 b6312) actual expected in
  if not test then failwithf "test 4712 failed";
  (* Paths of depth 2 *)
  (* .a632.#a631 *)
  let actual = r.a632.#a631 in
  let expected = #{ a190 = "0"; b190 = (unbox_unit ()) } in
  mark_test_run 4713;
  let test = (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) actual expected in
  if not test then failwithf "test 4713 failed";
  (* .a632.#b631 *)
  let actual = r.a632.#b631 in
  let expected = "1" in
  mark_test_run 4714;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4714 failed";
  (* Paths of depth 3 *)
  (* .a632.#a631.#a190 *)
  let actual = r.a632.#a631.#a190 in
  let expected = "0" in
  mark_test_run 4715;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4715 failed";
  (* .a632.#a631.#b190 *)
  let actual = r.a632.#a631.#b190 in
  let expected = (unbox_unit ()) in
  mark_test_run 4716;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4716 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a632 = a6321 } { a632 = a6322 } -> (fun #{ a631 = a6311; b631 = b6311 } #{ a631 = a6312; b631 = b6312 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6311 a6312 && (fun a b -> String.equal (globalize a) (globalize b)) b6311 b6312) a6321 a6322) in
  let next_r = { a632 = #{ a631 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b631 = "101" } } in
  let r_expected = { a632 = #{ a631 = #{ a190 = "0"; b190 = (unbox_unit ()) }; b631 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a632 *)
  r.a632 <- next_r.a632;
  let r_expected = { r_expected with a632 = next_r.a632 } in
  mark_test_run 4717;
  let test = eq r r_expected in
  if not test then failwithf "test 4717 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a632 = #{ a631 = #{ a190; b190 }; b631 } } = r in
  let expected_b631 = "101" in
  mark_test_run 4718;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b631 b631 in
  if not test then failwithf "test 4718 failed";
  let expected_a190 = "100" in
  mark_test_run 4719;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a190 a190 in
  if not test then failwithf "test 4719 failed";
  let expected_b190 = (unbox_unit ()) in
  mark_test_run 4720;
  let test = (fun _ _ -> true) expected_b190 b190 in
  if not test then failwithf "test 4720 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a632 } = r in
  let expected_a632 = #{ a631 = #{ a190 = "100"; b190 = (unbox_unit ()) }; b631 = "101" } in
  mark_test_run 4721;
  let test = (fun #{ a631 = a6311; b631 = b6311 } #{ a631 = a6312; b631 = b6312 } -> (fun #{ a190 = a1901; b190 = b1901 } #{ a190 = a1902; b190 = b1902 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1901 a1902 && (fun _ _ -> true) b1901 b1902) a6311 a6312 && (fun a b -> String.equal (globalize a) (globalize b)) b6311 b6312) expected_a632 a632 in
  if not test then failwithf "test 4721 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t634 = { #{ #{ string; string }; unit_u } }   *)
  (***************************************************)
  let r = { a634 = #{ a633 = #{ a192 = "0"; b192 = "1" }; b633 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a634 *)
  let actual = r.a634 in
  let expected = #{ a633 = #{ a192 = "0"; b192 = "1" }; b633 = (unbox_unit ()) } in
  mark_test_run 4722;
  let test = (fun #{ a633 = a6331; b633 = b6331 } #{ a633 = a6332; b633 = b6332 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6331 a6332 && (fun _ _ -> true) b6331 b6332) actual expected in
  if not test then failwithf "test 4722 failed";
  (* Paths of depth 2 *)
  (* .a634.#a633 *)
  let actual = r.a634.#a633 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 4723;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4723 failed";
  (* .a634.#b633 *)
  let actual = r.a634.#b633 in
  let expected = (unbox_unit ()) in
  mark_test_run 4724;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 4724 failed";
  (* Paths of depth 3 *)
  (* .a634.#a633.#a192 *)
  let actual = r.a634.#a633.#a192 in
  let expected = "0" in
  mark_test_run 4725;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4725 failed";
  (* .a634.#a633.#b192 *)
  let actual = r.a634.#a633.#b192 in
  let expected = "1" in
  mark_test_run 4726;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4726 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a634 = a6341 } { a634 = a6342 } -> (fun #{ a633 = a6331; b633 = b6331 } #{ a633 = a6332; b633 = b6332 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6331 a6332 && (fun _ _ -> true) b6331 b6332) a6341 a6342) in
  let next_r = { a634 = #{ a633 = #{ a192 = "100"; b192 = "101" }; b633 = (unbox_unit ()) } } in
  let r_expected = { a634 = #{ a633 = #{ a192 = "0"; b192 = "1" }; b633 = (unbox_unit ()) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a634 *)
  r.a634 <- next_r.a634;
  let r_expected = { r_expected with a634 = next_r.a634 } in
  mark_test_run 4727;
  let test = eq r r_expected in
  if not test then failwithf "test 4727 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a634 = #{ a633 = #{ a192; b192 }; b633 } } = r in
  let expected_b633 = (unbox_unit ()) in
  mark_test_run 4728;
  let test = (fun _ _ -> true) expected_b633 b633 in
  if not test then failwithf "test 4728 failed";
  let expected_a192 = "100" in
  mark_test_run 4729;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4729 failed";
  let expected_b192 = "101" in
  mark_test_run 4730;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4730 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a634 } = r in
  let expected_a634 = #{ a633 = #{ a192 = "100"; b192 = "101" }; b633 = (unbox_unit ()) } in
  mark_test_run 4731;
  let test = (fun #{ a633 = a6331; b633 = b6331 } #{ a633 = a6332; b633 = b6332 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6331 a6332 && (fun _ _ -> true) b6331 b6332) expected_a634 a634 in
  if not test then failwithf "test 4731 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************************)
  (*   t636 = { #{ #{ string; string }; string } }   *)
  (***************************************************)
  let r = { a636 = #{ a635 = #{ a192 = "0"; b192 = "1" }; b635 = "2" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a636 *)
  let actual = r.a636 in
  let expected = #{ a635 = #{ a192 = "0"; b192 = "1" }; b635 = "2" } in
  mark_test_run 4732;
  let test = (fun #{ a635 = a6351; b635 = b6351 } #{ a635 = a6352; b635 = b6352 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6351 a6352 && (fun a b -> String.equal (globalize a) (globalize b)) b6351 b6352) actual expected in
  if not test then failwithf "test 4732 failed";
  (* Paths of depth 2 *)
  (* .a636.#a635 *)
  let actual = r.a636.#a635 in
  let expected = #{ a192 = "0"; b192 = "1" } in
  mark_test_run 4733;
  let test = (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) actual expected in
  if not test then failwithf "test 4733 failed";
  (* .a636.#b635 *)
  let actual = r.a636.#b635 in
  let expected = "2" in
  mark_test_run 4734;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4734 failed";
  (* Paths of depth 3 *)
  (* .a636.#a635.#a192 *)
  let actual = r.a636.#a635.#a192 in
  let expected = "0" in
  mark_test_run 4735;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4735 failed";
  (* .a636.#a635.#b192 *)
  let actual = r.a636.#a635.#b192 in
  let expected = "1" in
  mark_test_run 4736;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 4736 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a636 = a6361 } { a636 = a6362 } -> (fun #{ a635 = a6351; b635 = b6351 } #{ a635 = a6352; b635 = b6352 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6351 a6352 && (fun a b -> String.equal (globalize a) (globalize b)) b6351 b6352) a6361 a6362) in
  let next_r = { a636 = #{ a635 = #{ a192 = "100"; b192 = "101" }; b635 = "102" } } in
  let r_expected = { a636 = #{ a635 = #{ a192 = "0"; b192 = "1" }; b635 = "2" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a636 *)
  r.a636 <- next_r.a636;
  let r_expected = { r_expected with a636 = next_r.a636 } in
  mark_test_run 4737;
  let test = eq r r_expected in
  if not test then failwithf "test 4737 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a636 = #{ a635 = #{ a192; b192 }; b635 } } = r in
  let expected_b635 = "102" in
  mark_test_run 4738;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b635 b635 in
  if not test then failwithf "test 4738 failed";
  let expected_a192 = "100" in
  mark_test_run 4739;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a192 a192 in
  if not test then failwithf "test 4739 failed";
  let expected_b192 = "101" in
  mark_test_run 4740;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b192 b192 in
  if not test then failwithf "test 4740 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a636 } = r in
  let expected_a636 = #{ a635 = #{ a192 = "100"; b192 = "101" }; b635 = "102" } in
  mark_test_run 4741;
  let test = (fun #{ a635 = a6351; b635 = b6351 } #{ a635 = a6352; b635 = b6352 } -> (fun #{ a192 = a1921; b192 = b1921 } #{ a192 = a1922; b192 = b1922 } -> (fun a b -> String.equal (globalize a) (globalize b)) a1921 a1922 && (fun a b -> String.equal (globalize a) (globalize b)) b1921 b1922) a6351 a6352 && (fun a b -> String.equal (globalize a) (globalize b)) b6351 b6352) expected_a636 a636 in
  if not test then failwithf "test 4741 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************************)
  (*   t638 = { #{ #{ int64x2#; int }; int } }   *)
  (***********************************************)
  let r = { a638 = #{ a637 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b637 = 3 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a638 *)
  let actual = r.a638 in
  let expected = #{ a637 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b637 = 3 } in
  mark_test_run 4742;
  let test = (fun #{ a637 = a6371; b637 = b6371 } #{ a637 = a6372; b637 = b6372 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6371 a6372 && (fun a b -> Int.equal a b) b6371 b6372) actual expected in
  if not test then failwithf "test 4742 failed";
  (* Paths of depth 2 *)
  (* .a638.#a637 *)
  let actual = r.a638.#a637 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } in
  mark_test_run 4743;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4743 failed";
  (* .a638.#b637 *)
  let actual = r.a638.#b637 in
  let expected = 3 in
  mark_test_run 4744;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4744 failed";
  (* Paths of depth 3 *)
  (* .a638.#a637.#a67 *)
  let actual = r.a638.#a637.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4745;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4745 failed";
  (* .a638.#a637.#b67 *)
  let actual = r.a638.#a637.#b67 in
  let expected = 2 in
  mark_test_run 4746;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4746 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a638 = a6381 } { a638 = a6382 } -> (fun #{ a637 = a6371; b637 = b6371 } #{ a637 = a6372; b637 = b6372 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6371 a6372 && (fun a b -> Int.equal a b) b6371 b6372) a6381 a6382) in
  let next_r = { a638 = #{ a637 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b637 = 103 } } in
  let r_expected = { a638 = #{ a637 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b637 = 3 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a638 *)
  r.a638 <- next_r.a638;
  let r_expected = { r_expected with a638 = next_r.a638 } in
  mark_test_run 4747;
  let test = eq r r_expected in
  if not test then failwithf "test 4747 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a638 = #{ a637 = #{ a67; b67 }; b637 } } = r in
  let expected_b637 = 103 in
  mark_test_run 4748;
  let test = (fun a b -> Int.equal a b) expected_b637 b637 in
  if not test then failwithf "test 4748 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4749;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4749 failed";
  let expected_b67 = 102 in
  mark_test_run 4750;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4750 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a638 } = r in
  let expected_a638 = #{ a637 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b637 = 103 } in
  mark_test_run 4751;
  let test = (fun #{ a637 = a6371; b637 = b6371 } #{ a637 = a6372; b637 = b6372 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6371 a6372 && (fun a b -> Int.equal a b) b6371 b6372) expected_a638 a638 in
  if not test then failwithf "test 4751 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t640 = { #{ #{ int64x2#; int }; int64x2# } }   *)
  (****************************************************)
  let r = { a640 = #{ a639 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b639 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a640 *)
  let actual = r.a640 in
  let expected = #{ a639 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b639 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 4752;
  let test = (fun #{ a639 = a6391; b639 = b6391 } #{ a639 = a6392; b639 = b6392 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6391 a6392 && int64x2_u_equal b6391 b6392) actual expected in
  if not test then failwithf "test 4752 failed";
  (* Paths of depth 2 *)
  (* .a640.#a639 *)
  let actual = r.a640.#a639 in
  let expected = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 } in
  mark_test_run 4753;
  let test = (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) actual expected in
  if not test then failwithf "test 4753 failed";
  (* .a640.#b639 *)
  let actual = r.a640.#b639 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 4754;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4754 failed";
  (* Paths of depth 3 *)
  (* .a640.#a639.#a67 *)
  let actual = r.a640.#a639.#a67 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4755;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4755 failed";
  (* .a640.#a639.#b67 *)
  let actual = r.a640.#a639.#b67 in
  let expected = 2 in
  mark_test_run 4756;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4756 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a640 = a6401 } { a640 = a6402 } -> (fun #{ a639 = a6391; b639 = b6391 } #{ a639 = a6392; b639 = b6392 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6391 a6392 && int64x2_u_equal b6391 b6392) a6401 a6402) in
  let next_r = { a640 = #{ a639 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b639 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  let r_expected = { a640 = #{ a639 = #{ a67 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b67 = 2 }; b639 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a640 *)
  r.a640 <- next_r.a640;
  let r_expected = { r_expected with a640 = next_r.a640 } in
  mark_test_run 4757;
  let test = eq r r_expected in
  if not test then failwithf "test 4757 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a640 = #{ a639 = #{ a67; b67 }; b639 } } = r in
  let expected_b639 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 4758;
  let test = int64x2_u_equal expected_b639 b639 in
  if not test then failwithf "test 4758 failed";
  let expected_a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4759;
  let test = int64x2_u_equal expected_a67 a67 in
  if not test then failwithf "test 4759 failed";
  let expected_b67 = 102 in
  mark_test_run 4760;
  let test = (fun a b -> Int.equal a b) expected_b67 b67 in
  if not test then failwithf "test 4760 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a640 } = r in
  let expected_a640 = #{ a639 = #{ a67 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b67 = 102 }; b639 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  mark_test_run 4761;
  let test = (fun #{ a639 = a6391; b639 = b6391 } #{ a639 = a6392; b639 = b6392 } -> (fun #{ a67 = a671; b67 = b671 } #{ a67 = a672; b67 = b672 } -> int64x2_u_equal a671 a672 && (fun a b -> Int.equal a b) b671 b672) a6391 a6392 && int64x2_u_equal b6391 b6392) expected_a640 a640 in
  if not test then failwithf "test 4761 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************************)
  (*   t642 = { #{ #{ int64x2#; int64x2# }; int } }   *)
  (****************************************************)
  let r = { a642 = #{ a641 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b641 = 4 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a642 *)
  let actual = r.a642 in
  let expected = #{ a641 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b641 = 4 } in
  mark_test_run 4762;
  let test = (fun #{ a641 = a6411; b641 = b6411 } #{ a641 = a6412; b641 = b6412 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6411 a6412 && (fun a b -> Int.equal a b) b6411 b6412) actual expected in
  if not test then failwithf "test 4762 failed";
  (* Paths of depth 2 *)
  (* .a642.#a641 *)
  let actual = r.a642.#a641 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4763;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4763 failed";
  (* .a642.#b641 *)
  let actual = r.a642.#b641 in
  let expected = 4 in
  mark_test_run 4764;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 4764 failed";
  (* Paths of depth 3 *)
  (* .a642.#a641.#a69 *)
  let actual = r.a642.#a641.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4765;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4765 failed";
  (* .a642.#a641.#b69 *)
  let actual = r.a642.#a641.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4766;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4766 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a642 = a6421 } { a642 = a6422 } -> (fun #{ a641 = a6411; b641 = b6411 } #{ a641 = a6412; b641 = b6412 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6411 a6412 && (fun a b -> Int.equal a b) b6411 b6412) a6421 a6422) in
  let next_r = { a642 = #{ a641 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b641 = 104 } } in
  let r_expected = { a642 = #{ a641 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b641 = 4 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a642 *)
  r.a642 <- next_r.a642;
  let r_expected = { r_expected with a642 = next_r.a642 } in
  mark_test_run 4767;
  let test = eq r r_expected in
  if not test then failwithf "test 4767 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a642 = #{ a641 = #{ a69; b69 }; b641 } } = r in
  let expected_b641 = 104 in
  mark_test_run 4768;
  let test = (fun a b -> Int.equal a b) expected_b641 b641 in
  if not test then failwithf "test 4768 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4769;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4769 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4770;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4770 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a642 } = r in
  let expected_a642 = #{ a641 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b641 = 104 } in
  mark_test_run 4771;
  let test = (fun #{ a641 = a6411; b641 = b6411 } #{ a641 = a6412; b641 = b6412 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6411 a6412 && (fun a b -> Int.equal a b) b6411 b6412) expected_a642 a642 in
  if not test then failwithf "test 4771 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t644 = { #{ #{ int64x2#; int64x2# }; int64x2# } }   *)
  (*********************************************************)
  let r = { a644 = #{ a643 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b643 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a644 *)
  let actual = r.a644 in
  let expected = #{ a643 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b643 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  mark_test_run 4772;
  let test = (fun #{ a643 = a6431; b643 = b6431 } #{ a643 = a6432; b643 = b6432 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6431 a6432 && int64x2_u_equal b6431 b6432) actual expected in
  if not test then failwithf "test 4772 failed";
  (* Paths of depth 2 *)
  (* .a644.#a643 *)
  let actual = r.a644.#a643 in
  let expected = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  mark_test_run 4773;
  let test = (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) actual expected in
  if not test then failwithf "test 4773 failed";
  (* .a644.#b643 *)
  let actual = r.a644.#b643 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 4774;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4774 failed";
  (* Paths of depth 3 *)
  (* .a644.#a643.#a69 *)
  let actual = r.a644.#a643.#a69 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 4775;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4775 failed";
  (* .a644.#a643.#b69 *)
  let actual = r.a644.#a643.#b69 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 4776;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 4776 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a644 = a6441 } { a644 = a6442 } -> (fun #{ a643 = a6431; b643 = b6431 } #{ a643 = a6432; b643 = b6432 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6431 a6432 && int64x2_u_equal b6431 b6432) a6441 a6442) in
  let next_r = { a644 = #{ a643 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b643 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } } in
  let r_expected = { a644 = #{ a643 = #{ a69 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b69 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) }; b643 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a644 *)
  r.a644 <- next_r.a644;
  let r_expected = { r_expected with a644 = next_r.a644 } in
  mark_test_run 4777;
  let test = eq r r_expected in
  if not test then failwithf "test 4777 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a644 = #{ a643 = #{ a69; b69 }; b643 } } = r in
  let expected_b643 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 4778;
  let test = int64x2_u_equal expected_b643 b643 in
  if not test then failwithf "test 4778 failed";
  let expected_a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 4779;
  let test = int64x2_u_equal expected_a69 a69 in
  if not test then failwithf "test 4779 failed";
  let expected_b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 4780;
  let test = int64x2_u_equal expected_b69 b69 in
  if not test then failwithf "test 4780 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a644 } = r in
  let expected_a644 = #{ a643 = #{ a69 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b69 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) }; b643 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } in
  mark_test_run 4781;
  let test = (fun #{ a643 = a6431; b643 = b6431 } #{ a643 = a6432; b643 = b6432 } -> (fun #{ a69 = a691; b69 = b691 } #{ a69 = a692; b69 = b692 } -> int64x2_u_equal a691 a692 && int64x2_u_equal b691 b692) a6431 a6432 && int64x2_u_equal b6431 b6432) expected_a644 a644 in
  if not test then failwithf "test 4781 failed";

  ()
;;
let () = to_run ();;

for i = 1 to 4781 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
