(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "idx_repr.ml stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void mod everything
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

let int64x2_u_equal i1 i2 =
    let a1 = int64_of_int64x2 i1 in
    let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
    let a2 = int64_of_int64x2 i2 in
    let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
    Int64.equal a1 a2 && Int64.equal b1 b2

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any mod separable) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any mod separable) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = { mutable a0 : int; mutable b0 : int } (* { int; int } *)
type t1 = { mutable a1 : int; mutable b1 : int; mutable c1 : int64x2# } (* { int; int; int64x2# } *)
type t2 = { mutable a2 : int; mutable b2 : int64 } (* { int; int64 } *)
type t3 = { mutable a3 : int; mutable b3 : float } (* { int; float } *)
type t4 = { mutable a4 : int; mutable b4 : int64x2#; mutable c4 : int64x2# } (* { int; int64x2#; int64x2# } *)
type t5 = #{ a5 : int; b5 : int } (* #{ int; int } *)
type t6 = { mutable a6 : int; mutable b6 : t5 } (* { int; #{ int; int } } *)
type t7 = #{ a7 : int32#; b7 : int32# } (* #{ int32#; int32# } *)
type t8 = { mutable a8 : int; mutable b8 : t7 } (* { int; #{ int32#; int32# } } *)
type t9 = #{ a9 : float } (* #{ float } *)
type t10 = { mutable a10 : int; mutable b10 : t9 } (* { int; #{ float } } *)
type t11 = #{ a11 : int64x2#; b11 : int64x2# } (* #{ int64x2#; int64x2# } *)
type t12 = { mutable a12 : int; mutable b12 : t11 } (* { int; #{ int64x2#; int64x2# } } *)
type t13 = { mutable a13 : int64; mutable b13 : int64 } (* { int64; int64 } *)
type t14 = { mutable a14 : int64#; mutable b14 : int } (* { int64#; int } *)
type t15 = { mutable a15 : int64#; mutable b15 : nativeint# } (* { int64#; nativeint# } *)
type t16 = { mutable a16 : int32# } (* { int32# } *)
type t17 = { mutable a17 : int32#; mutable b17 : int } (* { int32#; int } *)
type t18 = { mutable a18 : int32#; mutable b18 : int64 } (* { int32#; int64 } *)
type t19 = { mutable a19 : int32#; mutable b19 : int32#; mutable c19 : int32# } (* { int32#; int32#; int32# } *)
type t20 = { mutable a20 : int32#; mutable b20 : float } (* { int32#; float } *)
type t21 = #{ a21 : int32# } (* #{ int32# } *)
type t22 = { mutable a22 : int32#; mutable b22 : t21 } (* { int32#; #{ int32# } } *)
type t23 = { mutable a23 : nativeint# } (* { nativeint# } *)
type t24 = { mutable a24 : nativeint#; mutable b24 : int } (* { nativeint#; int } *)
type t25 = { mutable a25 : nativeint#; mutable b25 : int64# } (* { nativeint#; int64# } *)
type t26 = { mutable a26 : nativeint#; mutable b26 : nativeint# } (* { nativeint#; nativeint# } *)
type t27 = { mutable a27 : float; mutable b27 : int } (* { float; int } *)
type t28 = { mutable a28 : float; mutable b28 : float; mutable c28 : int } (* { float; float; int } *)
type t29 = #{ a29 : float; b29 : float# } (* #{ float; float# } *)
type t30 = { mutable a30 : float; mutable b30 : t29 } (* { float; #{ float; float# } } *)
type t31 = #{ a31 : float#; b31 : float# } (* #{ float#; float# } *)
type t32 = { mutable a32 : float; mutable b32 : t31 } (* { float; #{ float#; float# } } *)
type t33 = { mutable a33 : float#; mutable b33 : float } (* { float#; float } *)
type t34 = #{ a34 : float; b34 : float } (* #{ float; float } *)
type t35 = { mutable a35 : float#; mutable b35 : t34 } (* { float#; #{ float; float } } *)
type t36 = { mutable a36 : string; mutable b36 : string } (* { string; string } *)
type t37 = { mutable a37 : int64x2#; mutable b37 : int64x2#; mutable c37 : int64x2# } (* { int64x2#; int64x2#; int64x2# } *)
type t38 = #{ a38 : int } (* #{ int } *)
type t39 = { mutable a39 : int64x2#; mutable b39 : t38 } (* { int64x2#; #{ int } } *)
type t40 = { mutable a40 : t5 } (* { #{ int; int } } *)
type t41 = { mutable a41 : t5; mutable b41 : int } (* { #{ int; int }; int } *)
type t42 = { mutable a42 : t5; mutable b42 : int32# } (* { #{ int; int }; int32# } *)
type t43 = { mutable a43 : t5; mutable b43 : float } (* { #{ int; int }; float } *)
type t44 = #{ a44 : int; b44 : int32# } (* #{ int; int32# } *)
type t45 = { mutable a45 : t44; mutable b45 : int } (* { #{ int; int32# }; int } *)
type t46 = #{ a46 : int64; b46 : int64# } (* #{ int64; int64# } *)
type t47 = #{ a47 : int64#; b47 : float# } (* #{ int64#; float# } *)
type t48 = { mutable a48 : t46; mutable b48 : t47 } (* { #{ int64; int64# }; #{ int64#; float# } } *)
type t49 = #{ a49 : int64; b49 : string } (* #{ int64; string } *)
type t50 = #{ a50 : int64#; b50 : string } (* #{ int64#; string } *)
type t51 = { mutable a51 : t49; mutable b51 : t50 } (* { #{ int64; string }; #{ int64#; string } } *)
type t52 = { mutable a52 : t21 } (* { #{ int32# } } *)
type t53 = #{ a53 : int32#; b53 : int } (* #{ int32#; int } *)
type t54 = { mutable a54 : t53; mutable b54 : int32# } (* { #{ int32#; int }; int32# } *)
type t55 = { mutable a55 : t9; mutable b55 : int } (* { #{ float }; int } *)
type t56 = { mutable a56 : t9; mutable b56 : float } (* { #{ float }; float } *)
type t57 = { mutable a57 : t34 } (* { #{ float; float } } *)
type t58 = { mutable a58 : t34; mutable b58 : int } (* { #{ float; float }; int } *)
type t59 = #{ a59 : float# } (* #{ float# } *)
type t60 = { mutable a60 : t59; mutable b60 : float } (* { #{ float# }; float } *)
type t61 = #{ a61 : float#; b61 : float } (* #{ float#; float } *)
type t62 = { mutable a62 : t61 } (* { #{ float#; float } } *)
type t63 = #{ a63 : float32#; b63 : int64# } (* #{ float32#; int64# } *)
type t64 = #{ a64 : string; b64 : int64# } (* #{ string; int64# } *)
type t65 = { mutable a65 : t63; mutable b65 : t64 } (* { #{ float32#; int64# }; #{ string; int64# } } *)
type t66 = #{ a66 : string } (* #{ string } *)
type t67 = { mutable a67 : t66 } (* { #{ string } } *)
type t68 = #{ a68 : string; b68 : string } (* #{ string; string } *)
type t69 = { mutable a69 : t68 } (* { #{ string; string } } *)
type t70 = { mutable a70 : t68; mutable b70 : string } (* { #{ string; string }; string } *)
type t71 = #{ a71 : int64x2# } (* #{ int64x2# } *)
type t72 = { mutable a72 : t71; mutable b72 : int } (* { #{ int64x2# }; int } *)

let to_run () =
  (*************************)
  (*   t0 = { int; int }   *)
  (*************************)
  let r = { a0 = 0; b0 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 1;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1 failed";
  (* Paths of depth 1 *)
  (* .b0 *)
  let actual = r.b0 in
  let expected = 1 in
  mark_test_run 2;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 2 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01; b0 = b01 } { a0 = a02; b0 = b02 } -> (fun a b -> Int.equal a b) a01 a02 && (fun a b -> Int.equal a b) b01 b02) in
  let next_r = { a0 = 100; b0 = 101 } in
  let r_expected = { a0 = 0; b0 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 3;
  let test = eq r r_expected in
  if not test then failwithf "test 3 failed";
  Gc.compact ();
  (* .b0 *)
  r.b0 <- next_r.b0;
  let r_expected = { r_expected with b0 = next_r.b0 } in
  mark_test_run 4;
  let test = eq r r_expected in
  if not test then failwithf "test 4 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0; b0 } = r in
  let expected_a0 = 100 in
  mark_test_run 5;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 5 failed";
  let expected_b0 = 101 in
  mark_test_run 6;
  let test = (fun a b -> Int.equal a b) expected_b0 b0 in
  if not test then failwithf "test 6 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0; b0 } = r in
  let expected_a0 = 100 in
  mark_test_run 7;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 7 failed";
  let expected_b0 = 101 in
  mark_test_run 8;
  let test = (fun a b -> Int.equal a b) expected_b0 b0 in
  if not test then failwithf "test 8 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t1 = { int; int; int64x2# }   *)
  (***********************************)
  let r = { a1 = 0; b1 = 1; c1 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = 0 in
  mark_test_run 9;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 9 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = 1 in
  mark_test_run 10;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 10 failed";
  (* Paths of depth 1 *)
  (* .c1 *)
  let actual = r.c1 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 11;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 11 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11; c1 = c11 } { a1 = a12; b1 = b12; c1 = c12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12 && int64x2_u_equal c11 c12) in
  let next_r = { a1 = 100; b1 = 101; c1 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) } in
  let r_expected = { a1 = 0; b1 = 1; c1 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 12;
  let test = eq r r_expected in
  if not test then failwithf "test 12 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 13;
  let test = eq r r_expected in
  if not test then failwithf "test 13 failed";
  Gc.compact ();
  (* .c1 *)
  r.c1 <- next_r.c1;
  let r_expected = { r_expected with c1 = next_r.c1 } in
  mark_test_run 14;
  let test = eq r r_expected in
  if not test then failwithf "test 14 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1; c1 } = r in
  let expected_a1 = 100 in
  mark_test_run 15;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 15 failed";
  let expected_b1 = 101 in
  mark_test_run 16;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 16 failed";
  let expected_c1 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 17;
  let test = int64x2_u_equal expected_c1 c1 in
  if not test then failwithf "test 17 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1; c1 } = r in
  let expected_a1 = 100 in
  mark_test_run 18;
  let test = (fun a b -> Int.equal a b) expected_a1 a1 in
  if not test then failwithf "test 18 failed";
  let expected_b1 = 101 in
  mark_test_run 19;
  let test = (fun a b -> Int.equal a b) expected_b1 b1 in
  if not test then failwithf "test 19 failed";
  let expected_c1 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 20;
  let test = int64x2_u_equal expected_c1 c1 in
  if not test then failwithf "test 20 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************)
  (*   t2 = { int; int64 }   *)
  (***************************)
  let r = { a2 = 0; b2 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a2 *)
  let actual = r.a2 in
  let expected = 0 in
  mark_test_run 21;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 21 failed";
  (* Paths of depth 1 *)
  (* .b2 *)
  let actual = r.b2 in
  let expected = 1L in
  mark_test_run 22;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 22 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a2 = a21; b2 = b21 } { a2 = a22; b2 = b22 } -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64.equal (globalize a) (globalize b)) b21 b22) in
  let next_r = { a2 = 100; b2 = 101L } in
  let r_expected = { a2 = 0; b2 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a2 *)
  r.a2 <- next_r.a2;
  let r_expected = { r_expected with a2 = next_r.a2 } in
  mark_test_run 23;
  let test = eq r r_expected in
  if not test then failwithf "test 23 failed";
  Gc.compact ();
  (* .b2 *)
  r.b2 <- next_r.b2;
  let r_expected = { r_expected with b2 = next_r.b2 } in
  mark_test_run 24;
  let test = eq r r_expected in
  if not test then failwithf "test 24 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a2; b2 } = r in
  let expected_a2 = 100 in
  mark_test_run 25;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 25 failed";
  let expected_b2 = 101L in
  mark_test_run 26;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b2 b2 in
  if not test then failwithf "test 26 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a2; b2 } = r in
  let expected_a2 = 100 in
  mark_test_run 27;
  let test = (fun a b -> Int.equal a b) expected_a2 a2 in
  if not test then failwithf "test 27 failed";
  let expected_b2 = 101L in
  mark_test_run 28;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b2 b2 in
  if not test then failwithf "test 28 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************)
  (*   t3 = { int; float }   *)
  (***************************)
  let r = { a3 = 0; b3 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = 0 in
  mark_test_run 29;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 29 failed";
  (* Paths of depth 1 *)
  (* .b3 *)
  let actual = r.b3 in
  let expected = 1. in
  mark_test_run 30;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 30 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31; b3 = b31 } { a3 = a32; b3 = b32 } -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Float.equal (globalize a) (globalize b)) b31 b32) in
  let next_r = { a3 = 100; b3 = 101. } in
  let r_expected = { a3 = 0; b3 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 31;
  let test = eq r r_expected in
  if not test then failwithf "test 31 failed";
  Gc.compact ();
  (* .b3 *)
  r.b3 <- next_r.b3;
  let r_expected = { r_expected with b3 = next_r.b3 } in
  mark_test_run 32;
  let test = eq r r_expected in
  if not test then failwithf "test 32 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3; b3 } = r in
  let expected_a3 = 100 in
  mark_test_run 33;
  let test = (fun a b -> Int.equal a b) expected_a3 a3 in
  if not test then failwithf "test 33 failed";
  let expected_b3 = 101. in
  mark_test_run 34;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b3 b3 in
  if not test then failwithf "test 34 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3; b3 } = r in
  let expected_a3 = 100 in
  mark_test_run 35;
  let test = (fun a b -> Int.equal a b) expected_a3 a3 in
  if not test then failwithf "test 35 failed";
  let expected_b3 = 101. in
  mark_test_run 36;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b3 b3 in
  if not test then failwithf "test 36 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t4 = { int; int64x2#; int64x2# }   *)
  (****************************************)
  let r = { a4 = 0; b4 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c4 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a4 *)
  let actual = r.a4 in
  let expected = 0 in
  mark_test_run 37;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 37 failed";
  (* Paths of depth 1 *)
  (* .b4 *)
  let actual = r.b4 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 38;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 38 failed";
  (* Paths of depth 1 *)
  (* .c4 *)
  let actual = r.c4 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 39;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 39 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a4 = a41; b4 = b41; c4 = c41 } { a4 = a42; b4 = b42; c4 = c42 } -> (fun a b -> Int.equal a b) a41 a42 && int64x2_u_equal b41 b42 && int64x2_u_equal c41 c42) in
  let next_r = { a4 = 100; b4 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); c4 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  let r_expected = { a4 = 0; b4 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); c4 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a4 *)
  r.a4 <- next_r.a4;
  let r_expected = { r_expected with a4 = next_r.a4 } in
  mark_test_run 40;
  let test = eq r r_expected in
  if not test then failwithf "test 40 failed";
  Gc.compact ();
  (* .b4 *)
  r.b4 <- next_r.b4;
  let r_expected = { r_expected with b4 = next_r.b4 } in
  mark_test_run 41;
  let test = eq r r_expected in
  if not test then failwithf "test 41 failed";
  Gc.compact ();
  (* .c4 *)
  r.c4 <- next_r.c4;
  let r_expected = { r_expected with c4 = next_r.c4 } in
  mark_test_run 42;
  let test = eq r r_expected in
  if not test then failwithf "test 42 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a4; b4; c4 } = r in
  let expected_a4 = 100 in
  mark_test_run 43;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 43 failed";
  let expected_b4 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 44;
  let test = int64x2_u_equal expected_b4 b4 in
  if not test then failwithf "test 44 failed";
  let expected_c4 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 45;
  let test = int64x2_u_equal expected_c4 c4 in
  if not test then failwithf "test 45 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a4; b4; c4 } = r in
  let expected_a4 = 100 in
  mark_test_run 46;
  let test = (fun a b -> Int.equal a b) expected_a4 a4 in
  if not test then failwithf "test 46 failed";
  let expected_b4 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 47;
  let test = int64x2_u_equal expected_b4 b4 in
  if not test then failwithf "test 47 failed";
  let expected_c4 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 48;
  let test = int64x2_u_equal expected_c4 c4 in
  if not test then failwithf "test 48 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t6 = { int; #{ int; int } }   *)
  (***********************************)
  let r = { a6 = 0; b6 = #{ a5 = 1; b5 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a6 *)
  let actual = r.a6 in
  let expected = 0 in
  mark_test_run 49;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 49 failed";
  (* Paths of depth 1 *)
  (* .b6 *)
  let actual = r.b6 in
  let expected = #{ a5 = 1; b5 = 2 } in
  mark_test_run 50;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) actual expected in
  if not test then failwithf "test 50 failed";
  (* Paths of depth 2 *)
  (* .b6.#a5 *)
  let actual = r.b6.#a5 in
  let expected = 1 in
  mark_test_run 51;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 51 failed";
  (* .b6.#b5 *)
  let actual = r.b6.#b5 in
  let expected = 2 in
  mark_test_run 52;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 52 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a6 = a61; b6 = b61 } { a6 = a62; b6 = b62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) b61 b62) in
  let next_r = { a6 = 100; b6 = #{ a5 = 101; b5 = 102 } } in
  let r_expected = { a6 = 0; b6 = #{ a5 = 1; b5 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a6 *)
  r.a6 <- next_r.a6;
  let r_expected = { r_expected with a6 = next_r.a6 } in
  mark_test_run 53;
  let test = eq r r_expected in
  if not test then failwithf "test 53 failed";
  Gc.compact ();
  (* .b6 *)
  r.b6 <- next_r.b6;
  let r_expected = { r_expected with b6 = next_r.b6 } in
  mark_test_run 54;
  let test = eq r r_expected in
  if not test then failwithf "test 54 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a6; b6 = #{ a5; b5 } } = r in
  let expected_a6 = 100 in
  mark_test_run 55;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 55 failed";
  let expected_a5 = 101 in
  mark_test_run 56;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 56 failed";
  let expected_b5 = 102 in
  mark_test_run 57;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 57 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a6; b6 } = r in
  let expected_a6 = 100 in
  mark_test_run 58;
  let test = (fun a b -> Int.equal a b) expected_a6 a6 in
  if not test then failwithf "test 58 failed";
  let expected_b6 = #{ a5 = 101; b5 = 102 } in
  mark_test_run 59;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) expected_b6 b6 in
  if not test then failwithf "test 59 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************************)
  (*   t8 = { int; #{ int32#; int32# } }   *)
  (*****************************************)
  let r = { a8 = 0; b8 = #{ a7 = #1l; b7 = #2l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = 0 in
  mark_test_run 60;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 60 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = #{ a7 = #1l; b7 = #2l } in
  mark_test_run 61;
  let test = (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) actual expected in
  if not test then failwithf "test 61 failed";
  (* Paths of depth 2 *)
  (* .b8.#a7 *)
  let actual = r.b8.#a7 in
  let expected = #1l in
  mark_test_run 62;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 62 failed";
  (* .b8.#b7 *)
  let actual = r.b8.#b7 in
  let expected = #2l in
  mark_test_run 63;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 63 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81 } { a8 = a82; b8 = b82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b81 b82) in
  let next_r = { a8 = 100; b8 = #{ a7 = #101l; b7 = #102l } } in
  let r_expected = { a8 = 0; b8 = #{ a7 = #1l; b7 = #2l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 64;
  let test = eq r r_expected in
  if not test then failwithf "test 64 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 65;
  let test = eq r r_expected in
  if not test then failwithf "test 65 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8 = #{ a7; b7 } } = r in
  let expected_a8 = 100 in
  mark_test_run 66;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 66 failed";
  let expected_a7 = #101l in
  mark_test_run 67;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a7 a7 in
  if not test then failwithf "test 67 failed";
  let expected_b7 = #102l in
  mark_test_run 68;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b7 b7 in
  if not test then failwithf "test 68 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8 } = r in
  let expected_a8 = 100 in
  mark_test_run 69;
  let test = (fun a b -> Int.equal a b) expected_a8 a8 in
  if not test then failwithf "test 69 failed";
  let expected_b8 = #{ a7 = #101l; b7 = #102l } in
  mark_test_run 70;
  let test = (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) expected_b8 b8 in
  if not test then failwithf "test 70 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t10 = { int; #{ float } }   *)
  (*********************************)
  let r = { a10 = 0; b10 = #{ a9 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a10 *)
  let actual = r.a10 in
  let expected = 0 in
  mark_test_run 71;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 71 failed";
  (* Paths of depth 1 *)
  (* .b10 *)
  let actual = r.b10 in
  let expected = #{ a9 = 1. } in
  mark_test_run 72;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) actual expected in
  if not test then failwithf "test 72 failed";
  (* Paths of depth 2 *)
  (* .b10.#a9 *)
  let actual = r.b10.#a9 in
  let expected = 1. in
  mark_test_run 73;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 73 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a10 = a101; b10 = b101 } { a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) b101 b102) in
  let next_r = { a10 = 100; b10 = #{ a9 = 101. } } in
  let r_expected = { a10 = 0; b10 = #{ a9 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a10 *)
  r.a10 <- next_r.a10;
  let r_expected = { r_expected with a10 = next_r.a10 } in
  mark_test_run 74;
  let test = eq r r_expected in
  if not test then failwithf "test 74 failed";
  Gc.compact ();
  (* .b10 *)
  r.b10 <- next_r.b10;
  let r_expected = { r_expected with b10 = next_r.b10 } in
  mark_test_run 75;
  let test = eq r r_expected in
  if not test then failwithf "test 75 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a10; b10 = #{ a9 } } = r in
  let expected_a10 = 100 in
  mark_test_run 76;
  let test = (fun a b -> Int.equal a b) expected_a10 a10 in
  if not test then failwithf "test 76 failed";
  let expected_a9 = 101. in
  mark_test_run 77;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a9 a9 in
  if not test then failwithf "test 77 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a10; b10 } = r in
  let expected_a10 = 100 in
  mark_test_run 78;
  let test = (fun a b -> Int.equal a b) expected_a10 a10 in
  if not test then failwithf "test 78 failed";
  let expected_b10 = #{ a9 = 101. } in
  mark_test_run 79;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) expected_b10 b10 in
  if not test then failwithf "test 79 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t12 = { int; #{ int64x2#; int64x2# } }   *)
  (**********************************************)
  let r = { a12 = 0; b12 = #{ a11 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b11 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a12 *)
  let actual = r.a12 in
  let expected = 0 in
  mark_test_run 80;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 80 failed";
  (* Paths of depth 1 *)
  (* .b12 *)
  let actual = r.b12 in
  let expected = #{ a11 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b11 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } in
  mark_test_run 81;
  let test = (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> int64x2_u_equal a111 a112 && int64x2_u_equal b111 b112) actual expected in
  if not test then failwithf "test 81 failed";
  (* Paths of depth 2 *)
  (* .b12.#a11 *)
  let actual = r.b12.#a11 in
  let expected = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)) in
  mark_test_run 82;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 82 failed";
  (* .b12.#b11 *)
  let actual = r.b12.#b11 in
  let expected = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) in
  mark_test_run 83;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 83 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a12 = a121; b12 = b121 } { a12 = a122; b12 = b122 } -> (fun a b -> Int.equal a b) a121 a122 && (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> int64x2_u_equal a111 a112 && int64x2_u_equal b111 b112) b121 b122) in
  let next_r = { a12 = 100; b12 = #{ a11 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b11 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } } in
  let r_expected = { a12 = 0; b12 = #{ a11 = (interleave_low_64 (int64x2_of_int64 1L) (int64x2_of_int64 2L)); b11 = (interleave_low_64 (int64x2_of_int64 3L) (int64x2_of_int64 4L)) } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a12 *)
  r.a12 <- next_r.a12;
  let r_expected = { r_expected with a12 = next_r.a12 } in
  mark_test_run 84;
  let test = eq r r_expected in
  if not test then failwithf "test 84 failed";
  Gc.compact ();
  (* .b12 *)
  r.b12 <- next_r.b12;
  let r_expected = { r_expected with b12 = next_r.b12 } in
  mark_test_run 85;
  let test = eq r r_expected in
  if not test then failwithf "test 85 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a12; b12 = #{ a11; b11 } } = r in
  let expected_a12 = 100 in
  mark_test_run 86;
  let test = (fun a b -> Int.equal a b) expected_a12 a12 in
  if not test then failwithf "test 86 failed";
  let expected_a11 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)) in
  mark_test_run 87;
  let test = int64x2_u_equal expected_a11 a11 in
  if not test then failwithf "test 87 failed";
  let expected_b11 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) in
  mark_test_run 88;
  let test = int64x2_u_equal expected_b11 b11 in
  if not test then failwithf "test 88 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a12; b12 } = r in
  let expected_a12 = 100 in
  mark_test_run 89;
  let test = (fun a b -> Int.equal a b) expected_a12 a12 in
  if not test then failwithf "test 89 failed";
  let expected_b12 = #{ a11 = (interleave_low_64 (int64x2_of_int64 101L) (int64x2_of_int64 102L)); b11 = (interleave_low_64 (int64x2_of_int64 103L) (int64x2_of_int64 104L)) } in
  mark_test_run 90;
  let test = (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> int64x2_u_equal a111 a112 && int64x2_u_equal b111 b112) expected_b12 b12 in
  if not test then failwithf "test 90 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t13 = { int64; int64 }   *)
  (******************************)
  let r = { a13 = 0L; b13 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a13 *)
  let actual = r.a13 in
  let expected = 0L in
  mark_test_run 91;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 91 failed";
  (* Paths of depth 1 *)
  (* .b13 *)
  let actual = r.b13 in
  let expected = 1L in
  mark_test_run 92;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 92 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a13 = a131; b13 = b131 } { a13 = a132; b13 = b132 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a131 a132 && (fun a b -> Int64.equal (globalize a) (globalize b)) b131 b132) in
  let next_r = { a13 = 100L; b13 = 101L } in
  let r_expected = { a13 = 0L; b13 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a13 *)
  r.a13 <- next_r.a13;
  let r_expected = { r_expected with a13 = next_r.a13 } in
  mark_test_run 93;
  let test = eq r r_expected in
  if not test then failwithf "test 93 failed";
  Gc.compact ();
  (* .b13 *)
  r.b13 <- next_r.b13;
  let r_expected = { r_expected with b13 = next_r.b13 } in
  mark_test_run 94;
  let test = eq r r_expected in
  if not test then failwithf "test 94 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a13; b13 } = r in
  let expected_a13 = 100L in
  mark_test_run 95;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a13 a13 in
  if not test then failwithf "test 95 failed";
  let expected_b13 = 101L in
  mark_test_run 96;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b13 b13 in
  if not test then failwithf "test 96 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a13; b13 } = r in
  let expected_a13 = 100L in
  mark_test_run 97;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a13 a13 in
  if not test then failwithf "test 97 failed";
  let expected_b13 = 101L in
  mark_test_run 98;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b13 b13 in
  if not test then failwithf "test 98 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t14 = { int64#; int }   *)
  (*****************************)
  let r = { a14 = #0L; b14 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a14 *)
  let actual = r.a14 in
  let expected = #0L in
  mark_test_run 99;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 99 failed";
  (* Paths of depth 1 *)
  (* .b14 *)
  let actual = r.b14 in
  let expected = 1 in
  mark_test_run 100;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 100 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a14 = a141; b14 = b141 } { a14 = a142; b14 = b142 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a141 a142 && (fun a b -> Int.equal a b) b141 b142) in
  let next_r = { a14 = #100L; b14 = 101 } in
  let r_expected = { a14 = #0L; b14 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a14 *)
  r.a14 <- next_r.a14;
  let r_expected = { r_expected with a14 = next_r.a14 } in
  mark_test_run 101;
  let test = eq r r_expected in
  if not test then failwithf "test 101 failed";
  Gc.compact ();
  (* .b14 *)
  r.b14 <- next_r.b14;
  let r_expected = { r_expected with b14 = next_r.b14 } in
  mark_test_run 102;
  let test = eq r r_expected in
  if not test then failwithf "test 102 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a14; b14 } = r in
  let expected_a14 = #100L in
  mark_test_run 103;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a14 a14 in
  if not test then failwithf "test 103 failed";
  let expected_b14 = 101 in
  mark_test_run 104;
  let test = (fun a b -> Int.equal a b) expected_b14 b14 in
  if not test then failwithf "test 104 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a14; b14 } = r in
  let expected_a14 = #100L in
  mark_test_run 105;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a14 a14 in
  if not test then failwithf "test 105 failed";
  let expected_b14 = 101 in
  mark_test_run 106;
  let test = (fun a b -> Int.equal a b) expected_b14 b14 in
  if not test then failwithf "test 106 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t15 = { int64#; nativeint# }   *)
  (************************************)
  let r = { a15 = #0L; b15 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a15 *)
  let actual = r.a15 in
  let expected = #0L in
  mark_test_run 107;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 107 failed";
  (* Paths of depth 1 *)
  (* .b15 *)
  let actual = r.b15 in
  let expected = #1n in
  mark_test_run 108;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 108 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a15 = a151; b15 = b151 } { a15 = a152; b15 = b152 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a151 a152 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b151 b152) in
  let next_r = { a15 = #100L; b15 = #101n } in
  let r_expected = { a15 = #0L; b15 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a15 *)
  r.a15 <- next_r.a15;
  let r_expected = { r_expected with a15 = next_r.a15 } in
  mark_test_run 109;
  let test = eq r r_expected in
  if not test then failwithf "test 109 failed";
  Gc.compact ();
  (* .b15 *)
  r.b15 <- next_r.b15;
  let r_expected = { r_expected with b15 = next_r.b15 } in
  mark_test_run 110;
  let test = eq r r_expected in
  if not test then failwithf "test 110 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a15; b15 } = r in
  let expected_a15 = #100L in
  mark_test_run 111;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a15 a15 in
  if not test then failwithf "test 111 failed";
  let expected_b15 = #101n in
  mark_test_run 112;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b15 b15 in
  if not test then failwithf "test 112 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a15; b15 } = r in
  let expected_a15 = #100L in
  mark_test_run 113;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a15 a15 in
  if not test then failwithf "test 113 failed";
  let expected_b15 = #101n in
  mark_test_run 114;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b15 b15 in
  if not test then failwithf "test 114 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************)
  (*   t16 = { int32# }   *)
  (************************)
  let r = { a16 = #0l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a16 *)
  let actual = r.a16 in
  let expected = #0l in
  mark_test_run 115;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 115 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a16 = a161 } { a16 = a162 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162) in
  let next_r = { a16 = #100l } in
  let r_expected = { a16 = #0l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a16 *)
  r.a16 <- next_r.a16;
  let r_expected = { r_expected with a16 = next_r.a16 } in
  mark_test_run 116;
  let test = eq r r_expected in
  if not test then failwithf "test 116 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a16 } = r in
  let expected_a16 = #100l in
  mark_test_run 117;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a16 a16 in
  if not test then failwithf "test 117 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a16 } = r in
  let expected_a16 = #100l in
  mark_test_run 118;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a16 a16 in
  if not test then failwithf "test 118 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t17 = { int32#; int }   *)
  (*****************************)
  let r = { a17 = #0l; b17 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a17 *)
  let actual = r.a17 in
  let expected = #0l in
  mark_test_run 119;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 119 failed";
  (* Paths of depth 1 *)
  (* .b17 *)
  let actual = r.b17 in
  let expected = 1 in
  mark_test_run 120;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 120 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a17 = a171; b17 = b171 } { a17 = a172; b17 = b172 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172 && (fun a b -> Int.equal a b) b171 b172) in
  let next_r = { a17 = #100l; b17 = 101 } in
  let r_expected = { a17 = #0l; b17 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a17 *)
  r.a17 <- next_r.a17;
  let r_expected = { r_expected with a17 = next_r.a17 } in
  mark_test_run 121;
  let test = eq r r_expected in
  if not test then failwithf "test 121 failed";
  Gc.compact ();
  (* .b17 *)
  r.b17 <- next_r.b17;
  let r_expected = { r_expected with b17 = next_r.b17 } in
  mark_test_run 122;
  let test = eq r r_expected in
  if not test then failwithf "test 122 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a17; b17 } = r in
  let expected_a17 = #100l in
  mark_test_run 123;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a17 a17 in
  if not test then failwithf "test 123 failed";
  let expected_b17 = 101 in
  mark_test_run 124;
  let test = (fun a b -> Int.equal a b) expected_b17 b17 in
  if not test then failwithf "test 124 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a17; b17 } = r in
  let expected_a17 = #100l in
  mark_test_run 125;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a17 a17 in
  if not test then failwithf "test 125 failed";
  let expected_b17 = 101 in
  mark_test_run 126;
  let test = (fun a b -> Int.equal a b) expected_b17 b17 in
  if not test then failwithf "test 126 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t18 = { int32#; int64 }   *)
  (*******************************)
  let r = { a18 = #0l; b18 = 1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a18 *)
  let actual = r.a18 in
  let expected = #0l in
  mark_test_run 127;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 127 failed";
  (* Paths of depth 1 *)
  (* .b18 *)
  let actual = r.b18 in
  let expected = 1L in
  mark_test_run 128;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 128 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a18 = a181; b18 = b181 } { a18 = a182; b18 = b182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182 && (fun a b -> Int64.equal (globalize a) (globalize b)) b181 b182) in
  let next_r = { a18 = #100l; b18 = 101L } in
  let r_expected = { a18 = #0l; b18 = 1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a18 *)
  r.a18 <- next_r.a18;
  let r_expected = { r_expected with a18 = next_r.a18 } in
  mark_test_run 129;
  let test = eq r r_expected in
  if not test then failwithf "test 129 failed";
  Gc.compact ();
  (* .b18 *)
  r.b18 <- next_r.b18;
  let r_expected = { r_expected with b18 = next_r.b18 } in
  mark_test_run 130;
  let test = eq r r_expected in
  if not test then failwithf "test 130 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a18; b18 } = r in
  let expected_a18 = #100l in
  mark_test_run 131;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a18 a18 in
  if not test then failwithf "test 131 failed";
  let expected_b18 = 101L in
  mark_test_run 132;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b18 b18 in
  if not test then failwithf "test 132 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a18; b18 } = r in
  let expected_a18 = #100l in
  mark_test_run 133;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a18 a18 in
  if not test then failwithf "test 133 failed";
  let expected_b18 = 101L in
  mark_test_run 134;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_b18 b18 in
  if not test then failwithf "test 134 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t19 = { int32#; int32#; int32# }   *)
  (****************************************)
  let r = { a19 = #0l; b19 = #1l; c19 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a19 *)
  let actual = r.a19 in
  let expected = #0l in
  mark_test_run 135;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 135 failed";
  (* Paths of depth 1 *)
  (* .b19 *)
  let actual = r.b19 in
  let expected = #1l in
  mark_test_run 136;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 136 failed";
  (* Paths of depth 1 *)
  (* .c19 *)
  let actual = r.c19 in
  let expected = #2l in
  mark_test_run 137;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 137 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a19 = a191; b19 = b191; c19 = c191 } { a19 = a192; b19 = b192; c19 = c192 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c191 c192) in
  let next_r = { a19 = #100l; b19 = #101l; c19 = #102l } in
  let r_expected = { a19 = #0l; b19 = #1l; c19 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a19 *)
  r.a19 <- next_r.a19;
  let r_expected = { r_expected with a19 = next_r.a19 } in
  mark_test_run 138;
  let test = eq r r_expected in
  if not test then failwithf "test 138 failed";
  Gc.compact ();
  (* .b19 *)
  r.b19 <- next_r.b19;
  let r_expected = { r_expected with b19 = next_r.b19 } in
  mark_test_run 139;
  let test = eq r r_expected in
  if not test then failwithf "test 139 failed";
  Gc.compact ();
  (* .c19 *)
  r.c19 <- next_r.c19;
  let r_expected = { r_expected with c19 = next_r.c19 } in
  mark_test_run 140;
  let test = eq r r_expected in
  if not test then failwithf "test 140 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a19; b19; c19 } = r in
  let expected_a19 = #100l in
  mark_test_run 141;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a19 a19 in
  if not test then failwithf "test 141 failed";
  let expected_b19 = #101l in
  mark_test_run 142;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b19 b19 in
  if not test then failwithf "test 142 failed";
  let expected_c19 = #102l in
  mark_test_run 143;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c19 c19 in
  if not test then failwithf "test 143 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a19; b19; c19 } = r in
  let expected_a19 = #100l in
  mark_test_run 144;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a19 a19 in
  if not test then failwithf "test 144 failed";
  let expected_b19 = #101l in
  mark_test_run 145;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b19 b19 in
  if not test then failwithf "test 145 failed";
  let expected_c19 = #102l in
  mark_test_run 146;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_c19 c19 in
  if not test then failwithf "test 146 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t20 = { int32#; float }   *)
  (*******************************)
  let r = { a20 = #0l; b20 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a20 *)
  let actual = r.a20 in
  let expected = #0l in
  mark_test_run 147;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 147 failed";
  (* Paths of depth 1 *)
  (* .b20 *)
  let actual = r.b20 in
  let expected = 1. in
  mark_test_run 148;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 148 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a20 = a201; b20 = b201 } { a20 = a202; b20 = b202 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a201 a202 && (fun a b -> Float.equal (globalize a) (globalize b)) b201 b202) in
  let next_r = { a20 = #100l; b20 = 101. } in
  let r_expected = { a20 = #0l; b20 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a20 *)
  r.a20 <- next_r.a20;
  let r_expected = { r_expected with a20 = next_r.a20 } in
  mark_test_run 149;
  let test = eq r r_expected in
  if not test then failwithf "test 149 failed";
  Gc.compact ();
  (* .b20 *)
  r.b20 <- next_r.b20;
  let r_expected = { r_expected with b20 = next_r.b20 } in
  mark_test_run 150;
  let test = eq r r_expected in
  if not test then failwithf "test 150 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a20; b20 } = r in
  let expected_a20 = #100l in
  mark_test_run 151;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a20 a20 in
  if not test then failwithf "test 151 failed";
  let expected_b20 = 101. in
  mark_test_run 152;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b20 b20 in
  if not test then failwithf "test 152 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a20; b20 } = r in
  let expected_a20 = #100l in
  mark_test_run 153;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a20 a20 in
  if not test then failwithf "test 153 failed";
  let expected_b20 = 101. in
  mark_test_run 154;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b20 b20 in
  if not test then failwithf "test 154 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t22 = { int32#; #{ int32# } }   *)
  (*************************************)
  let r = { a22 = #0l; b22 = #{ a21 = #1l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a22 *)
  let actual = r.a22 in
  let expected = #0l in
  mark_test_run 155;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 155 failed";
  (* Paths of depth 1 *)
  (* .b22 *)
  let actual = r.b22 in
  let expected = #{ a21 = #1l } in
  mark_test_run 156;
  let test = (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) actual expected in
  if not test then failwithf "test 156 failed";
  (* Paths of depth 2 *)
  (* .b22.#a21 *)
  let actual = r.b22.#a21 in
  let expected = #1l in
  mark_test_run 157;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 157 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a22 = a221; b22 = b221 } { a22 = a222; b22 = b222 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a221 a222 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) b221 b222) in
  let next_r = { a22 = #100l; b22 = #{ a21 = #101l } } in
  let r_expected = { a22 = #0l; b22 = #{ a21 = #1l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a22 *)
  r.a22 <- next_r.a22;
  let r_expected = { r_expected with a22 = next_r.a22 } in
  mark_test_run 158;
  let test = eq r r_expected in
  if not test then failwithf "test 158 failed";
  Gc.compact ();
  (* .b22 *)
  r.b22 <- next_r.b22;
  let r_expected = { r_expected with b22 = next_r.b22 } in
  mark_test_run 159;
  let test = eq r r_expected in
  if not test then failwithf "test 159 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a22; b22 = #{ a21 } } = r in
  let expected_a22 = #100l in
  mark_test_run 160;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a22 a22 in
  if not test then failwithf "test 160 failed";
  let expected_a21 = #101l in
  mark_test_run 161;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a21 a21 in
  if not test then failwithf "test 161 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a22; b22 } = r in
  let expected_a22 = #100l in
  mark_test_run 162;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a22 a22 in
  if not test then failwithf "test 162 failed";
  let expected_b22 = #{ a21 = #101l } in
  mark_test_run 163;
  let test = (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) expected_b22 b22 in
  if not test then failwithf "test 163 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t23 = { nativeint# }   *)
  (****************************)
  let r = { a23 = #0n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a23 *)
  let actual = r.a23 in
  let expected = #0n in
  mark_test_run 164;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 164 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a23 = a231 } { a23 = a232 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a231 a232) in
  let next_r = { a23 = #100n } in
  let r_expected = { a23 = #0n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a23 *)
  r.a23 <- next_r.a23;
  let r_expected = { r_expected with a23 = next_r.a23 } in
  mark_test_run 165;
  let test = eq r r_expected in
  if not test then failwithf "test 165 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a23 } = r in
  let expected_a23 = #100n in
  mark_test_run 166;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a23 a23 in
  if not test then failwithf "test 166 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a23 } = r in
  let expected_a23 = #100n in
  mark_test_run 167;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a23 a23 in
  if not test then failwithf "test 167 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t24 = { nativeint#; int }   *)
  (*********************************)
  let r = { a24 = #0n; b24 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a24 *)
  let actual = r.a24 in
  let expected = #0n in
  mark_test_run 168;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 168 failed";
  (* Paths of depth 1 *)
  (* .b24 *)
  let actual = r.b24 in
  let expected = 1 in
  mark_test_run 169;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 169 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a24 = a241; b24 = b241 } { a24 = a242; b24 = b242 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a241 a242 && (fun a b -> Int.equal a b) b241 b242) in
  let next_r = { a24 = #100n; b24 = 101 } in
  let r_expected = { a24 = #0n; b24 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a24 *)
  r.a24 <- next_r.a24;
  let r_expected = { r_expected with a24 = next_r.a24 } in
  mark_test_run 170;
  let test = eq r r_expected in
  if not test then failwithf "test 170 failed";
  Gc.compact ();
  (* .b24 *)
  r.b24 <- next_r.b24;
  let r_expected = { r_expected with b24 = next_r.b24 } in
  mark_test_run 171;
  let test = eq r r_expected in
  if not test then failwithf "test 171 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a24; b24 } = r in
  let expected_a24 = #100n in
  mark_test_run 172;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a24 a24 in
  if not test then failwithf "test 172 failed";
  let expected_b24 = 101 in
  mark_test_run 173;
  let test = (fun a b -> Int.equal a b) expected_b24 b24 in
  if not test then failwithf "test 173 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a24; b24 } = r in
  let expected_a24 = #100n in
  mark_test_run 174;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a24 a24 in
  if not test then failwithf "test 174 failed";
  let expected_b24 = 101 in
  mark_test_run 175;
  let test = (fun a b -> Int.equal a b) expected_b24 b24 in
  if not test then failwithf "test 175 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t25 = { nativeint#; int64# }   *)
  (************************************)
  let r = { a25 = #0n; b25 = #1L } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a25 *)
  let actual = r.a25 in
  let expected = #0n in
  mark_test_run 176;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 176 failed";
  (* Paths of depth 1 *)
  (* .b25 *)
  let actual = r.b25 in
  let expected = #1L in
  mark_test_run 177;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 177 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a25 = a251; b25 = b251 } { a25 = a252; b25 = b252 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a251 a252 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b251 b252) in
  let next_r = { a25 = #100n; b25 = #101L } in
  let r_expected = { a25 = #0n; b25 = #1L } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a25 *)
  r.a25 <- next_r.a25;
  let r_expected = { r_expected with a25 = next_r.a25 } in
  mark_test_run 178;
  let test = eq r r_expected in
  if not test then failwithf "test 178 failed";
  Gc.compact ();
  (* .b25 *)
  r.b25 <- next_r.b25;
  let r_expected = { r_expected with b25 = next_r.b25 } in
  mark_test_run 179;
  let test = eq r r_expected in
  if not test then failwithf "test 179 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a25; b25 } = r in
  let expected_a25 = #100n in
  mark_test_run 180;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a25 a25 in
  if not test then failwithf "test 180 failed";
  let expected_b25 = #101L in
  mark_test_run 181;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b25 b25 in
  if not test then failwithf "test 181 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a25; b25 } = r in
  let expected_a25 = #100n in
  mark_test_run 182;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a25 a25 in
  if not test then failwithf "test 182 failed";
  let expected_b25 = #101L in
  mark_test_run 183;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b25 b25 in
  if not test then failwithf "test 183 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t26 = { nativeint#; nativeint# }   *)
  (****************************************)
  let r = { a26 = #0n; b26 = #1n } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a26 *)
  let actual = r.a26 in
  let expected = #0n in
  mark_test_run 184;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 184 failed";
  (* Paths of depth 1 *)
  (* .b26 *)
  let actual = r.b26 in
  let expected = #1n in
  mark_test_run 185;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 185 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a26 = a261; b26 = b261 } { a26 = a262; b26 = b262 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a261 a262 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b261 b262) in
  let next_r = { a26 = #100n; b26 = #101n } in
  let r_expected = { a26 = #0n; b26 = #1n } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a26 *)
  r.a26 <- next_r.a26;
  let r_expected = { r_expected with a26 = next_r.a26 } in
  mark_test_run 186;
  let test = eq r r_expected in
  if not test then failwithf "test 186 failed";
  Gc.compact ();
  (* .b26 *)
  r.b26 <- next_r.b26;
  let r_expected = { r_expected with b26 = next_r.b26 } in
  mark_test_run 187;
  let test = eq r r_expected in
  if not test then failwithf "test 187 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a26; b26 } = r in
  let expected_a26 = #100n in
  mark_test_run 188;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a26 a26 in
  if not test then failwithf "test 188 failed";
  let expected_b26 = #101n in
  mark_test_run 189;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b26 b26 in
  if not test then failwithf "test 189 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a26; b26 } = r in
  let expected_a26 = #100n in
  mark_test_run 190;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a26 a26 in
  if not test then failwithf "test 190 failed";
  let expected_b26 = #101n in
  mark_test_run 191;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_b26 b26 in
  if not test then failwithf "test 191 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************)
  (*   t27 = { float; int }   *)
  (****************************)
  let r = { a27 = 0.; b27 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a27 *)
  let actual = r.a27 in
  let expected = 0. in
  mark_test_run 192;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 192 failed";
  (* Paths of depth 1 *)
  (* .b27 *)
  let actual = r.b27 in
  let expected = 1 in
  mark_test_run 193;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 193 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a27 = a271; b27 = b271 } { a27 = a272; b27 = b272 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a271 a272 && (fun a b -> Int.equal a b) b271 b272) in
  let next_r = { a27 = 100.; b27 = 101 } in
  let r_expected = { a27 = 0.; b27 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a27 *)
  r.a27 <- next_r.a27;
  let r_expected = { r_expected with a27 = next_r.a27 } in
  mark_test_run 194;
  let test = eq r r_expected in
  if not test then failwithf "test 194 failed";
  Gc.compact ();
  (* .b27 *)
  r.b27 <- next_r.b27;
  let r_expected = { r_expected with b27 = next_r.b27 } in
  mark_test_run 195;
  let test = eq r r_expected in
  if not test then failwithf "test 195 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a27; b27 } = r in
  let expected_a27 = 100. in
  mark_test_run 196;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a27 a27 in
  if not test then failwithf "test 196 failed";
  let expected_b27 = 101 in
  mark_test_run 197;
  let test = (fun a b -> Int.equal a b) expected_b27 b27 in
  if not test then failwithf "test 197 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a27; b27 } = r in
  let expected_a27 = 100. in
  mark_test_run 198;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a27 a27 in
  if not test then failwithf "test 198 failed";
  let expected_b27 = 101 in
  mark_test_run 199;
  let test = (fun a b -> Int.equal a b) expected_b27 b27 in
  if not test then failwithf "test 199 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t28 = { float; float; int }   *)
  (***********************************)
  let r = { a28 = 0.; b28 = 1.; c28 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a28 *)
  let actual = r.a28 in
  let expected = 0. in
  mark_test_run 200;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 200 failed";
  (* Paths of depth 1 *)
  (* .b28 *)
  let actual = r.b28 in
  let expected = 1. in
  mark_test_run 201;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 201 failed";
  (* Paths of depth 1 *)
  (* .c28 *)
  let actual = r.c28 in
  let expected = 2 in
  mark_test_run 202;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 202 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a28 = a281; b28 = b281; c28 = c281 } { a28 = a282; b28 = b282; c28 = c282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Float.equal (globalize a) (globalize b)) b281 b282 && (fun a b -> Int.equal a b) c281 c282) in
  let next_r = { a28 = 100.; b28 = 101.; c28 = 102 } in
  let r_expected = { a28 = 0.; b28 = 1.; c28 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a28 *)
  r.a28 <- next_r.a28;
  let r_expected = { r_expected with a28 = next_r.a28 } in
  mark_test_run 203;
  let test = eq r r_expected in
  if not test then failwithf "test 203 failed";
  Gc.compact ();
  (* .b28 *)
  r.b28 <- next_r.b28;
  let r_expected = { r_expected with b28 = next_r.b28 } in
  mark_test_run 204;
  let test = eq r r_expected in
  if not test then failwithf "test 204 failed";
  Gc.compact ();
  (* .c28 *)
  r.c28 <- next_r.c28;
  let r_expected = { r_expected with c28 = next_r.c28 } in
  mark_test_run 205;
  let test = eq r r_expected in
  if not test then failwithf "test 205 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a28; b28; c28 } = r in
  let expected_a28 = 100. in
  mark_test_run 206;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a28 a28 in
  if not test then failwithf "test 206 failed";
  let expected_b28 = 101. in
  mark_test_run 207;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b28 b28 in
  if not test then failwithf "test 207 failed";
  let expected_c28 = 102 in
  mark_test_run 208;
  let test = (fun a b -> Int.equal a b) expected_c28 c28 in
  if not test then failwithf "test 208 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a28; b28; c28 } = r in
  let expected_a28 = 100. in
  mark_test_run 209;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a28 a28 in
  if not test then failwithf "test 209 failed";
  let expected_b28 = 101. in
  mark_test_run 210;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b28 b28 in
  if not test then failwithf "test 210 failed";
  let expected_c28 = 102 in
  mark_test_run 211;
  let test = (fun a b -> Int.equal a b) expected_c28 c28 in
  if not test then failwithf "test 211 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t30 = { float; #{ float; float# } }   *)
  (*******************************************)
  let r = { a30 = 0.; b30 = #{ a29 = 1.; b29 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a30 *)
  let actual = r.a30 in
  let expected = 0. in
  mark_test_run 212;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 212 failed";
  (* Paths of depth 1 *)
  (* .b30 *)
  let actual = r.b30 in
  let expected = #{ a29 = 1.; b29 = #2. } in
  mark_test_run 213;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b291 b292) actual expected in
  if not test then failwithf "test 213 failed";
  (* Paths of depth 2 *)
  (* .b30.#a29 *)
  let actual = r.b30.#a29 in
  let expected = 1. in
  mark_test_run 214;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 214 failed";
  (* .b30.#b29 *)
  let actual = r.b30.#b29 in
  let expected = #2. in
  mark_test_run 215;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 215 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a30 = a301; b30 = b301 } { a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b291 b292) b301 b302) in
  let next_r = { a30 = 100.; b30 = #{ a29 = 101.; b29 = #102. } } in
  let r_expected = { a30 = 0.; b30 = #{ a29 = 1.; b29 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a30 *)
  r.a30 <- next_r.a30;
  let r_expected = { r_expected with a30 = next_r.a30 } in
  mark_test_run 216;
  let test = eq r r_expected in
  if not test then failwithf "test 216 failed";
  Gc.compact ();
  (* .b30 *)
  r.b30 <- next_r.b30;
  let r_expected = { r_expected with b30 = next_r.b30 } in
  mark_test_run 217;
  let test = eq r r_expected in
  if not test then failwithf "test 217 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a30; b30 = #{ a29; b29 } } = r in
  let expected_a30 = 100. in
  mark_test_run 218;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a30 a30 in
  if not test then failwithf "test 218 failed";
  let expected_a29 = 101. in
  mark_test_run 219;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a29 a29 in
  if not test then failwithf "test 219 failed";
  let expected_b29 = #102. in
  mark_test_run 220;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b29 b29 in
  if not test then failwithf "test 220 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a30; b30 } = r in
  let expected_a30 = 100. in
  mark_test_run 221;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a30 a30 in
  if not test then failwithf "test 221 failed";
  let expected_b30 = #{ a29 = 101.; b29 = #102. } in
  mark_test_run 222;
  let test = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b291 b292) expected_b30 b30 in
  if not test then failwithf "test 222 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t32 = { float; #{ float#; float# } }   *)
  (********************************************)
  let r = { a32 = 0.; b32 = #{ a31 = #1.; b31 = #2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a32 *)
  let actual = r.a32 in
  let expected = 0. in
  mark_test_run 223;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 223 failed";
  (* Paths of depth 1 *)
  (* .b32 *)
  let actual = r.b32 in
  let expected = #{ a31 = #1.; b31 = #2. } in
  mark_test_run 224;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a311 a312 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b311 b312) actual expected in
  if not test then failwithf "test 224 failed";
  (* Paths of depth 2 *)
  (* .b32.#a31 *)
  let actual = r.b32.#a31 in
  let expected = #1. in
  mark_test_run 225;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 225 failed";
  (* .b32.#b31 *)
  let actual = r.b32.#b31 in
  let expected = #2. in
  mark_test_run 226;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 226 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a32 = a321; b32 = b321 } { a32 = a322; b32 = b322 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a311 a312 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b311 b312) b321 b322) in
  let next_r = { a32 = 100.; b32 = #{ a31 = #101.; b31 = #102. } } in
  let r_expected = { a32 = 0.; b32 = #{ a31 = #1.; b31 = #2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a32 *)
  r.a32 <- next_r.a32;
  let r_expected = { r_expected with a32 = next_r.a32 } in
  mark_test_run 227;
  let test = eq r r_expected in
  if not test then failwithf "test 227 failed";
  Gc.compact ();
  (* .b32 *)
  r.b32 <- next_r.b32;
  let r_expected = { r_expected with b32 = next_r.b32 } in
  mark_test_run 228;
  let test = eq r r_expected in
  if not test then failwithf "test 228 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a32; b32 = #{ a31; b31 } } = r in
  let expected_a32 = 100. in
  mark_test_run 229;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a32 a32 in
  if not test then failwithf "test 229 failed";
  let expected_a31 = #101. in
  mark_test_run 230;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a31 a31 in
  if not test then failwithf "test 230 failed";
  let expected_b31 = #102. in
  mark_test_run 231;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b31 b31 in
  if not test then failwithf "test 231 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a32; b32 } = r in
  let expected_a32 = 100. in
  mark_test_run 232;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a32 a32 in
  if not test then failwithf "test 232 failed";
  let expected_b32 = #{ a31 = #101.; b31 = #102. } in
  mark_test_run 233;
  let test = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a311 a312 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b311 b312) expected_b32 b32 in
  if not test then failwithf "test 233 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t33 = { float#; float }   *)
  (*******************************)
  let r = { a33 = #0.; b33 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a33 *)
  let actual = r.a33 in
  let expected = #0. in
  mark_test_run 234;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 234 failed";
  (* Paths of depth 1 *)
  (* .b33 *)
  let actual = r.b33 in
  let expected = 1. in
  mark_test_run 235;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 235 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a33 = a331; b33 = b331 } { a33 = a332; b33 = b332 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332) in
  let next_r = { a33 = #100.; b33 = 101. } in
  let r_expected = { a33 = #0.; b33 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a33 *)
  r.a33 <- next_r.a33;
  let r_expected = { r_expected with a33 = next_r.a33 } in
  mark_test_run 236;
  let test = eq r r_expected in
  if not test then failwithf "test 236 failed";
  Gc.compact ();
  (* .b33 *)
  r.b33 <- next_r.b33;
  let r_expected = { r_expected with b33 = next_r.b33 } in
  mark_test_run 237;
  let test = eq r r_expected in
  if not test then failwithf "test 237 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a33; b33 } = r in
  let expected_a33 = #100. in
  mark_test_run 238;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a33 a33 in
  if not test then failwithf "test 238 failed";
  let expected_b33 = 101. in
  mark_test_run 239;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 239 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a33; b33 } = r in
  let expected_a33 = #100. in
  mark_test_run 240;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a33 a33 in
  if not test then failwithf "test 240 failed";
  let expected_b33 = 101. in
  mark_test_run 241;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b33 b33 in
  if not test then failwithf "test 241 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************************)
  (*   t35 = { float#; #{ float; float } }   *)
  (*******************************************)
  let r = { a35 = #0.; b35 = #{ a34 = 1.; b34 = 2. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a35 *)
  let actual = r.a35 in
  let expected = #0. in
  mark_test_run 242;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 242 failed";
  (* Paths of depth 1 *)
  (* .b35 *)
  let actual = r.b35 in
  let expected = #{ a34 = 1.; b34 = 2. } in
  mark_test_run 243;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) actual expected in
  if not test then failwithf "test 243 failed";
  (* Paths of depth 2 *)
  (* .b35.#a34 *)
  let actual = r.b35.#a34 in
  let expected = 1. in
  mark_test_run 244;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 244 failed";
  (* .b35.#b34 *)
  let actual = r.b35.#b34 in
  let expected = 2. in
  mark_test_run 245;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 245 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a35 = a351; b35 = b351 } { a35 = a352; b35 = b352 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a351 a352 && (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) b351 b352) in
  let next_r = { a35 = #100.; b35 = #{ a34 = 101.; b34 = 102. } } in
  let r_expected = { a35 = #0.; b35 = #{ a34 = 1.; b34 = 2. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a35 *)
  r.a35 <- next_r.a35;
  let r_expected = { r_expected with a35 = next_r.a35 } in
  mark_test_run 246;
  let test = eq r r_expected in
  if not test then failwithf "test 246 failed";
  Gc.compact ();
  (* .b35 *)
  r.b35 <- next_r.b35;
  let r_expected = { r_expected with b35 = next_r.b35 } in
  mark_test_run 247;
  let test = eq r r_expected in
  if not test then failwithf "test 247 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a35; b35 = #{ a34; b34 } } = r in
  let expected_a35 = #100. in
  mark_test_run 248;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a35 a35 in
  if not test then failwithf "test 248 failed";
  let expected_a34 = 101. in
  mark_test_run 249;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a34 a34 in
  if not test then failwithf "test 249 failed";
  let expected_b34 = 102. in
  mark_test_run 250;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b34 b34 in
  if not test then failwithf "test 250 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a35; b35 } = r in
  let expected_a35 = #100. in
  mark_test_run 251;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a35 a35 in
  if not test then failwithf "test 251 failed";
  let expected_b35 = #{ a34 = 101.; b34 = 102. } in
  mark_test_run 252;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) expected_b35 b35 in
  if not test then failwithf "test 252 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************)
  (*   t36 = { string; string }   *)
  (********************************)
  let r = { a36 = "0"; b36 = "1" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a36 *)
  let actual = r.a36 in
  let expected = "0" in
  mark_test_run 253;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 253 failed";
  (* Paths of depth 1 *)
  (* .b36 *)
  let actual = r.b36 in
  let expected = "1" in
  mark_test_run 254;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 254 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a36 = a361; b36 = b361 } { a36 = a362; b36 = b362 } -> (fun a b -> String.equal (globalize a) (globalize b)) a361 a362 && (fun a b -> String.equal (globalize a) (globalize b)) b361 b362) in
  let next_r = { a36 = "100"; b36 = "101" } in
  let r_expected = { a36 = "0"; b36 = "1" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a36 *)
  r.a36 <- next_r.a36;
  let r_expected = { r_expected with a36 = next_r.a36 } in
  mark_test_run 255;
  let test = eq r r_expected in
  if not test then failwithf "test 255 failed";
  Gc.compact ();
  (* .b36 *)
  r.b36 <- next_r.b36;
  let r_expected = { r_expected with b36 = next_r.b36 } in
  mark_test_run 256;
  let test = eq r r_expected in
  if not test then failwithf "test 256 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a36; b36 } = r in
  let expected_a36 = "100" in
  mark_test_run 257;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a36 a36 in
  if not test then failwithf "test 257 failed";
  let expected_b36 = "101" in
  mark_test_run 258;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b36 b36 in
  if not test then failwithf "test 258 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a36; b36 } = r in
  let expected_a36 = "100" in
  mark_test_run 259;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a36 a36 in
  if not test then failwithf "test 259 failed";
  let expected_b36 = "101" in
  mark_test_run 260;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b36 b36 in
  if not test then failwithf "test 260 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**********************************************)
  (*   t37 = { int64x2#; int64x2#; int64x2# }   *)
  (**********************************************)
  let r = { a37 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b37 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c37 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a37 *)
  let actual = r.a37 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 261;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 261 failed";
  (* Paths of depth 1 *)
  (* .b37 *)
  let actual = r.b37 in
  let expected = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)) in
  mark_test_run 262;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 262 failed";
  (* Paths of depth 1 *)
  (* .c37 *)
  let actual = r.c37 in
  let expected = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) in
  mark_test_run 263;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 263 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a37 = a371; b37 = b371; c37 = c371 } { a37 = a372; b37 = b372; c37 = c372 } -> int64x2_u_equal a371 a372 && int64x2_u_equal b371 b372 && int64x2_u_equal c371 c372) in
  let next_r = { a37 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b37 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)); c37 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) } in
  let r_expected = { a37 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b37 = (interleave_low_64 (int64x2_of_int64 2L) (int64x2_of_int64 3L)); c37 = (interleave_low_64 (int64x2_of_int64 4L) (int64x2_of_int64 5L)) } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a37 *)
  r.a37 <- next_r.a37;
  let r_expected = { r_expected with a37 = next_r.a37 } in
  mark_test_run 264;
  let test = eq r r_expected in
  if not test then failwithf "test 264 failed";
  Gc.compact ();
  (* .b37 *)
  r.b37 <- next_r.b37;
  let r_expected = { r_expected with b37 = next_r.b37 } in
  mark_test_run 265;
  let test = eq r r_expected in
  if not test then failwithf "test 265 failed";
  Gc.compact ();
  (* .c37 *)
  r.c37 <- next_r.c37;
  let r_expected = { r_expected with c37 = next_r.c37 } in
  mark_test_run 266;
  let test = eq r r_expected in
  if not test then failwithf "test 266 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a37; b37; c37 } = r in
  let expected_a37 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 267;
  let test = int64x2_u_equal expected_a37 a37 in
  if not test then failwithf "test 267 failed";
  let expected_b37 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 268;
  let test = int64x2_u_equal expected_b37 b37 in
  if not test then failwithf "test 268 failed";
  let expected_c37 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 269;
  let test = int64x2_u_equal expected_c37 c37 in
  if not test then failwithf "test 269 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a37; b37; c37 } = r in
  let expected_a37 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 270;
  let test = int64x2_u_equal expected_a37 a37 in
  if not test then failwithf "test 270 failed";
  let expected_b37 = (interleave_low_64 (int64x2_of_int64 102L) (int64x2_of_int64 103L)) in
  mark_test_run 271;
  let test = int64x2_u_equal expected_b37 b37 in
  if not test then failwithf "test 271 failed";
  let expected_c37 = (interleave_low_64 (int64x2_of_int64 104L) (int64x2_of_int64 105L)) in
  mark_test_run 272;
  let test = int64x2_u_equal expected_c37 c37 in
  if not test then failwithf "test 272 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t39 = { int64x2#; #{ int } }   *)
  (************************************)
  let r = { a39 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b39 = #{ a38 = 2 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a39 *)
  let actual = r.a39 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 273;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 273 failed";
  (* Paths of depth 1 *)
  (* .b39 *)
  let actual = r.b39 in
  let expected = #{ a38 = 2 } in
  mark_test_run 274;
  let test = (fun #{ a38 = a381 } #{ a38 = a382 } -> (fun a b -> Int.equal a b) a381 a382) actual expected in
  if not test then failwithf "test 274 failed";
  (* Paths of depth 2 *)
  (* .b39.#a38 *)
  let actual = r.b39.#a38 in
  let expected = 2 in
  mark_test_run 275;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 275 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a39 = a391; b39 = b391 } { a39 = a392; b39 = b392 } -> int64x2_u_equal a391 a392 && (fun #{ a38 = a381 } #{ a38 = a382 } -> (fun a b -> Int.equal a b) a381 a382) b391 b392) in
  let next_r = { a39 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)); b39 = #{ a38 = 102 } } in
  let r_expected = { a39 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)); b39 = #{ a38 = 2 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a39 *)
  r.a39 <- next_r.a39;
  let r_expected = { r_expected with a39 = next_r.a39 } in
  mark_test_run 276;
  let test = eq r r_expected in
  if not test then failwithf "test 276 failed";
  Gc.compact ();
  (* .b39 *)
  r.b39 <- next_r.b39;
  let r_expected = { r_expected with b39 = next_r.b39 } in
  mark_test_run 277;
  let test = eq r r_expected in
  if not test then failwithf "test 277 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a39; b39 = #{ a38 } } = r in
  let expected_a39 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 278;
  let test = int64x2_u_equal expected_a39 a39 in
  if not test then failwithf "test 278 failed";
  let expected_a38 = 102 in
  mark_test_run 279;
  let test = (fun a b -> Int.equal a b) expected_a38 a38 in
  if not test then failwithf "test 279 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a39; b39 } = r in
  let expected_a39 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 280;
  let test = int64x2_u_equal expected_a39 a39 in
  if not test then failwithf "test 280 failed";
  let expected_b39 = #{ a38 = 102 } in
  mark_test_run 281;
  let test = (fun #{ a38 = a381 } #{ a38 = a382 } -> (fun a b -> Int.equal a b) a381 a382) expected_b39 b39 in
  if not test then failwithf "test 281 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t40 = { #{ int; int } }   *)
  (*******************************)
  let r = { a40 = #{ a5 = 0; b5 = 1 } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a40 *)
  let actual = r.a40 in
  let expected = #{ a5 = 0; b5 = 1 } in
  mark_test_run 282;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) actual expected in
  if not test then failwithf "test 282 failed";
  (* Paths of depth 2 *)
  (* .a40.#a5 *)
  let actual = r.a40.#a5 in
  let expected = 0 in
  mark_test_run 283;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 283 failed";
  (* .a40.#b5 *)
  let actual = r.a40.#b5 in
  let expected = 1 in
  mark_test_run 284;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 284 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a40 = a401 } { a40 = a402 } -> (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) a401 a402) in
  let next_r = { a40 = #{ a5 = 100; b5 = 101 } } in
  let r_expected = { a40 = #{ a5 = 0; b5 = 1 } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a40 *)
  r.a40 <- next_r.a40;
  let r_expected = { r_expected with a40 = next_r.a40 } in
  mark_test_run 285;
  let test = eq r r_expected in
  if not test then failwithf "test 285 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a40 = #{ a5; b5 } } = r in
  let expected_a5 = 100 in
  mark_test_run 286;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 286 failed";
  let expected_b5 = 101 in
  mark_test_run 287;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 287 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a40 } = r in
  let expected_a40 = #{ a5 = 100; b5 = 101 } in
  mark_test_run 288;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) expected_a40 a40 in
  if not test then failwithf "test 288 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t41 = { #{ int; int }; int }   *)
  (************************************)
  let r = { a41 = #{ a5 = 0; b5 = 1 }; b41 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a41 *)
  let actual = r.a41 in
  let expected = #{ a5 = 0; b5 = 1 } in
  mark_test_run 289;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) actual expected in
  if not test then failwithf "test 289 failed";
  (* Paths of depth 2 *)
  (* .a41.#a5 *)
  let actual = r.a41.#a5 in
  let expected = 0 in
  mark_test_run 290;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 290 failed";
  (* .a41.#b5 *)
  let actual = r.a41.#b5 in
  let expected = 1 in
  mark_test_run 291;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 291 failed";
  (* Paths of depth 1 *)
  (* .b41 *)
  let actual = r.b41 in
  let expected = 2 in
  mark_test_run 292;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 292 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a41 = a411; b41 = b411 } { a41 = a412; b41 = b412 } -> (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) a411 a412 && (fun a b -> Int.equal a b) b411 b412) in
  let next_r = { a41 = #{ a5 = 100; b5 = 101 }; b41 = 102 } in
  let r_expected = { a41 = #{ a5 = 0; b5 = 1 }; b41 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a41 *)
  r.a41 <- next_r.a41;
  let r_expected = { r_expected with a41 = next_r.a41 } in
  mark_test_run 293;
  let test = eq r r_expected in
  if not test then failwithf "test 293 failed";
  Gc.compact ();
  (* .b41 *)
  r.b41 <- next_r.b41;
  let r_expected = { r_expected with b41 = next_r.b41 } in
  mark_test_run 294;
  let test = eq r r_expected in
  if not test then failwithf "test 294 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a41 = #{ a5; b5 }; b41 } = r in
  let expected_a5 = 100 in
  mark_test_run 295;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 295 failed";
  let expected_b5 = 101 in
  mark_test_run 296;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 296 failed";
  let expected_b41 = 102 in
  mark_test_run 297;
  let test = (fun a b -> Int.equal a b) expected_b41 b41 in
  if not test then failwithf "test 297 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a41; b41 } = r in
  let expected_a41 = #{ a5 = 100; b5 = 101 } in
  mark_test_run 298;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) expected_a41 a41 in
  if not test then failwithf "test 298 failed";
  let expected_b41 = 102 in
  mark_test_run 299;
  let test = (fun a b -> Int.equal a b) expected_b41 b41 in
  if not test then failwithf "test 299 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t42 = { #{ int; int }; int32# }   *)
  (***************************************)
  let r = { a42 = #{ a5 = 0; b5 = 1 }; b42 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a42 *)
  let actual = r.a42 in
  let expected = #{ a5 = 0; b5 = 1 } in
  mark_test_run 300;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) actual expected in
  if not test then failwithf "test 300 failed";
  (* Paths of depth 2 *)
  (* .a42.#a5 *)
  let actual = r.a42.#a5 in
  let expected = 0 in
  mark_test_run 301;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 301 failed";
  (* .a42.#b5 *)
  let actual = r.a42.#b5 in
  let expected = 1 in
  mark_test_run 302;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 302 failed";
  (* Paths of depth 1 *)
  (* .b42 *)
  let actual = r.b42 in
  let expected = #2l in
  mark_test_run 303;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 303 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a42 = a421; b42 = b421 } { a42 = a422; b42 = b422 } -> (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let next_r = { a42 = #{ a5 = 100; b5 = 101 }; b42 = #102l } in
  let r_expected = { a42 = #{ a5 = 0; b5 = 1 }; b42 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a42 *)
  r.a42 <- next_r.a42;
  let r_expected = { r_expected with a42 = next_r.a42 } in
  mark_test_run 304;
  let test = eq r r_expected in
  if not test then failwithf "test 304 failed";
  Gc.compact ();
  (* .b42 *)
  r.b42 <- next_r.b42;
  let r_expected = { r_expected with b42 = next_r.b42 } in
  mark_test_run 305;
  let test = eq r r_expected in
  if not test then failwithf "test 305 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a42 = #{ a5; b5 }; b42 } = r in
  let expected_a5 = 100 in
  mark_test_run 306;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 306 failed";
  let expected_b5 = 101 in
  mark_test_run 307;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 307 failed";
  let expected_b42 = #102l in
  mark_test_run 308;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b42 b42 in
  if not test then failwithf "test 308 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a42; b42 } = r in
  let expected_a42 = #{ a5 = 100; b5 = 101 } in
  mark_test_run 309;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) expected_a42 a42 in
  if not test then failwithf "test 309 failed";
  let expected_b42 = #102l in
  mark_test_run 310;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b42 b42 in
  if not test then failwithf "test 310 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (**************************************)
  (*   t43 = { #{ int; int }; float }   *)
  (**************************************)
  let r = { a43 = #{ a5 = 0; b5 = 1 }; b43 = 2. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a43 *)
  let actual = r.a43 in
  let expected = #{ a5 = 0; b5 = 1 } in
  mark_test_run 311;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) actual expected in
  if not test then failwithf "test 311 failed";
  (* Paths of depth 2 *)
  (* .a43.#a5 *)
  let actual = r.a43.#a5 in
  let expected = 0 in
  mark_test_run 312;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 312 failed";
  (* .a43.#b5 *)
  let actual = r.a43.#b5 in
  let expected = 1 in
  mark_test_run 313;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 313 failed";
  (* Paths of depth 1 *)
  (* .b43 *)
  let actual = r.b43 in
  let expected = 2. in
  mark_test_run 314;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 314 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a43 = a431; b43 = b431 } { a43 = a432; b43 = b432 } -> (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) a431 a432 && (fun a b -> Float.equal (globalize a) (globalize b)) b431 b432) in
  let next_r = { a43 = #{ a5 = 100; b5 = 101 }; b43 = 102. } in
  let r_expected = { a43 = #{ a5 = 0; b5 = 1 }; b43 = 2. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a43 *)
  r.a43 <- next_r.a43;
  let r_expected = { r_expected with a43 = next_r.a43 } in
  mark_test_run 315;
  let test = eq r r_expected in
  if not test then failwithf "test 315 failed";
  Gc.compact ();
  (* .b43 *)
  r.b43 <- next_r.b43;
  let r_expected = { r_expected with b43 = next_r.b43 } in
  mark_test_run 316;
  let test = eq r r_expected in
  if not test then failwithf "test 316 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a43 = #{ a5; b5 }; b43 } = r in
  let expected_a5 = 100 in
  mark_test_run 317;
  let test = (fun a b -> Int.equal a b) expected_a5 a5 in
  if not test then failwithf "test 317 failed";
  let expected_b5 = 101 in
  mark_test_run 318;
  let test = (fun a b -> Int.equal a b) expected_b5 b5 in
  if not test then failwithf "test 318 failed";
  let expected_b43 = 102. in
  mark_test_run 319;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b43 b43 in
  if not test then failwithf "test 319 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a43; b43 } = r in
  let expected_a43 = #{ a5 = 100; b5 = 101 } in
  mark_test_run 320;
  let test = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int.equal a b) b51 b52) expected_a43 a43 in
  if not test then failwithf "test 320 failed";
  let expected_b43 = 102. in
  mark_test_run 321;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b43 b43 in
  if not test then failwithf "test 321 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t45 = { #{ int; int32# }; int }   *)
  (***************************************)
  let r = { a45 = #{ a44 = 0; b44 = #1l }; b45 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a45 *)
  let actual = r.a45 in
  let expected = #{ a44 = 0; b44 = #1l } in
  mark_test_run 322;
  let test = (fun #{ a44 = a441; b44 = b441 } #{ a44 = a442; b44 = b442 } -> (fun a b -> Int.equal a b) a441 a442 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b441 b442) actual expected in
  if not test then failwithf "test 322 failed";
  (* Paths of depth 2 *)
  (* .a45.#a44 *)
  let actual = r.a45.#a44 in
  let expected = 0 in
  mark_test_run 323;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 323 failed";
  (* .a45.#b44 *)
  let actual = r.a45.#b44 in
  let expected = #1l in
  mark_test_run 324;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 324 failed";
  (* Paths of depth 1 *)
  (* .b45 *)
  let actual = r.b45 in
  let expected = 2 in
  mark_test_run 325;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 325 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a45 = a451; b45 = b451 } { a45 = a452; b45 = b452 } -> (fun #{ a44 = a441; b44 = b441 } #{ a44 = a442; b44 = b442 } -> (fun a b -> Int.equal a b) a441 a442 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b441 b442) a451 a452 && (fun a b -> Int.equal a b) b451 b452) in
  let next_r = { a45 = #{ a44 = 100; b44 = #101l }; b45 = 102 } in
  let r_expected = { a45 = #{ a44 = 0; b44 = #1l }; b45 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a45 *)
  r.a45 <- next_r.a45;
  let r_expected = { r_expected with a45 = next_r.a45 } in
  mark_test_run 326;
  let test = eq r r_expected in
  if not test then failwithf "test 326 failed";
  Gc.compact ();
  (* .b45 *)
  r.b45 <- next_r.b45;
  let r_expected = { r_expected with b45 = next_r.b45 } in
  mark_test_run 327;
  let test = eq r r_expected in
  if not test then failwithf "test 327 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a45 = #{ a44; b44 }; b45 } = r in
  let expected_a44 = 100 in
  mark_test_run 328;
  let test = (fun a b -> Int.equal a b) expected_a44 a44 in
  if not test then failwithf "test 328 failed";
  let expected_b44 = #101l in
  mark_test_run 329;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b44 b44 in
  if not test then failwithf "test 329 failed";
  let expected_b45 = 102 in
  mark_test_run 330;
  let test = (fun a b -> Int.equal a b) expected_b45 b45 in
  if not test then failwithf "test 330 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a45; b45 } = r in
  let expected_a45 = #{ a44 = 100; b44 = #101l } in
  mark_test_run 331;
  let test = (fun #{ a44 = a441; b44 = b441 } #{ a44 = a442; b44 = b442 } -> (fun a b -> Int.equal a b) a441 a442 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b441 b442) expected_a45 a45 in
  if not test then failwithf "test 331 failed";
  let expected_b45 = 102 in
  mark_test_run 332;
  let test = (fun a b -> Int.equal a b) expected_b45 b45 in
  if not test then failwithf "test 332 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t48 = { #{ int64; int64# }; #{ int64#; float# } }   *)
  (*********************************************************)
  let r = { a48 = #{ a46 = 0L; b46 = #1L }; b48 = #{ a47 = #2L; b47 = #3. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a48 *)
  let actual = r.a48 in
  let expected = #{ a46 = 0L; b46 = #1L } in
  mark_test_run 333;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b461 b462) actual expected in
  if not test then failwithf "test 333 failed";
  (* Paths of depth 2 *)
  (* .a48.#a46 *)
  let actual = r.a48.#a46 in
  let expected = 0L in
  mark_test_run 334;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 334 failed";
  (* .a48.#b46 *)
  let actual = r.a48.#b46 in
  let expected = #1L in
  mark_test_run 335;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 335 failed";
  (* Paths of depth 1 *)
  (* .b48 *)
  let actual = r.b48 in
  let expected = #{ a47 = #2L; b47 = #3. } in
  mark_test_run 336;
  let test = (fun #{ a47 = a471; b47 = b471 } #{ a47 = a472; b47 = b472 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a471 a472 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b471 b472) actual expected in
  if not test then failwithf "test 336 failed";
  (* Paths of depth 2 *)
  (* .b48.#a47 *)
  let actual = r.b48.#a47 in
  let expected = #2L in
  mark_test_run 337;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 337 failed";
  (* .b48.#b47 *)
  let actual = r.b48.#b47 in
  let expected = #3. in
  mark_test_run 338;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 338 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a48 = a481; b48 = b481 } { a48 = a482; b48 = b482 } -> (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b461 b462) a481 a482 && (fun #{ a47 = a471; b47 = b471 } #{ a47 = a472; b47 = b472 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a471 a472 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b471 b472) b481 b482) in
  let next_r = { a48 = #{ a46 = 100L; b46 = #101L }; b48 = #{ a47 = #102L; b47 = #103. } } in
  let r_expected = { a48 = #{ a46 = 0L; b46 = #1L }; b48 = #{ a47 = #2L; b47 = #3. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a48 *)
  r.a48 <- next_r.a48;
  let r_expected = { r_expected with a48 = next_r.a48 } in
  mark_test_run 339;
  let test = eq r r_expected in
  if not test then failwithf "test 339 failed";
  Gc.compact ();
  (* .b48 *)
  r.b48 <- next_r.b48;
  let r_expected = { r_expected with b48 = next_r.b48 } in
  mark_test_run 340;
  let test = eq r r_expected in
  if not test then failwithf "test 340 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a48 = #{ a46; b46 }; b48 = #{ a47; b47 } } = r in
  let expected_a46 = 100L in
  mark_test_run 341;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a46 a46 in
  if not test then failwithf "test 341 failed";
  let expected_b46 = #101L in
  mark_test_run 342;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b46 b46 in
  if not test then failwithf "test 342 failed";
  let expected_a47 = #102L in
  mark_test_run 343;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a47 a47 in
  if not test then failwithf "test 343 failed";
  let expected_b47 = #103. in
  mark_test_run 344;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_b47 b47 in
  if not test then failwithf "test 344 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a48; b48 } = r in
  let expected_a48 = #{ a46 = 100L; b46 = #101L } in
  mark_test_run 345;
  let test = (fun #{ a46 = a461; b46 = b461 } #{ a46 = a462; b46 = b462 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b461 b462) expected_a48 a48 in
  if not test then failwithf "test 345 failed";
  let expected_b48 = #{ a47 = #102L; b47 = #103. } in
  mark_test_run 346;
  let test = (fun #{ a47 = a471; b47 = b471 } #{ a47 = a472; b47 = b472 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a471 a472 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b471 b472) expected_b48 b48 in
  if not test then failwithf "test 346 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************************)
  (*   t51 = { #{ int64; string }; #{ int64#; string } }   *)
  (*********************************************************)
  let r = { a51 = #{ a49 = 0L; b49 = "1" }; b51 = #{ a50 = #2L; b50 = "3" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a51 *)
  let actual = r.a51 in
  let expected = #{ a49 = 0L; b49 = "1" } in
  mark_test_run 347;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a491 a492 && (fun a b -> String.equal (globalize a) (globalize b)) b491 b492) actual expected in
  if not test then failwithf "test 347 failed";
  (* Paths of depth 2 *)
  (* .a51.#a49 *)
  let actual = r.a51.#a49 in
  let expected = 0L in
  mark_test_run 348;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 348 failed";
  (* .a51.#b49 *)
  let actual = r.a51.#b49 in
  let expected = "1" in
  mark_test_run 349;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 349 failed";
  (* Paths of depth 1 *)
  (* .b51 *)
  let actual = r.b51 in
  let expected = #{ a50 = #2L; b50 = "3" } in
  mark_test_run 350;
  let test = (fun #{ a50 = a501; b50 = b501 } #{ a50 = a502; b50 = b502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a501 a502 && (fun a b -> String.equal (globalize a) (globalize b)) b501 b502) actual expected in
  if not test then failwithf "test 350 failed";
  (* Paths of depth 2 *)
  (* .b51.#a50 *)
  let actual = r.b51.#a50 in
  let expected = #2L in
  mark_test_run 351;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 351 failed";
  (* .b51.#b50 *)
  let actual = r.b51.#b50 in
  let expected = "3" in
  mark_test_run 352;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 352 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a51 = a511; b51 = b511 } { a51 = a512; b51 = b512 } -> (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a491 a492 && (fun a b -> String.equal (globalize a) (globalize b)) b491 b492) a511 a512 && (fun #{ a50 = a501; b50 = b501 } #{ a50 = a502; b50 = b502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a501 a502 && (fun a b -> String.equal (globalize a) (globalize b)) b501 b502) b511 b512) in
  let next_r = { a51 = #{ a49 = 100L; b49 = "101" }; b51 = #{ a50 = #102L; b50 = "103" } } in
  let r_expected = { a51 = #{ a49 = 0L; b49 = "1" }; b51 = #{ a50 = #2L; b50 = "3" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a51 *)
  r.a51 <- next_r.a51;
  let r_expected = { r_expected with a51 = next_r.a51 } in
  mark_test_run 353;
  let test = eq r r_expected in
  if not test then failwithf "test 353 failed";
  Gc.compact ();
  (* .b51 *)
  r.b51 <- next_r.b51;
  let r_expected = { r_expected with b51 = next_r.b51 } in
  mark_test_run 354;
  let test = eq r r_expected in
  if not test then failwithf "test 354 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a51 = #{ a49; b49 }; b51 = #{ a50; b50 } } = r in
  let expected_a49 = 100L in
  mark_test_run 355;
  let test = (fun a b -> Int64.equal (globalize a) (globalize b)) expected_a49 a49 in
  if not test then failwithf "test 355 failed";
  let expected_b49 = "101" in
  mark_test_run 356;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b49 b49 in
  if not test then failwithf "test 356 failed";
  let expected_a50 = #102L in
  mark_test_run 357;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_a50 a50 in
  if not test then failwithf "test 357 failed";
  let expected_b50 = "103" in
  mark_test_run 358;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b50 b50 in
  if not test then failwithf "test 358 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a51; b51 } = r in
  let expected_a51 = #{ a49 = 100L; b49 = "101" } in
  mark_test_run 359;
  let test = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a491 a492 && (fun a b -> String.equal (globalize a) (globalize b)) b491 b492) expected_a51 a51 in
  if not test then failwithf "test 359 failed";
  let expected_b51 = #{ a50 = #102L; b50 = "103" } in
  mark_test_run 360;
  let test = (fun #{ a50 = a501; b50 = b501 } #{ a50 = a502; b50 = b502 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a501 a502 && (fun a b -> String.equal (globalize a) (globalize b)) b501 b502) expected_b51 b51 in
  if not test then failwithf "test 360 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t52 = { #{ int32# } }   *)
  (*****************************)
  let r = { a52 = #{ a21 = #0l } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a52 *)
  let actual = r.a52 in
  let expected = #{ a21 = #0l } in
  mark_test_run 361;
  let test = (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) actual expected in
  if not test then failwithf "test 361 failed";
  (* Paths of depth 2 *)
  (* .a52.#a21 *)
  let actual = r.a52.#a21 in
  let expected = #0l in
  mark_test_run 362;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 362 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a52 = a521 } { a52 = a522 } -> (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) a521 a522) in
  let next_r = { a52 = #{ a21 = #100l } } in
  let r_expected = { a52 = #{ a21 = #0l } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a52 *)
  r.a52 <- next_r.a52;
  let r_expected = { r_expected with a52 = next_r.a52 } in
  mark_test_run 363;
  let test = eq r r_expected in
  if not test then failwithf "test 363 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a52 = #{ a21 } } = r in
  let expected_a21 = #100l in
  mark_test_run 364;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a21 a21 in
  if not test then failwithf "test 364 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a52 } = r in
  let expected_a52 = #{ a21 = #100l } in
  mark_test_run 365;
  let test = (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a211 a212) expected_a52 a52 in
  if not test then failwithf "test 365 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************************)
  (*   t54 = { #{ int32#; int }; int32# }   *)
  (******************************************)
  let r = { a54 = #{ a53 = #0l; b53 = 1 }; b54 = #2l } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a54 *)
  let actual = r.a54 in
  let expected = #{ a53 = #0l; b53 = 1 } in
  mark_test_run 366;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun a b -> Int.equal a b) b531 b532) actual expected in
  if not test then failwithf "test 366 failed";
  (* Paths of depth 2 *)
  (* .a54.#a53 *)
  let actual = r.a54.#a53 in
  let expected = #0l in
  mark_test_run 367;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 367 failed";
  (* .a54.#b53 *)
  let actual = r.a54.#b53 in
  let expected = 1 in
  mark_test_run 368;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 368 failed";
  (* Paths of depth 1 *)
  (* .b54 *)
  let actual = r.b54 in
  let expected = #2l in
  mark_test_run 369;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 369 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a54 = a541; b54 = b541 } { a54 = a542; b54 = b542 } -> (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun a b -> Int.equal a b) b531 b532) a541 a542 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b541 b542) in
  let next_r = { a54 = #{ a53 = #100l; b53 = 101 }; b54 = #102l } in
  let r_expected = { a54 = #{ a53 = #0l; b53 = 1 }; b54 = #2l } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a54 *)
  r.a54 <- next_r.a54;
  let r_expected = { r_expected with a54 = next_r.a54 } in
  mark_test_run 370;
  let test = eq r r_expected in
  if not test then failwithf "test 370 failed";
  Gc.compact ();
  (* .b54 *)
  r.b54 <- next_r.b54;
  let r_expected = { r_expected with b54 = next_r.b54 } in
  mark_test_run 371;
  let test = eq r r_expected in
  if not test then failwithf "test 371 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a54 = #{ a53; b53 }; b54 } = r in
  let expected_a53 = #100l in
  mark_test_run 372;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a53 a53 in
  if not test then failwithf "test 372 failed";
  let expected_b53 = 101 in
  mark_test_run 373;
  let test = (fun a b -> Int.equal a b) expected_b53 b53 in
  if not test then failwithf "test 373 failed";
  let expected_b54 = #102l in
  mark_test_run 374;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b54 b54 in
  if not test then failwithf "test 374 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a54; b54 } = r in
  let expected_a54 = #{ a53 = #100l; b53 = 101 } in
  mark_test_run 375;
  let test = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a531 a532 && (fun a b -> Int.equal a b) b531 b532) expected_a54 a54 in
  if not test then failwithf "test 375 failed";
  let expected_b54 = #102l in
  mark_test_run 376;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_b54 b54 in
  if not test then failwithf "test 376 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************)
  (*   t55 = { #{ float }; int }   *)
  (*********************************)
  let r = { a55 = #{ a9 = 0. }; b55 = 1 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a55 *)
  let actual = r.a55 in
  let expected = #{ a9 = 0. } in
  mark_test_run 377;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) actual expected in
  if not test then failwithf "test 377 failed";
  (* Paths of depth 2 *)
  (* .a55.#a9 *)
  let actual = r.a55.#a9 in
  let expected = 0. in
  mark_test_run 378;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 378 failed";
  (* Paths of depth 1 *)
  (* .b55 *)
  let actual = r.b55 in
  let expected = 1 in
  mark_test_run 379;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 379 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a55 = a551; b55 = b551 } { a55 = a552; b55 = b552 } -> (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) a551 a552 && (fun a b -> Int.equal a b) b551 b552) in
  let next_r = { a55 = #{ a9 = 100. }; b55 = 101 } in
  let r_expected = { a55 = #{ a9 = 0. }; b55 = 1 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a55 *)
  r.a55 <- next_r.a55;
  let r_expected = { r_expected with a55 = next_r.a55 } in
  mark_test_run 380;
  let test = eq r r_expected in
  if not test then failwithf "test 380 failed";
  Gc.compact ();
  (* .b55 *)
  r.b55 <- next_r.b55;
  let r_expected = { r_expected with b55 = next_r.b55 } in
  mark_test_run 381;
  let test = eq r r_expected in
  if not test then failwithf "test 381 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a55 = #{ a9 }; b55 } = r in
  let expected_a9 = 100. in
  mark_test_run 382;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a9 a9 in
  if not test then failwithf "test 382 failed";
  let expected_b55 = 101 in
  mark_test_run 383;
  let test = (fun a b -> Int.equal a b) expected_b55 b55 in
  if not test then failwithf "test 383 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a55; b55 } = r in
  let expected_a55 = #{ a9 = 100. } in
  mark_test_run 384;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) expected_a55 a55 in
  if not test then failwithf "test 384 failed";
  let expected_b55 = 101 in
  mark_test_run 385;
  let test = (fun a b -> Int.equal a b) expected_b55 b55 in
  if not test then failwithf "test 385 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t56 = { #{ float }; float }   *)
  (***********************************)
  let r = { a56 = #{ a9 = 0. }; b56 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a56 *)
  let actual = r.a56 in
  let expected = #{ a9 = 0. } in
  mark_test_run 386;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) actual expected in
  if not test then failwithf "test 386 failed";
  (* Paths of depth 2 *)
  (* .a56.#a9 *)
  let actual = r.a56.#a9 in
  let expected = 0. in
  mark_test_run 387;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 387 failed";
  (* Paths of depth 1 *)
  (* .b56 *)
  let actual = r.b56 in
  let expected = 1. in
  mark_test_run 388;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 388 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a56 = a561; b56 = b561 } { a56 = a562; b56 = b562 } -> (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) a561 a562 && (fun a b -> Float.equal (globalize a) (globalize b)) b561 b562) in
  let next_r = { a56 = #{ a9 = 100. }; b56 = 101. } in
  let r_expected = { a56 = #{ a9 = 0. }; b56 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a56 *)
  r.a56 <- next_r.a56;
  let r_expected = { r_expected with a56 = next_r.a56 } in
  mark_test_run 389;
  let test = eq r r_expected in
  if not test then failwithf "test 389 failed";
  Gc.compact ();
  (* .b56 *)
  r.b56 <- next_r.b56;
  let r_expected = { r_expected with b56 = next_r.b56 } in
  mark_test_run 390;
  let test = eq r r_expected in
  if not test then failwithf "test 390 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a56 = #{ a9 }; b56 } = r in
  let expected_a9 = 100. in
  mark_test_run 391;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a9 a9 in
  if not test then failwithf "test 391 failed";
  let expected_b56 = 101. in
  mark_test_run 392;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b56 b56 in
  if not test then failwithf "test 392 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a56; b56 } = r in
  let expected_a56 = #{ a9 = 100. } in
  mark_test_run 393;
  let test = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a91 a92) expected_a56 a56 in
  if not test then failwithf "test 393 failed";
  let expected_b56 = 101. in
  mark_test_run 394;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b56 b56 in
  if not test then failwithf "test 394 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t57 = { #{ float; float } }   *)
  (***********************************)
  let r = { a57 = #{ a34 = 0.; b34 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a57 *)
  let actual = r.a57 in
  let expected = #{ a34 = 0.; b34 = 1. } in
  mark_test_run 395;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) actual expected in
  if not test then failwithf "test 395 failed";
  (* Paths of depth 2 *)
  (* .a57.#a34 *)
  let actual = r.a57.#a34 in
  let expected = 0. in
  mark_test_run 396;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 396 failed";
  (* .a57.#b34 *)
  let actual = r.a57.#b34 in
  let expected = 1. in
  mark_test_run 397;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 397 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a57 = a571 } { a57 = a572 } -> (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) a571 a572) in
  let next_r = { a57 = #{ a34 = 100.; b34 = 101. } } in
  let r_expected = { a57 = #{ a34 = 0.; b34 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a57 *)
  r.a57 <- next_r.a57;
  let r_expected = { r_expected with a57 = next_r.a57 } in
  mark_test_run 398;
  let test = eq r r_expected in
  if not test then failwithf "test 398 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a57 = #{ a34; b34 } } = r in
  let expected_a34 = 100. in
  mark_test_run 399;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a34 a34 in
  if not test then failwithf "test 399 failed";
  let expected_b34 = 101. in
  mark_test_run 400;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b34 b34 in
  if not test then failwithf "test 400 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a57 } = r in
  let expected_a57 = #{ a34 = 100.; b34 = 101. } in
  mark_test_run 401;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) expected_a57 a57 in
  if not test then failwithf "test 401 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (****************************************)
  (*   t58 = { #{ float; float }; int }   *)
  (****************************************)
  let r = { a58 = #{ a34 = 0.; b34 = 1. }; b58 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a58 *)
  let actual = r.a58 in
  let expected = #{ a34 = 0.; b34 = 1. } in
  mark_test_run 402;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) actual expected in
  if not test then failwithf "test 402 failed";
  (* Paths of depth 2 *)
  (* .a58.#a34 *)
  let actual = r.a58.#a34 in
  let expected = 0. in
  mark_test_run 403;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 403 failed";
  (* .a58.#b34 *)
  let actual = r.a58.#b34 in
  let expected = 1. in
  mark_test_run 404;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 404 failed";
  (* Paths of depth 1 *)
  (* .b58 *)
  let actual = r.b58 in
  let expected = 2 in
  mark_test_run 405;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 405 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a58 = a581; b58 = b581 } { a58 = a582; b58 = b582 } -> (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) a581 a582 && (fun a b -> Int.equal a b) b581 b582) in
  let next_r = { a58 = #{ a34 = 100.; b34 = 101. }; b58 = 102 } in
  let r_expected = { a58 = #{ a34 = 0.; b34 = 1. }; b58 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a58 *)
  r.a58 <- next_r.a58;
  let r_expected = { r_expected with a58 = next_r.a58 } in
  mark_test_run 406;
  let test = eq r r_expected in
  if not test then failwithf "test 406 failed";
  Gc.compact ();
  (* .b58 *)
  r.b58 <- next_r.b58;
  let r_expected = { r_expected with b58 = next_r.b58 } in
  mark_test_run 407;
  let test = eq r r_expected in
  if not test then failwithf "test 407 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a58 = #{ a34; b34 }; b58 } = r in
  let expected_a34 = 100. in
  mark_test_run 408;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_a34 a34 in
  if not test then failwithf "test 408 failed";
  let expected_b34 = 101. in
  mark_test_run 409;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b34 b34 in
  if not test then failwithf "test 409 failed";
  let expected_b58 = 102 in
  mark_test_run 410;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 410 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a58; b58 } = r in
  let expected_a58 = #{ a34 = 100.; b34 = 101. } in
  mark_test_run 411;
  let test = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun a b -> Float.equal (globalize a) (globalize b)) b341 b342) expected_a58 a58 in
  if not test then failwithf "test 411 failed";
  let expected_b58 = 102 in
  mark_test_run 412;
  let test = (fun a b -> Int.equal a b) expected_b58 b58 in
  if not test then failwithf "test 412 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t60 = { #{ float# }; float }   *)
  (************************************)
  let r = { a60 = #{ a59 = #0. }; b60 = 1. } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a60 *)
  let actual = r.a60 in
  let expected = #{ a59 = #0. } in
  mark_test_run 413;
  let test = (fun #{ a59 = a591 } #{ a59 = a592 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a591 a592) actual expected in
  if not test then failwithf "test 413 failed";
  (* Paths of depth 2 *)
  (* .a60.#a59 *)
  let actual = r.a60.#a59 in
  let expected = #0. in
  mark_test_run 414;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 414 failed";
  (* Paths of depth 1 *)
  (* .b60 *)
  let actual = r.b60 in
  let expected = 1. in
  mark_test_run 415;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 415 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a60 = a601; b60 = b601 } { a60 = a602; b60 = b602 } -> (fun #{ a59 = a591 } #{ a59 = a592 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a591 a592) a601 a602 && (fun a b -> Float.equal (globalize a) (globalize b)) b601 b602) in
  let next_r = { a60 = #{ a59 = #100. }; b60 = 101. } in
  let r_expected = { a60 = #{ a59 = #0. }; b60 = 1. } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a60 *)
  r.a60 <- next_r.a60;
  let r_expected = { r_expected with a60 = next_r.a60 } in
  mark_test_run 416;
  let test = eq r r_expected in
  if not test then failwithf "test 416 failed";
  Gc.compact ();
  (* .b60 *)
  r.b60 <- next_r.b60;
  let r_expected = { r_expected with b60 = next_r.b60 } in
  mark_test_run 417;
  let test = eq r r_expected in
  if not test then failwithf "test 417 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a60 = #{ a59 }; b60 } = r in
  let expected_a59 = #100. in
  mark_test_run 418;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a59 a59 in
  if not test then failwithf "test 418 failed";
  let expected_b60 = 101. in
  mark_test_run 419;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 419 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a60; b60 } = r in
  let expected_a60 = #{ a59 = #100. } in
  mark_test_run 420;
  let test = (fun #{ a59 = a591 } #{ a59 = a592 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a591 a592) expected_a60 a60 in
  if not test then failwithf "test 420 failed";
  let expected_b60 = 101. in
  mark_test_run 421;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b60 b60 in
  if not test then failwithf "test 421 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t62 = { #{ float#; float } }   *)
  (************************************)
  let r = { a62 = #{ a61 = #0.; b61 = 1. } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a62 *)
  let actual = r.a62 in
  let expected = #{ a61 = #0.; b61 = 1. } in
  mark_test_run 422;
  let test = (fun #{ a61 = a611; b61 = b611 } #{ a61 = a612; b61 = b612 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a611 a612 && (fun a b -> Float.equal (globalize a) (globalize b)) b611 b612) actual expected in
  if not test then failwithf "test 422 failed";
  (* Paths of depth 2 *)
  (* .a62.#a61 *)
  let actual = r.a62.#a61 in
  let expected = #0. in
  mark_test_run 423;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) actual expected in
  if not test then failwithf "test 423 failed";
  (* .a62.#b61 *)
  let actual = r.a62.#b61 in
  let expected = 1. in
  mark_test_run 424;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 424 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a62 = a621 } { a62 = a622 } -> (fun #{ a61 = a611; b61 = b611 } #{ a61 = a612; b61 = b612 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a611 a612 && (fun a b -> Float.equal (globalize a) (globalize b)) b611 b612) a621 a622) in
  let next_r = { a62 = #{ a61 = #100.; b61 = 101. } } in
  let r_expected = { a62 = #{ a61 = #0.; b61 = 1. } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a62 *)
  r.a62 <- next_r.a62;
  let r_expected = { r_expected with a62 = next_r.a62 } in
  mark_test_run 425;
  let test = eq r r_expected in
  if not test then failwithf "test 425 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a62 = #{ a61; b61 } } = r in
  let expected_a61 = #100. in
  mark_test_run 426;
  let test = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) expected_a61 a61 in
  if not test then failwithf "test 426 failed";
  let expected_b61 = 101. in
  mark_test_run 427;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b61 b61 in
  if not test then failwithf "test 427 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a62 } = r in
  let expected_a62 = #{ a61 = #100.; b61 = 101. } in
  mark_test_run 428;
  let test = (fun #{ a61 = a611; b61 = b611 } #{ a61 = a612; b61 = b612 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a611 a612 && (fun a b -> Float.equal (globalize a) (globalize b)) b611 b612) expected_a62 a62 in
  if not test then failwithf "test 428 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************************************)
  (*   t65 = { #{ float32#; int64# }; #{ string; int64# } }   *)
  (************************************************************)
  let r = { a65 = #{ a63 = #0.s; b63 = #1L }; b65 = #{ a64 = "2"; b64 = #3L } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a65 *)
  let actual = r.a65 in
  let expected = #{ a63 = #0.s; b63 = #1L } in
  mark_test_run 429;
  let test = (fun #{ a63 = a631; b63 = b631 } #{ a63 = a632; b63 = b632 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a631 a632 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b631 b632) actual expected in
  if not test then failwithf "test 429 failed";
  (* Paths of depth 2 *)
  (* .a65.#a63 *)
  let actual = r.a65.#a63 in
  let expected = #0.s in
  mark_test_run 430;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) actual expected in
  if not test then failwithf "test 430 failed";
  (* .a65.#b63 *)
  let actual = r.a65.#b63 in
  let expected = #1L in
  mark_test_run 431;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 431 failed";
  (* Paths of depth 1 *)
  (* .b65 *)
  let actual = r.b65 in
  let expected = #{ a64 = "2"; b64 = #3L } in
  mark_test_run 432;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> String.equal (globalize a) (globalize b)) a641 a642 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b641 b642) actual expected in
  if not test then failwithf "test 432 failed";
  (* Paths of depth 2 *)
  (* .b65.#a64 *)
  let actual = r.b65.#a64 in
  let expected = "2" in
  mark_test_run 433;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 433 failed";
  (* .b65.#b64 *)
  let actual = r.b65.#b64 in
  let expected = #3L in
  mark_test_run 434;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) actual expected in
  if not test then failwithf "test 434 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a65 = a651; b65 = b651 } { a65 = a652; b65 = b652 } -> (fun #{ a63 = a631; b63 = b631 } #{ a63 = a632; b63 = b632 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a631 a632 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b631 b632) a651 a652 && (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> String.equal (globalize a) (globalize b)) a641 a642 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b641 b642) b651 b652) in
  let next_r = { a65 = #{ a63 = #100.s; b63 = #101L }; b65 = #{ a64 = "102"; b64 = #103L } } in
  let r_expected = { a65 = #{ a63 = #0.s; b63 = #1L }; b65 = #{ a64 = "2"; b64 = #3L } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a65 *)
  r.a65 <- next_r.a65;
  let r_expected = { r_expected with a65 = next_r.a65 } in
  mark_test_run 435;
  let test = eq r r_expected in
  if not test then failwithf "test 435 failed";
  Gc.compact ();
  (* .b65 *)
  r.b65 <- next_r.b65;
  let r_expected = { r_expected with b65 = next_r.b65 } in
  mark_test_run 436;
  let test = eq r r_expected in
  if not test then failwithf "test 436 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a65 = #{ a63; b63 }; b65 = #{ a64; b64 } } = r in
  let expected_a63 = #100.s in
  mark_test_run 437;
  let test = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) expected_a63 a63 in
  if not test then failwithf "test 437 failed";
  let expected_b63 = #101L in
  mark_test_run 438;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b63 b63 in
  if not test then failwithf "test 438 failed";
  let expected_a64 = "102" in
  mark_test_run 439;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a64 a64 in
  if not test then failwithf "test 439 failed";
  let expected_b64 = #103L in
  mark_test_run 440;
  let test = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) expected_b64 b64 in
  if not test then failwithf "test 440 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a65; b65 } = r in
  let expected_a65 = #{ a63 = #100.s; b63 = #101L } in
  mark_test_run 441;
  let test = (fun #{ a63 = a631; b63 = b631 } #{ a63 = a632; b63 = b632 } -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a631 a632 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b631 b632) expected_a65 a65 in
  if not test then failwithf "test 441 failed";
  let expected_b65 = #{ a64 = "102"; b64 = #103L } in
  mark_test_run 442;
  let test = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> String.equal (globalize a) (globalize b)) a641 a642 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b641 b642) expected_b65 b65 in
  if not test then failwithf "test 442 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*****************************)
  (*   t67 = { #{ string } }   *)
  (*****************************)
  let r = { a67 = #{ a66 = "0" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a67 *)
  let actual = r.a67 in
  let expected = #{ a66 = "0" } in
  mark_test_run 443;
  let test = (fun #{ a66 = a661 } #{ a66 = a662 } -> (fun a b -> String.equal (globalize a) (globalize b)) a661 a662) actual expected in
  if not test then failwithf "test 443 failed";
  (* Paths of depth 2 *)
  (* .a67.#a66 *)
  let actual = r.a67.#a66 in
  let expected = "0" in
  mark_test_run 444;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 444 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a67 = a671 } { a67 = a672 } -> (fun #{ a66 = a661 } #{ a66 = a662 } -> (fun a b -> String.equal (globalize a) (globalize b)) a661 a662) a671 a672) in
  let next_r = { a67 = #{ a66 = "100" } } in
  let r_expected = { a67 = #{ a66 = "0" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a67 *)
  r.a67 <- next_r.a67;
  let r_expected = { r_expected with a67 = next_r.a67 } in
  mark_test_run 445;
  let test = eq r r_expected in
  if not test then failwithf "test 445 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a67 = #{ a66 } } = r in
  let expected_a66 = "100" in
  mark_test_run 446;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a66 a66 in
  if not test then failwithf "test 446 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a67 } = r in
  let expected_a67 = #{ a66 = "100" } in
  mark_test_run 447;
  let test = (fun #{ a66 = a661 } #{ a66 = a662 } -> (fun a b -> String.equal (globalize a) (globalize b)) a661 a662) expected_a67 a67 in
  if not test then failwithf "test 447 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t69 = { #{ string; string } }   *)
  (*************************************)
  let r = { a69 = #{ a68 = "0"; b68 = "1" } } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a69 *)
  let actual = r.a69 in
  let expected = #{ a68 = "0"; b68 = "1" } in
  mark_test_run 448;
  let test = (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) actual expected in
  if not test then failwithf "test 448 failed";
  (* Paths of depth 2 *)
  (* .a69.#a68 *)
  let actual = r.a69.#a68 in
  let expected = "0" in
  mark_test_run 449;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 449 failed";
  (* .a69.#b68 *)
  let actual = r.a69.#b68 in
  let expected = "1" in
  mark_test_run 450;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 450 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a69 = a691 } { a69 = a692 } -> (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) a691 a692) in
  let next_r = { a69 = #{ a68 = "100"; b68 = "101" } } in
  let r_expected = { a69 = #{ a68 = "0"; b68 = "1" } } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a69 *)
  r.a69 <- next_r.a69;
  let r_expected = { r_expected with a69 = next_r.a69 } in
  mark_test_run 451;
  let test = eq r r_expected in
  if not test then failwithf "test 451 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a69 = #{ a68; b68 } } = r in
  let expected_a68 = "100" in
  mark_test_run 452;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a68 a68 in
  if not test then failwithf "test 452 failed";
  let expected_b68 = "101" in
  mark_test_run 453;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b68 b68 in
  if not test then failwithf "test 453 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a69 } = r in
  let expected_a69 = #{ a68 = "100"; b68 = "101" } in
  mark_test_run 454;
  let test = (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) expected_a69 a69 in
  if not test then failwithf "test 454 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t70 = { #{ string; string }; string }   *)
  (*********************************************)
  let r = { a70 = #{ a68 = "0"; b68 = "1" }; b70 = "2" } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a70 *)
  let actual = r.a70 in
  let expected = #{ a68 = "0"; b68 = "1" } in
  mark_test_run 455;
  let test = (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) actual expected in
  if not test then failwithf "test 455 failed";
  (* Paths of depth 2 *)
  (* .a70.#a68 *)
  let actual = r.a70.#a68 in
  let expected = "0" in
  mark_test_run 456;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 456 failed";
  (* .a70.#b68 *)
  let actual = r.a70.#b68 in
  let expected = "1" in
  mark_test_run 457;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 457 failed";
  (* Paths of depth 1 *)
  (* .b70 *)
  let actual = r.b70 in
  let expected = "2" in
  mark_test_run 458;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 458 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a70 = a701; b70 = b701 } { a70 = a702; b70 = b702 } -> (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) a701 a702 && (fun a b -> String.equal (globalize a) (globalize b)) b701 b702) in
  let next_r = { a70 = #{ a68 = "100"; b68 = "101" }; b70 = "102" } in
  let r_expected = { a70 = #{ a68 = "0"; b68 = "1" }; b70 = "2" } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a70 *)
  r.a70 <- next_r.a70;
  let r_expected = { r_expected with a70 = next_r.a70 } in
  mark_test_run 459;
  let test = eq r r_expected in
  if not test then failwithf "test 459 failed";
  Gc.compact ();
  (* .b70 *)
  r.b70 <- next_r.b70;
  let r_expected = { r_expected with b70 = next_r.b70 } in
  mark_test_run 460;
  let test = eq r r_expected in
  if not test then failwithf "test 460 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a70 = #{ a68; b68 }; b70 } = r in
  let expected_a68 = "100" in
  mark_test_run 461;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a68 a68 in
  if not test then failwithf "test 461 failed";
  let expected_b68 = "101" in
  mark_test_run 462;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b68 b68 in
  if not test then failwithf "test 462 failed";
  let expected_b70 = "102" in
  mark_test_run 463;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b70 b70 in
  if not test then failwithf "test 463 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a70; b70 } = r in
  let expected_a70 = #{ a68 = "100"; b68 = "101" } in
  mark_test_run 464;
  let test = (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> String.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> String.equal (globalize a) (globalize b)) b681 b682) expected_a70 a70 in
  if not test then failwithf "test 464 failed";
  let expected_b70 = "102" in
  mark_test_run 465;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b70 b70 in
  if not test then failwithf "test 465 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t72 = { #{ int64x2# }; int }   *)
  (************************************)
  let r = { a72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b72 = 2 } in
  ref_to_force_heap_allocation := P r;
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a72 *)
  let actual = r.a72 in
  let expected = #{ a71 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) } in
  mark_test_run 466;
  let test = (fun #{ a71 = a711 } #{ a71 = a712 } -> int64x2_u_equal a711 a712) actual expected in
  if not test then failwithf "test 466 failed";
  (* Paths of depth 2 *)
  (* .a72.#a71 *)
  let actual = r.a72.#a71 in
  let expected = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) in
  mark_test_run 467;
  let test = int64x2_u_equal actual expected in
  if not test then failwithf "test 467 failed";
  (* Paths of depth 1 *)
  (* .b72 *)
  let actual = r.b72 in
  let expected = 2 in
  mark_test_run 468;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 468 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a72 = a721; b72 = b721 } { a72 = a722; b72 = b722 } -> (fun #{ a71 = a711 } #{ a71 = a712 } -> int64x2_u_equal a711 a712) a721 a722 && (fun a b -> Int.equal a b) b721 b722) in
  let next_r = { a72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) }; b72 = 102 } in
  let r_expected = { a72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 0L) (int64x2_of_int64 1L)) }; b72 = 2 } in
  ref_to_force_heap_allocation := P next_r;
  ref_to_force_heap_allocation := P r_expected;
  (* .a72 *)
  r.a72 <- next_r.a72;
  let r_expected = { r_expected with a72 = next_r.a72 } in
  mark_test_run 469;
  let test = eq r r_expected in
  if not test then failwithf "test 469 failed";
  Gc.compact ();
  (* .b72 *)
  r.b72 <- next_r.b72;
  let r_expected = { r_expected with b72 = next_r.b72 } in
  mark_test_run 470;
  let test = eq r r_expected in
  if not test then failwithf "test 470 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a72 = #{ a71 }; b72 } = r in
  let expected_a71 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) in
  mark_test_run 471;
  let test = int64x2_u_equal expected_a71 a71 in
  if not test then failwithf "test 471 failed";
  let expected_b72 = 102 in
  mark_test_run 472;
  let test = (fun a b -> Int.equal a b) expected_b72 b72 in
  if not test then failwithf "test 472 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a72; b72 } = r in
  let expected_a72 = #{ a71 = (interleave_low_64 (int64x2_of_int64 100L) (int64x2_of_int64 101L)) } in
  mark_test_run 473;
  let test = (fun #{ a71 = a711 } #{ a71 = a712 } -> int64x2_u_equal a711 a712) expected_a72 a72 in
  if not test then failwithf "test 473 failed";
  let expected_b72 = 102 in
  mark_test_run 474;
  let test = (fun a b -> Int.equal a b) expected_b72 b72 in
  if not test then failwithf "test 474 failed";

  ()
;;
let () = to_run ();;

for i = 1 to 474 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
