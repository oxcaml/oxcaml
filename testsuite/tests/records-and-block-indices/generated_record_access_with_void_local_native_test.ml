(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "idx_repr.ml stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void mod everything
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

let int64x2_u_equal i1 i2 =
    let a1 = int64_of_int64x2 i1 in
    let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
    let a2 = int64_of_int64x2 i2 in
    let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
    Int64.equal a1 a2 && Int64.equal b1 b2

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any mod separable) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any mod separable) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = { mutable a0 : int; mutable b0 : unit_u } (* { int; unit_u } *)
type t1 = { mutable a1 : int32#; mutable b1 : unit_u } (* { int32#; unit_u } *)
type t2 = { mutable a2 : nativeint#; mutable b2 : unit_u } (* { nativeint#; unit_u } *)
type t3 = { mutable a3 : unit_u; mutable b3 : unit_u; mutable c3 : string } (* { unit_u; unit_u; string } *)
type t4 = { mutable a4 : unit_u; mutable b4 : float } (* { unit_u; float } *)
type t5 = { mutable a5 : unit_u; mutable b5 : string; mutable c5 : string } (* { unit_u; string; string } *)
type t6 = #{ a6 : unit_u; b6 : string } (* #{ unit_u; string } *)
type t7 = { mutable a7 : unit_u; mutable b7 : t6 } (* { unit_u; #{ unit_u; string } } *)
type t8 = { mutable a8 : string; mutable b8 : unit_u; mutable c8 : string } (* { string; unit_u; string } *)
type t9 = { mutable a9 : string; mutable b9 : string; mutable c9 : unit_u } (* { string; string; unit_u } *)
type t10 = #{ a10 : unit_u } (* #{ unit_u } *)
type t11 = { mutable a11 : string; mutable b11 : t10 } (* { string; #{ unit_u } } *)
type t12 = #{ a12 : unit_u; b12 : unit_u } (* #{ unit_u; unit_u } *)
type t13 = { mutable a13 : string; mutable b13 : t12 } (* { string; #{ unit_u; unit_u } } *)
type v14 = C14_0 of unit_u (* (| unit_u) *)
type t15 = { mutable a15 : v14; mutable b15 : unit_u } (* { (| unit_u); unit_u } *)
type t16 = { mutable a16 : t10; mutable b16 : string } (* { #{ unit_u }; string } *)
type t17 = { mutable a17 : t6 } (* { #{ unit_u; string } } *)
type t18 = { mutable a18 : t6; mutable b18 : unit_u } (* { #{ unit_u; string }; unit_u } *)

let to_run () =
  (****************************)
  (*   t0 = { int; unit_u }   *)
  (****************************)
  let r = stack_ { a0 = 0; b0 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a0 *)
  let actual = r.a0 in
  let expected = 0 in
  mark_test_run 1;
  let test = (fun a b -> Int.equal a b) actual expected in
  if not test then failwithf "test 1 failed";
  (* Paths of depth 1 *)
  (* .b0 *)
  let actual = r.b0 in
  let expected = (unbox_unit ()) in
  mark_test_run 2;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 2 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a0 = a01; b0 = b01 } { a0 = a02; b0 = b02 } -> (fun a b -> Int.equal a b) a01 a02 && (fun _ _ -> true) b01 b02) in
  let next_r = stack_ { a0 = 100; b0 = (unbox_unit ()) } in
  let r_expected = stack_ { a0 = 0; b0 = (unbox_unit ()) } in
  (* .a0 *)
  r.a0 <- next_r.a0;
  let r_expected = { r_expected with a0 = next_r.a0 } in
  mark_test_run 3;
  let test = eq r r_expected in
  if not test then failwithf "test 3 failed";
  Gc.compact ();
  (* .b0 *)
  r.b0 <- next_r.b0;
  let r_expected = { r_expected with b0 = next_r.b0 } in
  mark_test_run 4;
  let test = eq r r_expected in
  if not test then failwithf "test 4 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a0; b0 } = r in
  let expected_a0 = 100 in
  mark_test_run 5;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 5 failed";
  let expected_b0 = (unbox_unit ()) in
  mark_test_run 6;
  let test = (fun _ _ -> true) expected_b0 b0 in
  if not test then failwithf "test 6 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a0; b0 } = r in
  let expected_a0 = 100 in
  mark_test_run 7;
  let test = (fun a b -> Int.equal a b) expected_a0 a0 in
  if not test then failwithf "test 7 failed";
  let expected_b0 = (unbox_unit ()) in
  mark_test_run 8;
  let test = (fun _ _ -> true) expected_b0 b0 in
  if not test then failwithf "test 8 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*******************************)
  (*   t1 = { int32#; unit_u }   *)
  (*******************************)
  let r = stack_ { a1 = #0l; b1 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a1 *)
  let actual = r.a1 in
  let expected = #0l in
  mark_test_run 9;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) actual expected in
  if not test then failwithf "test 9 failed";
  (* Paths of depth 1 *)
  (* .b1 *)
  let actual = r.b1 in
  let expected = (unbox_unit ()) in
  mark_test_run 10;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 10 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a1 = a11; b1 = b11 } { a1 = a12; b1 = b12 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a11 a12 && (fun _ _ -> true) b11 b12) in
  let next_r = stack_ { a1 = #100l; b1 = (unbox_unit ()) } in
  let r_expected = stack_ { a1 = #0l; b1 = (unbox_unit ()) } in
  (* .a1 *)
  r.a1 <- next_r.a1;
  let r_expected = { r_expected with a1 = next_r.a1 } in
  mark_test_run 11;
  let test = eq r r_expected in
  if not test then failwithf "test 11 failed";
  Gc.compact ();
  (* .b1 *)
  r.b1 <- next_r.b1;
  let r_expected = { r_expected with b1 = next_r.b1 } in
  mark_test_run 12;
  let test = eq r r_expected in
  if not test then failwithf "test 12 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a1; b1 } = r in
  let expected_a1 = #100l in
  mark_test_run 13;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a1 a1 in
  if not test then failwithf "test 13 failed";
  let expected_b1 = (unbox_unit ()) in
  mark_test_run 14;
  let test = (fun _ _ -> true) expected_b1 b1 in
  if not test then failwithf "test 14 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a1; b1 } = r in
  let expected_a1 = #100l in
  mark_test_run 15;
  let test = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) expected_a1 a1 in
  if not test then failwithf "test 15 failed";
  let expected_b1 = (unbox_unit ()) in
  mark_test_run 16;
  let test = (fun _ _ -> true) expected_b1 b1 in
  if not test then failwithf "test 16 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***********************************)
  (*   t2 = { nativeint#; unit_u }   *)
  (***********************************)
  let r = stack_ { a2 = #0n; b2 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a2 *)
  let actual = r.a2 in
  let expected = #0n in
  mark_test_run 17;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) actual expected in
  if not test then failwithf "test 17 failed";
  (* Paths of depth 1 *)
  (* .b2 *)
  let actual = r.b2 in
  let expected = (unbox_unit ()) in
  mark_test_run 18;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 18 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a2 = a21; b2 = b21 } { a2 = a22; b2 = b22 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a21 a22 && (fun _ _ -> true) b21 b22) in
  let next_r = stack_ { a2 = #100n; b2 = (unbox_unit ()) } in
  let r_expected = stack_ { a2 = #0n; b2 = (unbox_unit ()) } in
  (* .a2 *)
  r.a2 <- next_r.a2;
  let r_expected = { r_expected with a2 = next_r.a2 } in
  mark_test_run 19;
  let test = eq r r_expected in
  if not test then failwithf "test 19 failed";
  Gc.compact ();
  (* .b2 *)
  r.b2 <- next_r.b2;
  let r_expected = { r_expected with b2 = next_r.b2 } in
  mark_test_run 20;
  let test = eq r r_expected in
  if not test then failwithf "test 20 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a2; b2 } = r in
  let expected_a2 = #100n in
  mark_test_run 21;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a2 a2 in
  if not test then failwithf "test 21 failed";
  let expected_b2 = (unbox_unit ()) in
  mark_test_run 22;
  let test = (fun _ _ -> true) expected_b2 b2 in
  if not test then failwithf "test 22 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a2; b2 } = r in
  let expected_a2 = #100n in
  mark_test_run 23;
  let test = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) expected_a2 a2 in
  if not test then failwithf "test 23 failed";
  let expected_b2 = (unbox_unit ()) in
  mark_test_run 24;
  let test = (fun _ _ -> true) expected_b2 b2 in
  if not test then failwithf "test 24 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t3 = { unit_u; unit_u; string }   *)
  (***************************************)
  let r = stack_ { a3 = (unbox_unit ()); b3 = (unbox_unit ()); c3 = "0" } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a3 *)
  let actual = r.a3 in
  let expected = (unbox_unit ()) in
  mark_test_run 25;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 25 failed";
  (* Paths of depth 1 *)
  (* .b3 *)
  let actual = r.b3 in
  let expected = (unbox_unit ()) in
  mark_test_run 26;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 26 failed";
  (* Paths of depth 1 *)
  (* .c3 *)
  let actual = r.c3 in
  let expected = "0" in
  mark_test_run 27;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 27 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a3 = a31; b3 = b31; c3 = c31 } { a3 = a32; b3 = b32; c3 = c32 } -> (fun _ _ -> true) a31 a32 && (fun _ _ -> true) b31 b32 && (fun a b -> String.equal (globalize a) (globalize b)) c31 c32) in
  let next_r = stack_ { a3 = (unbox_unit ()); b3 = (unbox_unit ()); c3 = "100" } in
  let r_expected = stack_ { a3 = (unbox_unit ()); b3 = (unbox_unit ()); c3 = "0" } in
  (* .a3 *)
  r.a3 <- next_r.a3;
  let r_expected = { r_expected with a3 = next_r.a3 } in
  mark_test_run 28;
  let test = eq r r_expected in
  if not test then failwithf "test 28 failed";
  Gc.compact ();
  (* .b3 *)
  r.b3 <- next_r.b3;
  let r_expected = { r_expected with b3 = next_r.b3 } in
  mark_test_run 29;
  let test = eq r r_expected in
  if not test then failwithf "test 29 failed";
  Gc.compact ();
  (* .c3 *)
  r.c3 <- next_r.c3;
  let r_expected = { r_expected with c3 = next_r.c3 } in
  mark_test_run 30;
  let test = eq r r_expected in
  if not test then failwithf "test 30 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a3; b3; c3 } = r in
  let expected_a3 = (unbox_unit ()) in
  mark_test_run 31;
  let test = (fun _ _ -> true) expected_a3 a3 in
  if not test then failwithf "test 31 failed";
  let expected_b3 = (unbox_unit ()) in
  mark_test_run 32;
  let test = (fun _ _ -> true) expected_b3 b3 in
  if not test then failwithf "test 32 failed";
  let expected_c3 = "100" in
  mark_test_run 33;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c3 c3 in
  if not test then failwithf "test 33 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a3; b3; c3 } = r in
  let expected_a3 = (unbox_unit ()) in
  mark_test_run 34;
  let test = (fun _ _ -> true) expected_a3 a3 in
  if not test then failwithf "test 34 failed";
  let expected_b3 = (unbox_unit ()) in
  mark_test_run 35;
  let test = (fun _ _ -> true) expected_b3 b3 in
  if not test then failwithf "test 35 failed";
  let expected_c3 = "100" in
  mark_test_run 36;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c3 c3 in
  if not test then failwithf "test 36 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (******************************)
  (*   t4 = { unit_u; float }   *)
  (******************************)
  let r = stack_ { a4 = (unbox_unit ()); b4 = 0. } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a4 *)
  let actual = r.a4 in
  let expected = (unbox_unit ()) in
  mark_test_run 37;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 37 failed";
  (* Paths of depth 1 *)
  (* .b4 *)
  let actual = r.b4 in
  let expected = 0. in
  mark_test_run 38;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 38 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a4 = a41; b4 = b41 } { a4 = a42; b4 = b42 } -> (fun _ _ -> true) a41 a42 && (fun a b -> Float.equal (globalize a) (globalize b)) b41 b42) in
  let next_r = stack_ { a4 = (unbox_unit ()); b4 = 100. } in
  let r_expected = stack_ { a4 = (unbox_unit ()); b4 = 0. } in
  (* .a4 *)
  r.a4 <- next_r.a4;
  let r_expected = { r_expected with a4 = next_r.a4 } in
  mark_test_run 39;
  let test = eq r r_expected in
  if not test then failwithf "test 39 failed";
  Gc.compact ();
  (* .b4 *)
  r.b4 <- next_r.b4;
  let r_expected = { r_expected with b4 = next_r.b4 } in
  mark_test_run 40;
  let test = eq r r_expected in
  if not test then failwithf "test 40 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a4; b4 } = r in
  let expected_a4 = (unbox_unit ()) in
  mark_test_run 41;
  let test = (fun _ _ -> true) expected_a4 a4 in
  if not test then failwithf "test 41 failed";
  let expected_b4 = 100. in
  mark_test_run 42;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b4 b4 in
  if not test then failwithf "test 42 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a4; b4 } = r in
  let expected_a4 = (unbox_unit ()) in
  mark_test_run 43;
  let test = (fun _ _ -> true) expected_a4 a4 in
  if not test then failwithf "test 43 failed";
  let expected_b4 = 100. in
  mark_test_run 44;
  let test = (fun a b -> Float.equal (globalize a) (globalize b)) expected_b4 b4 in
  if not test then failwithf "test 44 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t5 = { unit_u; string; string }   *)
  (***************************************)
  let r = stack_ { a5 = (unbox_unit ()); b5 = "0"; c5 = "1" } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a5 *)
  let actual = r.a5 in
  let expected = (unbox_unit ()) in
  mark_test_run 45;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 45 failed";
  (* Paths of depth 1 *)
  (* .b5 *)
  let actual = r.b5 in
  let expected = "0" in
  mark_test_run 46;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 46 failed";
  (* Paths of depth 1 *)
  (* .c5 *)
  let actual = r.c5 in
  let expected = "1" in
  mark_test_run 47;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 47 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a5 = a51; b5 = b51; c5 = c51 } { a5 = a52; b5 = b52; c5 = c52 } -> (fun _ _ -> true) a51 a52 && (fun a b -> String.equal (globalize a) (globalize b)) b51 b52 && (fun a b -> String.equal (globalize a) (globalize b)) c51 c52) in
  let next_r = stack_ { a5 = (unbox_unit ()); b5 = "100"; c5 = "101" } in
  let r_expected = stack_ { a5 = (unbox_unit ()); b5 = "0"; c5 = "1" } in
  (* .a5 *)
  r.a5 <- next_r.a5;
  let r_expected = { r_expected with a5 = next_r.a5 } in
  mark_test_run 48;
  let test = eq r r_expected in
  if not test then failwithf "test 48 failed";
  Gc.compact ();
  (* .b5 *)
  r.b5 <- next_r.b5;
  let r_expected = { r_expected with b5 = next_r.b5 } in
  mark_test_run 49;
  let test = eq r r_expected in
  if not test then failwithf "test 49 failed";
  Gc.compact ();
  (* .c5 *)
  r.c5 <- next_r.c5;
  let r_expected = { r_expected with c5 = next_r.c5 } in
  mark_test_run 50;
  let test = eq r r_expected in
  if not test then failwithf "test 50 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a5; b5; c5 } = r in
  let expected_a5 = (unbox_unit ()) in
  mark_test_run 51;
  let test = (fun _ _ -> true) expected_a5 a5 in
  if not test then failwithf "test 51 failed";
  let expected_b5 = "100" in
  mark_test_run 52;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b5 b5 in
  if not test then failwithf "test 52 failed";
  let expected_c5 = "101" in
  mark_test_run 53;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c5 c5 in
  if not test then failwithf "test 53 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a5; b5; c5 } = r in
  let expected_a5 = (unbox_unit ()) in
  mark_test_run 54;
  let test = (fun _ _ -> true) expected_a5 a5 in
  if not test then failwithf "test 54 failed";
  let expected_b5 = "100" in
  mark_test_run 55;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b5 b5 in
  if not test then failwithf "test 55 failed";
  let expected_c5 = "101" in
  mark_test_run 56;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c5 c5 in
  if not test then failwithf "test 56 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (********************************************)
  (*   t7 = { unit_u; #{ unit_u; string } }   *)
  (********************************************)
  let r = stack_ { a7 = (unbox_unit ()); b7 = #{ a6 = (unbox_unit ()); b6 = "0" } } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a7 *)
  let actual = r.a7 in
  let expected = (unbox_unit ()) in
  mark_test_run 57;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 57 failed";
  (* Paths of depth 1 *)
  (* .b7 *)
  let actual = r.b7 in
  let expected = #{ a6 = (unbox_unit ()); b6 = "0" } in
  mark_test_run 58;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) actual expected in
  if not test then failwithf "test 58 failed";
  (* Paths of depth 2 *)
  (* .b7.#a6 *)
  let actual = r.b7.#a6 in
  let expected = (unbox_unit ()) in
  mark_test_run 59;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 59 failed";
  (* .b7.#b6 *)
  let actual = r.b7.#b6 in
  let expected = "0" in
  mark_test_run 60;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 60 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a7 = a71; b7 = b71 } { a7 = a72; b7 = b72 } -> (fun _ _ -> true) a71 a72 && (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) b71 b72) in
  let next_r = stack_ { a7 = (unbox_unit ()); b7 = #{ a6 = (unbox_unit ()); b6 = "100" } } in
  let r_expected = stack_ { a7 = (unbox_unit ()); b7 = #{ a6 = (unbox_unit ()); b6 = "0" } } in
  (* .a7 *)
  r.a7 <- next_r.a7;
  let r_expected = { r_expected with a7 = next_r.a7 } in
  mark_test_run 61;
  let test = eq r r_expected in
  if not test then failwithf "test 61 failed";
  Gc.compact ();
  (* .b7 *)
  r.b7 <- next_r.b7;
  let r_expected = { r_expected with b7 = next_r.b7 } in
  mark_test_run 62;
  let test = eq r r_expected in
  if not test then failwithf "test 62 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a7; b7 = #{ a6; b6 } } = r in
  let expected_a7 = (unbox_unit ()) in
  mark_test_run 63;
  let test = (fun _ _ -> true) expected_a7 a7 in
  if not test then failwithf "test 63 failed";
  let expected_a6 = (unbox_unit ()) in
  mark_test_run 64;
  let test = (fun _ _ -> true) expected_a6 a6 in
  if not test then failwithf "test 64 failed";
  let expected_b6 = "100" in
  mark_test_run 65;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b6 b6 in
  if not test then failwithf "test 65 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a7; b7 } = r in
  let expected_a7 = (unbox_unit ()) in
  mark_test_run 66;
  let test = (fun _ _ -> true) expected_a7 a7 in
  if not test then failwithf "test 66 failed";
  let expected_b7 = #{ a6 = (unbox_unit ()); b6 = "100" } in
  mark_test_run 67;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) expected_b7 b7 in
  if not test then failwithf "test 67 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t8 = { string; unit_u; string }   *)
  (***************************************)
  let r = stack_ { a8 = "0"; b8 = (unbox_unit ()); c8 = "1" } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a8 *)
  let actual = r.a8 in
  let expected = "0" in
  mark_test_run 68;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 68 failed";
  (* Paths of depth 1 *)
  (* .b8 *)
  let actual = r.b8 in
  let expected = (unbox_unit ()) in
  mark_test_run 69;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 69 failed";
  (* Paths of depth 1 *)
  (* .c8 *)
  let actual = r.c8 in
  let expected = "1" in
  mark_test_run 70;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 70 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a8 = a81; b8 = b81; c8 = c81 } { a8 = a82; b8 = b82; c8 = c82 } -> (fun a b -> String.equal (globalize a) (globalize b)) a81 a82 && (fun _ _ -> true) b81 b82 && (fun a b -> String.equal (globalize a) (globalize b)) c81 c82) in
  let next_r = stack_ { a8 = "100"; b8 = (unbox_unit ()); c8 = "101" } in
  let r_expected = stack_ { a8 = "0"; b8 = (unbox_unit ()); c8 = "1" } in
  (* .a8 *)
  r.a8 <- next_r.a8;
  let r_expected = { r_expected with a8 = next_r.a8 } in
  mark_test_run 71;
  let test = eq r r_expected in
  if not test then failwithf "test 71 failed";
  Gc.compact ();
  (* .b8 *)
  r.b8 <- next_r.b8;
  let r_expected = { r_expected with b8 = next_r.b8 } in
  mark_test_run 72;
  let test = eq r r_expected in
  if not test then failwithf "test 72 failed";
  Gc.compact ();
  (* .c8 *)
  r.c8 <- next_r.c8;
  let r_expected = { r_expected with c8 = next_r.c8 } in
  mark_test_run 73;
  let test = eq r r_expected in
  if not test then failwithf "test 73 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a8; b8; c8 } = r in
  let expected_a8 = "100" in
  mark_test_run 74;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a8 a8 in
  if not test then failwithf "test 74 failed";
  let expected_b8 = (unbox_unit ()) in
  mark_test_run 75;
  let test = (fun _ _ -> true) expected_b8 b8 in
  if not test then failwithf "test 75 failed";
  let expected_c8 = "101" in
  mark_test_run 76;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c8 c8 in
  if not test then failwithf "test 76 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a8; b8; c8 } = r in
  let expected_a8 = "100" in
  mark_test_run 77;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a8 a8 in
  if not test then failwithf "test 77 failed";
  let expected_b8 = (unbox_unit ()) in
  mark_test_run 78;
  let test = (fun _ _ -> true) expected_b8 b8 in
  if not test then failwithf "test 78 failed";
  let expected_c8 = "101" in
  mark_test_run 79;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_c8 c8 in
  if not test then failwithf "test 79 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (***************************************)
  (*   t9 = { string; string; unit_u }   *)
  (***************************************)
  let r = stack_ { a9 = "0"; b9 = "1"; c9 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a9 *)
  let actual = r.a9 in
  let expected = "0" in
  mark_test_run 80;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 80 failed";
  (* Paths of depth 1 *)
  (* .b9 *)
  let actual = r.b9 in
  let expected = "1" in
  mark_test_run 81;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 81 failed";
  (* Paths of depth 1 *)
  (* .c9 *)
  let actual = r.c9 in
  let expected = (unbox_unit ()) in
  mark_test_run 82;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 82 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a9 = a91; b9 = b91; c9 = c91 } { a9 = a92; b9 = b92; c9 = c92 } -> (fun a b -> String.equal (globalize a) (globalize b)) a91 a92 && (fun a b -> String.equal (globalize a) (globalize b)) b91 b92 && (fun _ _ -> true) c91 c92) in
  let next_r = stack_ { a9 = "100"; b9 = "101"; c9 = (unbox_unit ()) } in
  let r_expected = stack_ { a9 = "0"; b9 = "1"; c9 = (unbox_unit ()) } in
  (* .a9 *)
  r.a9 <- next_r.a9;
  let r_expected = { r_expected with a9 = next_r.a9 } in
  mark_test_run 83;
  let test = eq r r_expected in
  if not test then failwithf "test 83 failed";
  Gc.compact ();
  (* .b9 *)
  r.b9 <- next_r.b9;
  let r_expected = { r_expected with b9 = next_r.b9 } in
  mark_test_run 84;
  let test = eq r r_expected in
  if not test then failwithf "test 84 failed";
  Gc.compact ();
  (* .c9 *)
  r.c9 <- next_r.c9;
  let r_expected = { r_expected with c9 = next_r.c9 } in
  mark_test_run 85;
  let test = eq r r_expected in
  if not test then failwithf "test 85 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a9; b9; c9 } = r in
  let expected_a9 = "100" in
  mark_test_run 86;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a9 a9 in
  if not test then failwithf "test 86 failed";
  let expected_b9 = "101" in
  mark_test_run 87;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b9 b9 in
  if not test then failwithf "test 87 failed";
  let expected_c9 = (unbox_unit ()) in
  mark_test_run 88;
  let test = (fun _ _ -> true) expected_c9 c9 in
  if not test then failwithf "test 88 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a9; b9; c9 } = r in
  let expected_a9 = "100" in
  mark_test_run 89;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a9 a9 in
  if not test then failwithf "test 89 failed";
  let expected_b9 = "101" in
  mark_test_run 90;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b9 b9 in
  if not test then failwithf "test 90 failed";
  let expected_c9 = (unbox_unit ()) in
  mark_test_run 91;
  let test = (fun _ _ -> true) expected_c9 c9 in
  if not test then failwithf "test 91 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t11 = { string; #{ unit_u } }   *)
  (*************************************)
  let r = stack_ { a11 = "0"; b11 = #{ a10 = (unbox_unit ()) } } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a11 *)
  let actual = r.a11 in
  let expected = "0" in
  mark_test_run 92;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 92 failed";
  (* Paths of depth 1 *)
  (* .b11 *)
  let actual = r.b11 in
  let expected = #{ a10 = (unbox_unit ()) } in
  mark_test_run 93;
  let test = (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) actual expected in
  if not test then failwithf "test 93 failed";
  (* Paths of depth 2 *)
  (* .b11.#a10 *)
  let actual = r.b11.#a10 in
  let expected = (unbox_unit ()) in
  mark_test_run 94;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 94 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a11 = a111; b11 = b111 } { a11 = a112; b11 = b112 } -> (fun a b -> String.equal (globalize a) (globalize b)) a111 a112 && (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) b111 b112) in
  let next_r = stack_ { a11 = "100"; b11 = #{ a10 = (unbox_unit ()) } } in
  let r_expected = stack_ { a11 = "0"; b11 = #{ a10 = (unbox_unit ()) } } in
  (* .a11 *)
  r.a11 <- next_r.a11;
  let r_expected = { r_expected with a11 = next_r.a11 } in
  mark_test_run 95;
  let test = eq r r_expected in
  if not test then failwithf "test 95 failed";
  Gc.compact ();
  (* .b11 *)
  r.b11 <- next_r.b11;
  let r_expected = { r_expected with b11 = next_r.b11 } in
  mark_test_run 96;
  let test = eq r r_expected in
  if not test then failwithf "test 96 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a11; b11 = #{ a10 } } = r in
  let expected_a11 = "100" in
  mark_test_run 97;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a11 a11 in
  if not test then failwithf "test 97 failed";
  let expected_a10 = (unbox_unit ()) in
  mark_test_run 98;
  let test = (fun _ _ -> true) expected_a10 a10 in
  if not test then failwithf "test 98 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a11; b11 } = r in
  let expected_a11 = "100" in
  mark_test_run 99;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a11 a11 in
  if not test then failwithf "test 99 failed";
  let expected_b11 = #{ a10 = (unbox_unit ()) } in
  mark_test_run 100;
  let test = (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) expected_b11 b11 in
  if not test then failwithf "test 100 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t13 = { string; #{ unit_u; unit_u } }   *)
  (*********************************************)
  let r = stack_ { a13 = "0"; b13 = #{ a12 = (unbox_unit ()); b12 = (unbox_unit ()) } } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a13 *)
  let actual = r.a13 in
  let expected = "0" in
  mark_test_run 101;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 101 failed";
  (* Paths of depth 1 *)
  (* .b13 *)
  let actual = r.b13 in
  let expected = #{ a12 = (unbox_unit ()); b12 = (unbox_unit ()) } in
  mark_test_run 102;
  let test = (fun #{ a12 = a121; b12 = b121 } #{ a12 = a122; b12 = b122 } -> (fun _ _ -> true) a121 a122 && (fun _ _ -> true) b121 b122) actual expected in
  if not test then failwithf "test 102 failed";
  (* Paths of depth 2 *)
  (* .b13.#a12 *)
  let actual = r.b13.#a12 in
  let expected = (unbox_unit ()) in
  mark_test_run 103;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 103 failed";
  (* .b13.#b12 *)
  let actual = r.b13.#b12 in
  let expected = (unbox_unit ()) in
  mark_test_run 104;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 104 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a13 = a131; b13 = b131 } { a13 = a132; b13 = b132 } -> (fun a b -> String.equal (globalize a) (globalize b)) a131 a132 && (fun #{ a12 = a121; b12 = b121 } #{ a12 = a122; b12 = b122 } -> (fun _ _ -> true) a121 a122 && (fun _ _ -> true) b121 b122) b131 b132) in
  let next_r = stack_ { a13 = "100"; b13 = #{ a12 = (unbox_unit ()); b12 = (unbox_unit ()) } } in
  let r_expected = stack_ { a13 = "0"; b13 = #{ a12 = (unbox_unit ()); b12 = (unbox_unit ()) } } in
  (* .a13 *)
  r.a13 <- next_r.a13;
  let r_expected = { r_expected with a13 = next_r.a13 } in
  mark_test_run 105;
  let test = eq r r_expected in
  if not test then failwithf "test 105 failed";
  Gc.compact ();
  (* .b13 *)
  r.b13 <- next_r.b13;
  let r_expected = { r_expected with b13 = next_r.b13 } in
  mark_test_run 106;
  let test = eq r r_expected in
  if not test then failwithf "test 106 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a13; b13 = #{ a12; b12 } } = r in
  let expected_a13 = "100" in
  mark_test_run 107;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a13 a13 in
  if not test then failwithf "test 107 failed";
  let expected_a12 = (unbox_unit ()) in
  mark_test_run 108;
  let test = (fun _ _ -> true) expected_a12 a12 in
  if not test then failwithf "test 108 failed";
  let expected_b12 = (unbox_unit ()) in
  mark_test_run 109;
  let test = (fun _ _ -> true) expected_b12 b12 in
  if not test then failwithf "test 109 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a13; b13 } = r in
  let expected_a13 = "100" in
  mark_test_run 110;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_a13 a13 in
  if not test then failwithf "test 110 failed";
  let expected_b13 = #{ a12 = (unbox_unit ()); b12 = (unbox_unit ()) } in
  mark_test_run 111;
  let test = (fun #{ a12 = a121; b12 = b121 } #{ a12 = a122; b12 = b122 } -> (fun _ _ -> true) a121 a122 && (fun _ _ -> true) b121 b122) expected_b13 b13 in
  if not test then failwithf "test 111 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (************************************)
  (*   t15 = { (| unit_u); unit_u }   *)
  (************************************)
  let r = stack_ { a15 = (C14_0 (unbox_unit ())); b15 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a15 *)
  let actual = r.a15 in
  let expected = (C14_0 (unbox_unit ())) in
  mark_test_run 112;
  let test = (fun a b -> match a, b with C14_0(a0), C14_0(b0) -> (fun _ _ -> true) a0 b0) actual expected in
  if not test then failwithf "test 112 failed";
  (* Paths of depth 1 *)
  (* .b15 *)
  let actual = r.b15 in
  let expected = (unbox_unit ()) in
  mark_test_run 113;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 113 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a15 = a151; b15 = b151 } { a15 = a152; b15 = b152 } -> (fun a b -> match a, b with C14_0(a0), C14_0(b0) -> (fun _ _ -> true) a0 b0) a151 a152 && (fun _ _ -> true) b151 b152) in
  let next_r = stack_ { a15 = (C14_0 (unbox_unit ())); b15 = (unbox_unit ()) } in
  let r_expected = stack_ { a15 = (C14_0 (unbox_unit ())); b15 = (unbox_unit ()) } in
  (* .a15 *)
  r.a15 <- next_r.a15;
  let r_expected = { r_expected with a15 = next_r.a15 } in
  mark_test_run 114;
  let test = eq r r_expected in
  if not test then failwithf "test 114 failed";
  Gc.compact ();
  (* .b15 *)
  r.b15 <- next_r.b15;
  let r_expected = { r_expected with b15 = next_r.b15 } in
  mark_test_run 115;
  let test = eq r r_expected in
  if not test then failwithf "test 115 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a15; b15 } = r in
  let expected_a15 = (C14_0 (unbox_unit ())) in
  mark_test_run 116;
  let test = (fun a b -> match a, b with C14_0(a0), C14_0(b0) -> (fun _ _ -> true) a0 b0) expected_a15 a15 in
  if not test then failwithf "test 116 failed";
  let expected_b15 = (unbox_unit ()) in
  mark_test_run 117;
  let test = (fun _ _ -> true) expected_b15 b15 in
  if not test then failwithf "test 117 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a15; b15 } = r in
  let expected_a15 = (C14_0 (unbox_unit ())) in
  mark_test_run 118;
  let test = (fun a b -> match a, b with C14_0(a0), C14_0(b0) -> (fun _ _ -> true) a0 b0) expected_a15 a15 in
  if not test then failwithf "test 118 failed";
  let expected_b15 = (unbox_unit ()) in
  mark_test_run 119;
  let test = (fun _ _ -> true) expected_b15 b15 in
  if not test then failwithf "test 119 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t16 = { #{ unit_u }; string }   *)
  (*************************************)
  let r = stack_ { a16 = #{ a10 = (unbox_unit ()) }; b16 = "0" } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a16 *)
  let actual = r.a16 in
  let expected = #{ a10 = (unbox_unit ()) } in
  mark_test_run 120;
  let test = (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) actual expected in
  if not test then failwithf "test 120 failed";
  (* Paths of depth 2 *)
  (* .a16.#a10 *)
  let actual = r.a16.#a10 in
  let expected = (unbox_unit ()) in
  mark_test_run 121;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 121 failed";
  (* Paths of depth 1 *)
  (* .b16 *)
  let actual = r.b16 in
  let expected = "0" in
  mark_test_run 122;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 122 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a16 = a161; b16 = b161 } { a16 = a162; b16 = b162 } -> (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) a161 a162 && (fun a b -> String.equal (globalize a) (globalize b)) b161 b162) in
  let next_r = stack_ { a16 = #{ a10 = (unbox_unit ()) }; b16 = "100" } in
  let r_expected = stack_ { a16 = #{ a10 = (unbox_unit ()) }; b16 = "0" } in
  (* .a16 *)
  r.a16 <- next_r.a16;
  let r_expected = { r_expected with a16 = next_r.a16 } in
  mark_test_run 123;
  let test = eq r r_expected in
  if not test then failwithf "test 123 failed";
  Gc.compact ();
  (* .b16 *)
  r.b16 <- next_r.b16;
  let r_expected = { r_expected with b16 = next_r.b16 } in
  mark_test_run 124;
  let test = eq r r_expected in
  if not test then failwithf "test 124 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a16 = #{ a10 }; b16 } = r in
  let expected_a10 = (unbox_unit ()) in
  mark_test_run 125;
  let test = (fun _ _ -> true) expected_a10 a10 in
  if not test then failwithf "test 125 failed";
  let expected_b16 = "100" in
  mark_test_run 126;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b16 b16 in
  if not test then failwithf "test 126 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a16; b16 } = r in
  let expected_a16 = #{ a10 = (unbox_unit ()) } in
  mark_test_run 127;
  let test = (fun #{ a10 = a101 } #{ a10 = a102 } -> (fun _ _ -> true) a101 a102) expected_a16 a16 in
  if not test then failwithf "test 127 failed";
  let expected_b16 = "100" in
  mark_test_run 128;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b16 b16 in
  if not test then failwithf "test 128 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*************************************)
  (*   t17 = { #{ unit_u; string } }   *)
  (*************************************)
  let r = stack_ { a17 = #{ a6 = (unbox_unit ()); b6 = "0" } } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a17 *)
  let actual = r.a17 in
  let expected = #{ a6 = (unbox_unit ()); b6 = "0" } in
  mark_test_run 129;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) actual expected in
  if not test then failwithf "test 129 failed";
  (* Paths of depth 2 *)
  (* .a17.#a6 *)
  let actual = r.a17.#a6 in
  let expected = (unbox_unit ()) in
  mark_test_run 130;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 130 failed";
  (* .a17.#b6 *)
  let actual = r.a17.#b6 in
  let expected = "0" in
  mark_test_run 131;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 131 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a17 = a171 } { a17 = a172 } -> (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) a171 a172) in
  let next_r = stack_ { a17 = #{ a6 = (unbox_unit ()); b6 = "100" } } in
  let r_expected = stack_ { a17 = #{ a6 = (unbox_unit ()); b6 = "0" } } in
  (* .a17 *)
  r.a17 <- next_r.a17;
  let r_expected = { r_expected with a17 = next_r.a17 } in
  mark_test_run 132;
  let test = eq r r_expected in
  if not test then failwithf "test 132 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a17 = #{ a6; b6 } } = r in
  let expected_a6 = (unbox_unit ()) in
  mark_test_run 133;
  let test = (fun _ _ -> true) expected_a6 a6 in
  if not test then failwithf "test 133 failed";
  let expected_b6 = "100" in
  mark_test_run 134;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b6 b6 in
  if not test then failwithf "test 134 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a17 } = r in
  let expected_a17 = #{ a6 = (unbox_unit ()); b6 = "100" } in
  mark_test_run 135;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) expected_a17 a17 in
  if not test then failwithf "test 135 failed";

  ()
;;
let () = to_run ();;

let to_run () =
  (*********************************************)
  (*   t18 = { #{ unit_u; string }; unit_u }   *)
  (*********************************************)
  let r = stack_ { a18 = #{ a6 = (unbox_unit ()); b6 = "0" }; b18 = (unbox_unit ()) } in
  (* 1. Test field get *)
  (* Paths of depth 1 *)
  (* .a18 *)
  let actual = r.a18 in
  let expected = #{ a6 = (unbox_unit ()); b6 = "0" } in
  mark_test_run 136;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) actual expected in
  if not test then failwithf "test 136 failed";
  (* Paths of depth 2 *)
  (* .a18.#a6 *)
  let actual = r.a18.#a6 in
  let expected = (unbox_unit ()) in
  mark_test_run 137;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 137 failed";
  (* .a18.#b6 *)
  let actual = r.a18.#b6 in
  let expected = "0" in
  mark_test_run 138;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) actual expected in
  if not test then failwithf "test 138 failed";
  (* Paths of depth 1 *)
  (* .b18 *)
  let actual = r.b18 in
  let expected = (unbox_unit ()) in
  mark_test_run 139;
  let test = (fun _ _ -> true) actual expected in
  if not test then failwithf "test 139 failed";
  Gc.compact ();
  (* 2. Test field set *)
  (* Change [r] to [next_r] one field at a time *)
  let eq = (fun { a18 = a181; b18 = b181 } { a18 = a182; b18 = b182 } -> (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) a181 a182 && (fun _ _ -> true) b181 b182) in
  let next_r = stack_ { a18 = #{ a6 = (unbox_unit ()); b6 = "100" }; b18 = (unbox_unit ()) } in
  let r_expected = stack_ { a18 = #{ a6 = (unbox_unit ()); b6 = "0" }; b18 = (unbox_unit ()) } in
  (* .a18 *)
  r.a18 <- next_r.a18;
  let r_expected = { r_expected with a18 = next_r.a18 } in
  mark_test_run 140;
  let test = eq r r_expected in
  if not test then failwithf "test 140 failed";
  Gc.compact ();
  (* .b18 *)
  r.b18 <- next_r.b18;
  let r_expected = { r_expected with b18 = next_r.b18 } in
  mark_test_run 141;
  let test = eq r r_expected in
  if not test then failwithf "test 141 failed";
  Gc.compact ();
  (* 3. Test deep matching *)
  let { a18 = #{ a6; b6 }; b18 } = r in
  let expected_a6 = (unbox_unit ()) in
  mark_test_run 142;
  let test = (fun _ _ -> true) expected_a6 a6 in
  if not test then failwithf "test 142 failed";
  let expected_b6 = "100" in
  mark_test_run 143;
  let test = (fun a b -> String.equal (globalize a) (globalize b)) expected_b6 b6 in
  if not test then failwithf "test 143 failed";
  let expected_b18 = (unbox_unit ()) in
  mark_test_run 144;
  let test = (fun _ _ -> true) expected_b18 b18 in
  if not test then failwithf "test 144 failed";
  Gc.compact ();
  (* 4. Test shallow matching *)
  let { a18; b18 } = r in
  let expected_a18 = #{ a6 = (unbox_unit ()); b6 = "100" } in
  mark_test_run 145;
  let test = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun _ _ -> true) a61 a62 && (fun a b -> String.equal (globalize a) (globalize b)) b61 b62) expected_a18 a18 in
  if not test then failwithf "test 145 failed";
  let expected_b18 = (unbox_unit ()) in
  mark_test_run 146;
  let test = (fun _ _ -> true) expected_b18 b18 in
  if not test then failwithf "test 146 failed";

  ()
;;
let () = to_run ();;

for i = 1 to 146 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
