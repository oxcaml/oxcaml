(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 modules = "idx_repr.ml stubs.c";
 flags = "-extension layouts_alpha";
 bytecode;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
type unit_u : void mod everything
external unbox_unit : unit -> unit_u = "%unbox_unit"
external globalize : local_ 'a -> 'a = "%obj_dup";;
let int64x2_u_equal (_ : int64x2#) (_ : int64x2#) = failwith "should not be called from bytecode"

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any mod separable) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any mod separable) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any mod separable) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = #{ a0 : int; b0 : int } (* #{ int; int } *)
type t1 = #{ a1 : int; b1 : int64 } (* #{ int; int64 } *)
type t2 = #{ a2 : int32#; b2 : nativeint# } (* #{ int32#; nativeint# } *)
type t3 = #{ a3 : nativeint#; b3 : nativeint# } (* #{ nativeint#; nativeint# } *)
type t4 = #{ a4 : float#; b4 : float# } (* #{ float#; float# } *)
type t5 = #{ a5 : float# } (* #{ float# } *)
type t6 = #{ a6 : float#; b6 : t5 } (* #{ float#; #{ float# } } *)
type t7 = #{ a7 : string; b7 : string } (* #{ string; string } *)
type t8 = #{ a8 : int } (* #{ int } *)
type t9 = #{ a9 : t8 } (* #{ #{ int } } *)
type t10 = #{ a10 : t0; b10 : int } (* #{ #{ int; int }; int } *)
type t11 = #{ a11 : int; b11 : int32# } (* #{ int; int32# } *)
type t12 = #{ a12 : t11 } (* #{ #{ int; int32# } } *)
type t13 = #{ a13 : int32# } (* #{ int32# } *)
type t14 = #{ a14 : t13 } (* #{ #{ int32# } } *)
type t15 = #{ a15 : int32#; b15 : int32# } (* #{ int32#; int32# } *)
type t16 = #{ a16 : t15; b16 : int32# } (* #{ #{ int32#; int32# }; int32# } *)

let test size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 1;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 3;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 3 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 4;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 4 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t0 = #{ int; int }   *)
  (**************************)
  let eq = (fun #{ a0 = a01; b0 = b01 } #{ a0 = a02; b0 = b02 } -> (fun a b -> Int.equal a b) a01 a02 && (fun a b -> Int.equal a b) b01 b02) in
  let mk_value i = #{ a0 = (i + 0); b0 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t0 array = makearray_dynamic size #{ a0 = 0; b0 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 6;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 6 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a0] *)
    let el = #{ el with a0 = next_el.#a0 } in
    Idx_mut.unsafe_set a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 7;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 7 failed %d %d" size i;
    (* Path: [.#b0] *)
    let el = #{ el with b0 = next_el.#b0 } in
    Idx_mut.unsafe_set a ((.(i).#b0) : (t0 array, _) idx_mut) next_el.#b0;
    mark_test_run 8;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 8 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t1 = #{ int; int64 }   *)
  (****************************)
  let eq = (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int64.equal (globalize a) (globalize b)) b11 b12) in
  let mk_value i = #{ a1 = (i + 0); b1 = Int64.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t1 array = makearray_dynamic size #{ a1 = 0; b1 = 1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 9;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a1] *)
    let el = #{ el with a1 = next_el.#a1 } in
    Idx_mut.unsafe_set a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 11;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 11 failed %d %d" size i;
    (* Path: [.#b1] *)
    let el = #{ el with b1 = next_el.#b1 } in
    Idx_mut.unsafe_set a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 12;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 12 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t2 = #{ int32#; nativeint# }   *)
  (************************************)
  let eq = (fun #{ a2 = a21; b2 = b21 } #{ a2 = a22; b2 = b22 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a21 a22 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b21 b22) in
  let mk_value i = #{ a2 = Int32_u.of_int (i + 0); b2 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t2 array = makearray_dynamic size #{ a2 = #0l; b2 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 13;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 13 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 14;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 14 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a2] *)
    let el = #{ el with a2 = next_el.#a2 } in
    Idx_mut.unsafe_set a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 15;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 15 failed %d %d" size i;
    (* Path: [.#b2] *)
    let el = #{ el with b2 = next_el.#b2 } in
    Idx_mut.unsafe_set a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 16;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 16 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t3 = #{ nativeint#; nativeint# }   *)
  (****************************************)
  let eq = (fun #{ a3 = a31; b3 = b31 } #{ a3 = a32; b3 = b32 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a31 a32 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b31 b32) in
  let mk_value i = #{ a3 = Nativeint_u.of_int (i + 0); b3 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t3 array = makearray_dynamic size #{ a3 = #0n; b3 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 17;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 17 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 18;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 18 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a3] *)
    let el = #{ el with a3 = next_el.#a3 } in
    Idx_mut.unsafe_set a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 19;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 19 failed %d %d" size i;
    (* Path: [.#b3] *)
    let el = #{ el with b3 = next_el.#b3 } in
    Idx_mut.unsafe_set a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 20;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 20 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t4 = #{ float#; float# }   *)
  (********************************)
  let eq = (fun #{ a4 = a41; b4 = b41 } #{ a4 = a42; b4 = b42 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a41 a42 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b41 b42) in
  let mk_value i = #{ a4 = Float_u.of_int (i + 0); b4 = Float_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t4 array = makearray_dynamic size #{ a4 = #0.; b4 = #1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 21;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 21 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 22;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 22 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a4] *)
    let el = #{ el with a4 = next_el.#a4 } in
    Idx_mut.unsafe_set a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 23;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 23 failed %d %d" size i;
    (* Path: [.#b4] *)
    let el = #{ el with b4 = next_el.#b4 } in
    Idx_mut.unsafe_set a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 24;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 24 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t6 = #{ float#; #{ float# } }   *)
  (*************************************)
  let eq = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a61 a62 && (fun #{ a5 = a51 } #{ a5 = a52 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a51 a52) b61 b62) in
  let mk_value i = #{ a6 = Float_u.of_int (i + 0); b6 = #{ a5 = Float_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t6 array = makearray_dynamic size #{ a6 = #0.; b6 = #{ a5 = #1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 25;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 25 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 26;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 26 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a6] *)
    let el = #{ el with a6 = next_el.#a6 } in
    Idx_mut.unsafe_set a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 27;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 27 failed %d %d" size i;
    (* Path: [.#b6] *)
    let el = #{ el with b6 = next_el.#b6 } in
    Idx_mut.unsafe_set a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 28;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 28 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b6.#a5] *)
    let el = #{ el with b6 = #{ el.#b6 with a5 = next_el.#b6.#a5 } } in
    Idx_mut.unsafe_set a ((.(i).#b6.#a5) : (t6 array, _) idx_mut) next_el.#b6.#a5;
    mark_test_run 29;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 29 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t7 = #{ string; string }   *)
  (********************************)
  let eq = (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> String.equal (globalize a) (globalize b)) a71 a72 && (fun a b -> String.equal (globalize a) (globalize b)) b71 b72) in
  let mk_value i = #{ a7 = Int.to_string (i + 0); b7 = Int.to_string (i + 1) } in
  (* Create an array of size [size] *)
  let a : t7 array = makearray_dynamic size #{ a7 = "0"; b7 = "1" } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 30;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 30 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 31;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 31 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a7] *)
    let el = #{ el with a7 = next_el.#a7 } in
    Idx_mut.unsafe_set a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 32;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 32 failed %d %d" size i;
    (* Path: [.#b7] *)
    let el = #{ el with b7 = next_el.#b7 } in
    Idx_mut.unsafe_set a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 33;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 33 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t9 = #{ #{ int } }   *)
  (**************************)
  let eq = (fun #{ a9 = a91 } #{ a9 = a92 } -> (fun #{ a8 = a81 } #{ a8 = a82 } -> (fun a b -> Int.equal a b) a81 a82) a91 a92) in
  let mk_value i = #{ a9 = #{ a8 = (i + 0) } } in
  (* Create an array of size [size] *)
  let a : t9 array = makearray_dynamic size #{ a9 = #{ a8 = 0 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 34;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 34 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 35;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 35 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a9] *)
    let el = #{ el with a9 = next_el.#a9 } in
    Idx_mut.unsafe_set a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 36;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 36 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a9.#a8] *)
    let el = #{ el with a9 = #{ el.#a9 with a8 = next_el.#a9.#a8 } } in
    Idx_mut.unsafe_set a ((.(i).#a9.#a8) : (t9 array, _) idx_mut) next_el.#a9.#a8;
    mark_test_run 37;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 37 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t10 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun #{ a0 = a01; b0 = b01 } #{ a0 = a02; b0 = b02 } -> (fun a b -> Int.equal a b) a01 a02 && (fun a b -> Int.equal a b) b01 b02) a101 a102 && (fun a b -> Int.equal a b) b101 b102) in
  let mk_value i = #{ a10 = #{ a0 = (i + 0); b0 = (i + 1) }; b10 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t10 array = makearray_dynamic size #{ a10 = #{ a0 = 0; b0 = 1 }; b10 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 38;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 38 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 39;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 39 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a10] *)
    let el = #{ el with a10 = next_el.#a10 } in
    Idx_mut.unsafe_set a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 40;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 40 failed %d %d" size i;
    (* Path: [.#b10] *)
    let el = #{ el with b10 = next_el.#b10 } in
    Idx_mut.unsafe_set a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 41;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 41 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a10.#a0] *)
    let el = #{ el with a10 = #{ el.#a10 with a0 = next_el.#a10.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#a10.#a0) : (t10 array, _) idx_mut) next_el.#a10.#a0;
    mark_test_run 42;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 42 failed %d %d" size i;
    (* Path: [.#a10.#b0] *)
    let el = #{ el with a10 = #{ el.#a10 with b0 = next_el.#a10.#b0 } } in
    Idx_mut.unsafe_set a ((.(i).#a10.#b0) : (t10 array, _) idx_mut) next_el.#a10.#b0;
    mark_test_run 43;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 43 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t12 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun #{ a12 = a121 } #{ a12 = a122 } -> (fun #{ a11 = a111; b11 = b111 } #{ a11 = a112; b11 = b112 } -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b111 b112) a121 a122) in
  let mk_value i = #{ a12 = #{ a11 = (i + 0); b11 = Int32_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t12 array = makearray_dynamic size #{ a12 = #{ a11 = 0; b11 = #1l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 44;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 44 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 45;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 45 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a12] *)
    let el = #{ el with a12 = next_el.#a12 } in
    Idx_mut.unsafe_set a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 46;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 46 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a12.#a11] *)
    let el = #{ el with a12 = #{ el.#a12 with a11 = next_el.#a12.#a11 } } in
    Idx_mut.unsafe_set a ((.(i).#a12.#a11) : (t12 array, _) idx_mut) next_el.#a12.#a11;
    mark_test_run 47;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 47 failed %d %d" size i;
    (* Path: [.#a12.#b11] *)
    let el = #{ el with a12 = #{ el.#a12 with b11 = next_el.#a12.#b11 } } in
    Idx_mut.unsafe_set a ((.(i).#a12.#b11) : (t12 array, _) idx_mut) next_el.#a12.#b11;
    mark_test_run 48;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 48 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t14 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun #{ a14 = a141 } #{ a14 = a142 } -> (fun #{ a13 = a131 } #{ a13 = a132 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a131 a132) a141 a142) in
  let mk_value i = #{ a14 = #{ a13 = Int32_u.of_int (i + 0) } } in
  (* Create an array of size [size] *)
  let a : t14 array = makearray_dynamic size #{ a14 = #{ a13 = #0l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 49;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 49 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 50;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 50 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a14] *)
    let el = #{ el with a14 = next_el.#a14 } in
    Idx_mut.unsafe_set a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 51;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 51 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a14.#a13] *)
    let el = #{ el with a14 = #{ el.#a14 with a13 = next_el.#a14.#a13 } } in
    Idx_mut.unsafe_set a ((.(i).#a14.#a13) : (t14 array, _) idx_mut) next_el.#a14.#a13;
    mark_test_run 52;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 52 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t16 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun #{ a16 = a161; b16 = b161 } #{ a16 = a162; b16 = b162 } -> (fun #{ a15 = a151; b15 = b151 } #{ a15 = a152; b15 = b152 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a151 a152 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b151 b152) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) in
  let mk_value i = #{ a16 = #{ a15 = Int32_u.of_int (i + 0); b15 = Int32_u.of_int (i + 1) }; b16 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t16 array = makearray_dynamic size #{ a16 = #{ a15 = #0l; b15 = #1l }; b16 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 53;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 53 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 54;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 54 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] at all paths of depth 1 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a16] *)
    let el = #{ el with a16 = next_el.#a16 } in
    Idx_mut.unsafe_set a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 55;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 55 failed %d %d" size i;
    (* Path: [.#b16] *)
    let el = #{ el with b16 = next_el.#b16 } in
    Idx_mut.unsafe_set a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 56;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 56 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] at all paths of depth 2 to be the corresponding item *)
    (* in [next_el].*)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a16.#a15] *)
    let el = #{ el with a16 = #{ el.#a16 with a15 = next_el.#a16.#a15 } } in
    Idx_mut.unsafe_set a ((.(i).#a16.#a15) : (t16 array, _) idx_mut) next_el.#a16.#a15;
    mark_test_run 57;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 57 failed %d %d" size i;
    (* Path: [.#a16.#b15] *)
    let el = #{ el with a16 = #{ el.#a16 with b15 = next_el.#a16.#b15 } } in
    Idx_mut.unsafe_set a ((.(i).#a16.#b15) : (t16 array, _) idx_mut) next_el.#a16.#b15;
    mark_test_run 58;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 58 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()
;;

let to_run () =
  iter sizes ~f:test;
  ()
;;
let () = to_run ();;

for i = 1 to 58 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
