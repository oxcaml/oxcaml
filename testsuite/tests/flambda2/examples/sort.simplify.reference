let code failwith_0 deleted in
let code invalid_arg_1 deleted in
let code `@_2` deleted in
let code length_aux_3 deleted in
let code length_4 deleted in
let code cons_5 deleted in
let $camlSort__immstring67 = "hd" in
let code hd_6 deleted in
let $camlSort__immstring79 = "tl" in
let code tl_7 deleted in
let $camlSort__immstring108 = "nth" in
let code nth_aux_9 deleted in
let $camlSort__immstring110 = "List.nth" in
let code nth_8 deleted in
let code nth_aux_11 deleted in
let code nth_opt_10 deleted in
let code rev_append_12 deleted in
let code rev_13 deleted in
let code init_tailrec_aux_14 deleted in
let code init_aux_15 deleted in
let $camlSort__immstring202 = "List.init" in
let code init_16 deleted in
let code flatten_17 deleted in
let code map_18 deleted in
let code mapi_19 deleted in
let code mapi_20 deleted in
let code rmap_f_22 deleted in
let code rev_map_21 deleted in
let code iter_23 deleted in
let code iteri_24 deleted in
let code iteri_25 deleted in
let code fold_left_26 deleted in
let code fold_right_27 deleted in
let $camlSort__immstring356 = "List.map2" in
let code map2_28 deleted in
let $camlSort__immstring390 = "List.rev_map2" in
let code rmap2_f_30 deleted in
let code rev_map2_29 deleted in
let $camlSort__immstring414 = "List.iter2" in
let code iter2_31 deleted in
let $camlSort__immstring439 = "List.fold_left2" in
let code fold_left2_32 deleted in
let $camlSort__immstring464 = "List.fold_right2" in
let code fold_right2_33 deleted in
let code for_all_34 deleted in
let code exists_35 deleted in
let $camlSort__immstring515 = "List.for_all2" in
let code for_all2_36 deleted in
let $camlSort__immstring540 = "List.exists2" in
let code exists2_37 deleted in
let code loopify(never) size(10) newer_version_of(failwith_0)
      failwith_0_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlSort__failwith_38 = closure failwith_0_1 @failwith in
let code loopify(never) size(10) newer_version_of(invalid_arg_1)
      invalid_arg_1_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlSort__invalid_arg_39 = closure invalid_arg_1_1 @invalid_arg in
let $`camlSort__@_40` =
  closure `@_2_1` @`@`
and code rec loopify(never) size(25) newer_version_of(`@_2`)
      `@_2_1`
        (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (l1) in
  switch prim
    | 0 -> k2
    | 1 -> k (l2)
    where k2 =
      ((let Pfield = %block_load.[`1`] (l1) in
        apply direct(`@_2_1`)
          ($`camlSort__@_40` ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (Pfield, l2)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           let Pfield = %block_load.[`0`] (l1) in
           let Pmakeblock = %block.[`0`] (Pfield, apply_result) in
           cont k (Pmakeblock))
in
let code rec loopify(done) size(16) newer_version_of(length_aux_3)
      length_aux_3_1
        (len : imm tagged, param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (len, param)
    where rec self
                (len_1 : imm tagged,
                 param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (len_1)
         where k2 =
           let Pfield = %block_load.[`1`] (param_1) in
           let int_add = %int_barith.add (len_1, 1) in
           cont self (int_add, Pfield))
in
let $camlSort__length_aux_41 = closure length_aux_3_1 @length_aux in
let code loopify(never) size(4) newer_version_of(length_4)
      length_4_1 (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  apply direct(length_aux_3_1)
    ($camlSort__length_aux_41 : _ -> imm tagged) (0, l) -> k * k1
in
let $camlSort__length_42 = closure length_4_1 @length in
let code loopify(never) size(8) newer_version_of(cons_5)
      cons_5_1 (a : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let Pmakeblock = %block.[`0`] (a, l) in
  cont k (Pmakeblock)
in
let $camlSort__cons_43 = closure cons_5_1 @cons in
let code loopify(never) size(17) newer_version_of(hd_6)
      hd_6_1 (param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      apply direct(failwith_0_1)
        ($camlSort__failwith_38 : _ -> val)
          ($camlSort__immstring67)
          -> never * k1
    where k2 =
      let Pfield = %block_load.[`0`] (param) in
      cont k (Pfield)
in
let $camlSort__hd_44 = closure hd_6_1 @hd in
let code loopify(never) size(17) newer_version_of(tl_7)
      tl_7_1 (param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      apply direct(failwith_0_1)
        ($camlSort__failwith_38
         : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
          ($camlSort__immstring79)
          -> never * k1
    where k2 =
      let Pfield = %block_load.[`1`] (param) in
      cont k (Pfield)
in
let $camlSort__tl_45 = closure tl_7_1 @tl in
let code rec loopify(done) size(34) newer_version_of(nth_aux_9)
      nth_aux_9_1
        (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ], n : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont self (l, n)
    where rec self
                (l_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 n_1 : imm tagged) =
      let prim = %is_int (l_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k3
         where k3 =
           apply direct(failwith_0_1)
             ($camlSort__failwith_38 : _ -> val)
               ($camlSort__immstring108)
               -> never * k1
         where k2 =
           let prim_1 = %phys_eq (n_1, 0) in
           (switch prim_1
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let Pfield = %block_load.[`0`] (l_1) in
                cont k (Pfield)
              where k2 =
                let int_sub = %int_barith.sub (n_1, 1) in
                let Pfield = %block_load.[`1`] (l_1) in
                cont self (Pfield, int_sub)))
in
let $camlSort__nth_aux_47 = closure nth_aux_9_1 @nth_aux in
let code loopify(never) size(20) newer_version_of(nth_8)
      nth_8_1 (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ], n : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let prim = %int_comp.lt (n, 0) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      apply direct(invalid_arg_1_1)
        ($camlSort__invalid_arg_39 : _ -> val)
          ($camlSort__immstring110)
          -> never * k1
    where k2 =
      apply direct(nth_aux_9_1)
        ($camlSort__nth_aux_47 : _ -> val) (l, n) -> k * k1
in
let $camlSort__nth_46 = closure nth_8_1 @nth in
let code rec loopify(done) size(36) newer_version_of(nth_aux_11)
      nth_aux_11_1
        (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ], n : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  cont self (l, n)
    where rec self
                (l_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 n_1 : imm tagged) =
      let prim = %is_int (l_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           let prim_1 = %phys_eq (n_1, 0) in
           (switch prim_1
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let Pfield = %block_load.[`0`] (l_1) in
                let Pmakeblock = %block.[`0`] (Pfield) in
                cont k (Pmakeblock)
              where k2 =
                let int_sub = %int_barith.sub (n_1, 1) in
                let Pfield = %block_load.[`1`] (l_1) in
                cont self (Pfield, int_sub)))
in
let $camlSort__nth_aux_49 = closure nth_aux_11_1 @nth_aux_1 in
let code loopify(never) size(20) newer_version_of(nth_opt_10)
      nth_opt_10_1
        (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ], n : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  let prim = %int_comp.lt (n, 0) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      apply direct(invalid_arg_1_1)
        ($camlSort__invalid_arg_39 : _ -> [ 0 | 0 of val ])
          ($camlSort__immstring110)
          -> never * k1
    where k2 =
      apply direct(nth_aux_11_1)
        ($camlSort__nth_aux_49 : _ -> [ 0 | 0 of val ]) (l, n) -> k * k1
in
let $camlSort__nth_opt_48 = closure nth_opt_10_1 @nth_opt in
let code rec loopify(done) size(22) newer_version_of(rev_append_12)
      rev_append_12_1
        (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  cont self (l1, l2)
    where rec self
                (l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let prim = %is_int (l1_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (l2_1)
         where k2 =
           let Pfield = %block_load.[`0`] (l1_1) in
           let Pmakeblock = %block.[`0`] (Pfield, l2_1) in
           let Pfield_1 = %block_load.[`1`] (l1_1) in
           cont self (Pfield_1, Pmakeblock))
in
let $camlSort__rev_append_50 = closure rev_append_12_1 @rev_append in
let code loopify(never) size(4) newer_version_of(rev_13)
      rev_13_1 (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  apply direct(rev_append_12_1)
    ($camlSort__rev_append_50
     : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
      (l, 0)
      -> k * k1
in
let $camlSort__rev_51 = closure rev_13_1 @rev in
let code rec loopify(done) size(29) newer_version_of(init_tailrec_aux_14)
      init_tailrec_aux_14_1
        (acc : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         i : imm tagged,
         n : imm tagged,
         f : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  cont self (acc, i)
    where rec self
                (acc_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 i_1 : imm tagged) =
      let n_1 = n in
      let f_1 = f in
      let prim = %int_comp.ge (i_1, n_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (acc_1)
         where k2 =
           let int_add = %int_barith.add (i_1, 1) in
           (apply f_1 (i_1) -> k2 * k1
              where k2 (apply_result : val) =
                let Pmakeblock = %block.[`0`] (apply_result, acc_1) in
                cont self (Pmakeblock, int_add)))
in
let $camlSort__init_tailrec_aux_52 =
  closure init_tailrec_aux_14_1 @init_tailrec_aux
in
let $camlSort__init_aux_53 =
  closure init_aux_15_1 @init_aux
and code rec loopify(never) size(32) newer_version_of(init_aux_15)
      init_aux_15_1 (i : imm tagged, n : imm tagged, f : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %int_comp.ge (i, n) in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      (apply f (i) -> k2 * k1
         where k2 (r : val) =
           ((let int_add = %int_barith.add (i, 1) in
             apply direct(init_aux_15_1)
               ($camlSort__init_aux_53 ~ depth my_depth -> succ my_depth
                : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                 (int_add, n, f)
                 -> k2 * k1)
              where k2
                      (apply_result :
                         [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                let Pmakeblock = %block.[`0`] (r, apply_result) in
                cont k (Pmakeblock)))
in
let code loopify(never) size(40) newer_version_of(init_16)
      init_16_1 (len : imm tagged, f : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %int_comp.lt (len, 0) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      apply direct(invalid_arg_1_1)
        ($camlSort__invalid_arg_39
         : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
          ($camlSort__immstring202)
          -> never * k1
    where k2 =
      let prim_1 = %int_comp.gt (len, 10000) in
      (switch prim_1
         | 0 -> k2
         | 1 -> k3
         where k3 =
           (apply direct(init_tailrec_aux_14_1)
              ($camlSort__init_tailrec_aux_52
               : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                (0, 0, len, f)
                -> k3 * k1
              where k3
                      (apply_result :
                         [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                apply direct(rev_append_12_1) inlining_state(depth(10))
                  ($camlSort__rev_append_50
                   : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                    (apply_result, 0)
                    -> k * k1)
         where k2 =
           apply direct(init_aux_15_1)
             ($camlSort__init_aux_53
              : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
               (0, len, f)
               -> k * k1)
in
let $camlSort__init_54 = closure init_16_1 @init in
let $camlSort__flatten_55 =
  closure flatten_17_1 @flatten
and code rec loopify(never) size(21) newer_version_of(flatten_17)
      flatten_17_1 (param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      ((let Pfield = %block_load.[`1`] (param) in
        apply direct(flatten_17_1)
          ($camlSort__flatten_55 ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (Pfield)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           let Pfield = %block_load.[`0`] (param) in
           apply direct(`@_2_1`)
             ($`camlSort__@_40`
              : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
               (Pfield, apply_result)
               -> k * k1)
in
let $camlSort__map_56 =
  closure map_18_1 @map
and code rec loopify(never) size(31) newer_version_of(map_18)
      map_18_1 (f : val, param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      ((let Pfield = %block_load.[`0`] (param) in
        apply f (Pfield) -> k2 * k1)
         where k2 (r : val) =
           ((let Pfield = %block_load.[`1`] (param) in
             apply direct(map_18_1)
               ($camlSort__map_56 ~ depth my_depth -> succ my_depth
                : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                 (f, Pfield)
                 -> k2 * k1)
              where k2
                      (apply_result :
                         [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                let Pmakeblock = %block.[`0`] (r, apply_result) in
                cont k (Pmakeblock)))
in
let $camlSort__mapi_57 =
  closure mapi_19_1 @mapi
and code rec loopify(never) size(33) newer_version_of(mapi_19)
      mapi_19_1
        (i : imm tagged,
         f : val,
         param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      ((let Pfield = %block_load.[`0`] (param) in
        apply f (i, Pfield) -> k2 * k1)
         where k2 (r : val) =
           ((let Pfield = %block_load.[`1`] (param) in
             let int_add = %int_barith.add (i, 1) in
             apply direct(mapi_19_1)
               ($camlSort__mapi_57 ~ depth my_depth -> succ my_depth
                : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                 (int_add, f, Pfield)
                 -> k2 * k1)
              where k2
                      (apply_result :
                         [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                let Pmakeblock = %block.[`0`] (r, apply_result) in
                cont k (Pmakeblock)))
in
let code loopify(never) size(4) newer_version_of(mapi_20)
      mapi_20_1 (f : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  apply direct(mapi_19_1)
    ($camlSort__mapi_57 : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
      (0, f, l)
      -> k * k1
in
let $camlSort__mapi_58 = closure mapi_20_1 @mapi_1 in
let code rec loopify(done) size(29) newer_version_of(rmap_f_22)
      rmap_f_22_1
        (accu : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  cont self (accu, param)
    where rec self
                (accu_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f = %project_value_slot.[`rmap_f`].[`f`] (my_closure) in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (accu_1)
         where k2 =
           let Pfield = %block_load.[`1`] (param_1) in
           ((let Pfield_1 = %block_load.[`0`] (param_1) in
             apply f (Pfield_1) -> k2 * k1)
              where k2 (apply_result : val) =
                let Pmakeblock = %block.[`0`] (apply_result, accu_1) in
                cont self (Pmakeblock, Pfield)))
in
let code loopify(never) size(42) newer_version_of(rev_map_21)
      rev_map_21_1 (f : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let rmap_f = closure rmap_f_22_1 @rmap_f with { f = f } in
  apply direct(rmap_f_22_1)
    (rmap_f : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
      (0, l)
      -> k * k1
in
let $camlSort__rev_map_59 = closure rev_map_21_1 @rev_map in
let code rec loopify(done) size(22) newer_version_of(iter_23)
      iter_23_1 (f : val, param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (param)
    where rec self (param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           ((let Pfield = %block_load.[`0`] (param_1) in
             apply f_1 (Pfield) -> k3 * k1
               where k3 (param_2) =
                 cont k2)
              where k2 =
                let Pfield = %block_load.[`1`] (param_1) in
                cont self (Pfield)))
in
let $camlSort__iter_60 = closure iter_23_1 @iter in
let code rec loopify(done) size(24) newer_version_of(iteri_24)
      iteri_24_1
        (i : imm tagged,
         f : val,
         param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (i, param)
    where rec self
                (i_1 : imm tagged,
                 param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           ((let Pfield = %block_load.[`0`] (param_1) in
             apply f_1 (i_1, Pfield) -> k3 * k1
               where k3 (param_2) =
                 cont k2)
              where k2 =
                let Pfield = %block_load.[`1`] (param_1) in
                let int_add = %int_barith.add (i_1, 1) in
                cont self (int_add, Pfield)))
in
let $camlSort__iteri_61 = closure iteri_24_1 @iteri in
let code loopify(never) size(4) newer_version_of(iteri_25)
      iteri_25_1 (f : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  apply direct(iteri_24_1)
    ($camlSort__iteri_61 : _ -> imm tagged) (0, f, l) -> k * k1
in
let $camlSort__iteri_62 = closure iteri_25_1 @iteri_1 in
let code rec loopify(done) size(21) newer_version_of(fold_left_26)
      fold_left_26_1
        (f : val, accu, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1 =
  cont self (accu, l)
    where rec self (accu_1, l_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      let prim = %is_int (l_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (accu_1)
         where k2 =
           let Pfield = %block_load.[`1`] (l_1) in
           ((let Pfield_1 = %block_load.[`0`] (l_1) in
             apply f_1 (accu_1, Pfield_1) -> k2 * k1)
              where k2 (apply_result) =
                cont self (apply_result, Pfield)))
in
let $camlSort__fold_left_63 = closure fold_left_26_1 @fold_left in
let $camlSort__fold_right_64 =
  closure fold_right_27_1 @fold_right
and code rec loopify(never) size(23) newer_version_of(fold_right_27)
      fold_right_27_1
        (f : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ], accu)
        my_closure _region _ghost_region my_depth
        -> k * k1 =
  let prim = %is_int (l) in
  switch prim
    | 0 -> k2
    | 1 -> k (accu)
    where k2 =
      ((let Pfield = %block_load.[`1`] (l) in
        apply direct(fold_right_27_1)
          $camlSort__fold_right_64 ~ depth my_depth -> succ my_depth
            (f, Pfield, accu)
            -> k2 * k1)
         where k2 (apply_result) =
           let Pfield = %block_load.[`0`] (l) in
           apply f (Pfield, apply_result) -> k * k1)
in
let $camlSort__map2_65 =
  closure map2_28_1 @map2
and code rec loopify(never) size(59) newer_version_of(map2_28)
      map2_28_1
        (f : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  (let prim = %is_int (l1) in
   switch prim
     | 0 -> k3
     | 1 -> k4
     where k4 =
       let prim_1 = %is_int (l2) in
       switch prim_1
         | 0 -> k2
         | 1 -> k (0)
     where k3 =
       let prim_1 = %is_int (l2) in
       (switch prim_1
          | 0 -> k3
          | 1 -> k2
          where k3 =
            ((let Pfield = %block_load.[`0`] (l2) in
              let Pfield_1 = %block_load.[`0`] (l1) in
              apply f (Pfield_1, Pfield) -> k3 * k1)
               where k3 (r : val) =
                 ((let Pfield = %block_load.[`1`] (l2) in
                   let Pfield_1 = %block_load.[`1`] (l1) in
                   apply direct(map2_28_1)
                     ($camlSort__map2_65 ~ depth my_depth -> succ my_depth
                      : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                       (f, Pfield_1, Pfield)
                       -> k3 * k1)
                    where k3
                            (apply_result :
                               [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                      let Pmakeblock = %block.[`0`] (r, apply_result) in
                      cont k (Pmakeblock)))))
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlSort__invalid_arg_39
         : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
          ($camlSort__immstring356)
          -> never * k1
in
let code rec loopify(done) size(57) newer_version_of(rmap2_f_30)
      rmap2_f_30_1
        (accu : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  cont self (accu, l1, l2)
    where rec self
                (accu_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f = %project_value_slot.[`rmap2_f`].[`f_1`] (my_closure) in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (accu_1)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 let Pfield = %block_load.[`1`] (l2_1) in
                 let Pfield_1 = %block_load.[`1`] (l1_1) in
                 ((let Pfield_2 = %block_load.[`0`] (l2_1) in
                   let Pfield_3 = %block_load.[`0`] (l1_1) in
                   apply f (Pfield_3, Pfield_2) -> k3 * k1)
                    where k3 (apply_result : val) =
                      let Pmakeblock = %block.[`0`] (apply_result, accu_1) in
                      cont self (Pmakeblock, Pfield_1, Pfield))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort__invalid_arg_39
              : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
               ($camlSort__immstring390)
               -> never * k1)
in
let code loopify(never) size(71) newer_version_of(rev_map2_29)
      rev_map2_29_1
        (f : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let rmap2_f = closure rmap2_f_30_1 @rmap2_f
  with { invalid_arg = $camlSort__invalid_arg_39; f_1 = f }
  in
  apply direct(rmap2_f_30_1)
    (rmap2_f : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
      (0, l1, l2)
      -> k * k1
in
let $camlSort__rev_map2_66 = closure rev_map2_29_1 @rev_map2 in
let code rec loopify(done) size(50) newer_version_of(iter2_31)
      iter2_31_1
        (f : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (l1, l2)
    where rec self
                (l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (0)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 ((let Pfield = %block_load.[`0`] (l2_1) in
                   let Pfield_1 = %block_load.[`0`] (l1_1) in
                   apply f_1 (Pfield_1, Pfield) -> k4 * k1
                     where k4 (param) =
                       cont k3)
                    where k3 =
                      let Pfield = %block_load.[`1`] (l2_1) in
                      let Pfield_1 = %block_load.[`1`] (l1_1) in
                      cont self (Pfield_1, Pfield))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort__invalid_arg_39 : _ -> imm tagged)
               ($camlSort__immstring414)
               -> never * k1)
in
let $camlSort__iter2_67 = closure iter2_31_1 @iter2 in
let code rec loopify(done) size(49) newer_version_of(fold_left2_32)
      fold_left2_32_1
        (f : val,
         accu : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont self (accu, l1, l2)
    where rec self
                (accu_1 : val,
                 l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (accu_1)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 let Pfield = %block_load.[`1`] (l2_1) in
                 let Pfield_1 = %block_load.[`1`] (l1_1) in
                 ((let Pfield_2 = %block_load.[`0`] (l2_1) in
                   let Pfield_3 = %block_load.[`0`] (l1_1) in
                   apply f_1 (accu_1, Pfield_3, Pfield_2) -> k3 * k1)
                    where k3 (apply_result : val) =
                      cont self (apply_result, Pfield_1, Pfield))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort__invalid_arg_39 : _ -> val)
               ($camlSort__immstring439)
               -> never * k1)
in
let $camlSort__fold_left2_68 = closure fold_left2_32_1 @fold_left2 in
let $camlSort__fold_right2_69 =
  closure fold_right2_33_1 @fold_right2
and code rec loopify(never) size(51) newer_version_of(fold_right2_33)
      fold_right2_33_1
        (f : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         accu : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  (let prim = %is_int (l1) in
   switch prim
     | 0 -> k3
     | 1 -> k4
     where k4 =
       let prim_1 = %is_int (l2) in
       switch prim_1
         | 0 -> k2
         | 1 -> k (accu)
     where k3 =
       let prim_1 = %is_int (l2) in
       (switch prim_1
          | 0 -> k3
          | 1 -> k2
          where k3 =
            ((let Pfield = %block_load.[`1`] (l2) in
              let Pfield_1 = %block_load.[`1`] (l1) in
              apply direct(fold_right2_33_1)
                ($camlSort__fold_right2_69 ~ depth my_depth -> succ my_depth
                 : _ -> val)
                  (f, Pfield_1, Pfield, accu)
                  -> k3 * k1)
               where k3 (apply_result : val) =
                 let Pfield = %block_load.[`0`] (l2) in
                 let Pfield_1 = %block_load.[`0`] (l1) in
                 apply f (Pfield_1, Pfield, apply_result) -> k * k1)))
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlSort__invalid_arg_39 : _ -> val)
          ($camlSort__immstring464)
          -> never * k1
in
let code rec loopify(done) size(33) newer_version_of(for_all_34)
      for_all_34_1
        (p : val, param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (param)
    where rec self (param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let p_1 = p in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (1)
         where k2 =
           ((let Pfield = %block_load.[`0`] (param_1) in
             apply p_1 (Pfield) -> k3 * k1
               where k3 (param_2 : imm tagged) =
                 let unboxed_field = %untag_imm (param_2) in
                 cont k2 (unboxed_field))
              where k2 (unboxed_field : imm) =
                let naked_immediate = unboxed_field in
                (switch naked_immediate
                   | 0 -> k (0)
                   | 1 -> k2
                   where k2 =
                     let Pfield = %block_load.[`1`] (param_1) in
                     cont self (Pfield))))
in
let $camlSort__for_all_70 = closure for_all_34_1 @for_all in
let code rec loopify(done) size(33) newer_version_of(exists_35)
      exists_35_1
        (p : val, param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (param)
    where rec self (param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let p_1 = p in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           ((let Pfield = %block_load.[`0`] (param_1) in
             apply p_1 (Pfield) -> k3 * k1
               where k3 (param_2 : imm tagged) =
                 let unboxed_field = %untag_imm (param_2) in
                 cont k2 (unboxed_field))
              where k2 (unboxed_field : imm) =
                let naked_immediate = unboxed_field in
                (switch naked_immediate
                   | 0 -> k2
                   | 1 -> k (1)
                   where k2 =
                     let Pfield = %block_load.[`1`] (param_1) in
                     cont self (Pfield))))
in
let $camlSort__exists_71 = closure exists_35_1 @exists in
let code rec loopify(done) size(61) newer_version_of(for_all2_36)
      for_all2_36_1
        (p : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (l1, l2)
    where rec self
                (l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let p_1 = p in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (1)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 ((let Pfield = %block_load.[`0`] (l2_1) in
                   let Pfield_1 = %block_load.[`0`] (l1_1) in
                   apply p_1 (Pfield_1, Pfield) -> k4 * k1
                     where k4 (param : imm tagged) =
                       let unboxed_field = %untag_imm (param) in
                       cont k3 (unboxed_field))
                    where k3 (unboxed_field : imm) =
                      let naked_immediate = unboxed_field in
                      (switch naked_immediate
                         | 0 -> k (0)
                         | 1 -> k3
                         where k3 =
                           let Pfield = %block_load.[`1`] (l2_1) in
                           let Pfield_1 = %block_load.[`1`] (l1_1) in
                           cont self (Pfield_1, Pfield)))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort__invalid_arg_39 : _ -> imm tagged)
               ($camlSort__immstring515)
               -> never * k1)
in
let $camlSort__for_all2_72 = closure for_all2_36_1 @for_all2 in
let code rec loopify(done) size(61) newer_version_of(exists2_37)
      exists2_37_1
        (p : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (l1, l2)
    where rec self
                (l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let p_1 = p in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (0)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 ((let Pfield = %block_load.[`0`] (l2_1) in
                   let Pfield_1 = %block_load.[`0`] (l1_1) in
                   apply p_1 (Pfield_1, Pfield) -> k4 * k1
                     where k4 (param : imm tagged) =
                       let unboxed_field = %untag_imm (param) in
                       cont k3 (unboxed_field))
                    where k3 (unboxed_field : imm) =
                      let naked_immediate = unboxed_field in
                      (switch naked_immediate
                         | 0 -> k3
                         | 1 -> k (1)
                         where k3 =
                           let Pfield = %block_load.[`1`] (l2_1) in
                           let Pfield_1 = %block_load.[`1`] (l1_1) in
                           cont self (Pfield_1, Pfield)))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort__invalid_arg_39 : _ -> imm tagged)
               ($camlSort__immstring540)
               -> never * k1)
in
let $camlSort__exists2_73 = closure exists2_37_1 @exists2 in
let $camlSort =
  Block 0 ($camlSort__failwith_38,
           $camlSort__invalid_arg_39,
           $`camlSort__@_40`,
           $camlSort__length_aux_41,
           $camlSort__length_42,
           $camlSort__cons_43,
           $camlSort__hd_44,
           $camlSort__tl_45,
           $camlSort__nth_46,
           $camlSort__nth_opt_48,
           $`camlSort__@_40`,
           $camlSort__rev_append_50,
           $camlSort__rev_51,
           $camlSort__init_tailrec_aux_52,
           $camlSort__init_aux_53,
           10000,
           $camlSort__init_54,
           $camlSort__flatten_55,
           $camlSort__flatten_55,
           $camlSort__map_56,
           $camlSort__mapi_58,
           $camlSort__rev_map_59,
           $camlSort__iter_60,
           $camlSort__iteri_62,
           $camlSort__fold_left_63,
           $camlSort__fold_right_64,
           $camlSort__map2_65,
           $camlSort__rev_map2_66,
           $camlSort__iter2_67,
           $camlSort__fold_left2_68,
           $camlSort__fold_right2_69,
           $camlSort__for_all_70,
           $camlSort__exists_71,
           $camlSort__for_all2_72,
           $camlSort__exists2_73)
in
cont done ($camlSort)
