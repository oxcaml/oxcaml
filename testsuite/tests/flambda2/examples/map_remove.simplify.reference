let code bal_0 deleted in
let code min_binding_1 deleted in
let $camlMap_remove__immstring46 = "Map.remove_min_elt" in
let code remove_min_binding_2 deleted in
let code merge_3 deleted in
let code remove_4 deleted in
let code inline(never) loopify(never) size(9) newer_version_of(bal_0)
      bal_0_1
        (l :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ],
         v : imm tagged,
         r :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0
          | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
              [ 0 | 0 of val * imm tagged * val ] ] =
  let Pmakeblock = %block.[`0`] (l, v, r) in
  cont k (Pmakeblock)
in
let $camlMap_remove__bal_5 = closure bal_0_1 @bal in
let code rec loopify(done) size(26) newer_version_of(min_binding_1)
      min_binding_1_1
        (param :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (param)
    where rec self
                (param_1 :
                   [ 0
                   | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
                       [ 0 | 0 of val * imm tagged * val ] ]) =
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k1 pop(reraise k1) ($`*predef*`.caml_exn_Not_found)
         where k2 =
           let l = %block_load.[`0`] (param_1) in
           let prim_1 = %is_int (l) in
           (switch prim_1
              | 0 -> self (l)
              | 1 -> k2
              where k2 =
                let Pfield = %block_load.[`1`] (param_1) in
                cont k (Pfield)))
in
let $camlMap_remove__min_binding_6 = closure min_binding_1_1 @min_binding in
let $camlMap_remove__Pmakeblock161 =
  Block 0 ($`*predef*`.caml_exn_Invalid_argument,
           $camlMap_remove__immstring46)
in
let $camlMap_remove__remove_min_binding_7 =
  closure remove_min_binding_2_1 @remove_min_binding
and code rec loopify(never) size(35) newer_version_of(remove_min_binding_2)
      remove_min_binding_2_1
        (param :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0
          | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
              [ 0 | 0 of val * imm tagged * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k1 pop(reraise k1) ($camlMap_remove__Pmakeblock161)
    where k2 =
      let l = %block_load.[`0`] (param) in
      let prim_1 = %is_int (l) in
      (switch prim_1
         | 0 -> k2
         | 1 -> k3
         where k3 =
           let Pfield = %block_load.[`2`] (param) in
           cont k (Pfield)
         where k2 =
           let Pfield = %block_load.[`2`] (param) in
           let Pfield_1 = %block_load.[`1`] (param) in
           (apply direct(remove_min_binding_2_1)
              ($camlMap_remove__remove_min_binding_7 ~ depth my_depth -> succ my_depth
               : _ ->
                 [ 0
                 | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
                     [ 0 | 0 of val * imm tagged * val ] ]
               )
                (l)
                -> k2 * k1
              where k2
                      (apply_result :
                         [ 0
                         | 0 of [ 0 | 0 of val * imm tagged * val ] *
                             imm tagged * [ 0 | 0 of val * imm tagged * val ]
                         ]) =
                apply direct(bal_0_1)
                  ($camlMap_remove__bal_5
                   : _ ->
                     [ 0
                     | 0 of [ 0 | 0 of val * imm tagged * val ] *
                         imm tagged * [ 0 | 0 of val * imm tagged * val ] ]
                   )
                    (apply_result, Pfield_1, Pfield)
                    -> k * k1))
in
let code loopify(never) size(34) newer_version_of(merge_3)
      merge_3_1
        (t1 :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ],
         t2 :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0
          | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
              [ 0 | 0 of val * imm tagged * val ] ] =
  let prim = %is_int (t1) in
  switch prim
    | 0 -> k2
    | 1 -> k (t2)
    where k2 =
      let prim_1 = %is_int (t2) in
      (switch prim_1
         | 0 -> k2
         | 1 -> k (t1)
         where k2 =
           (apply direct(min_binding_1_1)
              ($camlMap_remove__min_binding_6 : _ -> imm tagged)
                (t2)
                -> k2 * k1
              where k2 (x : imm tagged) =
                (apply direct(remove_min_binding_2_1)
                   ($camlMap_remove__remove_min_binding_7
                    : _ ->
                      [ 0
                      | 0 of [ 0 | 0 of val * imm tagged * val ] *
                          imm tagged * [ 0 | 0 of val * imm tagged * val ] ]
                    )
                     (t2)
                     -> k2 * k1
                   where k2
                           (apply_result :
                              [ 0
                              | 0 of [ 0 | 0 of val * imm tagged * val ] *
                                  imm tagged *
                                  [ 0 | 0 of val * imm tagged * val ] ]) =
                     apply direct(bal_0_1)
                       ($camlMap_remove__bal_5
                        : _ ->
                          [ 0
                          | 0 of [ 0 | 0 of val * imm tagged * val ] *
                              imm tagged *
                              [ 0 | 0 of val * imm tagged * val ] ]
                        )
                         (t1, x, apply_result)
                         -> k * k1)))
in
let $camlMap_remove__merge_8 = closure merge_3_1 @merge in
let code loopify(never) size(36) newer_version_of(remove_4)
      remove_4_1
        (x : imm tagged,
         param :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
               [ 0 | 0 of val * imm tagged * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0
          | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
              [ 0 | 0 of val * imm tagged * val ] ] =
  let prim = %is_int (param) in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      let l = %block_load.[`0`] (param) in
      let Pfield = %block_load.[`1`] (param) in
      let prim_1 = %int_comp.qmark (x, Pfield) in
      let int_compare = %tag_imm (prim_1) in
      let prim_2 = %phys_eq (int_compare, 0) in
      (switch prim_2
         | 0 -> k (l)
         | 1 -> k2
         where k2 =
           let Pfield_1 = %block_load.[`2`] (param) in
           apply direct(merge_3_1)
             ($camlMap_remove__merge_8
              : _ ->
                [ 0
                | 0 of [ 0 | 0 of val * imm tagged * val ] * imm tagged *
                    [ 0 | 0 of val * imm tagged * val ] ]
              )
               (l, Pfield_1)
               -> k * k1)
in
let $camlMap_remove__remove_9 = closure remove_4_1 @remove in
let $camlMap_remove =
  Block 0 ($camlMap_remove__bal_5,
           $camlMap_remove__min_binding_6,
           $camlMap_remove__remove_min_binding_7,
           $camlMap_remove__merge_8,
           $camlMap_remove__remove_9)
in
cont done ($camlMap_remove)
