let $camlTests14__first_const = Block 0 () in
(let code size(5)
       set_0 (t : val)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let Psetfield = %block_set.`imm`.[`0`] (t, 42) in
   cont k1 (Psetfield)
 in
 let code size(7)
       nth_char_1 (s : val, n : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let prim = %num_conv.[`tagged_imm`].[`imm`] (n) in
   let prim_1 = %string_load.[`8`] (s, prim) in
   let Pstringrefu = %tag_imm (prim_1) in
   cont k1 (Pstringrefu)
 in
 let code size(32)
       needs_try_region_2 (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   (let try_region = %begin_try_region () in
    let try_ghost_region = %begin_try_ghost_region () in
    cont k5 push(k4)
      where k5 =
        let Popaque = %opaque (42) in
        (cont k5 pop(k4)
           where k5 =
             cont k3 (Popaque))
      where k4 exn (`exn` : val) =
        let `unit` = %end_try_region (try_region) in
        let unit_1 = %end_try_ghost_region (try_ghost_region) in
        ((let Pfield = %block_load.[`7`] ($Stdlib.camlStdlib) in
          let prim = %phys_eq (`exn`, Pfield) in
          let eq = %tag_imm (prim) in
          (let untagged = %untag_imm (eq) in
           switch untagged
             | 0 -> k5
             | 1 -> k1 (0))
            where k5 =
              cont k4)
           where k4 =
             cont k2 pop(reraise k2) (`exn`)))
     where k3 (n : imm tagged) =
       cont k1 (1)
 in
 let code size(30)
       gadt_match_3 (x : [ 0 |1 | 0 of imm tagged ], n : val)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : val =
   let next_depth = rec_info (succ my_depth) in
   (let prim = %is_int (x) in
    let is_scrutinee_int = %tag_imm (prim) in
    let untagged = %untag_imm (is_scrutinee_int) in
    switch untagged
      | 0 -> k4
      | 1 -> k5)
     where k5 =
       let untagged = %untag_imm (x) in
       switch untagged
         | 0 -> k1 (n)
         | 1 -> k3
     where k4 =
       let prim = %get_tag (x) in
       let scrutinee_tag = %tag_imm (prim) in
       invalid "Zero_switch_arms"
     where k3 =
       let Popaque = %opaque (n) in
       cont k1 (Popaque)
 in
 let set = closure set_0 @set in
 let nth_char = closure nth_char_1 @nth_char in
 let needs_try_region = closure needs_try_region_2 @needs_try_region in
 let gadt_match = closure gadt_match_3 @gadt_match in
 let Pmakeblock = %block.[`0`] (set, nth_char, needs_try_region, gadt_match)
 in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load.tag[`0`].`size`[`4`].[`0`] (module_block) in
    let field_1 = %block_load.tag[`0`].`size`[`4`].[`1`] (module_block) in
    let field_2 = %block_load.tag[`0`].`size`[`4`].[`2`] (module_block) in
    let field_3 = %block_load.tag[`0`].`size`[`4`].[`3`] (module_block) in
    let $camlTests14 = Block 0 (field_0, field_1, field_2, field_3) in
    cont done ($camlTests14)
