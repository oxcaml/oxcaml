let code min_0 deleted in
let code extend_1 deleted in
let code inline(never) loopify(never) size(21) newer_version_of(min_0)
      min_0_1 (x : val, y : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply ccall
    ($`*extern*`.caml_lessequal : val * val -> val) (x, y) -> k2 * k1
    where k2 (Pccall) =
      let untagged = %untag_imm (Pccall) in
      switch untagged
        | 0 -> k (y)
        | 1 -> k (x)
in
let $camlBytes2__min_2 = closure min_0_1 @min in
let code loopify(never) size(47) newer_version_of(extend_1)
      extend_1_1
        (len : imm tagged, s : val, left : imm tagged, right, r : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  (let prim = %int_comp.lt (left, 0) in
   switch prim
     | 0 -> k2 (0, left)
     | 1 -> k3
     where k3 =
       let srcoff = %int_barith.sub (0, left) in
       cont k2 (srcoff, 0))
    where k2 (srcoff : imm tagged, dstoff : imm tagged) =
      ((let int_sub = %int_barith.sub (len, dstoff) in
        let prim = %bytes_length (s) in
        let Pbyteslength = %tag_imm (prim) in
        let int_sub_1 = %int_barith.sub (Pbyteslength, srcoff) in
        apply direct(min_0_1)
          ($camlBytes2__min_2 : _ -> imm tagged)
            (int_sub_1, int_sub)
            -> k2 * k1)
         where k2 (cpylen : imm tagged) =
           let prim = %int_comp.gt (cpylen, 0) in
           (switch prim
              | 0 -> k (r)
              | 1 -> k2
              where k2 =
                (apply ccall noalloc
                   ($`*extern*`.caml_blit_bytes
                    : val * val * val * val * val -> val)
                     (s, srcoff, r, dstoff, cpylen)
                     -> k2 * k1
                   where k2 (param) =
                     cont k (r))))
in
let $camlBytes2__extend_3 = closure extend_1_1 @extend in
let $camlBytes2 = Block 0 ($camlBytes2__min_2, $camlBytes2__extend_3) in
cont done ($camlBytes2)
