let code `fn[unbox_closure.ml:12,12--25]_2` deleted in
let code bar_1 deleted in
let code foobar_0 deleted in
let code loopify(never) size(7) newer_version_of(`fn[unbox_closure.ml:12,12--25]_2`)
      `fn[unbox_closure.ml:12,12--25]_2_1` (z : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let x =
    %project_value_slot.[`fn[unbox_closure.ml:12,12--25]`].[`x`] (my_closure)
  in
  let y =
    %project_value_slot.[`fn[unbox_closure.ml:12,12--25]`].[`y`] (my_closure)
  in
  let int_add = %int_barith.add (x, y) in
  let int_add_1 = %int_barith.add (int_add, z) in
  cont k (int_add_1)
in
let code loopify(never) size(18) newer_version_of(bar_1)
      bar_1_1 (y : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let x = %project_value_slot.[`bar`].[`x_1`] (my_closure) in
  let Popaque = %opaque (0) in
  let `fn[unbox_closure.ml:12,12--25]` =
    closure `fn[unbox_closure.ml:12,12--25]_2_1`
      @`fn[unbox_closure.ml:12,12--25]`
  with { x = x; y = y }
  in
  cont k (`fn[unbox_closure.ml:12,12--25]`)
in
let code loopify(never) size(53) newer_version_of(foobar_0)
      foobar_0_1 (b : imm tagged, x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let `region` = %begin_region () in
  let bar = closure bar_1_1 @bar with { x_1 = x } in
  (let untagged = %untag_imm (b) in
   switch untagged
     | 0 -> k3
     | 1 -> k4)
    where k4 =
      apply direct(bar_1_1) (bar : _ -> val) (3) -> k2 * k1
    where k3 =
      apply direct(bar_1_1) (bar : _ -> val) (42) -> k2 * k1
    where k2 (f : val) =
      let `unit` = %end_region (`region`) in
      apply f (x) -> k * k1
in
let $camlUnbox_closure__foobar_3 = closure foobar_0_1 @foobar in
let $camlUnbox_closure = Block 0 ($camlUnbox_closure__foobar_3) in
cont done ($camlUnbox_closure)
