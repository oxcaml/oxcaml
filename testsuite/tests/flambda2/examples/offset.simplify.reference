let code f_2 deleted in
let code g_3 deleted in
let code h_4 deleted in
let code inline_0 deleted in
let code loopify(never) size(16) newer_version_of(f_2)
      f_2_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let r = %project_value_slot.[`f`].[`r`] (my_closure) in
  let a = %project_value_slot.[`f`].[`a`] (my_closure) in
  (let untagged = %untag_imm (a) in
   switch untagged
     | 0 -> k (0)
     | 1 -> k2)
    where k2 =
      let int_add = %int_barith.add (r, x) in
      cont k (int_add)
in
let code loopify(never) size(20) newer_version_of(g_3)
      g_3_1 (x : imm tagged, y : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let s = %project_value_slot.[`g`].[`s`] (my_closure) in
  let b = %project_value_slot.[`g`].[`b`] (my_closure) in
  (let untagged = %untag_imm (b) in
   switch untagged
     | 0 -> k (0)
     | 1 -> k2)
    where k2 =
      let int_mul = %int_barith.mul (x, y) in
      let int_add = %int_barith.add (s, int_mul) in
      cont k (int_add)
in
let code loopify(never) size(39) newer_version_of(h_4)
      h_4_1 (x : imm tagged, y : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let b = %project_value_slot.[`h`].[`b`] (my_closure) in
  let a = %project_value_slot.[`h`].[`a`] (my_closure) in
  let g = %project_function_slot.[`h`].[`g`] (my_closure) in
  let f = %project_function_slot.[`h`].[`f`] (my_closure) in
  (let untagged = %untag_imm (b) in
   switch untagged
     | 0 -> k2 (0)
     | 1 -> k3)
    where k3 =
      apply direct(g_3_1)
        (g ~ depth my_depth -> succ my_depth : _ -> imm tagged)
          (x, y)
          -> k2 * k1
    where k2 (staticcatch_result : imm tagged) =
      ((let untagged = %untag_imm (a) in
        switch untagged
          | 0 -> k2 (0)
          | 1 -> k3)
         where k3 =
           let int_add = %int_barith.add (x, y) in
           apply direct(f_2_1)
             (f ~ depth my_depth -> succ my_depth : _ -> imm tagged)
               (int_add)
               -> k2 * k1
         where k2 (staticcatch_result_1 : imm tagged) =
           let int_add =
             %int_barith.add (staticcatch_result_1, staticcatch_result)
           in
           cont k (int_add))
in
let code inline(always) loopify(never) size(101) newer_version_of(inline_0)
      inline_0_1 (a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(partial_apply1_44) inlined(never) inlining_state(depth(10))
    ($Stdlib__Random.camlStdlib__Random__partial_apply1_104 : _ -> imm tagged
     )
      (10)
      -> k2 * k1
    where k2 (r : imm tagged) =
      (apply direct(partial_apply1_44) inlined(never)
              inlining_state(depth(10))
         ($Stdlib__Random.camlStdlib__Random__partial_apply1_104
          : _ -> imm tagged)
           (10)
           -> k2 * k1
         where k2 (s : imm tagged) =
           let f = closure f_2_1 @f
           and g = closure g_3_1 @g
           and h = closure h_4_1 @h
           with { a = a; b = b; r = r; s = s }
           in
           cont k (h))
in
let $camlOffset__inline_5 = closure inline_0_1 @`inline` in
apply direct(partial_apply1_44) inlined(never) inlining_state(depth(11))
  ($Stdlib__Random.camlStdlib__Random__partial_apply1_104 : _ -> imm tagged)
    (10)
    -> k * error
  where k (r : imm tagged) =
    (apply direct(partial_apply1_44) inlined(never) inlining_state(depth(11))
       ($Stdlib__Random.camlStdlib__Random__partial_apply1_104
        : _ -> imm tagged)
         (10)
         -> k * error
       where k (s : imm tagged) =
         let code loopify(never) size(0) newer_version_of(g_3_1)
               g_3_2 (x : imm tagged, y : imm tagged)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : imm tagged =
           cont k (0)
         in
         let $camlOffset__f_7 =
           closure f_2_2 @f
         and $camlOffset__g_8 =
           closure g_3_2 @g
         and $camlOffset__h_9 =
           closure h_4_2 @h
         and code loopify(never) size(6) newer_version_of(h_4_1)
               h_4_2 (x : imm tagged, y : imm tagged)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : imm tagged =
           let int_add = %int_barith.add (x, y) in
           apply direct(f_2_2) inlining_state(depth(1))
             ($camlOffset__f_7 ~ depth my_depth -> succ my_depth
              : _ -> imm tagged)
               (int_add)
               -> k * k1
         and code loopify(never) size(4) newer_version_of(f_2_1)
               f_2_2 (x : imm tagged)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : imm tagged =
           let r_1 = %project_value_slot.[`f`].[`r`] ($camlOffset__f_7) in
           let int_add = %int_barith.add (r_1, x) in
           cont k (int_add)
           with { a = 1; b = 0; r = r; s = s }
         in
         (apply direct(partial_apply1_44) inlined(never)
                 inlining_state(depth(11))
            ($Stdlib__Random.camlStdlib__Random__partial_apply1_104
             : _ -> imm tagged)
              (10)
              -> k * error
            where k (r_1 : imm tagged) =
              (apply direct(partial_apply1_44) inlined(never)
                      inlining_state(depth(11))
                 ($Stdlib__Random.camlStdlib__Random__partial_apply1_104
                  : _ -> imm tagged)
                   (10)
                   -> k * error
                 where k (s_1 : imm tagged) =
                   let code loopify(never) size(0) newer_version_of(f_2_1)
                         f_2_3 (x : imm tagged)
                           my_closure _region _ghost_region my_depth
                           -> k * k1
                           : imm tagged =
                     cont k (0)
                   in
                   let code loopify(never) size(0) newer_version_of(g_3_1)
                         g_3_3 (x : imm tagged, y : imm tagged)
                           my_closure _region _ghost_region my_depth
                           -> k * k1
                           : imm tagged =
                     cont k (0)
                   in
                   let code loopify(never) size(0) newer_version_of(h_4_1)
                         h_4_3 (x : imm tagged, y : imm tagged)
                           my_closure _region _ghost_region my_depth
                           -> k * k1
                           : imm tagged =
                     cont k (0)
                   in
                   let $camlOffset__f_10 =
                     closure f_2_3 @f
                   and $camlOffset__g_11 =
                     closure g_3_3 @g
                   and $camlOffset__h_12 =
                     closure h_4_3 @h
                     with { a = 0; b = 0; r = r_1; s = s_1 }
                   in
                   let $camlOffset =
                     Block 0 ($camlOffset__inline_5,
                              $camlOffset__h_9,
                              $camlOffset__h_12)
                   in
                   cont done ($camlOffset))))
