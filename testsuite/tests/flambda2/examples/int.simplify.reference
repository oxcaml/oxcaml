let code failwith_0 deleted in
let code invalid_arg_1 deleted in
let code `@_2` deleted in
let code abs_3 deleted in
let code lognot_4 deleted in
let code loopify(never) size(5)
      equal_5 (prim : imm tagged, prim_1 : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim_2 = %phys_eq (prim, prim_1) in
  let eq = %tag_imm (prim_2) in
  cont k (eq)
in
let code loopify(never) size(7)
      compare_6 (prim : imm tagged, prim_1 : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim_2 = %int_comp.qmark (prim, prim_1) in
  let int_compare = %tag_imm (prim_2) in
  cont k (int_compare)
in
let $camlInt__immstring75 = "%d" in
let code to_string_7 deleted in
let code loopify(never) size(10) newer_version_of(failwith_0)
      failwith_0_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlInt__failwith_8 = closure failwith_0_1 @failwith in
let code loopify(never) size(10) newer_version_of(invalid_arg_1)
      invalid_arg_1_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlInt__invalid_arg_9 = closure invalid_arg_1_1 @invalid_arg in
let $`camlInt__@_10` =
  closure `@_2_1` @`@`
and code rec loopify(never) size(25) newer_version_of(`@_2`)
      `@_2_1`
        (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (l1) in
  switch prim
    | 0 -> k2
    | 1 -> k (l2)
    where k2 =
      ((let Pfield = %block_load.[`1`] (l1) in
        apply direct(`@_2_1`)
          ($`camlInt__@_10` ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (Pfield, l2)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           let Pfield = %block_load.[`0`] (l1) in
           let Pmakeblock = %block.[`0`] (Pfield, apply_result) in
           cont k (Pmakeblock))
in
let code loopify(never) size(15) newer_version_of(abs_3)
      abs_3_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %int_comp.ge (x, 0) in
  switch prim
    | 0 -> k2
    | 1 -> k (x)
    where k2 =
      let int_neg = %int_barith.sub (0, x) in
      cont k (int_neg)
in
let $camlInt__abs_11 = closure abs_3_1 @abs in
let code loopify(never) size(3) newer_version_of(lognot_4)
      lognot_4_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let int_xor = %int_barith.xor (x, -1) in
  cont k (int_xor)
in
let $camlInt__lognot_12 = closure lognot_4_1 @lognot in
let $camlInt__equal_13 = closure equal_5 @equal in
let $camlInt__compare_14 = closure compare_6 @compare in
let code loopify(never) size(10) newer_version_of(to_string_7)
      to_string_7_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply ccall
    ($`*extern*`.caml_format_int : val * val -> val)
      ($camlInt__immstring75, x)
      -> k * k1
in
let $camlInt__to_string_15 = closure to_string_7_1 @to_string in
let $camlInt =
  Block 0 ($camlInt__failwith_8,
           $camlInt__invalid_arg_9,
           $`camlInt__@_10`,
           0,
           1,
           -1,
           $camlInt__abs_11,
           4611686018427387903,
           -4611686018427387904,
           $camlInt__lognot_12,
           $camlInt__equal_13,
           $camlInt__compare_14,
           $camlInt__to_string_15)
in
cont done ($camlInt)
