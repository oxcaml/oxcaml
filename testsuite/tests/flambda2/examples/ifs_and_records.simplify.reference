let code help_desired_0 deleted in
let code help_wrap_1 deleted in
let code help_variant_2 deleted in
let code help_wrap_variant_3 deleted in
let code help_tuple_4 deleted in
let code help_interior_if_5 deleted in
let code help_no_if_6 deleted in
let code help_no_if_tuple_7 deleted in
let code main_desired_8 deleted in
let code main_wrap_9 deleted in
let code main_variant_10 deleted in
let code main_wrap_variant_11 deleted in
let code main_tuple_12 deleted in
let code main_interior_if_13 deleted in
let code main_no_if_14 deleted in
let code main_no_if_tuple_15 deleted in
let code main_hand_inline_16 deleted in
let code main_hand_inline_tuple_17 deleted in
let $camlIfs_and_records__empty_block4 = Block 0 () in
let code inline(always) loopify(never) size(27) newer_version_of(help_desired_0)
      help_desired_0_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2
     | 1 -> k3)
    where k3 =
      let Pmakeblock = %block.[`0`] (b, a) in
      cont k (Pmakeblock)
    where k2 =
      let Pmakeblock = %block.[`0`] (a, b) in
      cont k (Pmakeblock)
in
let $camlIfs_and_records__help_desired_18 =
  closure help_desired_0_1 @help_desired
in
let code inline(always) loopify(never) size(19) newer_version_of(help_wrap_1)
      help_wrap_1_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (a, b)
     | 1 -> k2 (b, a))
    where k2 (a_1 : imm tagged, b_1 : imm tagged) =
      let Pmakeblock = %block.[`0`] (a_1, b_1) in
      cont k (Pmakeblock)
in
let $camlIfs_and_records__help_wrap_19 = closure help_wrap_1_1 @help_wrap in
let code inline(always) loopify(never) size(27) newer_version_of(help_variant_2)
      help_variant_2_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2
     | 1 -> k3)
    where k3 =
      let Pmakeblock = %block.[`0`] (b, a) in
      cont k (Pmakeblock)
    where k2 =
      let Pmakeblock = %block.[`0`] (a, b) in
      cont k (Pmakeblock)
in
let $camlIfs_and_records__help_variant_20 =
  closure help_variant_2_1 @help_variant
in
let code inline(always) loopify(never) size(19) newer_version_of(help_wrap_variant_3)
      help_wrap_variant_3_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (a, b)
     | 1 -> k2 (b, a))
    where k2 (a_1 : imm tagged, b_1 : imm tagged) =
      let Pmakeblock = %block.[`0`] (a_1, b_1) in
      cont k (Pmakeblock)
in
let $camlIfs_and_records__help_wrap_variant_21 =
  closure help_wrap_variant_3_1 @help_wrap_variant
in
let code inline(always) loopify(never) size(27) newer_version_of(help_tuple_4)
      help_tuple_4_1 (should_swap : imm tagged, a, b)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of val * val ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2
     | 1 -> k3)
    where k3 =
      let Pmakeblock = %block.[`0`] (b, a) in
      cont k (Pmakeblock)
    where k2 =
      let Pmakeblock = %block.[`0`] (a, b) in
      cont k (Pmakeblock)
in
let $camlIfs_and_records__help_tuple_22 = closure help_tuple_4_1 @help_tuple
in
let code inline(always) loopify(never) size(30) newer_version_of(help_interior_if_5)
      help_interior_if_5_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b)
     | 1 -> k2 (a))
    where k2 (switch_result : imm tagged) =
      ((let untagged = %untag_imm (should_swap) in
        switch untagged
          | 0 -> k2 (a)
          | 1 -> k2 (b))
         where k2 (switch_result_1 : imm tagged) =
           let Pmakeblock = %block.[`0`] (switch_result_1, switch_result) in
           cont k (Pmakeblock))
in
let $camlIfs_and_records__help_interior_if_23 =
  closure help_interior_if_5_1 @help_interior_if
in
let code inline(always) loopify(never) size(8) newer_version_of(help_no_if_6)
      help_no_if_6_1 (param, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of imm tagged * imm tagged ] =
  let Pmakeblock = %block.[`0`] (a, b) in
  cont k (Pmakeblock)
in
let $camlIfs_and_records__help_no_if_24 = closure help_no_if_6_1 @help_no_if
in
let code inline(always) loopify(never) size(8) newer_version_of(help_no_if_tuple_7)
      help_no_if_tuple_7_1 (param, a, b)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 of val * val ] =
  let Pmakeblock = %block.[`0`] (a, b) in
  cont k (Pmakeblock)
in
let $camlIfs_and_records__help_no_if_tuple_25 =
  closure help_no_if_tuple_7_1 @help_no_if_tuple
in
let code loopify(never) size(14) newer_version_of(main_desired_8)
      main_desired_8_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b, a)
     | 1 -> k2 (a, b))
    where k2 (unboxed_field_1, unboxed_field_0) =
      let int_sub = %int_barith.sub (unboxed_field_0, unboxed_field_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_desired_26 =
  closure main_desired_8_1 @main_desired
in
let code loopify(never) size(14) newer_version_of(main_wrap_9)
      main_wrap_9_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (a, b)
     | 1 -> k2 (b, a))
    where k2 (a_1 : imm tagged, b_1 : imm tagged) =
      let int_sub = %int_barith.sub (a_1, b_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_wrap_27 = closure main_wrap_9_1 @main_wrap in
let code loopify(never) size(14) newer_version_of(main_variant_10)
      main_variant_10_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b, a)
     | 1 -> k2 (a, b))
    where k2 (unboxed_field_1, unboxed_field_0) =
      let int_sub = %int_barith.sub (unboxed_field_0, unboxed_field_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_variant_28 =
  closure main_variant_10_1 @main_variant
in
let code loopify(never) size(14) newer_version_of(main_wrap_variant_11)
      main_wrap_variant_11_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (a, b)
     | 1 -> k2 (b, a))
    where k2 (a_1 : imm tagged, b_1 : imm tagged) =
      let int_sub = %int_barith.sub (a_1, b_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_wrap_variant_29 =
  closure main_wrap_variant_11_1 @main_wrap_variant
in
let code loopify(never) size(14) newer_version_of(main_tuple_12)
      main_tuple_12_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b, a)
     | 1 -> k2 (a, b))
    where k2 (unboxed_field_1, unboxed_field_0) =
      let int_sub = %int_barith.sub (unboxed_field_0, unboxed_field_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_tuple_30 = closure main_tuple_12_1 @main_tuple
in
let code loopify(never) size(25) newer_version_of(main_interior_if_13)
      main_interior_if_13_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b)
     | 1 -> k2 (a))
    where k2 (switch_result : imm tagged) =
      ((let untagged = %untag_imm (should_swap) in
        switch untagged
          | 0 -> k2 (a)
          | 1 -> k2 (b))
         where k2 (switch_result_1 : imm tagged) =
           let int_sub = %int_barith.sub (switch_result_1, switch_result) in
           cont k (int_sub))
in
let $camlIfs_and_records__main_interior_if_31 =
  closure main_interior_if_13_1 @main_interior_if
in
let code loopify(never) size(3) newer_version_of(main_no_if_14)
      main_no_if_14_1 (should_swap, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let int_sub = %int_barith.sub (a, b) in
  cont k (int_sub)
in
let $camlIfs_and_records__main_no_if_32 = closure main_no_if_14_1 @main_no_if
in
let code loopify(never) size(3) newer_version_of(main_no_if_tuple_15)
      main_no_if_tuple_15_1 (should_swap, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let int_sub = %int_barith.sub (a, b) in
  cont k (int_sub)
in
let $camlIfs_and_records__main_no_if_tuple_33 =
  closure main_no_if_tuple_15_1 @main_no_if_tuple
in
let code loopify(never) size(14) newer_version_of(main_hand_inline_16)
      main_hand_inline_16_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (b, a)
     | 1 -> k2 (a, b))
    where k2 (unboxed_field_1, unboxed_field_0) =
      let int_sub = %int_barith.sub (unboxed_field_0, unboxed_field_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_hand_inline_34 =
  closure main_hand_inline_16_1 @main_hand_inline
in
let code loopify(never) size(14) newer_version_of(main_hand_inline_tuple_17)
      main_hand_inline_tuple_17_1
        (should_swap : imm tagged, a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (should_swap) in
   switch untagged
     | 0 -> k2 (a, b)
     | 1 -> k2 (b, a))
    where k2 (a_1 : imm tagged, b_1 : imm tagged) =
      let int_sub = %int_barith.sub (a_1, b_1) in
      cont k (int_sub)
in
let $camlIfs_and_records__main_hand_inline_tuple_35 =
  closure main_hand_inline_tuple_17_1 @main_hand_inline_tuple
in
let $camlIfs_and_records =
  Block 0 ($camlIfs_and_records__empty_block4,
           $camlIfs_and_records__empty_block4,
           $camlIfs_and_records__help_desired_18,
           $camlIfs_and_records__help_wrap_19,
           $camlIfs_and_records__help_variant_20,
           $camlIfs_and_records__help_wrap_variant_21,
           $camlIfs_and_records__help_tuple_22,
           $camlIfs_and_records__help_interior_if_23,
           $camlIfs_and_records__help_no_if_24,
           $camlIfs_and_records__help_no_if_tuple_25,
           $camlIfs_and_records__main_desired_26,
           $camlIfs_and_records__main_wrap_27,
           $camlIfs_and_records__main_variant_28,
           $camlIfs_and_records__main_wrap_variant_29,
           $camlIfs_and_records__main_tuple_30,
           $camlIfs_and_records__main_interior_if_31,
           $camlIfs_and_records__main_no_if_32,
           $camlIfs_and_records__main_no_if_tuple_33,
           $camlIfs_and_records__main_hand_inline_34,
           $camlIfs_and_records__main_hand_inline_tuple_35)
in
cont done ($camlIfs_and_records)
