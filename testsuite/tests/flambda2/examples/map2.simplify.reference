let code failwith_0 deleted in
let code invalid_arg_1 deleted in
let $camlMap2__immstring48 = "map2.ml" in
let $camlMap2__const_block50 = Block 0 ($camlMap2__immstring48, 236, 9) in
let $camlMap2__Pmakeblock53 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlMap2__const_block50)
in
let code merge_2 deleted in
let code loopify(never) size(10) newer_version_of(failwith_0)
      failwith_0_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlMap2__failwith_3 = closure failwith_0_1 @failwith in
let code loopify(never) size(10) newer_version_of(invalid_arg_1)
      invalid_arg_1_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlMap2__invalid_arg_4 = closure invalid_arg_1_1 @invalid_arg in
let code rec loopify(done) size(57) newer_version_of(merge_2)
      merge_2_1
        (f,
         s1 :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
               imm tagged * val *
               [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
               imm tagged ],
         s2 :
           [ 0
           | 0 of [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
               imm tagged * val *
               [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
               imm tagged ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0
          | 0 of [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
              imm tagged * val *
              [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
              imm tagged ] =
  cont self (s1, s2)
    where rec self
                (s1_1 :
                   [ 0
                   | 0 of [ 0
                          | 0 of val * imm tagged * val * val * imm tagged ] *
                       imm tagged * val *
                       [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
                       imm tagged ],
                 s2_1 :
                   [ 0
                   | 0 of [ 0
                          | 0 of val * imm tagged * val * val * imm tagged ] *
                       imm tagged * val *
                       [ 0 | 0 of val * imm tagged * val * val * imm tagged ] *
                       imm tagged ]) =
      ((let prim = %is_int (s1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (s2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (0)
          where k3 =
            let prim_1 = %is_int (s2_1) in
            let Pisint = %tag_imm (prim_1) in
            let Pnot = %boolean_not (Pisint) in
            let Pfield = %block_load.[`4`] (s1_1) in
            let prim_2 = %int_comp.ge (Pfield, Pnot) in
            (switch prim_2
               | 0 -> k2
               | 1 -> k3
               where k3 =
                 let Pfield_1 = %block_load.[`3`] (s1_1) in
                 let Pfield_2 = %block_load.[`0`] (s1_1) in
                 cont self (Pfield_2, Pfield_1)))
         where k2 =
           let prim = %is_int (s2_1) in
           (switch prim
              | 0 -> k2
              | 1 -> k1 pop(regular k1) ($camlMap2__Pmakeblock53)
              where k2 =
                let Pfield = %block_load.[`3`] (s2_1) in
                let Pfield_1 = %block_load.[`0`] (s2_1) in
                cont self (Pfield_1, Pfield)))
in
let $camlMap2__merge_5 = closure merge_2_1 @merge in
let $camlMap2 =
  Block 0 ($camlMap2__failwith_3,
           $camlMap2__invalid_arg_4,
           $camlMap2__merge_5)
in
cont done ($camlMap2)
