let $camlTests13__first_const = Block 0 () in
(let code size(1)
       `fn[tests13.ml:30,44--59]_2` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (0)
 in
 let code size(1)
       `fn[tests13.ml:30,31--43]_3` (x)
         my_closure _region _ghost_region my_depth
         -> k1 * k2 =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (x)
 in
 let code size(26)
       `fn[tests13.ml:27,2--118]_1` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2 =
   let next_depth = rec_info (succ my_depth) in
   let map_foo =
     %project_value_slot.[`fn[tests13.ml:27,2--118]`].[`map_foo`]
       (my_closure)
   in
   let i =
     %project_value_slot.[`fn[tests13.ml:27,2--118]`].[`i`] (my_closure)
   in
   let j = %int_barith.add (i, 3) in
   let Popaque = %opaque (j) in
   let `fn[tests13.ml:30,44--59]` =
     closure `fn[tests13.ml:30,44--59]_2` @`fn[tests13.ml:30,44--59]`
   in
   let `fn[tests13.ml:30,31--43]` =
     closure `fn[tests13.ml:30,31--43]_3` @`fn[tests13.ml:30,31--43]`
   in
   apply inlined(never)
     map_foo
       (`fn[tests13.ml:30,31--43]`, `fn[tests13.ml:30,44--59]`, 0)
       -> k1 * k2
 in
 let code inline(always) size(36)
       bar_0 (i : imm tagged, map_foo : val)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : val =
   let next_depth = rec_info (succ my_depth) in
   let `fn[tests13.ml:27,2--118]` =
     closure `fn[tests13.ml:27,2--118]_1` @`fn[tests13.ml:27,2--118]`
   with { i = i; map_foo = map_foo }
   in
   cont k1 (`fn[tests13.ml:27,2--118]`)
 in
 let code size(1)
       `fn[tests13.ml:41,15--28]_5` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (0)
 in
 let code rec size(72)
       map_foo_4 (f : val, seq : val, param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   let bar = %project_value_slot.[`map_foo`].[`bar`] (my_closure) in
   apply seq (0) -> k3 * k2
     where k3 (`*match*` : [ 0 | 0 of val * val ]) =
       ((let prim = %is_int (`*match*`) in
         let Pisint = %tag_imm (prim) in
         (let untagged = %untag_imm (Pisint) in
          switch untagged
            | 0 -> k4
            | 1 -> k1 (0))
           where k4 =
             cont k3)
          where k3 =
            ((let Popaque = %opaque (0) in
              (let untagged = %untag_imm (Popaque) in
               switch untagged
                 | 0 -> k6
                 | 1 -> k7)
                where k7 =
                  cont k4
                where k6 =
                  cont k5)
               where k5 =
                 apply direct(bar_0)
                   (bar : _ -> val)
                     (20, my_closure ~ depth my_depth -> next_depth)
                     -> k3 * k2
               where k4 =
                 apply direct(bar_0)
                   (bar : _ -> val)
                     (10, my_closure ~ depth my_depth -> next_depth)
                     -> k3 * k2
               where k3 (g : val) =
                 (apply inlined(always) g (0) -> k3 * k2
                    where k3 (g_result : [ 0 | 0 of val * val ]) =
                      let Popaque = %opaque (g_result) in
                      let `fn[tests13.ml:41,15--28]` =
                        closure `fn[tests13.ml:41,15--28]_5`
                          @`fn[tests13.ml:41,15--28]`
                      in
                      ((let Pfield = %block_load.[`0`] (`*match*`) in
                        apply f (Pfield) -> k3 * k2)
                         where k3 (apply_result : val) =
                           let Pmakeblock =
                             %block.[`0`]
                               (apply_result, `fn[tests13.ml:41,15--28]`)
                           in
                           cont k1 (Pmakeblock)))))
 in
 let bar = closure bar_0 @bar in
 let map_foo = closure map_foo_4 @map_foo with { bar = bar } in
 let Pmakeblock = %block.[`0`] (map_foo) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load.tag[`0`].`size`[`1`].[`0`] (module_block) in
    let $camlTests13 = Block 0 (field_0) in
    cont done ($camlTests13)
