let code g_1 deleted and code f_0 deleted in
let z = %opaque (42) in
let $camlToplevel_rec__f_2 =
  closure f_0_1 @f
and $camlToplevel_rec__g_3 =
  closure g_1_1 @g
and code rec loopify(never) size(10) newer_version_of(g_1)
      g_1_1 (y : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let z_1 = %project_value_slot.[`g`].[`z`] ($camlToplevel_rec__g_3) in
  (let int_sub = %int_barith.sub (y, 1) in
   apply direct(f_0_1)
     ($camlToplevel_rec__f_2 ~ depth my_depth -> succ my_depth
      : _ -> imm tagged)
       (int_sub)
       -> k2 * k1)
    where k2 (apply_result : imm tagged) =
      let int_add = %int_barith.add (z_1, apply_result) in
      cont k (int_add)
and code rec loopify(never) size(10) newer_version_of(f_0)
      f_0_1 (x : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let z_1 = %project_value_slot.[`f`].[`z`] ($camlToplevel_rec__f_2) in
  (let int_add = %int_barith.add (x, 1) in
   apply direct(g_1_1)
     ($camlToplevel_rec__g_3 ~ depth my_depth -> succ my_depth
      : _ -> imm tagged)
       (int_add)
       -> k2 * k1)
    where k2 (apply_result : imm tagged) =
      let int_add = %int_barith.add (z_1, apply_result) in
      cont k (int_add)
  with { z = z }
in
let $camlToplevel_rec =
  Block 0 (z, $camlToplevel_rec__f_2, $camlToplevel_rec__g_3)
in
cont done ($camlToplevel_rec)
