let $camlTests__first_const = Block 0 () in
(let code inline(always) size(1)
       to_inline_0 (_x, _y)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (42)
 in
 let code size(79)
       f_1
         (c : imm tagged,
          m : [ 0 | 0 of val ],
          n : [ 0 | 0 of val ],
          x' : imm tagged,
          y' : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : imm tagged =
   let next_depth = rec_info (succ my_depth) in
   let to_inline = %project_value_slot.[`f`].[`to_inline`] (my_closure) in
   (let prim = %int_comp.lt (c, 0) in
    let int_lessthan = %tag_imm (prim) in
    (let untagged = %untag_imm (int_lessthan) in
     switch untagged
       | 0 -> k5
       | 1 -> k3 (x'))
      where k5 =
        cont k4)
     where k4 =
       let int_add = %int_barith.add (x', 1) in
       cont k3 (int_add)
     where k3 (x : imm tagged) =
       ((let prim = %int_comp.lt (c, 0) in
         let int_lessthan = %tag_imm (prim) in
         (let untagged = %untag_imm (int_lessthan) in
          switch untagged
            | 0 -> k5
            | 1 -> k3 (y'))
           where k5 =
             cont k4)
          where k4 =
            let int_add = %int_barith.add (y', 1) in
            cont k3 (int_add)
          where k3 (y : imm tagged) =
            ((let prim = %is_int (m) in
              let Pisint = %tag_imm (prim) in
              (let untagged = %untag_imm (Pisint) in
               switch untagged
                 | 0 -> k4
                 | 1 -> k1 (0))
                where k4 =
                  cont k3)
               where k3 =
                 ((let prim = %is_int (n) in
                   let Pisint = %tag_imm (prim) in
                   (let untagged = %untag_imm (Pisint) in
                    switch untagged
                      | 0 -> k4
                      | 1 -> k1 (1))
                     where k4 =
                       cont k3)
                    where k3 =
                      let Pfield = %block_load.[`0`] (n) in
                      let Pfield_1 = %block_load.[`0`] (m) in
                      let int_add = %int_barith.add (Pfield_1, Pfield) in
                      let int_add_1 = %int_barith.add (x, y) in
                      apply direct(to_inline_0)
                        (to_inline : _ -> imm tagged)
                          (int_add_1, int_add)
                          -> k1 * k2)))
 in
 let to_inline = closure to_inline_0 @to_inline in
 let f = closure f_1 @f with { to_inline = to_inline } in
 let Pmakeblock = %block.[`0`] (to_inline, f) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load.tag[`0`].`size`[`2`].[`0`] (module_block) in
    let field_1 = %block_load.tag[`0`].`size`[`2`].[`1`] (module_block) in
    let $camlTests = Block 0 (field_0, field_1) in
    cont done ($camlTests)
