let $camlTests8__first_const = Block 0 () in
(let code size(1)
       `fn[tests8.ml:20,62--77]_2` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (0)
 in
 let code size(1)
       `fn[tests8.ml:20,49--61]_3` (x : val)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : val =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (x)
 in
 let code size(21)
       `fn[tests8.ml:20,12--80]_1` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   let map_foo =
     %project_value_slot.[`fn[tests8.ml:20,12--80]`].[`my_closure`]
       (my_closure)
   in
   let `fn[tests8.ml:20,62--77]` =
     closure `fn[tests8.ml:20,62--77]_2` @`fn[tests8.ml:20,62--77]`
   in
   let `fn[tests8.ml:20,49--61]` =
     closure `fn[tests8.ml:20,49--61]_3` @`fn[tests8.ml:20,49--61]`
   in
   apply direct(map_foo_0) inlined(never)
     (map_foo : _ -> [ 0 | 0 of val * val ])
       (`fn[tests8.ml:20,49--61]`, `fn[tests8.ml:20,62--77]`, 0)
       -> k1 * k2
 and code rec size(65)
       map_foo_0 (f : val, seq : val, param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   apply seq (0) -> k3 * k2
     where k3 (`*match*` : [ 0 | 0 of val * val ]) =
       ((let prim = %is_int (`*match*`) in
         let Pisint = %tag_imm (prim) in
         (let untagged = %untag_imm (Pisint) in
          switch untagged
            | 0 -> k4
            | 1 -> k1 (0))
           where k4 =
             cont k3)
          where k3 =
            let `fn[tests8.ml:20,12--80]` =
              closure `fn[tests8.ml:20,12--80]_1` @`fn[tests8.ml:20,12--80]`
            with { my_closure = my_closure ~ depth my_depth -> next_depth }
            in
            ((let Pfield = %block_load.[`0`] (`*match*`) in
              apply f (Pfield) -> k3 * k2)
               where k3 (apply_result : val) =
                 let Pmakeblock =
                   %block.[`0`] (apply_result, `fn[tests8.ml:20,12--80]`)
                 in
                 cont k1 (Pmakeblock)))
 in
 let map_foo = closure map_foo_0 @map_foo in
 let Pmakeblock = %block.[`0`] (map_foo) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load.tag[`0`].`size`[`1`].[`0`] (module_block) in
    let $camlTests8 = Block 0 (field_0) in
    cont done ($camlTests8)
