let code failwith_180 deleted in
let code invalid_arg_181 deleted in
let code `@_182` deleted in
let code loopify(never) size(1)
      bts_183 (prim : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont k (prim)
in
let code loopify(never) size(1)
      bos_184 (prim : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont k (prim)
in
let code make_185 deleted in
let code init_186 deleted in
let code copy_187 deleted in
let code sub_188 deleted in
let $camlString__immstring8066 = "String.concat" in
let code ensure_ge_189 deleted in
let code sum_lengths_190 deleted in
let code unsafe_blits_191 deleted in
let $camlString__immstring8140 = "" in
let code concat_192 deleted in
let code iter_193 deleted in
let code iteri_194 deleted in
let code map_195 deleted in
let code mapi_196 deleted in
let code is_space_197 deleted in
let code trim_198 deleted in
let code escape_if_needed_200 deleted in
let code escaped_199 deleted in
let code index_rec_201 deleted in
let code index_202 deleted in
let code index_rec_opt_203 deleted in
let code index_opt_204 deleted in
let $camlString__immstring8373 = "String.index_from / Bytes.index_from" in
let code index_from_205 deleted in
let $camlString__immstring8392 =
  "String.index_from_opt / Bytes.index_from_opt"
in
let code index_from_opt_206 deleted in
let code rindex_rec_207 deleted in
let code rindex_208 deleted in
let $camlString__immstring8440 = "String.rindex_from / Bytes.rindex_from" in
let code rindex_from_209 deleted in
let code rindex_rec_opt_210 deleted in
let code rindex_opt_211 deleted in
let $camlString__immstring8487 =
  "String.rindex_from_opt / Bytes.rindex_from_opt"
in
let code rindex_from_opt_212 deleted in
let $camlString__immstring8518 = "String.contains_from / Bytes.contains_from"
in
let code contains_from_213 deleted in
let code contains_214 deleted in
let $camlString__immstring8556 =
  "String.rcontains_from / Bytes.rcontains_from"
in
let code rcontains_from_215 deleted in
let code uppercase_ascii_216 deleted in
let code lowercase_ascii_217 deleted in
let code capitalize_ascii_218 deleted in
let code uncapitalize_ascii_219 deleted in
let code compare_220 deleted in
let code split_on_char_221 deleted in
let code uppercase_222 deleted in
let code lowercase_223 deleted in
let code capitalize_224 deleted in
let code uncapitalize_225 deleted in
let code to_seq_226 deleted in
let code to_seqi_227 deleted in
let code of_seq_228 deleted in
let code loopify(never) size(10) newer_version_of(failwith_180)
      failwith_180_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlString__failwith_229 = closure failwith_180_1 @failwith in
let code loopify(never) size(10) newer_version_of(invalid_arg_181)
      invalid_arg_181_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlString__invalid_arg_230 = closure invalid_arg_181_1 @invalid_arg in
let $`camlString__@_231` =
  closure `@_182_1` @`@`
and code rec loopify(never) size(25) newer_version_of(`@_182`)
      `@_182_1`
        (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (l1) in
  switch prim
    | 0 -> k2
    | 1 -> k (l2)
    where k2 =
      ((let Pfield = %block_load.[`1`] (l1) in
        apply direct(`@_182_1`)
          ($`camlString__@_231` ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (Pfield, l2)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           let Pfield = %block_load.[`0`] (l1) in
           let Pmakeblock = %block.[`0`] (Pfield, apply_result) in
           cont k (Pmakeblock))
in
let $camlString__bts_232 = closure bts_183 @bts in
let $camlString__bos_233 = closure bos_184 @bos in
let code loopify(never) size(4) newer_version_of(make_185)
      make_185_1 (n : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(make_27)
    ($Bytes.camlBytes__make_110 : _ -> val) (n, c) -> k * k1
in
let $camlString__make_234 = closure make_185_1 @make in
let code loopify(never) size(4) newer_version_of(init_186)
      init_186_1 (n : imm tagged, f : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(init_28)
    ($Bytes.camlBytes__init_111 : _ -> val) (n, f) -> k * k1
in
let $camlString__init_235 = closure init_186_1 @init in
let code loopify(never) size(4) newer_version_of(copy_187)
      copy_187_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(copy_29) ($Bytes.camlBytes__copy_112 : _ -> val) (s) -> k * k1
in
let $camlString__copy_236 = closure copy_187_1 @copy in
let code loopify(never) size(4) newer_version_of(sub_188)
      sub_188_1 (s : val, ofs : imm tagged, len : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(sub_32)
    ($Bytes.camlBytes__sub_115 : _ -> val) (s, ofs, len) -> k * k1
in
let $camlString__sub_237 = closure sub_188_1 @sub in
let code loopify(never) size(16) newer_version_of(ensure_ge_189)
      ensure_ge_189_1 (x : imm tagged, y : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %int_comp.ge (x, y) in
  switch prim
    | 0 -> k2
    | 1 -> k (x)
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> imm tagged)
          ($camlString__immstring8066)
          -> never * k1
in
let $camlString__ensure_ge_238 = closure ensure_ge_189_1 @ensure_ge in
let code rec loopify(done) size(51) newer_version_of(sum_lengths_190)
      sum_lengths_190_1
        (acc : imm tagged,
         seplen : imm tagged,
         param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (acc, param)
    where rec self
                (acc_1 : imm tagged,
                 param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let seplen_1 = seplen in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (acc_1)
         where k2 =
           let hd = %block_load.[`0`] (param_1) in
           let Pfield = %block_load.[`1`] (param_1) in
           let prim_1 = %is_int (Pfield) in
           (switch prim_1
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let prim_2 = %string_length (hd) in
                let Pstringlength = %tag_imm (prim_2) in
                let int_add = %int_barith.add (Pstringlength, acc_1) in
                cont k (int_add)
              where k2 =
                ((let prim_2 = %string_length (hd) in
                  let Pstringlength = %tag_imm (prim_2) in
                  let int_add = %int_barith.add (Pstringlength, seplen_1) in
                  let int_add_1 = %int_barith.add (int_add, acc_1) in
                  apply direct(ensure_ge_189_1)
                    ($camlString__ensure_ge_238 : _ -> imm tagged)
                      (int_add_1, acc_1)
                      -> k2 * k1)
                   where k2 (apply_result : imm tagged) =
                     cont self (apply_result, Pfield))))
in
let $camlString__sum_lengths_239 = closure sum_lengths_190_1 @sum_lengths in
let code rec loopify(done) size(59) newer_version_of(unsafe_blits_191)
      unsafe_blits_191_1
        (dst : val,
         pos : imm tagged,
         sep : val,
         seplen : imm tagged,
         param : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont self (pos, param)
    where rec self
                (pos_1 : imm tagged,
                 param_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let dst_1 = dst in
      let sep_1 = sep in
      let seplen_1 = seplen in
      let prim = %is_int (param_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (dst_1)
         where k2 =
           let hd = %block_load.[`0`] (param_1) in
           let Pfield = %block_load.[`1`] (param_1) in
           let prim_1 = %is_int (Pfield) in
           (switch prim_1
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let prim_2 = %string_length (hd) in
                let Pstringlength = %tag_imm (prim_2) in
                (apply ccall noalloc
                   ($`*extern*`.caml_blit_string
                    : val * val * val * val * val -> val)
                     (hd, 0, dst_1, pos_1, Pstringlength)
                     -> k3 * k1
                   where k3 (param_2) =
                     cont k (dst_1))
              where k2 =
                let prim_2 = %string_length (hd) in
                let Pstringlength = %tag_imm (prim_2) in
                (apply ccall noalloc
                   ($`*extern*`.caml_blit_string
                    : val * val * val * val * val -> val)
                     (hd, 0, dst_1, pos_1, Pstringlength)
                     -> k3 * k1
                   where k3 (param_2) =
                     cont k2
                   where k2 =
                     let int_add = %int_barith.add (pos_1, Pstringlength) in
                     (apply ccall noalloc
                        ($`*extern*`.caml_blit_string
                         : val * val * val * val * val -> val)
                          (sep_1, 0, dst_1, int_add, seplen_1)
                          -> k3 * k1
                        where k3 (param_2) =
                          cont k2
                        where k2 =
                          let int_add_1 = %int_barith.add (int_add, seplen_1)
                          in
                          cont self (int_add_1, Pfield)))))
in
let $camlString__unsafe_blits_240 = closure unsafe_blits_191_1 @unsafe_blits
in
let code loopify(never) size(36) newer_version_of(concat_192)
      concat_192_1 (sep : val, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let prim = %is_int (l) in
  switch prim
    | 0 -> k2
    | 1 -> k ($camlString__immstring8140)
    where k2 =
      let prim_1 = %string_length (sep) in
      let seplen = %tag_imm (prim_1) in
      (apply direct(sum_lengths_190_1)
         ($camlString__sum_lengths_239 : _ -> imm tagged)
           (0, seplen, l)
           -> k2 * k1
         where k2 (apply_result : imm tagged) =
           (apply ccall
              ($`*extern*`.caml_create_bytes : val -> val)
                (apply_result)
                -> k2 * k1
              where k2 (Pccall) =
                apply direct(unsafe_blits_191_1)
                  ($camlString__unsafe_blits_240 : _ -> val)
                    (Pccall, 0, sep, seplen, l)
                    -> k * k1))
in
let $camlString__concat_241 = closure concat_192_1 @concat in
let code loopify(never) size(50) newer_version_of(iter_193)
      iter_193_1 (f : val, s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  let for_stop = %int_barith.sub (Pstringlength, 1) in
  let prim_1 = %int_comp.le (0, for_stop) in
  switch prim_1
    | 0 -> k (0)
    | 1 -> k2
    where k2 =
      (cont k2 (0)
         where rec k2 (i : imm tagged) =
           ((let prim_2 = %num_conv.[`tagged_imm`].[`imm`] (i) in
             let prim_3 = %string_load.[`8`] (s, prim_2) in
             let Pstringrefu = %tag_imm (prim_3) in
             apply f (Pstringrefu) -> k4 * k1
               where k4 (param) =
                 cont k3)
              where k3 =
                let prim_2 = %int_comp.ne (i, for_stop) in
                (switch prim_2
                   | 0 -> k (0)
                   | 1 -> k3
                   where k3 =
                     let int_succ = %int_barith.add (i, 1) in
                     cont k2 (int_succ))))
in
let $camlString__iter_242 = closure iter_193_1 @iter in
let code loopify(never) size(50) newer_version_of(iteri_194)
      iteri_194_1 (f : val, s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  let for_stop = %int_barith.sub (Pstringlength, 1) in
  let prim_1 = %int_comp.le (0, for_stop) in
  switch prim_1
    | 0 -> k (0)
    | 1 -> k2
    where k2 =
      (cont k2 (0)
         where rec k2 (i : imm tagged) =
           ((let prim_2 = %num_conv.[`tagged_imm`].[`imm`] (i) in
             let prim_3 = %string_load.[`8`] (s, prim_2) in
             let Pstringrefu = %tag_imm (prim_3) in
             apply f (i, Pstringrefu) -> k4 * k1
               where k4 (param) =
                 cont k3)
              where k3 =
                let prim_2 = %int_comp.ne (i, for_stop) in
                (switch prim_2
                   | 0 -> k (0)
                   | 1 -> k3
                   where k3 =
                     let int_succ = %int_barith.add (i, 1) in
                     cont k2 (int_succ))))
in
let $camlString__iteri_243 = closure iteri_194_1 @iteri in
let code loopify(never) size(4) newer_version_of(map_195)
      map_195_1 (f : val, s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(map_49)
    ($Bytes.camlBytes__map_132 : _ -> val) (f, s) -> k * k1
in
let $camlString__map_244 = closure map_195_1 @map in
let code loopify(never) size(4) newer_version_of(mapi_196)
      mapi_196_1 (f : val, s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(mapi_50)
    ($Bytes.camlBytes__mapi_133 : _ -> val) (f, s) -> k * k1
in
let $camlString__mapi_245 = closure mapi_196_1 @mapi in
let code loopify(never) size(25) newer_version_of(is_space_197)
      is_space_197_1 (param : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let switcher = %int_barith.add (param, -9) in
  let prim = %int_comp.unsigned.lt (4, switcher) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      let prim_1 = %int_comp.ne (switcher, 23) in
      let tagged_scrutinee = %tag_imm (prim_1) in
      let not_scrutinee = %boolean_not (tagged_scrutinee) in
      cont k (not_scrutinee)
    where k2 =
      let prim_1 = %int_comp.ne (switcher, 2) in
      let tagged_scrutinee = %tag_imm (prim_1) in
      cont k (tagged_scrutinee)
in
let $camlString__is_space_246 = closure is_space_197_1 @is_space in
let code loopify(never) size(71) newer_version_of(trim_198)
      trim_198_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply ccall noalloc
    ($`*extern*`.caml_string_equal : val * val -> val)
      (s, $camlString__immstring8140)
      -> k2 * k1
    where k2 (Pccall) =
      ((let untagged = %untag_imm (Pccall) in
        switch untagged
          | 0 -> k2
          | 1 -> k (s))
         where k2 =
           ((let prim = %string_load.[`8`] (s, 0i) in
             let Pstringrefu = %tag_imm (prim) in
             apply direct(is_space_197_1)
               ($camlString__is_space_246 : _ -> imm tagged)
                 (Pstringrefu)
                 -> k4 * k1
               where k4 (param : imm tagged) =
                 let unboxed_field = %untag_imm (param) in
                 cont k3 (unboxed_field))
              where k3 (unboxed_field : imm) =
                let naked_immediate = unboxed_field in
                (switch naked_immediate
                   | 0 -> k3
                   | 1 -> k2
                   where k3 =
                     ((let prim = %string_length (s) in
                       let Pstringlength = %tag_imm (prim) in
                       let int_sub = %int_barith.sub (Pstringlength, 1) in
                       let prim_1 =
                         %num_conv.[`tagged_imm`].[`imm`] (int_sub)
                       in
                       let prim_2 = %string_load.[`8`] (s, prim_1) in
                       let Pstringrefu = %tag_imm (prim_2) in
                       apply direct(is_space_197_1)
                         ($camlString__is_space_246 : _ -> imm tagged)
                           (Pstringrefu)
                           -> k4 * k1
                         where k4 (param : imm tagged) =
                           let unboxed_field_1 = %untag_imm (param) in
                           cont k3 (unboxed_field_1))
                        where k3 (unboxed_field_1 : imm) =
                          let naked_immediate_1 = unboxed_field_1 in
                          switch naked_immediate_1
                            | 0 -> k (s)
                            | 1 -> k2))
              where k2 =
                apply direct(trim_47)
                  ($Bytes.camlBytes__trim_130 : _ -> val) (s) -> k * k1))
in
let $camlString__trim_247 = closure trim_198_1 @trim in
let code rec loopify(done) size(66) newer_version_of(escape_if_needed_200)
      escape_if_needed_200_1 (s : val, n : imm tagged, i : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont self (i)
    where rec self (i_1 : imm tagged) =
      let s_1 = s in
      let n_1 = n in
      let prim = %int_comp.ge (i_1, n_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (s_1)
         where k2 =
           let prim_1 = %num_conv.[`tagged_imm`].[`imm`] (i_1) in
           let prim_2 = %string_load.[`8`] (s_1, prim_1) in
           let `*match*` = %tag_imm (prim_2) in
           ((let switcher = %int_barith.add (`*match*`, -32) in
             let prim_3 = %int_comp.unsigned.lt (59, switcher) in
             switch prim_3
               | 0 -> k4
               | 1 -> k5
               where k5 =
                 let int_add = %int_barith.add (switcher, -61) in
                 let prim_4 = %int_comp.unsigned.lt (33, int_add) in
                 switch prim_4
                   | 0 -> k3
                   | 1 -> k2
               where k4 =
                 let prim_4 = %int_comp.ne (switcher, 2) in
                 switch prim_4
                   | 0 -> k2
                   | 1 -> k3)
              where k3 =
                let int_add = %int_barith.add (i_1, 1) in
                cont self (int_add)
              where k2 =
                apply direct(escaped_48)
                  ($Bytes.camlBytes__escaped_131 : _ -> val) (s_1) -> k * k1))
in
let $camlString__escape_if_needed_249 =
  closure escape_if_needed_200_1 @escape_if_needed
in
let code loopify(never) size(11) newer_version_of(escaped_199)
      escaped_199_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  apply direct(escape_if_needed_200_1)
    ($camlString__escape_if_needed_249 : _ -> val)
      (s, Pstringlength, 0)
      -> k * k1
in
let $camlString__escaped_248 = closure escaped_199_1 @escaped in
let code rec loopify(done) size(34) newer_version_of(index_rec_201)
      index_rec_201_1
        (s : val, lim : imm tagged, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (i)
    where rec self (i_1 : imm tagged) =
      let s_1 = s in
      let lim_1 = lim in
      let c_1 = c in
      let prim = %int_comp.ge (i_1, lim_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k1 pop(regular k1) ($`*predef*`.caml_exn_Not_found)
         where k2 =
           let prim_1 = %num_conv.[`tagged_imm`].[`imm`] (i_1) in
           let prim_2 = %string_load.[`8`] (s_1, prim_1) in
           let Pstringrefu = %tag_imm (prim_2) in
           let prim_3 = %phys_eq (Pstringrefu, c_1) in
           (switch prim_3
              | 0 -> k2
              | 1 -> k (i_1)
              where k2 =
                let int_add = %int_barith.add (i_1, 1) in
                cont self (int_add)))
in
let $camlString__index_rec_250 = closure index_rec_201_1 @index_rec in
let code loopify(never) size(11) newer_version_of(index_202)
      index_202_1 (s : val, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  apply direct(index_rec_201_1)
    ($camlString__index_rec_250 : _ -> imm tagged)
      (s, Pstringlength, 0, c)
      -> k * k1
in
let $camlString__index_251 = closure index_202_1 @index in
let code rec loopify(done) size(41) newer_version_of(index_rec_opt_203)
      index_rec_opt_203_1
        (s : val, lim : imm tagged, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  cont self (i)
    where rec self (i_1 : imm tagged) =
      let s_1 = s in
      let lim_1 = lim in
      let c_1 = c in
      let prim = %int_comp.ge (i_1, lim_1) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           let prim_1 = %num_conv.[`tagged_imm`].[`imm`] (i_1) in
           let prim_2 = %string_load.[`8`] (s_1, prim_1) in
           let Pstringrefu = %tag_imm (prim_2) in
           let prim_3 = %phys_eq (Pstringrefu, c_1) in
           (switch prim_3
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let Pmakeblock = %block.[`0`] (i_1) in
                cont k (Pmakeblock)
              where k2 =
                let int_add = %int_barith.add (i_1, 1) in
                cont self (int_add)))
in
let $camlString__index_rec_opt_252 =
  closure index_rec_opt_203_1 @index_rec_opt
in
let code loopify(never) size(11) newer_version_of(index_opt_204)
      index_opt_204_1 (s : val, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  apply direct(index_rec_opt_203_1)
    ($camlString__index_rec_opt_252 : _ -> [ 0 | 0 of val ])
      (s, Pstringlength, 0, c)
      -> k * k1
in
let $camlString__index_opt_253 = closure index_opt_204_1 @index_opt in
let code loopify(never) size(39) newer_version_of(index_from_205)
      index_from_205_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let l = %tag_imm (prim) in
  (let prim_1 = %int_comp.lt (i, 0) in
   switch prim_1
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_2 = %int_comp.gt (i, l) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            apply direct(index_rec_201_1)
              ($camlString__index_rec_250 : _ -> imm tagged)
                (s, l, i, c)
                -> k * k1))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> imm tagged)
          ($camlString__immstring8373)
          -> never * k1
in
let $camlString__index_from_254 = closure index_from_205_1 @index_from in
let code loopify(never) size(39) newer_version_of(index_from_opt_206)
      index_from_opt_206_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  let prim = %string_length (s) in
  let l = %tag_imm (prim) in
  (let prim_1 = %int_comp.lt (i, 0) in
   switch prim_1
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_2 = %int_comp.gt (i, l) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            apply direct(index_rec_opt_203_1)
              ($camlString__index_rec_opt_252 : _ -> [ 0 | 0 of val ])
                (s, l, i, c)
                -> k * k1))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> [ 0 | 0 of val ])
          ($camlString__immstring8392)
          -> never * k1
in
let $camlString__index_from_opt_255 =
  closure index_from_opt_206_1 @index_from_opt
in
let code rec loopify(done) size(34) newer_version_of(rindex_rec_207)
      rindex_rec_207_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  cont self (i)
    where rec self (i_1 : imm tagged) =
      let s_1 = s in
      let c_1 = c in
      let prim = %int_comp.lt (i_1, 0) in
      (switch prim
         | 0 -> k2
         | 1 -> k1 pop(regular k1) ($`*predef*`.caml_exn_Not_found)
         where k2 =
           let prim_1 = %num_conv.[`tagged_imm`].[`imm`] (i_1) in
           let prim_2 = %string_load.[`8`] (s_1, prim_1) in
           let Pstringrefu = %tag_imm (prim_2) in
           let prim_3 = %phys_eq (Pstringrefu, c_1) in
           (switch prim_3
              | 0 -> k2
              | 1 -> k (i_1)
              where k2 =
                let int_sub = %int_barith.sub (i_1, 1) in
                cont self (int_sub)))
in
let $camlString__rindex_rec_256 = closure rindex_rec_207_1 @rindex_rec in
let code loopify(never) size(13) newer_version_of(rindex_208)
      rindex_208_1 (s : val, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  let int_sub = %int_barith.sub (Pstringlength, 1) in
  apply direct(rindex_rec_207_1)
    ($camlString__rindex_rec_256 : _ -> imm tagged) (s, int_sub, c) -> k * k1
in
let $camlString__rindex_257 = closure rindex_208_1 @rindex in
let code loopify(never) size(39) newer_version_of(rindex_from_209)
      rindex_from_209_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let prim = %int_comp.lt (i, -1) in
   switch prim
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_1 = %string_length (s) in
       let Pstringlength = %tag_imm (prim_1) in
       let prim_2 = %int_comp.ge (i, Pstringlength) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            apply direct(rindex_rec_207_1)
              ($camlString__rindex_rec_256 : _ -> imm tagged)
                (s, i, c)
                -> k * k1))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> imm tagged)
          ($camlString__immstring8440)
          -> never * k1
in
let $camlString__rindex_from_258 = closure rindex_from_209_1 @rindex_from in
let code rec loopify(done) size(41) newer_version_of(rindex_rec_opt_210)
      rindex_rec_opt_210_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  cont self (i)
    where rec self (i_1 : imm tagged) =
      let s_1 = s in
      let c_1 = c in
      let prim = %int_comp.lt (i_1, 0) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           let prim_1 = %num_conv.[`tagged_imm`].[`imm`] (i_1) in
           let prim_2 = %string_load.[`8`] (s_1, prim_1) in
           let Pstringrefu = %tag_imm (prim_2) in
           let prim_3 = %phys_eq (Pstringrefu, c_1) in
           (switch prim_3
              | 0 -> k2
              | 1 -> k3
              where k3 =
                let Pmakeblock = %block.[`0`] (i_1) in
                cont k (Pmakeblock)
              where k2 =
                let int_sub = %int_barith.sub (i_1, 1) in
                cont self (int_sub)))
in
let $camlString__rindex_rec_opt_259 =
  closure rindex_rec_opt_210_1 @rindex_rec_opt
in
let code loopify(never) size(13) newer_version_of(rindex_opt_211)
      rindex_opt_211_1 (s : val, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  let int_sub = %int_barith.sub (Pstringlength, 1) in
  apply direct(rindex_rec_opt_210_1)
    ($camlString__rindex_rec_opt_259 : _ -> [ 0 | 0 of val ])
      (s, int_sub, c)
      -> k * k1
in
let $camlString__rindex_opt_260 = closure rindex_opt_211_1 @rindex_opt in
let code loopify(never) size(39) newer_version_of(rindex_from_opt_212)
      rindex_from_opt_212_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val ] =
  (let prim = %int_comp.lt (i, -1) in
   switch prim
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_1 = %string_length (s) in
       let Pstringlength = %tag_imm (prim_1) in
       let prim_2 = %int_comp.ge (i, Pstringlength) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            apply direct(rindex_rec_opt_210_1)
              ($camlString__rindex_rec_opt_259 : _ -> [ 0 | 0 of val ])
                (s, i, c)
                -> k * k1))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> [ 0 | 0 of val ])
          ($camlString__immstring8487)
          -> never * k1
in
let $camlString__rindex_from_opt_261 =
  closure rindex_from_opt_212_1 @rindex_from_opt
in
let code loopify(never) size(62) newer_version_of(contains_from_213)
      contains_from_213_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %string_length (s) in
  let l = %tag_imm (prim) in
  (let prim_1 = %int_comp.lt (i, 0) in
   switch prim_1
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_2 = %int_comp.gt (i, l) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            let try_region = %begin_try_region () in
            let try_ghost_region = %begin_try_ghost_region () in
            (cont k4 push(k3)
               where k4 =
                 (apply direct(index_rec_201_1)
                    ($camlString__index_rec_250 : _ -> imm tagged)
                      (s, l, i, c)
                      -> k5 * k3
                    where k5 (param : imm tagged) =
                      cont k4
                    where k4 =
                      cont k pop(k3) (1))
               where k3 exn (`exn` : val) =
                 let `unit` = %end_try_region (try_region) in
                 let unit_1 = %end_try_ghost_region (try_ghost_region) in
                 let prim_3 =
                   %phys_eq (`exn`, $`*predef*`.caml_exn_Not_found)
                 in
                 switch prim_3
                   | 0 -> k1 pop(reraise k1) (`exn`)
                   | 1 -> k (0))))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> imm tagged)
          ($camlString__immstring8518)
          -> never * k1
in
let $camlString__contains_from_262 =
  closure contains_from_213_1 @contains_from
in
let code loopify(never) size(4) newer_version_of(contains_214)
      contains_214_1 (s : val, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  apply direct(contains_from_213_1)
    ($camlString__contains_from_262 : _ -> imm tagged) (s, 0, c) -> k * k1
in
let $camlString__contains_263 = closure contains_214_1 @contains in
let code loopify(never) size(62) newer_version_of(rcontains_from_215)
      rcontains_from_215_1 (s : val, i : imm tagged, c : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let prim = %int_comp.lt (i, 0) in
   switch prim
     | 0 -> k3
     | 1 -> k2
     where k3 =
       let prim_1 = %string_length (s) in
       let Pstringlength = %tag_imm (prim_1) in
       let prim_2 = %int_comp.ge (i, Pstringlength) in
       (switch prim_2
          | 0 -> k3
          | 1 -> k2
          where k3 =
            let try_region = %begin_try_region () in
            let try_ghost_region = %begin_try_ghost_region () in
            (cont k4 push(k3)
               where k4 =
                 (apply direct(rindex_rec_207_1)
                    ($camlString__rindex_rec_256 : _ -> imm tagged)
                      (s, i, c)
                      -> k5 * k3
                    where k5 (param : imm tagged) =
                      cont k4
                    where k4 =
                      cont k pop(k3) (1))
               where k3 exn (`exn` : val) =
                 let `unit` = %end_try_region (try_region) in
                 let unit_1 = %end_try_ghost_region (try_ghost_region) in
                 let prim_3 =
                   %phys_eq (`exn`, $`*predef*`.caml_exn_Not_found)
                 in
                 switch prim_3
                   | 0 -> k1 pop(reraise k1) (`exn`)
                   | 1 -> k (0))))
    where k2 =
      apply direct(invalid_arg_181_1)
        ($camlString__invalid_arg_230 : _ -> imm tagged)
          ($camlString__immstring8556)
          -> never * k1
in
let $camlString__rcontains_from_264 =
  closure rcontains_from_215_1 @rcontains_from
in
let code loopify(never) size(4) newer_version_of(uppercase_ascii_216)
      uppercase_ascii_216_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(map_49) inlining_state(depth(10))
    ($Bytes.camlBytes__map_132 : _ -> val)
      ($Char.camlChar__uppercase_ascii_19, s)
      -> k * k1
in
let $camlString__uppercase_ascii_265 =
  closure uppercase_ascii_216_1 @uppercase_ascii
in
let code loopify(never) size(4) newer_version_of(lowercase_ascii_217)
      lowercase_ascii_217_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(map_49) inlining_state(depth(10))
    ($Bytes.camlBytes__map_132 : _ -> val)
      ($Char.camlChar__lowercase_ascii_18, s)
      -> k * k1
in
let $camlString__lowercase_ascii_266 =
  closure lowercase_ascii_217_1 @lowercase_ascii
in
let code loopify(never) size(4) newer_version_of(capitalize_ascii_218)
      capitalize_ascii_218_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(apply1_53) inlining_state(depth(10))
    ($Bytes.camlBytes__apply1_136 : _ -> val)
      ($Char.camlChar__uppercase_ascii_19, s)
      -> k * k1
in
let $camlString__capitalize_ascii_267 =
  closure capitalize_ascii_218_1 @capitalize_ascii
in
let code loopify(never) size(4) newer_version_of(uncapitalize_ascii_219)
      uncapitalize_ascii_219_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(apply1_53) inlining_state(depth(10))
    ($Bytes.camlBytes__apply1_136 : _ -> val)
      ($Char.camlChar__lowercase_ascii_18, s)
      -> k * k1
in
let $camlString__uncapitalize_ascii_268 =
  closure uncapitalize_ascii_219_1 @uncapitalize_ascii
in
let code loopify(never) size(4) newer_version_of(compare_220)
      compare_220_1 (x : val, y : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  apply ccall noalloc
    ($`*extern*`.caml_string_compare : val * val -> val) (x, y) -> k * k1
in
let $camlString__compare_269 = closure compare_220_1 @compare in
let code loopify(never) size(85) newer_version_of(split_on_char_221)
      split_on_char_221_1 (sep : imm tagged, s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %string_length (s) in
  let Pstringlength = %tag_imm (prim) in
  let for_start = %int_barith.sub (Pstringlength, 1) in
  (let prim_1 = %int_comp.ge (for_start, 0) in
   switch prim_1
     | 0 -> k2 (0, Pstringlength)
     | 1 -> k3
     where k3 =
       (cont k3 (for_start, 0, Pstringlength)
          where rec k3
                      (i : imm tagged,
                       r_756_unboxed0 :
                         [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                       j_757_unboxed0 : imm tagged) =
            ((let prim_2 = %num_conv.[`tagged_imm`].[`imm`] (i) in
              let prim_3 = %string_load.[`8`] (s, prim_2) in
              let Pstringrefu = %tag_imm (prim_3) in
              let prim_4 = %phys_eq (Pstringrefu, sep) in
              switch prim_4
                | 0 -> k4 (r_756_unboxed0, j_757_unboxed0)
                | 1 -> k5
                where k5 =
                  let int_sub = %int_barith.sub (j_757_unboxed0, i) in
                  let int_sub_1 = %int_barith.sub (int_sub, 1) in
                  let int_add = %int_barith.add (i, 1) in
                  (apply direct(sub_32) inlining_state(depth(10))
                     ($Bytes.camlBytes__sub_115 : _ -> val)
                       (s, int_add, int_sub_1)
                       -> k5 * k1
                     where k5 (return_val0 : val) =
                       let Pmakeblock =
                         %block.[`0`] (return_val0, r_756_unboxed0)
                       in
                       cont k4 (Pmakeblock, i)))
               where k4
                       (r_756_unboxed0_1 :
                          [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                        j_757_unboxed0_1 : imm tagged) =
                 let prim_2 = %int_comp.ne (i, 0) in
                 (switch prim_2
                    | 0 -> k2 (r_756_unboxed0_1, j_757_unboxed0_1)
                    | 1 -> k4
                    where k4 =
                      let int_pred = %int_barith.sub (i, 1) in
                      cont k3 (int_pred, r_756_unboxed0_1, j_757_unboxed0_1)))))
    where k2
            (r_756_unboxed0 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
             j_757_unboxed0 : imm tagged) =
      (apply direct(sub_32) inlining_state(depth(10))
         ($Bytes.camlBytes__sub_115 : _ -> val)
           (s, 0, j_757_unboxed0)
           -> k2 * k1
         where k2 (return_val0 : val) =
           let Pmakeblock = %block.[`0`] (return_val0, r_756_unboxed0) in
           cont k (Pmakeblock))
in
let $camlString__split_on_char_270 =
  closure split_on_char_221_1 @split_on_char
in
let code loopify(never) size(4) newer_version_of(uppercase_222)
      uppercase_222_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(map_49) inlining_state(depth(10))
    ($Bytes.camlBytes__map_132 : _ -> val)
      ($Char.camlChar__uppercase_17, s)
      -> k * k1
in
let $camlString__uppercase_271 = closure uppercase_222_1 @uppercase in
let code loopify(never) size(4) newer_version_of(lowercase_223)
      lowercase_223_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(map_49) inlining_state(depth(10))
    ($Bytes.camlBytes__map_132 : _ -> val)
      ($Char.camlChar__lowercase_16, s)
      -> k * k1
in
let $camlString__lowercase_272 = closure lowercase_223_1 @lowercase in
let code loopify(never) size(4) newer_version_of(capitalize_224)
      capitalize_224_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(apply1_53) inlining_state(depth(10))
    ($Bytes.camlBytes__apply1_136 : _ -> val)
      ($Char.camlChar__uppercase_17, s)
      -> k * k1
in
let $camlString__capitalize_273 = closure capitalize_224_1 @capitalize in
let code loopify(never) size(4) newer_version_of(uncapitalize_225)
      uncapitalize_225_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(apply1_53) inlining_state(depth(10))
    ($Bytes.camlBytes__apply1_136 : _ -> val)
      ($Char.camlChar__lowercase_16, s)
      -> k * k1
in
let $camlString__uncapitalize_274 = closure uncapitalize_225_1 @uncapitalize
in
let code loopify(never) size(4) newer_version_of(to_seq_226)
      to_seq_226_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(to_seq_76)
    ($Bytes.camlBytes__to_seq_159 : _ -> val) (s) -> k * k1
in
let $camlString__to_seq_275 = closure to_seq_226_1 @to_seq in
let code loopify(never) size(4) newer_version_of(to_seqi_227)
      to_seqi_227_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(to_seqi_80)
    ($Bytes.camlBytes__to_seqi_160 : _ -> val) (s) -> k * k1
in
let $camlString__to_seqi_276 = closure to_seqi_227_1 @to_seqi in
let code loopify(never) size(4) newer_version_of(of_seq_228)
      of_seq_228_1 (g : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  apply direct(of_seq_84)
    ($Bytes.camlBytes__of_seq_161 : _ -> val) (g) -> k * k1
in
let $camlString__of_seq_277 = closure of_seq_228_1 @of_seq in
let $camlString =
  Block 0 ($camlString__failwith_229,
           $camlString__invalid_arg_230,
           $`camlString__@_231`,
           $camlString__bts_232,
           $camlString__bos_233,
           $camlString__make_234,
           $camlString__init_235,
           $camlString__copy_236,
           $camlString__sub_237,
           $Bytes.camlBytes__fill_119,
           $Bytes.camlBytes__blit_string_121,
           $camlString__ensure_ge_238,
           $camlString__sum_lengths_239,
           $camlString__unsafe_blits_240,
           $camlString__concat_241,
           $camlString__iter_242,
           $camlString__iteri_243,
           $camlString__map_244,
           $camlString__mapi_245,
           $camlString__is_space_246,
           $camlString__trim_247,
           $camlString__escaped_248,
           $camlString__index_rec_250,
           $camlString__index_251,
           $camlString__index_rec_opt_252,
           $camlString__index_opt_253,
           $camlString__index_from_254,
           $camlString__index_from_opt_255,
           $camlString__rindex_rec_256,
           $camlString__rindex_257,
           $camlString__rindex_from_258,
           $camlString__rindex_rec_opt_259,
           $camlString__rindex_opt_260,
           $camlString__rindex_from_opt_261,
           $camlString__contains_from_262,
           $camlString__contains_263,
           $camlString__rcontains_from_264,
           $camlString__uppercase_ascii_265,
           $camlString__lowercase_ascii_266,
           $camlString__capitalize_ascii_267,
           $camlString__uncapitalize_ascii_268,
           $camlString__compare_269,
           $camlString__split_on_char_270,
           $camlString__uppercase_271,
           $camlString__lowercase_272,
           $camlString__capitalize_273,
           $camlString__uncapitalize_274,
           $camlString__to_seq_275,
           $camlString__to_seqi_276,
           $camlString__of_seq_277)
in
cont done ($camlString)
