let code `fn[tests8.ml:20,62--77]_2` deleted in
let code `fn[tests8.ml:20,49--61]_3` deleted in
let code map_foo_0 deleted and code `fn[tests8.ml:20,12--80]_1` deleted in
let code loopify(never) size(1) newer_version_of(`fn[tests8.ml:20,49--61]_3`)
      `fn[tests8.ml:20,49--61]_3_1` (x : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont k (x)
in
let $`camlTests8__fn[tests8.ml:20,49--61]_6` =
  closure `fn[tests8.ml:20,49--61]_3_1` @`fn[tests8.ml:20,49--61]`
in
let code loopify(never) size(1) newer_version_of(`fn[tests8.ml:20,62--77]_2`)
      `fn[tests8.ml:20,62--77]_2_1` (param : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * val ] =
  cont k (0)
in
let $`camlTests8__fn[tests8.ml:20,62--77]_5` =
  closure `fn[tests8.ml:20,62--77]_2_1` @`fn[tests8.ml:20,62--77]`
in
let $camlTests8__map_foo_4 =
  closure map_foo_0_1 @map_foo
and code rec loopify(never) size(44) newer_version_of(map_foo_0)
      map_foo_0_1 (f : val, seq : val, param : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * val ] =
  apply seq (0) -> k2 * k1
    where k2 (`*match*` : [ 0 | 0 of val * val ]) =
      let prim = %is_int (`*match*`) in
      (switch prim
         | 0 -> k2
         | 1 -> k (0)
         where k2 =
           let `fn[tests8.ml:20,12--80]` =
             closure `fn[tests8.ml:20,12--80]_1_1` @`fn[tests8.ml:20,12--80]`
           with {
             my_closure =
               $camlTests8__map_foo_4 ~ depth my_depth -> succ my_depth
           }
           in
           ((let Pfield = %block_load.[`0`] (`*match*`) in
             apply f (Pfield) -> k2 * k1)
              where k2 (apply_result : val) =
                let Pmakeblock =
                  %block.[`0`] (apply_result, `fn[tests8.ml:20,12--80]`)
                in
                cont k (Pmakeblock)))
and code loopify(never) size(4) newer_version_of(`fn[tests8.ml:20,12--80]_1`)
      `fn[tests8.ml:20,12--80]_1_1` (param : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * val ] =
  apply direct(map_foo_0_1) inlined(never)
    ($camlTests8__map_foo_4 ~ depth do_not_inline -> do_not_inline
     : _ -> [ 0 | 0 of val * val ])
      ($`camlTests8__fn[tests8.ml:20,49--61]_6`,
       $`camlTests8__fn[tests8.ml:20,62--77]_5`,
       0)
      -> k * k1
in
let $camlTests8 = Block 0 ($camlTests8__map_foo_4) in
cont done ($camlTests8)
