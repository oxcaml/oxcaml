let code invalid_arg_1 deleted in
let $camlB__immstring35 = "foo" in
let code `++_2` deleted in
let code extend_0 deleted in
let code loopify(never) size(10) newer_version_of(invalid_arg_1)
      invalid_arg_1_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlB__invalid_arg_4 = closure invalid_arg_1_1 @invalid_arg in
let code loopify(never) size(28) newer_version_of(`++_2`)
      `++_2_1` (a : imm tagged, b : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %int_comp.lt (a, 0) in
  let prim_1 = %int_comp.lt (b, 0) in
  switch prim
    | 0 -> k2
    | 1 -> k3
    where k3 =
      switch prim_1
        | 0 -> k2
        | 1 -> k (42)
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlB__invalid_arg_4 : _ -> imm tagged)
          ($camlB__immstring35)
          -> never * k1
in
let $`camlB__++_5` = closure `++_2_1` @`++` in
let code loopify(never) size(20) newer_version_of(extend_0)
      extend_0_1 (s : imm tagged, left : imm tagged, right : imm tagged)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  apply direct(`++_2_1`)
    ($`camlB__++_5` : _ -> imm tagged) (s, left) -> k3 * k1
    where k3 (apply_result : imm tagged) =
      apply direct(`++_2_1`)
        ($`camlB__++_5` : _ -> imm tagged) (apply_result, right) -> k2 * k1
    where k2 (x : imm tagged) =
      let prim = %int_comp.lt (left, 0) in
      switch prim
        | 0 -> k (x)
        | 1 -> k (0)
in
let $camlB__extend_3 = closure extend_0_1 @extend in
let $camlB = Block 0 ($camlB__extend_3) in
cont done ($camlB)
