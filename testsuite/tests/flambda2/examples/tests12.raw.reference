let $camlTests12__first_const = Block 0 () in
(let code size(1)
       `fn[tests12.ml:25,52--67]_2` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (0)
 in
 let code size(1)
       `fn[tests12.ml:25,39--51]_3` (x)
         my_closure _region _ghost_region my_depth
         -> k1 * k2 =
   let next_depth = rec_info (succ my_depth) in
   cont k1 (x)
 in
 let code size(23)
       `fn[tests12.ml:25,2--70]_1` (param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2 =
   let next_depth = rec_info (succ my_depth) in
   let map_foo =
     %project_value_slot.[`fn[tests12.ml:25,2--70]`].[`map_foo`] (my_closure)
   in
   let `fn[tests12.ml:25,52--67]` =
     closure `fn[tests12.ml:25,52--67]_2` @`fn[tests12.ml:25,52--67]`
   in
   let `fn[tests12.ml:25,39--51]` =
     closure `fn[tests12.ml:25,39--51]_3` @`fn[tests12.ml:25,39--51]`
   in
   apply inlined(never)
     map_foo
       (`fn[tests12.ml:25,39--51]`, `fn[tests12.ml:25,52--67]`, 0)
       -> k1 * k2
 in
 let code inline(always) size(32)
       bar_0 (map_foo : val)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : val =
   let next_depth = rec_info (succ my_depth) in
   let `fn[tests12.ml:25,2--70]` =
     closure `fn[tests12.ml:25,2--70]_1` @`fn[tests12.ml:25,2--70]`
   with { map_foo = map_foo }
   in
   cont k1 (`fn[tests12.ml:25,2--70]`)
 in
 let code rec size(64)
       map_foo_4 (f : val, seq : val, param : imm tagged)
         my_closure _region _ghost_region my_depth
         -> k1 * k2
         : [ 0 | 0 of val * val ] =
   let next_depth = rec_info (succ my_depth) in
   let bar = %project_value_slot.[`map_foo`].[`bar`] (my_closure) in
   apply seq (0) -> k3 * k2
     where k3 (`*match*` : [ 0 | 0 of val * val ]) =
       ((let prim = %is_int (`*match*`) in
         let Pisint = %tag_imm (prim) in
         (let untagged = %untag_imm (Pisint) in
          switch untagged
            | 0 -> k4
            | 1 -> k1 (0))
           where k4 =
             cont k3)
          where k3 =
            ((let Popaque = %opaque (0) in
              (let untagged = %untag_imm (Popaque) in
               switch untagged
                 | 0 -> k6
                 | 1 -> k7)
                where k7 =
                  cont k4
                where k6 =
                  cont k5)
               where k5 =
                 apply direct(bar_0)
                   (bar : _ -> val)
                     (my_closure ~ depth my_depth -> next_depth)
                     -> k3 * k2
               where k4 =
                 apply direct(bar_0)
                   (bar : _ -> val)
                     (my_closure ~ depth my_depth -> next_depth)
                     -> k3 * k2
               where k3 (g : val) =
                 (apply inlined(always) g (0) -> k3 * k2
                    where k3 (g_result : [ 0 | 0 of val * val ]) =
                      let Popaque = %opaque (g_result) in
                      ((let Pfield = %block_load.[`0`] (`*match*`) in
                        apply f (Pfield) -> k3 * k2)
                         where k3 (apply_result : val) =
                           let Pmakeblock = %block.[`0`] (apply_result, g) in
                           cont k1 (Pmakeblock)))))
 in
 let bar = closure bar_0 @bar in
 let map_foo = closure map_foo_4 @map_foo with { bar = bar } in
 let Pmakeblock = %block.[`0`] (bar, map_foo) in
 cont k (Pmakeblock))
  where k define_root_symbol (module_block) =
    let field_0 = %block_load.tag[`0`].`size`[`2`].[`0`] (module_block) in
    let field_1 = %block_load.tag[`0`].`size`[`2`].[`1`] (module_block) in
    let $camlTests12 = Block 0 (field_0, field_1) in
    cont done ($camlTests12)
