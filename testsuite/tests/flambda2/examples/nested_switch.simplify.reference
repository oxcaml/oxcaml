let code test_0 deleted in
let code f_1 deleted in
let code inline(always) loopify(never) size(31) newer_version_of(test_0)
      test_0_1 (foo : imm tagged, x, y)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (foo) in
   switch untagged
     | 0 -> k2
     | 1 -> k3)
    where k3 =
      apply ccall
        ($`*extern*`.caml_lessthan : val * val -> val) (x, y) -> k * k1
    where k2 =
      apply ccall
        ($`*extern*`.caml_greaterthan : val * val -> val) (x, y) -> k * k1
in
let $camlNested_switch__test_2 = closure test_0_1 @test in
let code loopify(never) size(21) newer_version_of(f_1)
      f_1_1 (foo : imm tagged, x, y)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : imm tagged =
  (let untagged = %untag_imm (foo) in
   switch untagged
     | 0 -> k2
     | 1 -> k (0))
    where k2 =
      apply ccall inlining_state(depth(1))
        ($`*extern*`.caml_greaterthan : val * val -> val) (x, y) -> k * k1
in
let $camlNested_switch__f_3 = closure f_1_1 @f in
let $camlNested_switch =
  Block 0 ($camlNested_switch__test_2, $camlNested_switch__f_3)
in
cont done ($camlNested_switch)
