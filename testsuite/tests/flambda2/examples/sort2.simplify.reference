let code failwith_0 deleted in
let code invalid_arg_1 deleted in
let code `@_2` deleted in
let $camlSort2__immstring56 = "List.fold_left2" in
let code f1_71 deleted in
let code f2_72 deleted in
let code f3_73 deleted in
let code f4_74 deleted in
let code loopify(never) size(10) newer_version_of(failwith_0)
      failwith_0_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlSort2__failwith_75 = closure failwith_0_1 @failwith in
let code loopify(never) size(10) newer_version_of(invalid_arg_1)
      invalid_arg_1_1 (s : val)
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s) in
  cont k1 pop(regular k1) (Pmakeblock)
in
let $camlSort2__invalid_arg_76 = closure invalid_arg_1_1 @invalid_arg in
let $`camlSort2__@_77` =
  closure `@_2_1` @`@`
and code rec loopify(never) size(25) newer_version_of(`@_2`)
      `@_2_1`
        (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int (l1) in
  switch prim
    | 0 -> k2
    | 1 -> k (l2)
    where k2 =
      ((let Pfield = %block_load.[`1`] (l1) in
        apply direct(`@_2_1`)
          ($`camlSort2__@_77` ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (Pfield, l2)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           let Pfield = %block_load.[`0`] (l1) in
           let Pmakeblock = %block.[`0`] (Pfield, apply_result) in
           cont k (Pmakeblock))
in
let code rec loopify(done) size(49) newer_version_of(f1_71)
      f1_71_1
        (f : val,
         accu : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  cont self (accu, l1, l2)
    where rec self
                (accu_1 : val,
                 l1_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                 l2_1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
      let f_1 = f in
      ((let prim = %is_int (l1_1) in
        switch prim
          | 0 -> k3
          | 1 -> k4
          where k4 =
            let prim_1 = %is_int (l2_1) in
            switch prim_1
              | 0 -> k2
              | 1 -> k (accu_1)
          where k3 =
            let prim_1 = %is_int (l2_1) in
            (switch prim_1
               | 0 -> k3
               | 1 -> k2
               where k3 =
                 let Pfield = %block_load.[`1`] (l2_1) in
                 let Pfield_1 = %block_load.[`1`] (l1_1) in
                 ((let Pfield_2 = %block_load.[`0`] (l2_1) in
                   let Pfield_3 = %block_load.[`0`] (l1_1) in
                   apply f_1 (accu_1, Pfield_3, Pfield_2) -> k3 * k1)
                    where k3 (apply_result : val) =
                      cont self (apply_result, Pfield_1, Pfield))))
         where k2 =
           apply direct(invalid_arg_1_1)
             ($camlSort2__invalid_arg_76 : _ -> val)
               ($camlSort2__immstring56)
               -> never * k1)
in
let $camlSort2__f1_146 = closure f1_71_1 @f1 in
let code loopify(never) size(51) newer_version_of(f2_72)
      f2_72_1
        (f : val,
         accu : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  (let prim = %is_int (l1) in
   switch prim
     | 0 -> k3
     | 1 -> k4
     where k4 =
       let prim_1 = %is_int (l2) in
       switch prim_1
         | 0 -> k2
         | 1 -> k (accu)
     where k3 =
       let prim_1 = %is_int (l2) in
       (switch prim_1
          | 0 -> k3
          | 1 -> k2
          where k3 =
            let Pfield = %block_load.[`1`] (l2) in
            let Pfield_1 = %block_load.[`1`] (l1) in
            ((let Pfield_2 = %block_load.[`0`] (l2) in
              let Pfield_3 = %block_load.[`0`] (l1) in
              apply f (accu, Pfield_3, Pfield_2) -> k3 * k1)
               where k3 (apply_result : val) =
                 apply direct(f1_71_1)
                   ($camlSort2__f1_146 : _ -> val)
                     (f, apply_result, Pfield_1, Pfield)
                     -> k * k1)))
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlSort2__invalid_arg_76 : _ -> val)
          ($camlSort2__immstring56)
          -> never * k1
in
let $camlSort2__f2_147 = closure f2_72_1 @f2 in
let code loopify(never) size(51) newer_version_of(f3_73)
      f3_73_1
        (f : val,
         accu : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  (let prim = %is_int (l1) in
   switch prim
     | 0 -> k3
     | 1 -> k4
     where k4 =
       let prim_1 = %is_int (l2) in
       switch prim_1
         | 0 -> k2
         | 1 -> k (accu)
     where k3 =
       let prim_1 = %is_int (l2) in
       (switch prim_1
          | 0 -> k3
          | 1 -> k2
          where k3 =
            let Pfield = %block_load.[`1`] (l2) in
            let Pfield_1 = %block_load.[`1`] (l1) in
            ((let Pfield_2 = %block_load.[`0`] (l2) in
              let Pfield_3 = %block_load.[`0`] (l1) in
              apply f (accu, Pfield_3, Pfield_2) -> k3 * k1)
               where k3 (apply_result : val) =
                 apply direct(f1_71_1)
                   ($camlSort2__f1_146 : _ -> val)
                     (f, apply_result, Pfield_1, Pfield)
                     -> k * k1)))
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlSort2__invalid_arg_76 : _ -> val)
          ($camlSort2__immstring56)
          -> never * k1
in
let $camlSort2__f3_148 = closure f3_73_1 @f3 in
let code loopify(never) size(51) newer_version_of(f4_74)
      f4_74_1
        (f : val,
         accu : val,
         l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
         l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure _region _ghost_region my_depth
        -> k * k1
        : val =
  (let prim = %is_int (l1) in
   switch prim
     | 0 -> k3
     | 1 -> k4
     where k4 =
       let prim_1 = %is_int (l2) in
       switch prim_1
         | 0 -> k2
         | 1 -> k (accu)
     where k3 =
       let prim_1 = %is_int (l2) in
       (switch prim_1
          | 0 -> k3
          | 1 -> k2
          where k3 =
            let Pfield = %block_load.[`1`] (l2) in
            let Pfield_1 = %block_load.[`1`] (l1) in
            ((let Pfield_2 = %block_load.[`0`] (l2) in
              let Pfield_3 = %block_load.[`0`] (l1) in
              apply f (accu, Pfield_3, Pfield_2) -> k3 * k1)
               where k3 (apply_result : val) =
                 apply direct(f1_71_1)
                   ($camlSort2__f1_146 : _ -> val)
                     (f, apply_result, Pfield_1, Pfield)
                     -> k * k1)))
    where k2 =
      apply direct(invalid_arg_1_1)
        ($camlSort2__invalid_arg_76 : _ -> val)
          ($camlSort2__immstring56)
          -> never * k1
in
let $camlSort2__f4_149 = closure f4_74_1 @f4 in
let $camlSort2 =
  Block 0 ($camlSort2__failwith_75,
           $camlSort2__invalid_arg_76,
           $`camlSort2__@_77`,
           $camlSort2__f1_146,
           $camlSort2__f2_147,
           $camlSort2__f3_148,
           $camlSort2__f4_149)
in
cont done ($camlSort2)
