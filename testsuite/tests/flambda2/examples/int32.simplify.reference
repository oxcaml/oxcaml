let code failwith_0 deleted in
let code invalid_arg_1 deleted in
let code min_2 deleted in
let code max_3 deleted in
let code abs_4 deleted in
let code lnot_5 deleted in
let $camlInt32__int3299 = 1l in
let code succ_6 deleted in
let code pred_7 deleted in
let $camlInt32__int3296 = 0l in
let code abs_8 deleted in
let $camlInt32__int32102 = -1l in
let code lognot_9 deleted in
let code `fn[int32.ml:572,4--81]_11` deleted in
let $camlInt32__immstring188 = "0x1_0000_0000" in
let $camlInt32__int32139 = 2147483647l in
let $camlInt32__int32136 = -2147483648l in
let $camlInt32__immstring32 = "Int32.Stdlib.Exit" in
let $camlInt32__immstring10 = "Pervasives.array_bound_error" in
let $camlInt32__immstring7 = "index out of bounds" in
let $camlInt32__Pmakeblock229 =
  Block 0 ($`*predef*`.caml_exn_Invalid_argument, $camlInt32__immstring7)
in
apply ccall
  ($`*extern*`.caml_register_named_value : val * val -> val)
    ($camlInt32__immstring10, $camlInt32__Pmakeblock229)
    -> k1 * error
  where k1 (param) =
    cont k
  where k =
    let code loopify(never) size(10) newer_version_of(failwith_0)
          failwith_0_1 (s : val)
            my_closure _region _ghost_region my_depth
            -> k * k1
            : val =
      let Pmakeblock = %block.[`0`] ($`*predef*`.caml_exn_Failure, s) in
      cont k1 pop(regular k1) (Pmakeblock)
    in
    let $camlInt32__failwith_12 = closure failwith_0_1 @failwith in
    let code loopify(never) size(10) newer_version_of(invalid_arg_1)
          invalid_arg_1_1 (s : val)
            my_closure _region _ghost_region my_depth
            -> k * k1
            : val =
      let Pmakeblock =
        %block.[`0`] ($`*predef*`.caml_exn_Invalid_argument, s)
      in
      cont k1 pop(regular k1) (Pmakeblock)
    in
    let $camlInt32__invalid_arg_13 = closure invalid_arg_1_1 @invalid_arg in
    (apply ccall noalloc
       ($`*extern*`.caml_fresh_oo_id : val -> val) (0) -> k * error
       where k (Pccall) =
         let $camlInt32__Exit248 =
           Block immutable_unique
           248 ($camlInt32__immstring32, Pccall)
         in
         let code loopify(never) size(21) newer_version_of(min_2)
               min_2_1 (x : val, y : val)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : val =
           apply ccall
             ($`*extern*`.caml_lessequal : val * val -> val)
               (x, y)
               -> k2 * k1
             where k2 (Pccall_1) =
               let untagged = %untag_imm (Pccall_1) in
               switch untagged
                 | 0 -> k (y)
                 | 1 -> k (x)
         in
         let $camlInt32__min_14 = closure min_2_1 @min in
         let code loopify(never) size(21) newer_version_of(max_3)
               max_3_1 (x : val, y : val)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : val =
           apply ccall
             ($`*extern*`.caml_greaterequal : val * val -> val)
               (x, y)
               -> k2 * k1
             where k2 (Pccall_1) =
               let untagged = %untag_imm (Pccall_1) in
               switch untagged
                 | 0 -> k (y)
                 | 1 -> k (x)
         in
         let $camlInt32__max_15 = closure max_3_1 @max in
         let code loopify(never) size(15) newer_version_of(abs_4)
               abs_4_1 (x : imm tagged)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : imm tagged =
           let prim = %int_comp.ge (x, 0) in
           switch prim
             | 0 -> k2
             | 1 -> k (x)
             where k2 =
               let int_neg = %int_barith.sub (0, x) in
               cont k (int_neg)
         in
         let $camlInt32__abs_16 = closure abs_4_1 @abs in
         let code loopify(never) size(3) newer_version_of(lnot_5)
               lnot_5_1 (x : imm tagged)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : imm tagged =
           let int_xor = %int_barith.xor (x, -1) in
           cont k (int_xor)
         in
         let $camlInt32__lnot_17 = closure lnot_5_1 @lnot in
         let $camlInt32__Pmakeblock299 =
           Block 0 ($camlInt32__failwith_12,
                    $camlInt32__invalid_arg_13,
                    $camlInt32__Exit248,
                    $`*predef*`.caml_exn_Match_failure,
                    $`*predef*`.caml_exn_Assert_failure,
                    $`*predef*`.caml_exn_Invalid_argument,
                    $`*predef*`.caml_exn_Failure,
                    $`*predef*`.caml_exn_Not_found,
                    $`*predef*`.caml_exn_Out_of_memory,
                    $`*predef*`.caml_exn_Stack_overflow,
                    $`*predef*`.caml_exn_Sys_error,
                    $`*predef*`.caml_exn_End_of_file,
                    $`*predef*`.caml_exn_Division_by_zero,
                    $`*predef*`.caml_exn_Sys_blocked_io,
                    $`*predef*`.caml_exn_Undefined_recursive_module,
                    $camlInt32__min_14,
                    $camlInt32__max_15,
                    $camlInt32__abs_16,
                    $camlInt32__lnot_17,
                    4611686018427387903,
                    -4611686018427387904)
         in
         let code loopify(never) size(10) newer_version_of(succ_6)
               succ_6_1 (n : int32 boxed)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : int32 boxed =
           let prim = %unbox_num.`int32` (n) in
           let prim_1 = %int_barith.`int32`.add (prim, 1l) in
           let int32_add = %box_num.`int32` (prim_1) in
           cont k (int32_add)
         in
         let $camlInt32__succ_18 = closure succ_6_1 @`succ` in
         let code loopify(never) size(10) newer_version_of(pred_7)
               pred_7_1 (n : int32 boxed)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : int32 boxed =
           let prim = %unbox_num.`int32` (n) in
           let prim_1 = %int_barith.`int32`.sub (prim, 1l) in
           let int32_sub = %box_num.`int32` (prim_1) in
           cont k (int32_sub)
         in
         let $camlInt32__pred_19 = closure pred_7_1 @pred in
         let code loopify(never) size(22) newer_version_of(abs_8)
               abs_8_1 (n : int32 boxed)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : int32 boxed =
           let prim = %unbox_num.`int32` (n) in
           let prim_1 = %int_comp.`int32`.ge (prim, 0l) in
           switch prim_1
             | 0 -> k2
             | 1 -> k (n)
             where k2 =
               let prim_2 = %int_barith.`int32`.sub (0l, prim) in
               let int32_neg = %box_num.`int32` (prim_2) in
               cont k (int32_neg)
         in
         let $camlInt32__abs_20 = closure abs_8_1 @abs_1 in
         let code loopify(never) size(10) newer_version_of(lognot_9)
               lognot_9_1 (n : int32 boxed)
                 my_closure _region _ghost_region my_depth
                 -> k * k1
                 : int32 boxed =
           let prim = %unbox_num.`int32` (n) in
           let prim_1 = %int_barith.`int32`.xor (prim, -1l) in
           let int32_xor = %box_num.`int32` (prim_1) in
           cont k (int32_xor)
         in
         let $camlInt32__lognot_21 = closure lognot_9_1 @lognot in
         (apply ccall
            ($`*extern*`.caml_int_of_string : val -> val)
              ($camlInt32__immstring188)
              -> k * error
            where k (move) =
              let $`camlInt32__fn[int32.ml:572,4--81]_22` =
                closure `fn[int32.ml:572,4--81]_11_1`
                  @`fn[int32.ml:572,4--81]`
              and code loopify(never) size(27) newer_version_of(`fn[int32.ml:572,4--81]_11`)
                    `fn[int32.ml:572,4--81]_11_1` (n : int32 boxed)
                      my_closure _region _ghost_region my_depth
                      -> k * k1
                      : [ 0 | 0 of val ] =
                let move_1 =
                  %project_value_slot.[`fn[int32.ml:572,4--81]`].[`move`]
                    ($`camlInt32__fn[int32.ml:572,4--81]_22`)
                in
                let prim = %unbox_num.`int32` (n) in
                let prim_1 = %num_conv.[`int32`].[`imm`] (prim) in
                let i = %tag_imm (prim_1) in
                (let prim_2 = %int_comp.lt (i, 0) in
                 switch prim_2
                   | 0 -> k2 (i)
                   | 1 -> k3
                   where k3 =
                     let int_add = %int_barith.add (i, move_1) in
                     cont k2 (int_add))
                  where k2 (staticcatch_result : imm tagged) =
                    let Pmakeblock = %block.[`0`] (staticcatch_result) in
                    cont k (Pmakeblock)
                with { move = move }
              in
              let $camlInt32 =
                Block 0 ($camlInt32__Pmakeblock299,
                         $camlInt32__int3296,
                         $camlInt32__int3299,
                         $camlInt32__int32102,
                         $camlInt32__succ_18,
                         $camlInt32__pred_19,
                         $camlInt32__abs_20,
                         $camlInt32__int32136,
                         $camlInt32__int32139,
                         $camlInt32__lognot_21,
                         $`camlInt32__fn[int32.ml:572,4--81]_22`)
              in
              cont done ($camlInt32)))
