diff --git a/Changes b/Changes
index 6e4fd28754e1..9e2231003268 100644
--- a/Changes
+++ b/Changes
@@ -3053,6 +3053,10 @@ OCaml 4.14 maintenance version
   (emitted for Linux in #8805)
   (Hannes Mehnert, review by Nicolás Ojeda Bär)
 
+- #13448, #13449: fix a code-generation bug on unsafe array accesses
+  at type int32, int64, nativeint, which has been introduced in OCaml 4.04.
+  (Gabriel Scherer, review by Nicolás Ojeda Bär and Vincent Laviron,
+   report by Simon Cruanes)
 
 OCaml 4.14.1 (20 December 2022)
 ------------------------------
diff --git a/asmcomp/cmmgen.ml b/asmcomp/cmmgen.ml
index edbfeaa1a795..28c317fc2b34 100644
--- a/asmcomp/cmmgen.ml
+++ b/asmcomp/cmmgen.ml
@@ -238,6 +238,21 @@ type unboxed_number_kind =
   | Boxed of boxed_number * bool (* true: boxed form available at no cost *)
   | No_result (* expression never returns a result *)
 
+(* A value kind [vk] is compatible with a boxed-number kind [bk]
+   if the boxing operation [bk] returns a value that may live in the
+   value kind [vk]. *)
+let compatible_kind vk bk =
+  match bk with
+  | No_unboxing | No_result -> true
+  | Boxed (bn, _) ->
+      match bn, vk with
+      | _, Pgenval -> true
+      | (Boxed_float _ | Boxed_integer _), Pintval -> false
+      | Boxed_float _, Pfloatval -> true
+      | Boxed_integer _, Pfloatval -> false
+      | Boxed_float _, Pboxedintval _ -> false
+      | Boxed_integer (bi1, _), Pboxedintval bi2 -> bi1 = bi2
+
 (* Given unboxed_number_kind from two branches of the code, returns the
    resulting unboxed_number_kind.
 
@@ -259,10 +274,24 @@ let join_unboxed_number_kind ~strict k1 k2 =
       k
   | _, _ -> No_unboxing
 
-let is_unboxed_number_cmm ~strict cmm =
+(* [is_unboxed_number_cmm ~strict ~kind cmm] computes an unboxed
+   number kind for the value returned by the expression [cmm].
+
+   See [join_unboxed_number_kind] above for the meaning of the
+   [~strict] parameter.
+
+   [~kind] is the value kind expected for the return value. If the
+   expression contains branches returning different boxed number
+   kinds, only those that are compatible with the expected return kind
+   are considered -- the other must be unreachable if the program is
+   well-typed. In particular, the unboxed number kind we return shall
+   be compatible with it in the sense of [compatible_kind] above.
+*)
+let is_unboxed_number_cmm ~strict ~kind cmm =
   let r = ref No_result in
   let notify k =
-    r := join_unboxed_number_kind ~strict !r k
+    if compatible_kind kind k then
+      r := join_unboxed_number_kind ~strict !r k
   in
   let rec aux = function
     | Cop(Calloc, [Cconst_natint (hdr, _); _], dbg)
@@ -666,7 +695,7 @@ and transl_catch env nfail ids body handler dbg =
            | Pintval | Pgenval -> true
          in
          u := join_unboxed_number_kind ~strict !u
-             (is_unboxed_number_cmm ~strict c)
+             (is_unboxed_number_cmm ~strict ~kind c)
       )
       ids args
   in
@@ -1179,14 +1208,14 @@ and transl_let env str kind id exp transl_body =
         (* It would be safe to always unbox in this case, but
            we do it only if this indeed allows us to get rid of
            some allocations in the bound expression. *)
-        is_unboxed_number_cmm ~strict:false cexp
+        is_unboxed_number_cmm ~strict:false ~kind cexp
     | _, Pgenval ->
         (* Here we don't know statically that the bound expression
            evaluates to an unboxable number type.  We need to be stricter
            and ensure that all possible branches in the expression
            return a boxed value (of the same kind).  Indeed, with GADTs,
            different branches could return different types. *)
-        is_unboxed_number_cmm ~strict:true cexp
+        is_unboxed_number_cmm ~strict:true ~kind cexp
     | _, Pintval ->
         No_unboxing
   in
diff --git a/testsuite/tests/float-unboxing/bug13448.ml b/testsuite/tests/float-unboxing/bug13448.ml
new file mode 100644
index 000000000000..3a8d7de603cd
--- /dev/null
+++ b/testsuite/tests/float-unboxing/bug13448.ml
@@ -0,0 +1,19 @@
+(* TEST *)
+
+(* Regression test for #13448, see explanations in #13449.
+   This minimized test was proposed by Nicolas Ojeda Bar.
+*)
+
+external unsafe_get : 'a array -> int -> 'a = "%array_unsafe_get"
+let uget =
+  (* This intermediate definition avoids primitive specialization in
+     lambda/translprim at the call site below (so that the access
+     remain at kind Pgenval in the Lambda representation), but does
+     not prevent inlining during the Closure pass. *)
+  unsafe_get
+
+let () =
+  let int32 = 123456l in
+  let arr = [| int32 |] in
+  let n = uget arr 0 in
+  assert (n = int32)
diff --git a/testsuite/tests/float-unboxing/bug13448bis.ml b/testsuite/tests/float-unboxing/bug13448bis.ml
new file mode 100644
index 000000000000..6dc2319768a5
--- /dev/null
+++ b/testsuite/tests/float-unboxing/bug13448bis.ml
@@ -0,0 +1,26 @@
+(* TEST *)
+
+(* Regression test for #13448, see explanations in #13449.
+   Another variant of the bug, with GADTs instead of flat float arrays *)
+type _ t =
+  | Int32 : int32 t
+  | Float : float t
+
+let constant = 42l
+
+let[@inline always] default : type a . a t -> a = function
+  | Float ->
+     (* We want an expression that starts
+        with box<float>(...). *)
+     exp 0.
+  | Int32 ->
+     (* We want an expression that does not start
+        with box<int32>(...). *)
+     Sys.opaque_identity constant
+
+let () =
+  (* we use [opaque_identity] so that [default gadt] is not
+     reduced at compile-time. *)
+  let gadt = Sys.opaque_identity Int32 in
+  let n = default gadt in
+  assert (n = constant)
