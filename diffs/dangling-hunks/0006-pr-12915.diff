diff --git a/Changes b/Changes
index 9616bf66201f..fae010036f9b 100644
--- a/Changes
+++ b/Changes
@@ -10,6 +10,9 @@ _______________
 - #12876: Port ThreadSanitizer support to Linux on POWER
   (Miod Vallat, review by Tim McGilchrist)
 
+- #12915: Port ThreadSanitizer support to Linux on s390x
+  (Miod Vallat, review by Tim McGilchrist)
+
 ### Code generation and optimizations:
 
 ### Standard library:
diff --git a/configure b/configure
index b1d9e4227866..be94f99b16d5 100755
--- a/configure
+++ b/configure
@@ -16666,9 +16666,7 @@ esac
 fi
 
 # ThreadSanitizer support is currently only available for Linux/FreeBSD/macOS
-# on amd64, Linux/macOS on arm64 and Linux on POWER and riscv64.
-# ThreadSanitizer supports more architectures but the OCaml client side is not
-# implemented (yet).
+# on amd64, Linux/macOS on arm64 and Linux on POWER, riscv64 and s390x.
 if test "x$enable_tsan" = "xyes"
 then :
   case "$arch" in #(
@@ -16727,6 +16725,20 @@ esac ;; #(
   *) :
     as_fn_error $? "thread sanitizer not supported on system $system" "$LINENO" 5
         ;;
+esac ;; #(
+  s390x) :
+    case "$system" in #(
+  linux) :
+    case "$ocaml_cv_cc_vendor" in #(
+  gcc-*|clang-*) :
+    tsan=true ;; #(
+  *) :
+    as_fn_error $? "thread sanitizer not supported with vendor=$ocaml_cv_cc_vendor\"" "$LINENO" 5
+          ;;
+esac ;; #(
+  *) :
+    as_fn_error $? "thread sanitizer not supported on system $system" "$LINENO" 5
+        ;;
 esac ;; #(
   *) :
     as_fn_error $? "thread sanitizer not supported on arch $arch" "$LINENO" 5
@@ -16870,6 +16882,8 @@ fi
     libunwind_ldflags="-lunwind -lunwind-ppc64" ;; #(
   "riscv") :
     libunwind_ldflags="-lunwind -lunwind-riscv" ;; #(
+  "s390x") :
+    libunwind_ldflags="-lunwind -lunwind-s390x" ;; #(
   *) :
      ;;
 esac ;;
diff --git a/configure.ac b/configure.ac
index 3becd0adf5be..1016470045ce 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1701,9 +1701,7 @@ AS_IF([test "x$enable_instrumented_runtime" != "xno" ],
 )
 
 # ThreadSanitizer support is currently only available for Linux/FreeBSD/macOS
-# on amd64, Linux/macOS on arm64 and Linux on POWER and riscv64.
-# ThreadSanitizer supports more architectures but the OCaml client side is not
-# implemented (yet).
+# on amd64, Linux/macOS on arm64 and Linux on POWER, riscv64 and s390x.
 AS_IF([test "x$enable_tsan" = "xyes" ],
   [AS_CASE(["$arch"],
     [amd64],
@@ -1746,6 +1744,16 @@ AS_IF([test "x$enable_tsan" = "xyes" ],
          )],
         [AC_MSG_ERROR([thread sanitizer not supported on system $system])]
        )],
+    [s390x],
+      [AS_CASE(["$system"],
+        [linux],
+        [AS_CASE(["$ocaml_cv_cc_vendor"],
+          [gcc-*|clang-*], [tsan=true],
+          [AC_MSG_ERROR(m4_normalize([thread sanitizer not supported with
+            vendor=$ocaml_cv_cc_vendor"]))]
+         )],
+        [AC_MSG_ERROR([thread sanitizer not supported on system $system])]
+       )],
       [AC_MSG_ERROR([thread sanitizer not supported on arch $arch])]
   )],
   [tsan=false])
@@ -1811,7 +1819,8 @@ AS_IF([$tsan],
       ["amd64"], [libunwind_ldflags="-lunwind -lunwind-x86_64"],
       ["arm64"], [libunwind_ldflags="-lunwind -lunwind-aarch64"],
       ["power"], [libunwind_ldflags="-lunwind -lunwind-ppc64"],
-      ["riscv"], [libunwind_ldflags="-lunwind -lunwind-riscv"])])
+      ["riscv"], [libunwind_ldflags="-lunwind -lunwind-riscv"],
+      ["s390x"], [libunwind_ldflags="-lunwind -lunwind-s390x"])])
 
   AS_IF([test x"$LIBUNWIND_LDFLAGS" != x],
     [libunwind_ldflags="$LIBUNWIND_LDFLAGS $libunwind_ldflags"])
diff --git a/manual/src/cmds/tsan.etex b/manual/src/cmds/tsan.etex
index c26ce7b6a6b9..0a0aa8fec1eb 100644
--- a/manual/src/cmds/tsan.etex
+++ b/manual/src/cmds/tsan.etex
@@ -27,7 +27,7 @@ opam switch create <YOUR-SWITCH-NAME-HERE> ocaml-option-tsan
 
 TSan support for OCaml is currently available for the x86_64 architecture, on
 FreeBSD, Linux and macOS, for the arm64 architecture on Linux and macOS, and
-for the POWER architecture on Linux.
+for the POWER, riscv and s390x architectures on Linux.
 
 Building OCaml with TSan support requires GCC or Clang. Minimal supported
 versions are GCC 11 and Clang 14. Note that TSan data race reports with GCC 11
diff --git a/runtime/s390x.S b/runtime/s390x.S
index ed53c1d9b5f9..64e287bf6127 100644
--- a/runtime/s390x.S
+++ b/runtime/s390x.S
@@ -72,6 +72,9 @@
 #define CFI_RESTORE(r)
 #endif
 
+/* Stack space to be reserved by the caller of a C function */
+#define RESERVED_STACK          160
+
 /* special sleb128 constants, precalculated */
 /* Cstack_sp + 160 = 8 + 160 = 168, encoded as sleb128 */
 #define Cstack_sp_plus_160_sleb128_2byte 168, 1
@@ -103,10 +106,10 @@
 #define Handler_parent          24
 
 /* struct c_stack_link */
-#define Cstack_stack           160
-#define Cstack_sp              168
-#define Cstack_prev            176
-#define SIZEOF_C_STACK_LINK    184
+#define Cstack_stack           (RESERVED_STACK + 0)
+#define Cstack_sp              (RESERVED_STACK + 8)
+#define Cstack_prev            (RESERVED_STACK + 16)
+#define SIZEOF_C_STACK_LINK    (RESERVED_STACK + 24)
 
 /******************************************************************************/
 /* DWARF */
@@ -285,6 +288,96 @@ caml_system__code_begin:
         lg      ALLOC_PTR, Caml_state(young_ptr);      \
         lg      TRAP_PTR, Caml_state(exn_handler);
 
+#if defined(WITH_THREAD_SANITIZER) /* { */
+
+/* Setup a C call stack frame (which is the caller's duty), and save the
+   current value of the return address to the stack. */
+#define TSAN_SETUP_C_CALL                              \
+        lay     %r15, -(RESERVED_STACK+8)(%r15);                  \
+        CFI_ADJUST(RESERVED_STACK+8);                             \
+        stg     %r14, (RESERVED_STACK+0)(%r15)
+
+/* Restore the value of the return address from the stack and undo the C call
+   stack frame. */
+#define TSAN_CLEANUP_AFTER_C_CALL                      \
+        lg      %r14, (RESERVED_STACK+0)(%r15);                   \
+        CFI_RESTORE(14);                               \
+        la      %r15, (RESERVED_STACK+8)(%r15);                   \
+        CFI_ADJUST(-(RESERVED_STACK+8))
+
+/* Invoke a C function, switching back and forth the OCaml and C stacks. */
+#define TSAN_C_CALL(fun)                               \
+        SWITCH_OCAML_TO_C;                             \
+        TSAN_SETUP_C_CALL;                             \
+        brasl %r14, GCALL(fun);                        \
+        TSAN_CLEANUP_AFTER_C_CALL;                     \
+        SWITCH_C_TO_OCAML
+
+/* Invoke __tsan_func_entry(return address in the caller) */
+#define TSAN_ENTER_FUNCTION                            \
+        lgr     C_ARG_1, %r14; /* arg1: return address in caller */ \
+        TSAN_C_CALL(__tsan_func_entry)
+
+/* Invoke __tsan_func_exit(0) */
+#define TSAN_EXIT_FUNCTION                             \
+        lgfi    C_ARG_1, 0;                            \
+        TSAN_C_CALL(__tsan_func_exit)
+
+/* This is similar to SAVE_ALL_REGS, but only saving the caller-saved
+   registers. */
+#define TSAN_SAVE_CALLER_REGS                          \
+    /* First, save the young_ptr. */                   \
+        stg     ALLOC_PTR, Caml_state(young_ptr);      \
+        stg     TRAP_PTR,  Caml_state(exn_handler);    \
+    /* Now, use ALLOC_PTR to point to the gc_regs bucket */  \
+        lg      ALLOC_PTR, Caml_state(gc_regs_buckets);\
+        lg      %r0,            0(ALLOC_PTR); /* next ptr */ \
+        stg     %r0, Caml_state(gc_regs_buckets);      \
+    /* Save caller-saved registers */                  \
+        stmg    %r2,%r5,    (2*8)(ALLOC_PTR);          \
+        std     %f0,     (0+11)*8(ALLOC_PTR);          \
+        std     %f1,     (1+11)*8(ALLOC_PTR);          \
+        std     %f2,     (2+11)*8(ALLOC_PTR);          \
+        std     %f3,     (3+11)*8(ALLOC_PTR);          \
+        std     %f4,     (4+11)*8(ALLOC_PTR);          \
+        std     %f5,     (5+11)*8(ALLOC_PTR);          \
+        std     %f6,     (6+11)*8(ALLOC_PTR);          \
+        std     %f7,     (7+11)*8(ALLOC_PTR);          \
+        la      ALLOC_PTR, 16(ALLOC_PTR);              \
+        stg     ALLOC_PTR, Caml_state(gc_regs);        \
+        lg      ALLOC_PTR, Caml_state(young_ptr)
+
+/* This is similar to RESTORE_ALL_REGS, but only restoring the caller-saved
+   registers. */
+#define TSAN_RESTORE_CALLER_REGS                       \
+        lg      ALLOC_PTR, Caml_state(gc_regs);        \
+        lay     ALLOC_PTR, -16(ALLOC_PTR);             \
+    /* Restore registers */                            \
+        lmg     %r2,%r5,    (2*8)(ALLOC_PTR);          \
+        ld      %f0,     (0+11)*8(ALLOC_PTR);          \
+        ld      %f1,     (1+11)*8(ALLOC_PTR);          \
+        ld      %f2,     (2+11)*8(ALLOC_PTR);          \
+        ld      %f3,     (3+11)*8(ALLOC_PTR);          \
+        ld      %f4,     (4+11)*8(ALLOC_PTR);          \
+        ld      %f5,     (5+11)*8(ALLOC_PTR);          \
+        ld      %f6,     (6+11)*8(ALLOC_PTR);          \
+        ld      %f7,     (7+11)*8(ALLOC_PTR);          \
+    /* Put gc_regs struct back in bucket linked list */\
+        lg      %r0, Caml_state(gc_regs_buckets);      \
+        stg     %r0,            0(ALLOC_PTR); /* next ptr */ \
+        stg     ALLOC_PTR, Caml_state(gc_regs_buckets);\
+    /* Reload new allocation pointer & exn handler */  \
+        lg      ALLOC_PTR, Caml_state(young_ptr);      \
+        lg      TRAP_PTR, Caml_state(exn_handler)
+
+#else /* } { */
+
+#define TSAN_ENTER_FUNCTION
+#define TSAN_EXIT_FUNCTION
+#define TSAN_SAVE_CALLER_REGS
+#define TSAN_RESTORE_CALLER_REGS
+
+#endif /* } */
 
 FUNCTION(G(caml_call_realloc_stack))
 CFI_STARTPROC
@@ -400,6 +493,9 @@ CFI_STARTPROC
         CFI_ADJUST(8)
         stg     %r14, 0(%r15)
         CFI_OFFSET(14, -168)
+        TSAN_SAVE_CALLER_REGS
+        TSAN_ENTER_FUNCTION
+        TSAN_RESTORE_CALLER_REGS
 LBL(caml_c_call):
     /* Arguments:
         C arguments         : %r2, %r3, %r4, %r5, %r6
@@ -422,6 +518,21 @@ LBL(caml_c_call):
         lg      TRAP_PTR, Caml_state(exn_handler)
     /* Load ocaml stack and restore global variables */
         SWITCH_C_TO_OCAML
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save return value registers. Since the called function could be
+       anything, it may have returned its result (if any) either in %r2
+       or %f0. */
+        lay     %r15, -16(%r15)
+        CFI_ADJUST(16)
+        stg     %r2, 0(%r15)
+        std     %f0, 8(%r15)
+        TSAN_EXIT_FUNCTION
+    /* Restore return value registers */
+        ld      %f0, 8(%r15)
+        lg      %r2, 0(%r15)
+        la      %r15, 16(%r15)
+        CFI_ADJUST(-16)
+#endif
     /* Return to OCaml caller */
         lg      %r14, 0(%r15)
         CFI_RESTORE(14)
@@ -461,7 +572,7 @@ LBL(105):
         jl      LBL(106)
         lg      %r0, 0(%r8)
         lay     %r15, -8(%r15)
-        stg     %r0, 160(%r15)
+        stg     %r0, RESERVED_STACK(%r15)
         CFI_ADJUST(8)
         brcl    15, LBL(105)
 LBL(106):
@@ -490,6 +601,20 @@ ENDFUNCTION(G(caml_c_call_stack_args))
 FUNCTION(G(caml_start_program))
 CFI_STARTPROC
         CFI_SIGNAL_FRAME
+#if defined(WITH_THREAD_SANITIZER)
+        lay     %r15, -8(%r15)
+        CFI_ADJUST(8)
+        stg     C_ARG_1, 0(%r15)
+    /* We can't use TSAN_ENTER_FUNCTION here, as it assumes to run on an
+       OCaml stack, yet we are still on a C stack at this point. */
+        lgr     C_ARG_1, %r14
+        TSAN_SETUP_C_CALL
+        brasl   %r14, GCALL(__tsan_func_entry)
+        TSAN_CLEANUP_AFTER_C_CALL
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 8(%r15)
+        CFI_ADJUST(-8)
+#endif
     /* Load Caml_state into TMP (was passed as an argument from C) */
         lgr    TMP3, C_ARG_1
     /* Initial entry point is G(caml_program) */
@@ -497,12 +622,12 @@ CFI_STARTPROC
     /* Common code for caml_start_program and caml_callback* */
 LBL(caml_start_program):
     /* Allocate stack frame */
-        lay     %r15, -160(%r15)
+        lay     %r15, -RESERVED_STACK(%r15)
     /* Save all callee-save registers + return address */
     /* GPR 6..14 at sp + 0 ... sp + 64
        FPR 10..15 at sp + 72 ... sp + 128 */
         stmg    %r6,%r14, 0(%r15)
-        CFI_OFFSET(14, 64 - 160)
+        CFI_OFFSET(14, 64 - RESERVED_STACK)
         std     %f8, 72(%r15)
         std     %f9, 80(%r15)
         std     %f10, 88(%r15)
@@ -575,6 +700,20 @@ LBL(return_result):  /* restore GC regs */
         stg     %r8, Caml_state(c_stack)
         la      %r15, SIZEOF_C_STACK_LINK(%r15)
         CFI_ADJUST(SIZEOF_C_STACK_LINK)
+#if defined(WITH_THREAD_SANITIZER)
+    /* We can't use TSAN_EXIT_FUNCTION here, as it assumes to run on an
+       OCaml stack, and we are back to a C stack at this point. */
+        lay     %r15, -8(%r15)
+        CFI_ADJUST(8)
+        stg     C_ARG_1, 0(%r15)
+        lgfi    C_ARG_1, 0
+        TSAN_SETUP_C_CALL
+        brasl   %r14, GCALL(__tsan_func_exit)
+        TSAN_CLEANUP_AFTER_C_CALL
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 8(%r15)
+        CFI_ADJUST(-8)
+#endif
     /* Restore callee-save registers. */
         lmg     %r6,%r14, 0(%r15)
         CFI_RESTORE(14)
@@ -587,7 +726,7 @@ LBL(return_result):  /* restore GC regs */
         ld      %f14, 120(%r15)
         ld      %f15, 128(%r15)
     /* Return */
-        la     %r15, 160(%r15)
+        la     %r15, RESERVED_STACK(%r15)
     /* Return to caller. */
         br      %r14
 LBL(trap_handler):
@@ -633,7 +772,7 @@ LBL(caml_reraise_exn_stash):
     /* Switch to C stack */
         lg      %r15, Caml_state(c_stack)
         PREPARE_FOR_C_CALL
-        CFI_ADJUST(160)
+        CFI_ADJUST(RESERVED_STACK)
         brasl %r14, GCALL(caml_stash_backtrace)
         CLEANUP_AFTER_C_CALL
     /* Restore exception bucket and raise */
@@ -650,6 +789,23 @@ CFI_STARTPROC
 CFI_ENDPROC
 ENDFUNCTION(G(caml_reraise_exn))
 
+#if defined(WITH_THREAD_SANITIZER)
+/* When TSan support is enabled, this routine should be called just before
+   raising an exception. It calls __tsan_func_exit for every OCaml frame about
+   to be exited due to the exception.
+   Takes no arguments, clobbers a0, a1, a2 and potentially all
+   caller-saved registers of the C calling convention. */
+FUNCTION(G(caml_tsan_exit_on_raise_asm))
+CFI_STARTPROC
+        lgr     C_ARG_1, %r14           /* arg1: pc of raise */
+        lgr     C_ARG_2, %r15           /* arg2: sp of raise */
+        lgr     C_ARG_3, TRAP_PTR       /* arg3: sp of handler */
+        TSAN_C_CALL(caml_tsan_exit_on_raise)
+        br      %r14
+CFI_ENDPROC
+ENDFUNCTION(G(caml_tsan_exit_on_raise_asm))
+#endif
+
 /* Raise an exception from C */
 
 FUNCTION(G(caml_raise_exception))
@@ -664,6 +820,24 @@ CFI_STARTPROC
     /* Discard the C stack pointer and reset to ocaml stack */
         lg      TMP, Caml_state(current_stack)
         lg      %r15, Stack_sp(TMP)
+#if defined(WITH_THREAD_SANITIZER)
+        lgr     C_ARG_2, %r15
+        lay     %r15, -8(%r15)
+        CFI_ADJUST(8)
+        stg     C_ARG_1, 0(%r15)        /* preserve exception bucket */
+    /* Call __tsan_func_exit for every OCaml stack frame exited due to the
+       exception */
+        lg      C_ARG_1, 0(C_ARG_2)     /* arg1: pc of raise */
+        /* This stack address adjustment is required to compensate the
+           saving of r14 in SWITCH_OCAML_STACKS, which causes Stack_sp()
+           to be 8 bytes lower than expected. */
+        la      C_ARG_2, 8(C_ARG_2)     /* arg2: sp of raise */
+        lgr     C_ARG_3, TRAP_PTR       /* arg3: sp of handler */
+        TSAN_C_CALL(caml_tsan_exit_on_raise)
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 8(%r15)
+        CFI_ADJUST(-8)
+#endif
     /* Restore frame and link on return to OCaml */
         lg      %r14, 0(%r15)
         CFI_RESTORE(14)
@@ -678,6 +852,23 @@ ENDFUNCTION(G(caml_raise_exception))
 
 FUNCTION(G(caml_callback_asm))
 CFI_STARTPROC
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2, r3, r4 and r14 before C call */
+        lay     %r15, -(RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(RESERVED_STACK+32)
+        stg     C_ARG_1, (RESERVED_STACK+0)(%r15)
+        stg     C_ARG_2, (RESERVED_STACK+8)(%r15)
+        stg     C_ARG_3, (RESERVED_STACK+16)(%r15)
+        stg     %r14, (RESERVED_STACK+24)(%r15)
+        lgr     C_ARG_1, %r14
+        brasl   %r14, GCALL(__tsan_func_entry)
+        lg      %r14, (RESERVED_STACK+24)(%r15)
+        lg      C_ARG_3, (RESERVED_STACK+16)(%r15)
+        lg      C_ARG_2, (RESERVED_STACK+8)(%r15)
+        lg      C_ARG_1, (RESERVED_STACK+0)(%r15)
+        la      %r15, (RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(-(RESERVED_STACK+32))
+#endif
     /* Initial shuffling of arguments */
     /* (%r2 = Caml_state, %r3 = closure, 0(%r4) = first arg) */
         lgr     TMP3, C_ARG_1        /* Caml_state */
@@ -690,6 +881,23 @@ ENDFUNCTION(G(caml_callback_asm))
 
 FUNCTION(G(caml_callback2_asm))
 CFI_STARTPROC
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2, r3, r4 and r14 before C call */
+        lay     %r15, -(RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(RESERVED_STACK+32)
+        stg     C_ARG_1, (RESERVED_STACK+0)(%r15)
+        stg     C_ARG_2, (RESERVED_STACK+8)(%r15)
+        stg     C_ARG_3, (RESERVED_STACK+16)(%r15)
+        stg     %r14, (RESERVED_STACK+24)(%r15)
+        lgr     C_ARG_1, %r14
+        brasl   %r14, GCALL(__tsan_func_entry)
+        lg      %r14, (RESERVED_STACK+24)(%r15)
+        lg      C_ARG_3, (RESERVED_STACK+16)(%r15)
+        lg      C_ARG_2, (RESERVED_STACK+8)(%r15)
+        lg      C_ARG_1, (RESERVED_STACK+0)(%r15)
+        la      %r15, (RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(-(RESERVED_STACK+32))
+#endif
     /* Initial shuffling of arguments */
     /* (%r2 = Caml_state, %r3 = closure, 0(%r4) = arg1, 8(%r4) = arg2) */
         lgr     TMP3, C_ARG_1       /* Caml_state */
@@ -704,6 +912,23 @@ ENDFUNCTION(G(caml_callback2_asm))
 
 FUNCTION(G(caml_callback3_asm))
 CFI_STARTPROC
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2, r3, r4 and r14 before C call */
+        lay     %r15, -(RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(RESERVED_STACK+32)
+        stg     C_ARG_1, (RESERVED_STACK+0)(%r15)
+        stg     C_ARG_2, (RESERVED_STACK+8)(%r15)
+        stg     C_ARG_3, (RESERVED_STACK+16)(%r15)
+        stg     %r14, (RESERVED_STACK+24)(%r15)
+        lgr     C_ARG_1, %r14
+        brasl   %r14, GCALL(__tsan_func_entry)
+        lg      %r14, (RESERVED_STACK+24)(%r15)
+        lg      C_ARG_3, (RESERVED_STACK+16)(%r15)
+        lg      C_ARG_2, (RESERVED_STACK+8)(%r15)
+        lg      C_ARG_1, (RESERVED_STACK+0)(%r15)
+        la      %r15, (RESERVED_STACK+32)(%r15)
+        CFI_ADJUST(-(RESERVED_STACK+32))
+#endif
     /* Initial shuffling of arguments */
     /* (%r2 = Caml_state, %r3 = closure, 0(%r4) = arg1, 8(%r4) = arg2,
         16(%r4) = arg3) */
@@ -739,14 +964,39 @@ LBL(do_perform):
         %r3: continuation
         %r4: old_stack
         %r5: last_fiber */
-
+#if defined(WITH_THREAD_SANITIZER)
+    /* Signal to TSan all stack frames exited by the perform. */
+        TSAN_SAVE_CALLER_REGS
+        lgr     C_ARG_1, %r14   /* arg1: pc of perform */
+        lgr     C_ARG_2, %r15   /* arg2: sp of perform */
+        TSAN_C_CALL(caml_tsan_exit_on_perform)
+        TSAN_RESTORE_CALLER_REGS
+#endif
         lg      %r9, Stack_handler(%r4)  /* %r9 := old stack -> handler */
         lg      %r8, Handler_parent(%r9)
         clgfi   %r8, 0   /* %r8 := parent stack; is parent NULL? */
         je      LBL(112)
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2-r5. r8 and r9 are callee-saved
+       and do not need to be preserved here. */
+        lay     %r15, -32(%r15)
+        CFI_ADJUST(32)
+        stg     C_ARG_1, 0(%r15)
+        stg     C_ARG_2, 8(%r15)
+        stg     C_ARG_3, 16(%r15)
+        stg     C_ARG_4, 24(%r15)
+    /* Match the TSan-enter made from caml_runstack */
+        TSAN_EXIT_FUNCTION
+        lg      C_ARG_4, 24(%r15)
+        lg      C_ARG_3, 16(%r15)
+        lg      C_ARG_2, 8(%r15)
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 32(%r15)
+        CFI_ADJUST(-32)
+#endif
         SWITCH_OCAML_STACKS(%r4, %r8)
-     /* We have to null the Handler_parent after the switch because the
-        Handler_parent is needed to unwind the stack for backtraces */
+    /* We have to null the Handler_parent after the switch because the
+       Handler_parent is needed to unwind the stack for backtraces */
         lgfi    %r0, 0
         stg     %r0, Handler_parent(%r9) /* Set parent of performer to NULL */
         lgr     %r4, %r5                 /* %r4 = last_fiber */
@@ -759,6 +1009,20 @@ LBL(112):
         lay     %r8, -1(%r8)        /* r8 := Ptr_val(r8) */
         lg      %r9, Caml_state(current_stack)
         SWITCH_OCAML_STACKS(%r9, %r8)
+#if defined(WITH_THREAD_SANITIZER)
+    /* We must let the TSan runtime know that we switched back to the
+       original performer stack. For that, we perform the necessary calls
+       to __tsan_func_entry via caml_tsan_entry_on_resume.
+       Note that, from TSan's point of view, we just exited all stack frames,
+       including those of the main fiber. This is ok, because we will re-enter
+       them immediately via caml_tsan_entry_on_resume below. */
+        TSAN_SAVE_CALLER_REGS
+        lgr     C_ARG_1, %r14   /* arg1: pc of perform */
+        lgr     C_ARG_2, %r15   /* arg2: sp of perform */
+        lgr     C_ARG_3, %r8    /* arg3: performer stack */
+        TSAN_C_CALL(caml_tsan_entry_on_resume)
+        TSAN_RESTORE_CALLER_REGS
+#endif
     /* No parent stack. Raise Unhandled. */
         LEA_VAR(caml_raise_unhandled_effect, ADDITIONAL_ARG)
         brcl    15, GCALL(caml_c_call)
@@ -786,6 +1050,36 @@ CFI_STARTPROC
     /*  check if stack null, then already used */
         cgfi    %r2, 0
         jz      LBL(caml_resume_1)
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2-r5 */
+        lay     %r15, -32(%r15)
+        CFI_ADJUST(32)
+        stg     C_ARG_1, 0(%r15)
+        stg     C_ARG_2, 8(%r15)
+        stg     C_ARG_3, 16(%r15)
+        stg     C_ARG_4, 24(%r15)
+    /* Necessary to include the caller of caml_resume in the TSan backtrace */
+        TSAN_ENTER_FUNCTION
+        lg      C_ARG_4, 24(%r15)
+        lg      C_ARG_3, 16(%r15)
+        lg      C_ARG_2, 8(%r15)
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 32(%r15)
+        CFI_ADJUST(-32)
+        TSAN_SAVE_CALLER_REGS
+    /* Signal to TSan all stack frames exited by the perform. */
+        lgr     C_ARG_3, %r2            /* arg3: fiber */
+        lg      C_ARG_2, Stack_sp(%r2)
+        lg      C_ARG_1, 0(C_ARG_2)     /* arg1: pc of perform */
+        /* This stack address adjustment is required to compensate the
+           saving of r14 in SWITCH_OCAML_STACKS, which causes Stack_sp()
+           to be 8 bytes lower than expected. */
+        la      C_ARG_2, 8(C_ARG_2)     /* arg2: sp of raise */
+        TSAN_C_CALL(caml_tsan_entry_on_resume)
+        TSAN_RESTORE_CALLER_REGS
+    /* Reload lost value of %r6 */
+        lg      %r6,  0(%r3)  /* code pointer */
+#endif
     /* Add current stack to the end */
         lg      %r8, (Stack_handler-1)(%r5)
         lg      %r9, Caml_state(current_stack)
@@ -806,6 +1100,21 @@ ENDFUNCTION(G(caml_resume))
    then invoke either the value or exception handler */
 FUNCTION(G(caml_runstack))
 CFI_STARTPROC
+#if defined(WITH_THREAD_SANITIZER)
+    /* Save non-callee-saved registers r2-r4 */
+        lay     %r15, -24(%r15)
+        CFI_ADJUST(24)
+        stg     C_ARG_1, 0(%r15)
+        stg     C_ARG_2, 8(%r15)
+        stg     C_ARG_3, 16(%r15)
+    /* Necessary to include the caller of caml_runstack in the TSan backtrace */
+        TSAN_ENTER_FUNCTION
+        lg      C_ARG_3, 16(%r15)
+        lg      C_ARG_2, 8(%r15)
+        lg      C_ARG_1, 0(%r15)
+        la      %r15, 24(%r15)
+        CFI_ADJUST(-24)
+#endif
         CFI_SIGNAL_FRAME
         lay     %r15, -8(%r15)
         CFI_ADJUST(8)
@@ -865,14 +1174,26 @@ LBL(caml_runstack_1):
         CFI_DEF_CFA_REGISTER(DW_REG_r9)
         lg      %r15, Caml_state(c_stack)
         PREPARE_FOR_C_CALL
-        CFI_ADJUST(160)
+        CFI_ADJUST(RESERVED_STACK)
         brasl %r14, GCALL(caml_free_stack)
         CLEANUP_AFTER_C_CALL
-    /* switch directly to parent stack with correct return */
-        lgr     %r2,  %r12
-        lgr     %r3,  %r7
+    /* switch directly to parent stack */
         lgr     %r15, %r9
         CFI_RESTORE_STATE
+#if defined(WITH_THREAD_SANITIZER)
+    /* Signal to TSan that we exit caml_runstack. Theoretically, no registers
+       need to be saved here, but TSAN_EXIT_FUNCTION uses SWITCH_OCAML_TO_C
+       which clobbers %r12 (TMP2), so we need to preserve it here. */
+        lay     %r15, -8(%r15)
+        CFI_ADJUST(8)
+        stg     %r12, 0(%r15)
+        TSAN_EXIT_FUNCTION
+        lg      %r12, 0(%r15)
+        la      %r15, 8(%r15)
+        CFI_ADJUST(-8)
+#endif
+        lgr     %r2,  %r12
+        lgr     %r3,  %r7
         lg      TMP, 0(%r3) /* code pointer */
     /* Invoke handle_value (or handle_exn) */
         lg      %r14, 0(%r15)
@@ -893,6 +1214,8 @@ CFI_STARTPROC
         stg     %r14, 0(%r15)
         CFI_OFFSET(14, -168)
         ENTER_FUNCTION
+    /* No registers require saving before C call to TSan */
+        TSAN_ENTER_FUNCTION
         LEA_VAR(caml_array_bound_error_asm, ADDITIONAL_ARG)
     /* Note the following jumps in the middle of caml_c_call, since stack
        has already been adjusted. */
