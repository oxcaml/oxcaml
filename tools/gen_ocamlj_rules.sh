#!/usr/bin/env bash
set -euo pipefail
# Generate dune rules for building stdlib with ocamlj

if [[ $# -ne 0 ]]; then
    echo "$0: expected no arguments" >&2
    exit 1
fi

# CR-someday jvanburen: these are copied from elsewhere as I don't think dune
# has a way to expose the ocaml flags to a regular rule

# flags from ../duneconf/runtime_stdlib.ws:
RUNTIME_STDLIB_FLAGS='-directory stdlib -warn-error +A -alert -unsafe_multidomain'

# flags from ../dune:
MAIN_ENV_FLAGS='-principal -warn-error +A -w +a-4-9-40-41-42-44-45-48-66-67-70'

# flags from ./dune:
OCAML_FLAGS='-strict-sequence -g -absname -bin-annot -nostdlib -safe-string -strict-formats'

OCAMLJ_FLAGS="${RUNTIME_STDLIB_FLAGS} ${MAIN_ENV_FLAGS} ${OCAML_FLAGS} -I %{workspace_root}/stdlib/.stdlib.objs/byte -I . -no-alias-deps -nopervasives -nostdlib"

# CR jvanburen: enable sourcemaps when available
JSOO_FLAGS="--debuginfo --enable=with-js-error --pretty"

# Transform module names or file names into stdlib file names (without extensions).
# Idempotent.
function compilation-unit-name {
    while [[ $# -gt 0 ]]; do
        # skip .cmi files
        if  [[ $1 != *.cmi ]]; then
            local noext="${1%%.*}" # Remove any file extension
            case "$noext" in
                stdlib__*|[Cc]amlinternal*|[Ss]tdlib|[Ss]td_exit)
                    echo "${noext,}" ;;
                *)
                    echo "stdlib__${noext^}"
                    ;;
            esac
        fi
        shift
    done
}

# Associative arrays:
declare -A srcs # compilation unit -> impl file (.ml)
declare -A deps # compilation unit -> whitespace-separated dependencies

# Populate deps using ocamldep
while IFS=': ' read -r target deps_line; do
    # stdlib.pp.ml is generated by the rest of the dune file by applying
    # expand_module_aliases.awk to stdlib.ml, and requires special handling here
    # to compile the right file with the right dependencies
    case "${target}" in
        stdlib.pp.cmx) continue ;;
        stdlib.cmx) target=stdlib.pp.cmx;;
    esac

    # Extract compilation unit name from implementation filename
    cu="$(compilation-unit-name "${target}")"
    srcs[$cu]="${target%.*}.ml"
    deps[$cu]="$(compilation-unit-name ${deps_line})"
done < <(ocamldep -native -one-line -pp "awk -f remove_module_aliases.awk" -impl *.ml)

if [[ ! -v srcs[stdlib] ]]; then
    echo "$0: no source for stdlib, are you running it in the right directory? (pwd is $PWD)" >&2
    exit 1
fi

# Get topological order for creating stdlib.cmja
stdlib_cmja_contents=$(
    for cu in "${!deps[@]}"; do
        # std_exit doesn't go in the stdlib archive
        [[ ${cu} != std_exit ]] || continue

        # Make sure to still add $cu to archive, even if it has no deps
        for dep in ${deps[$cu]:-$cu}; do
            echo "${cu}.cmj ${dep}.cmj"
        done
    done | tsort | uniq | tac | tr '\n' ' ')

# Generate dune rules
echo ";; Generated dune rules for ocamlj stdlib compilation"
echo ";; Do not edit - this file is auto-generated by $0"
echo ""

# Individual compilation rules
for cu in "${!srcs[@]}"; do
    echo "(rule"
    echo " (targets ${cu}.cmj ${cu}.cmjx)"
    echo " (deps "
    echo "  ${srcs[$cu]}"
    echo "  %{workspace_root}/stdlib/.stdlib.objs/byte/${cu}.cmi"
    # Add module dependencies
    [[ -z ${deps[$cu]} ]] || printf '  %s.cmjx\n' ${deps[$cu]}
    echo " )"

    if [[ ${deps[$cu]} == *stdlib* ]]; then
        maybe_open_stdlib=' -open Stdlib'
    else
        maybe_open_stdlib=''
    fi

    echo " (action (run %{bin:ocamlj} ${OCAMLJ_FLAGS}${maybe_open_stdlib} -o ${cu}.cmj -c -impl ${srcs[$cu]})))"
    echo ""
done

cat <<EOF
(rule
 (target stdlib.cmja)
 (deps ${stdlib_cmja_contents})
 (action (run %{bin:ocamlj} ${OCAMLJ_FLAGS} -a -o stdlib.cmja %{deps})))

(rule
 (target stdlib.js)
 (deps stdlib.cmja)
 (action
  (run %{bin:js_of_ocaml} ${JSOO_FLAGS} -o %{target} %{deps})))

(rule
 (target std_exit.js)
 (deps std_exit.cmj)
 (action
  (run %{bin:js_of_ocaml} ${JSOO_FLAGS} -o %{target} %{deps})))
EOF
