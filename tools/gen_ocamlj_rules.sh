#!/usr/bin/env bash
set -euo pipefail
# Generate dune rules for building libraries, including stdlib, for javascript
# with ocamlj

if [[ $# -ne 1 ]]; then
    echo "$0: expected an arguments" >&2
    exit 1
fi

library="$1"
src="../${library}"
dst="${src}-js"
cmis_dir="${src}/.${library}.objs/byte"


# CR-someday jvanburen: these are copied from elsewhere as I don't think dune
# has a way to expose the ocaml flags to a regular rule

# flags from ../duneconf/runtime_stdlib.ws:
OCAMLJ_FLAGS=()
OCAMLJ_FLAGS+=(-directory "${library}")
OCAMLJ_FLAGS+=(-warn-error +A)
OCAMLJ_FLAGS+=(-alert -unsafe_multidomain)
# flags from ../dune:
OCAMLJ_FLAGS+=(-principal)
OCAMLJ_FLAGS+=(-warn-error +A)
OCAMLJ_FLAGS+=(-w +a-4-9-40-41-42-44-45-48-66-67-70)
# flags from ./dune:
OCAMLJ_FLAGS+=(-strict-sequence)
OCAMLJ_FLAGS+=(-g)
OCAMLJ_FLAGS+=(-absname)
OCAMLJ_FLAGS+=(-bin-annot)
OCAMLJ_FLAGS+=(-strict-formats)
OCAMLJ_FLAGS+=(-jsopt --source-map-inline)

if [[ $library == stdlib ]]; then
    OCAMLJ_FLAGS+=(-nopervasives -nostdlib)
elif [[ $library == stdlib_* ]]; then
    OCAMLJ_FLAGS+=(-extension-universe "${library#stdlib_}")
fi

OCAMLJ_FLAGS+=(-I "${cmis_dir}")
OCAMLJ_FLAGS+=(-I "${dst}")
OCAMLJ_FLAGS+=(-no-alias-deps)

# CR jvanburen: enable sourcemaps when available
JSOO_FLAGS=(--debuginfo --enable=effects,with-js-error --pretty)

# Transform module names or file names into stdlib file names (without extensions).
# Idempotent.
function compilation-unit-name {
    while [[ $# -gt 0 ]]; do
        # skip .cmi files
        if  [[ $1 != *.cmi ]]; then
            local noext="${1%%.*}" # Remove any file extension
            if [[ ${noext,} == ${library}__* || ${noext,} == camlinternal* || ${noext,} == std_exit || ${noext,} == ${library} ]]; then
                echo "${noext,}"
            else
                echo "${library}__${noext^}"
            fi
        fi
        shift
    done
}

# Associative arrays:
declare -A srcs # compilation unit -> impl file (.ml)
declare -A deps # compilation unit -> whitespace-separated dependencies

# Populate deps using ocamldep
while IFS=': ' read -r target deps_line; do
    # stdlib.pp.ml is generated by the rest of the dune file by applying
    # expand_module_aliases.awk to stdlib.ml, and requires special handling here
    # to compile the right file with the right dependencies
    case "${target}" in
        stdlib.pp.cmx) continue ;;
        stdlib.cmx) target=stdlib.pp.cmx;;
    esac

    # Extract compilation unit name from implementation filename
    cu="$(compilation-unit-name "${target}")"
    srcs[$cu]="${target%.*}.ml"
    deps[$cu]="$(compilation-unit-name ${deps_line})"
done < <(
    cd "${library}"
    if [[ $library == stdlib ]]; then
        ocamldep -native -one-line -pp "awk -f remove_module_aliases.awk" -impl *.ml
    else
        ocamldep -native -one-line -impl *.ml
    fi)

if [[ ! -v srcs["${library}"] ]]; then
    echo "$0: no source for ${library}, are you running it in the right directory? (pwd is $PWD)" >&2

    for src in "${!srcs[@]}"; do
        echo "$src: ${srcs[$src]}" >&2
    done
    exit 1
fi

        # Get topological order for creating $library.cmjxa
        cmjxa_contents=$(
    for cu in "${!deps[@]}"; do
        # std_exit doesn't go in the stdlib archive
        [[ ${cu} != std_exit ]] || continue

        # Make sure to still add $cu to archive, even if it has no deps
        for dep in ${deps[$cu]:-$cu}; do
            echo "${cu}.cmjx ${dep}.cmjx"
        done

        # This horrifying sed command just reverses the input, like `tac` except available
        # on both macos and linux
    done | tsort | uniq | sed '1!G;h;$!d' | tr '\n' ' ')

# Generate dune rules
echo ";; Generated dune rules for ocamlj $library compilation"
echo ";; Do not edit - this file is auto-generated by $0"
echo ""

# Individual compilation rules
for cu in "${!srcs[@]}"; do
    echo "(rule"
    echo " (targets ${cu}.cmjo ${cu}.cmjx)"
    echo " (deps "
    echo "  (source_tree ${src})"
    echo "  ${cmis_dir}/${cu}.cmi"
    # Add module dependencies
    [[ -z ${deps[$cu]} ]] || printf '  %s.cmjx\n' ${deps[$cu]}
    echo " )"

    if [[ ${library} == stdlib && ${deps[$cu]} == *stdlib* ]]; then
        maybe_open_stdlib=' -open Stdlib'
    elif [[ ${library} != stdlib && ${#deps[@]} -gt 1 ]]; then
         maybe_open_stdlib=" -open ${library^}__"
    else
        maybe_open_stdlib=''
    fi


    echo " (action (chdir ${src} (run %{bin:ocamlj} ${OCAMLJ_FLAGS[*]}${maybe_open_stdlib} -o ${dst}/${cu} -c -impl ${srcs[$cu]}))))"
    echo ""
done

cat <<EOF
(rule
 (targets ${library}.cmjxa ${library}.cmja)
 (deps ${cmjxa_contents})
 (action (run %{bin:ocamlj} ${OCAMLJ_FLAGS[*]} -linkall -a -o ${library}.cmjxa %{deps})))
EOF
