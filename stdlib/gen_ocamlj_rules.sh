#!/usr/bin/env bash
set -euo pipefail

# Generate dune rules for building stdlib with ocamlj
# This script generates an inc file to be included via dynamic_include

# Use ocamldep from _install/bin to handle new syntax
OCAMLDEP=$(which ocamldep)
# if [ ! -x "$OCAMLDEP" ]; then
#     echo "Error: ocamldep not found at $OCAMLDEP" >&2
#     echo "Please build the compiler first with 'make install'" >&2
#     exit 1
# fi

# Temporary files
DEPS_FILE=$(mktemp)
TSORT_INPUT=$(mktemp)
trap "rm -f $DEPS_FILE $TSORT_INPUT" EXIT

# Get all stdlib modules
ALL_MODULES=()
for ml in *.ml; do
    [ "$ml" = "*.ml" ] && continue
    module="${ml%.ml}"
    ALL_MODULES+=("$module")
done

# Generate dependencies using ocamldep
# First for regular modules
$OCAMLDEP -one-line -native *.ml | grep -v '^stdlib\.cmx' > "$DEPS_FILE" || true
# Then for stdlib.ml with preprocessing
$OCAMLDEP -one-line -native -pp "awk -f ./remove_module_aliases.awk" stdlib.ml >> "$DEPS_FILE" || true

# Build dependency graph for tsort
declare -A module_deps
declare -A module_targets

while IFS=': ' read -r target deps_line; do
    # Extract module name from target
    target="${target%.cmx}"

    # Transform module name based on camlInternal prefix
    if [[ $target == camlinternal* ]] || [[ $target == camlInternal* ]]; then
        module_name="$target"
    elif [[ $target == stdlib ]]; then
        module_name="stdlib"
    elif [[ $target == std_exit ]]; then
        module_name="std_exit"
    else
        # Capitalize first letter for stdlib__ prefix
        first_char="${target:0:1}"
        rest="${target:1}"
        module_name="stdlib__${first_char^^}${rest}"
    fi

    module_targets["$target"]="$module_name"
    module_deps["$target"]=""

    # Process dependencies
    for dep in $deps_line; do
        if [[ $dep == *.cmx ]]; then
            dep_module="${dep%.cmx}"

            # Special handling for stdlib dependencies
            if [[ $target == camlInternalFormatBasics ]] || [[ $target == stdlib ]]; then
                deps_line="${deps_line//stdlib.cmx/}"
                continue
            fi

            # Transform dependency name
            if [[ $dep_module == camlinternal* ]] || [[ $dep_module == camlInternal* ]]; then
                dep_name="$dep_module"
            elif [[ $dep_module == stdlib ]]; then
                dep_name="stdlib"
            elif [[ $dep_module == std_exit ]]; then
                dep_name="std_exit"
            else
                first_char="${dep_module:0:1}"
                rest="${dep_module:1}"
                dep_name="stdlib__${first_char^^}${rest}"
            fi

            module_deps["$target"]+=" $dep_name.cmj"
            # Add edge for tsort
            echo "$module_name.cmj $dep_name.cmj" >> "$TSORT_INPUT"
        fi
    done

    # If module has no dependencies, add it to tsort input anyway
    if [ -z "${module_deps[$target]}" ]; then
        echo "$module_name.cmj $module_name.cmj" >> "$TSORT_INPUT"
    fi
done < "$DEPS_FILE"

# Get topological order
if [ -s "$TSORT_INPUT" ]; then
    TOPO_ORDER=($(tsort "$TSORT_INPUT" 2>/dev/null | tac | uniq))
else
    TOPO_ORDER=()
fi

# Generate dune rules
echo "; Generated dune rules for ocamlj stdlib compilation"
echo "; Do not edit - this file is auto-generated by gen_ocamlj_rules.sh"
echo ""

# Individual compilation rules
for module in "${ALL_MODULES[@]}"; do
    [ "$module" = "stdlib" ] && continue  # Handle stdlib specially later
    [ "$module" = "std_exit" ] && continue  # Handle std_exit specially later

    # Get target name with stdlib__ prefix where appropriate
    if [[ $module == camlinternal* ]] || [[ $module == camlInternal* ]]; then
        target_base="$module"
    else
        first_char="${module:0:1}"
        rest="${module:1}"
        target_base="stdlib__${first_char^^}${rest}"
    fi

    echo "(rule"
    echo " (targets $target_base.cmj $target_base.cmjx)"
    echo -n " (deps $module.ml"

    # Add .mli dependency if it exists
    if [ -f "$module.mli" ]; then
        echo -n " $module.mli"
    fi

    # Add module dependencies
    if [ -n "${module_deps[$module]:-}" ]; then
        for dep in ${module_deps[$module]}; do
            echo -n " $dep"
            # Also add .cmjx for each .cmj dependency
            echo -n " ${dep%.cmj}.cmjx"
        done
    fi
    echo ")"

    echo " (action (run %{bin:ocamlj} -nopervasives -nostdlib -o $target_base.cmj -c $module.ml)))"
    echo ""
done

# Special rule for stdlib.ml with preprocessing
echo "(rule"
echo " (targets stdlib.cmj stdlib.cmjx)"
echo " (deps stdlib.ml stdlib.mli"
# Add dependencies for stdlib
if [ -n "${module_deps[stdlib]:-}" ]; then
    for dep in ${module_deps[stdlib]}; do
        echo -n " $dep"
        echo -n " ${dep%.cmj}.cmjx"
    done
fi
echo ")"
echo " (action"
echo "  (pipe-stdout"
echo "   (run awk -f %{dep:remove_module_aliases.awk} %{dep:stdlib.ml})"
echo "   (run %{bin:ocamlj} -nopervasives -nostdlib -o stdlib.cmj -c -impl -))))"
echo ""

# Special rule for std_exit
echo "(rule"
echo " (targets std_exit.cmj std_exit.cmjx)"
echo " (deps std_exit.ml"
if [ -n "${module_deps[std_exit]:-}" ]; then
    for dep in ${module_deps[std_exit]}; do
        echo -n " $dep"
        echo -n " ${dep%.cmj}.cmjx"
    done
fi
echo ")"
echo " (action (run %{bin:ocamlj} -nopervasives -nostdlib -o std_exit.cmj -c std_exit.ml)))"
echo ""

# Archive creation rule (excluding std_exit)
echo "(rule"
echo " (target stdlib.cmja)"
echo " (deps"

# List all .cmj files in topological order, excluding std_exit
for cmj in "${TOPO_ORDER[@]}"; do
    if [[ $cmj != std_exit.cmj ]] && [[ $cmj == *.cmj ]]; then
        echo "  $cmj"
    fi
done

echo " )"
echo " (action (run %{bin:ocamlj} -a -o stdlib.cmja"

# List modules for archive command
for cmj in "${TOPO_ORDER[@]}"; do
    if [[ $cmj != std_exit.cmj ]] && [[ $cmj == *.cmj ]]; then
        echo -n " $cmj"
    fi
done
echo ")))"
echo ""

# JavaScript conversion rules
echo "; JavaScript conversion using js_of_ocaml"
echo ""

echo "(rule"
echo " (target stdlib.js)"
echo " (deps stdlib.cmja (:jsoo %{bin:js_of_ocaml}))"
echo " (action"
echo "  (run %{jsoo}"
echo "   --debuginfo"
echo "   --pretty"
echo "   --enable=effects"
echo "   --enable=with-js-error"
echo "   --source-map-inline"
echo "   -o %{target}"
echo "   %{deps})))"
echo ""

echo "(rule"
echo " (target std_exit.js)"
echo " (deps std_exit.cmj (:jsoo %{bin:js_of_ocaml}))"
echo " (action"
echo "  (run %{jsoo}"
echo "   --debuginfo"
echo "   --pretty"
echo "   --enable=effects"
echo "   --enable=with-js-error"
echo "   --source-map-inline"
echo "   -o %{target}"
echo "   std_exit.cmj)))"
